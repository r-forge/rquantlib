# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.4
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

##   Generated via the command line invocation:
##	 /usr/local/bin/swig -r -c++ -o QuantLib.cpp ../SWIG/quantlib.i


#                         srun.swg                            #
#
# This is the basic code that is needed at run time within R to
# provide and define the relevant classes.  It is included
# automatically in the generated code by copying the contents of
# srun.swg into the newly created binding code.


# This could be provided as a separate run-time library but this
# approach allows the code to to be included directly into the
# generated bindings and so removes the need to have and install an
# additional library.  We may however end up with multiple copies of
# this and some confusion at run-time as to which class to use. This
# is an issue when we use NAMESPACES as we may need to export certain
# classes.

######################################################################

if(length(getClassDef("RSWIGStruct")) == 0) 
  setClass("RSWIGStruct", representation("VIRTUAL"))



if(length(getClassDef("ExternalReference")) == 0) 
# Should be virtual but this means it loses its slots currently
#representation("VIRTUAL")
  setClass("ExternalReference", representation( ref = "externalptr"))



if(length(getClassDef("NativeRoutinePointer")) == 0) 
  setClass("NativeRoutinePointer", 
              representation(parameterTypes = "character",
                             returnType = "character",
                             "VIRTUAL"), 
              contains = "ExternalReference")

if(length(getClassDef("CRoutinePointer")) == 0) 
  setClass("CRoutinePointer", contains = "NativeRoutinePointer")


if(length(getClassDef("EnumerationValue")) == 0) 
  setClass("EnumerationValue", contains = "integer")


if(!isGeneric("copyToR")) 
 setGeneric("copyToR",
            function(value, obj = new(gsub("Ref$", "", class(value)))) 
               standardGeneric("copyToR"
           ))

setGeneric("delete", function(obj) standardGeneric("delete"))


SWIG_createNewRef = 
function(className, ..., append = TRUE)
{
  f = get(paste("new", className, sep = "_"), mode = "function")

  f(...)
}

if(!isGeneric("copyToC")) 
 setGeneric("copyToC", 
             function(value, obj = RSWIG_createNewRef(class(value)))
              standardGeneric("copyToC"
            ))


# 
defineEnumeration =
function(name, .values, where = topenv(parent.frame()), suffix = "Value")
{
   # Mirror the class definitions via the E analogous to .__C__
  defName = paste(".__E__", name, sep = "")
  assign(defName,  .values,  envir = where)

  if(nchar(suffix))
    name = paste(name, suffix, sep = "")

  setClass(name, contains = "EnumerationValue", where = where)
}

enumToInteger <- function(name,type)
{
   if (is.character(name)) {
   ans <- as.integer(get(paste(".__E__", type, sep = ""))[name])
   if (is.na(ans)) {warning("enum not found ", name, " ", type)}
   ans
   } 
}

enumFromInteger =
function(i,type)
{
  itemlist <- get(paste(".__E__", type, sep=""))
  names(itemlist)[match(i, itemlist)]
}

coerceIfNotSubclass =
function(obj, type) 
{
    if(!is(obj, type)) {as(obj, type)} else obj
}


setClass("SWIGArray", representation(dims = "integer"), contains = "ExternalReference")

setMethod("length", "SWIGArray", function(x) x@dims[1])


defineEnumeration("SCopyReferences",
                   .values = c( "FALSE" = 0, "TRUE" = 1, "DEEP" = 2))

assert = 
function(condition, message = "")
{
  if(!condition)
    stop(message)

  TRUE
}


if(FALSE) {
print.SWIGFunction =
function(x, ...)
 {
 }
}


#######################################################################

R_SWIG_getCallbackFunctionStack =
function()
{
    # No PACKAGE argument as we don't know what the DLL is.
  .Call("R_SWIG_debug_getCallbackFunctionData")
}

R_SWIG_addCallbackFunctionStack =
function(fun, userData = NULL)
{
    # No PACKAGE argument as we don't know what the DLL is.
  .Call("R_SWIG_R_pushCallbackFunctionData", fun, userData)
}


#######################################################################


setClass('C++Reference', contains = 'ExternalReference')
setClass('_p_Period', contains = 'C++Reference')
setClass('_p_std__vectorT_Period_std__allocatorT_Period_t_t', contains = 'C++Reference')
setClass('_p_Date', contains = 'C++Reference')
setClass('_p_DateParser', contains = 'C++Reference')
setClass('_p_PeriodParser', contains = 'C++Reference')
setClass('_p_std__vectorT_Date_std__allocatorT_Date_t_t', contains = 'C++Reference')
setClass('_p_IMM', contains = 'ExternalReference')
setClass("IMM",
    representation(
),
        contains = "RSWIGStruct")


# End class IMM

setClass('_p_std__vectorT_int_std__allocatorT_int_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_double_std__allocatorT_double_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_bool_std__allocatorT_bool_t_t', contains = 'C++Reference')
setClass('_p_boost__shared_ptrT_Exercise_t', contains = 'C++Reference')
setClass('_p_EuropeanExercisePtr', contains = c('_p_boost__shared_ptrT_Exercise_t'))
setClass('_p_AmericanExercisePtr', contains = c('_p_boost__shared_ptrT_Exercise_t'))
setClass('_p_BermudanExercisePtr', contains = c('_p_boost__shared_ptrT_Exercise_t'))
setClass('_p_boost__shared_ptrT_Observable_t', contains = 'C++Reference')
setClass('_p_Array', contains = 'C++Reference')
setClass('_p_DefaultLexicographicalViewColumn', contains = 'C++Reference')
setClass('_p_DefaultLexicographicalView', contains = 'C++Reference')
setClass('_p_Matrix', contains = 'C++Reference')
setClass('_p_SalvagingAlgorithm', contains = 'ExternalReference')
setClass("SalvagingAlgorithm",
    representation(
),
        contains = "RSWIGStruct")


# End class SalvagingAlgorithm

setClass('_p_SVD', contains = 'C++Reference')
setClass('_p_boost__shared_ptrT_Quote_t', contains = 'C++Reference')
setClass('_p_HandleT_Quote_t', contains = 'C++Reference')
setClass('_p_RelinkableHandleT_Quote_t', contains = c('_p_HandleT_Quote_t'))
setClass('_p_SimpleQuotePtr', contains = c('_p_boost__shared_ptrT_Quote_t'))
setClass('_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_std__allocatorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_std__allocatorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_t_t', contains = 'C++Reference')
setClass('_p_DayCounter', contains = 'C++Reference')
setClass('_p_QuantLib__Actual360', contains = c('_p_DayCounter'))
setClass('_p_QuantLib__Actual365Fixed', contains = c('_p_DayCounter'))
setClass('_p_QuantLib__Thirty360', contains = c('_p_DayCounter'))
setClass('_p_QuantLib__ActualActual', contains = c('_p_DayCounter'))
setClass('_p_QuantLib__OneDayCounter', contains = c('_p_DayCounter'))
setClass('_p_QuantLib__SimpleDayCounter', contains = c('_p_DayCounter'))
setClass('_p_QuantLib__Business252', contains = c('_p_DayCounter'))
setClass('_p_InterestRate', contains = 'C++Reference')
setClass('_p_Calendar', contains = 'C++Reference')
setClass('_p_QuantLib__Argentina', contains = c('_p_Calendar'))
setClass('_p_QuantLib__Australia', contains = c('_p_Calendar'))
setClass('_p_QuantLib__Brazil', contains = c('_p_Calendar'))
setClass('_p_QuantLib__Canada', contains = c('_p_Calendar'))
setClass('_p_QuantLib__China', contains = c('_p_Calendar'))
setClass('_p_QuantLib__CzechRepublic', contains = c('_p_Calendar'))
setClass('_p_QuantLib__Denmark', contains = c('_p_Calendar'))
setClass('_p_QuantLib__Finland', contains = c('_p_Calendar'))
setClass('_p_QuantLib__Germany', contains = c('_p_Calendar'))
setClass('_p_QuantLib__HongKong', contains = c('_p_Calendar'))
setClass('_p_QuantLib__Hungary', contains = c('_p_Calendar'))
setClass('_p_QuantLib__Iceland', contains = c('_p_Calendar'))
setClass('_p_QuantLib__India', contains = c('_p_Calendar'))
setClass('_p_QuantLib__Indonesia', contains = c('_p_Calendar'))
setClass('_p_QuantLib__Italy', contains = c('_p_Calendar'))
setClass('_p_QuantLib__Japan', contains = c('_p_Calendar'))
setClass('_p_QuantLib__Mexico', contains = c('_p_Calendar'))
setClass('_p_QuantLib__NewZealand', contains = c('_p_Calendar'))
setClass('_p_QuantLib__Norway', contains = c('_p_Calendar'))
setClass('_p_QuantLib__Poland', contains = c('_p_Calendar'))
setClass('_p_QuantLib__Russia', contains = c('_p_Calendar'))
setClass('_p_QuantLib__SaudiArabia', contains = c('_p_Calendar'))
setClass('_p_QuantLib__Singapore', contains = c('_p_Calendar'))
setClass('_p_QuantLib__Slovakia', contains = c('_p_Calendar'))
setClass('_p_QuantLib__SouthAfrica', contains = c('_p_Calendar'))
setClass('_p_QuantLib__SouthKorea', contains = c('_p_Calendar'))
setClass('_p_QuantLib__Sweden', contains = c('_p_Calendar'))
setClass('_p_QuantLib__Switzerland', contains = c('_p_Calendar'))
setClass('_p_QuantLib__Taiwan', contains = c('_p_Calendar'))
setClass('_p_QuantLib__TARGET', contains = c('_p_Calendar'))
setClass('_p_QuantLib__Turkey', contains = c('_p_Calendar'))
setClass('_p_QuantLib__Ukraine', contains = c('_p_Calendar'))
setClass('_p_QuantLib__UnitedKingdom', contains = c('_p_Calendar'))
setClass('_p_QuantLib__UnitedStates', contains = c('_p_Calendar'))
setClass('_p_QuantLib__NullCalendar', contains = c('_p_Calendar'))
setClass('_p_QuantLib__WeekendsOnly', contains = c('_p_Calendar'))
setClass('_p_QuantLib__JointCalendar', contains = c('_p_Calendar'))
setClass('_p_QuantLib__BespokeCalendar', contains = c('_p_Calendar'))
setClass('_p_Rounding', contains = 'C++Reference')
setClass('_p_UpRounding', contains = c('_p_Rounding'))
setClass('_p_DownRounding', contains = c('_p_Rounding'))
setClass('_p_ClosestRounding', contains = c('_p_Rounding'))
setClass('_p_CeilingTruncation', contains = c('_p_Rounding'))
setClass('_p_FloorTruncation', contains = c('_p_Rounding'))
setClass('_p_Currency', contains = 'C++Reference')
setClass('_p_QuantLib__ARSCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__ATSCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__AUDCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__BDTCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__BEFCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__BGLCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__BRLCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__BYRCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__CADCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__CHFCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__CLPCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__CNYCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__COPCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__CYPCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__CZKCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__DEMCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__DKKCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__EEKCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__ESPCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__EURCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__FIMCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__FRFCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__GBPCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__GRDCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__HKDCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__HUFCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__IEPCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__ILSCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__INRCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__IQDCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__IRRCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__ISKCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__ITLCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__JPYCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__KRWCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__KWDCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__LTLCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__LUFCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__LVLCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__MTLCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__MXNCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__NLGCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__NOKCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__NPRCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__NZDCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__PEHCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__PEICurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__PENCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__PKRCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__PLNCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__PTECurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__ROLCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__RONCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__SARCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__SEKCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__SGDCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__SITCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__SKKCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__THBCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__TRLCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__TRYCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__TTDCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__TWDCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__USDCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__VEBCurrency', contains = c('_p_Currency'))
setClass('_p_QuantLib__ZARCurrency', contains = c('_p_Currency'))
setClass('_p_SafeLinearInterpolation', contains = 'C++Reference')
setClass('_p_SafeLogLinearInterpolation', contains = 'C++Reference')
setClass('_p_SafeBackwardFlatInterpolation', contains = 'C++Reference')
setClass('_p_SafeForwardFlatInterpolation', contains = 'C++Reference')
setClass('_p_SafeCubicNaturalSpline', contains = 'C++Reference')
setClass('_p_SafeLogCubicNaturalSpline', contains = 'C++Reference')
setClass('_p_SafeMonotonicCubicNaturalSpline', contains = 'C++Reference')
setClass('_p_SafeMonotonicLogCubicNaturalSpline', contains = 'C++Reference')
setClass('_p_SafeKrugerCubic', contains = 'C++Reference')
setClass('_p_SafeKrugerLogCubic', contains = 'C++Reference')
setClass('_p_SafeFritschButlandCubic', contains = 'C++Reference')
setClass('_p_SafeFritschButlandLogCubic', contains = 'C++Reference')
setClass('_p_SafeParabolic', contains = 'C++Reference')
setClass('_p_SafeLogParabolic', contains = 'C++Reference')
setClass('_p_SafeMonotonicParabolic', contains = 'C++Reference')
setClass('_p_SafeMonotonicLogParabolic', contains = 'C++Reference')
setClass('_p_SafeBilinearInterpolation', contains = 'C++Reference')
setClass('_p_SafeBicubicSpline', contains = 'C++Reference')
setClass('_p_BackwardFlat', contains = 'ExternalReference')
setClass("BackwardFlat",
    representation(
),
        contains = "RSWIGStruct")


# End class BackwardFlat

setClass('_p_ForwardFlat', contains = 'ExternalReference')
setClass("ForwardFlat",
    representation(
),
        contains = "RSWIGStruct")


# End class ForwardFlat

setClass('_p_Linear', contains = 'ExternalReference')
setClass("Linear",
    representation(
),
        contains = "RSWIGStruct")


# End class Linear

setClass('_p_LogLinear', contains = 'ExternalReference')
setClass("LogLinear",
    representation(
),
        contains = "RSWIGStruct")


# End class LogLinear

setClass('_p_Cubic', contains = 'ExternalReference')
setClass("Cubic",
    representation(
),
        contains = "RSWIGStruct")


# End class Cubic

setClass('_p_boost__shared_ptrT_YieldTermStructure_t', contains = 'C++Reference')
setClass('_p_HandleT_YieldTermStructure_t', contains = 'C++Reference')
setClass('_p_RelinkableHandleT_YieldTermStructure_t', contains = c('_p_HandleT_YieldTermStructure_t'))
setClass('_p_ImpliedTermStructurePtr', contains = c('_p_boost__shared_ptrT_YieldTermStructure_t'))
setClass('_p_ZeroSpreadedTermStructurePtr', contains = c('_p_boost__shared_ptrT_YieldTermStructure_t'))
setClass('_p_ForwardSpreadedTermStructurePtr', contains = c('_p_boost__shared_ptrT_YieldTermStructure_t'))
setClass('_p_FlatForwardPtr', contains = c('_p_boost__shared_ptrT_YieldTermStructure_t'))
setClass('_p_TimeSeriesT_double_std__mapT_Date_double_t_t', contains = 'C++Reference')
setClass('_p_TimeSeriesT_IntervalPrice_std__mapT_Date_IntervalPrice_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_IntervalPrice_std__allocatorT_IntervalPrice_t_t', contains = 'C++Reference')
setClass('_p_IntervalPrice', contains = 'C++Reference')
setClass('_p_IndexManager', contains = 'C++Reference')
setClass('_p_boost__shared_ptrT_Index_t', contains = 'C++Reference')
setClass('_p_InterestRateIndexPtr', contains = c('_p_boost__shared_ptrT_Index_t'))
setClass('_p_IborIndexPtr', contains = c('_p_InterestRateIndexPtr'))
setClass('_p_SwapIndexPtr', contains = c('_p_InterestRateIndexPtr'))
setClass('_p_AUDLiborPtr', contains = c('_p_IborIndexPtr'))
setClass('_p_CADLiborPtr', contains = c('_p_IborIndexPtr'))
setClass('_p_CdorPtr', contains = c('_p_IborIndexPtr'))
setClass('_p_CHFLiborPtr', contains = c('_p_IborIndexPtr'))
setClass('_p_DKKLiborPtr', contains = c('_p_IborIndexPtr'))
setClass('_p_EuriborPtr', contains = c('_p_IborIndexPtr'))
setClass('_p_EuriborSWPtr', contains = c('_p_EuriborPtr'))
setClass('_p_Euribor2WPtr', contains = c('_p_EuriborPtr'))
setClass('_p_Euribor3WPtr', contains = c('_p_EuriborPtr'))
setClass('_p_Euribor1MPtr', contains = c('_p_EuriborPtr'))
setClass('_p_Euribor2MPtr', contains = c('_p_EuriborPtr'))
setClass('_p_Euribor3MPtr', contains = c('_p_EuriborPtr'))
setClass('_p_Euribor4MPtr', contains = c('_p_EuriborPtr'))
setClass('_p_Euribor5MPtr', contains = c('_p_EuriborPtr'))
setClass('_p_Euribor6MPtr', contains = c('_p_EuriborPtr'))
setClass('_p_Euribor7MPtr', contains = c('_p_EuriborPtr'))
setClass('_p_Euribor8MPtr', contains = c('_p_EuriborPtr'))
setClass('_p_Euribor9MPtr', contains = c('_p_EuriborPtr'))
setClass('_p_Euribor10MPtr', contains = c('_p_EuriborPtr'))
setClass('_p_Euribor11MPtr', contains = c('_p_EuriborPtr'))
setClass('_p_Euribor1YPtr', contains = c('_p_EuriborPtr'))
setClass('_p_Euribor365Ptr', contains = c('_p_IborIndexPtr'))
setClass('_p_Euribor365_SWPtr', contains = c('_p_Euribor365Ptr'))
setClass('_p_Euribor365_2WPtr', contains = c('_p_Euribor365Ptr'))
setClass('_p_Euribor365_3WPtr', contains = c('_p_Euribor365Ptr'))
setClass('_p_Euribor365_1MPtr', contains = c('_p_Euribor365Ptr'))
setClass('_p_Euribor365_2MPtr', contains = c('_p_Euribor365Ptr'))
setClass('_p_Euribor365_3MPtr', contains = c('_p_Euribor365Ptr'))
setClass('_p_Euribor365_4MPtr', contains = c('_p_Euribor365Ptr'))
setClass('_p_Euribor365_5MPtr', contains = c('_p_Euribor365Ptr'))
setClass('_p_Euribor365_6MPtr', contains = c('_p_Euribor365Ptr'))
setClass('_p_Euribor365_7MPtr', contains = c('_p_Euribor365Ptr'))
setClass('_p_Euribor365_8MPtr', contains = c('_p_Euribor365Ptr'))
setClass('_p_Euribor365_9MPtr', contains = c('_p_Euribor365Ptr'))
setClass('_p_Euribor365_10MPtr', contains = c('_p_Euribor365Ptr'))
setClass('_p_Euribor365_11MPtr', contains = c('_p_Euribor365Ptr'))
setClass('_p_Euribor365_1YPtr', contains = c('_p_Euribor365Ptr'))
setClass('_p_EURLiborPtr', contains = c('_p_IborIndexPtr'))
setClass('_p_EURLiborSWPtr', contains = c('_p_EURLiborPtr'))
setClass('_p_EURLibor2WPtr', contains = c('_p_EURLiborPtr'))
setClass('_p_EURLibor1MPtr', contains = c('_p_EURLiborPtr'))
setClass('_p_EURLibor2MPtr', contains = c('_p_EURLiborPtr'))
setClass('_p_EURLibor3MPtr', contains = c('_p_EURLiborPtr'))
setClass('_p_EURLibor4MPtr', contains = c('_p_EURLiborPtr'))
setClass('_p_EURLibor5MPtr', contains = c('_p_EURLiborPtr'))
setClass('_p_EURLibor6MPtr', contains = c('_p_EURLiborPtr'))
setClass('_p_EURLibor7MPtr', contains = c('_p_EURLiborPtr'))
setClass('_p_EURLibor8MPtr', contains = c('_p_EURLiborPtr'))
setClass('_p_EURLibor9MPtr', contains = c('_p_EURLiborPtr'))
setClass('_p_EURLibor10MPtr', contains = c('_p_EURLiborPtr'))
setClass('_p_EURLibor11MPtr', contains = c('_p_EURLiborPtr'))
setClass('_p_EURLibor1YPtr', contains = c('_p_EURLiborPtr'))
setClass('_p_GBPLiborPtr', contains = c('_p_IborIndexPtr'))
setClass('_p_JibarPtr', contains = c('_p_IborIndexPtr'))
setClass('_p_JPYLiborPtr', contains = c('_p_IborIndexPtr'))
setClass('_p_NZDLiborPtr', contains = c('_p_IborIndexPtr'))
setClass('_p_SEKLiborPtr', contains = c('_p_IborIndexPtr'))
setClass('_p_TiborPtr', contains = c('_p_IborIndexPtr'))
setClass('_p_TRLiborPtr', contains = c('_p_IborIndexPtr'))
setClass('_p_USDLiborPtr', contains = c('_p_IborIndexPtr'))
setClass('_p_ZiborPtr', contains = c('_p_IborIndexPtr'))
setClass('_p_EuriborSwapIsdaFixAPtr', contains = c('_p_SwapIndexPtr'))
setClass('_p_EuriborSwapIsdaFixBPtr', contains = c('_p_SwapIndexPtr'))
setClass('_p_EuriborSwapIfrFixPtr', contains = c('_p_SwapIndexPtr'))
setClass('_p_EurLiborSwapIsdaFixAPtr', contains = c('_p_SwapIndexPtr'))
setClass('_p_EurLiborSwapIsdaFixBPtr', contains = c('_p_SwapIndexPtr'))
setClass('_p_EurLiborSwapIfrFixPtr', contains = c('_p_SwapIndexPtr'))
setClass('_p_Brent', contains = 'C++Reference')
setClass('_p_Bisection', contains = 'C++Reference')
setClass('_p_FalsePosition', contains = 'C++Reference')
setClass('_p_Ridder', contains = 'C++Reference')
setClass('_p_Secant', contains = 'C++Reference')
setClass('_p_Constraint', contains = 'C++Reference')
setClass('_p_BoundaryConstraint', contains = c('_p_Constraint'))
setClass('_p_NoConstraint', contains = c('_p_Constraint'))
setClass('_p_PositiveConstraint', contains = c('_p_Constraint'))
setClass('_p_EndCriteria', contains = 'C++Reference')
setClass('_p_OptimizationMethod', contains = 'C++Reference')
setClass('_p_ConjugateGradient', contains = c('_p_OptimizationMethod'))
setClass('_p_Simplex', contains = c('_p_OptimizationMethod'))
setClass('_p_SteepestDescent', contains = c('_p_OptimizationMethod'))
setClass('_p_BFGS', contains = c('_p_OptimizationMethod'))
setClass('_p_Optimizer', contains = 'C++Reference')
setClass('_p_boost__shared_ptrT_BlackVolTermStructure_t', contains = 'C++Reference')
setClass('_p_HandleT_BlackVolTermStructure_t', contains = 'C++Reference')
setClass('_p_RelinkableHandleT_BlackVolTermStructure_t', contains = c('_p_HandleT_BlackVolTermStructure_t'))
setClass('_p_boost__shared_ptrT_LocalVolTermStructure_t', contains = 'C++Reference')
setClass('_p_HandleT_LocalVolTermStructure_t', contains = 'C++Reference')
setClass('_p_RelinkableHandleT_LocalVolTermStructure_t', contains = c('_p_HandleT_LocalVolTermStructure_t'))
setClass('_p_boost__shared_ptrT_OptionletVolatilityStructure_t', contains = 'C++Reference')
setClass('_p_HandleT_OptionletVolatilityStructure_t', contains = 'C++Reference')
setClass('_p_RelinkableHandleT_OptionletVolatilityStructure_t', contains = c('_p_HandleT_OptionletVolatilityStructure_t'))
setClass('_p_boost__shared_ptrT_SwaptionVolatilityStructure_t', contains = 'C++Reference')
setClass('_p_HandleT_SwaptionVolatilityStructure_t', contains = 'C++Reference')
setClass('_p_RelinkableHandleT_SwaptionVolatilityStructure_t', contains = c('_p_HandleT_SwaptionVolatilityStructure_t'))
setClass('_p_BlackConstantVolPtr', contains = c('_p_boost__shared_ptrT_BlackVolTermStructure_t'))
setClass('_p_BlackVarianceCurvePtr', contains = c('_p_boost__shared_ptrT_BlackVolTermStructure_t'))
setClass('_p_BlackVarianceSurfacePtr', contains = c('_p_boost__shared_ptrT_BlackVolTermStructure_t'))
setClass('_p_LocalConstantVolPtr', contains = c('_p_boost__shared_ptrT_LocalVolTermStructure_t'))
setClass('_p_ConstantOptionletVolatilityPtr', contains = c('_p_boost__shared_ptrT_OptionletVolatilityStructure_t'))
setClass('_p_ConstantSwaptionVolatilityPtr', contains = c('_p_boost__shared_ptrT_SwaptionVolatilityStructure_t'))
setClass('_p_SwaptionVolatilityMatrixPtr', contains = c('_p_boost__shared_ptrT_SwaptionVolatilityStructure_t'))
setClass('_p_SwaptionVolCube1Ptr', contains = c('_p_boost__shared_ptrT_SwaptionVolatilityStructure_t'))
setClass('_p_SwaptionVolCube2Ptr', contains = c('_p_boost__shared_ptrT_SwaptionVolatilityStructure_t'))
setClass('_p_boost__shared_ptrT_StochasticProcess_t', contains = 'C++Reference')
setClass('_p_StochasticProcess1DPtr', contains = c('_p_boost__shared_ptrT_StochasticProcess_t'))
setClass('_p_GeneralizedBlackScholesProcessPtr', contains = c('_p_StochasticProcess1DPtr'))
setClass('_p_BlackScholesProcessPtr', contains = c('_p_GeneralizedBlackScholesProcessPtr'))
setClass('_p_BlackScholesMertonProcessPtr', contains = c('_p_GeneralizedBlackScholesProcessPtr'))
setClass('_p_BlackProcessPtr', contains = c('_p_GeneralizedBlackScholesProcessPtr'))
setClass('_p_GarmanKohlagenProcessPtr', contains = c('_p_GeneralizedBlackScholesProcessPtr'))
setClass('_p_Merton76ProcessPtr', contains = c('_p_StochasticProcess1DPtr'))
setClass('_p_StochasticProcessArrayPtr', contains = c('_p_boost__shared_ptrT_StochasticProcess_t'))
setClass('_p_GeometricBrownianMotionProcessPtr', contains = c('_p_StochasticProcess1DPtr'))
setClass('_p_VarianceGammaProcessPtr', contains = c('_p_StochasticProcess1DPtr'))
setClass('_p_HestonProcessPtr', contains = c('_p_boost__shared_ptrT_StochasticProcess_t'))
setClass('_p_BatesProcessPtr', contains = c('_p_HestonProcessPtr'))
setClass('_p_std__vectorT_boost__shared_ptrT_StochasticProcess_t_std__allocatorT_boost__shared_ptrT_StochasticProcess_t_t_t', contains = 'C++Reference')
setClass('_p_boost__shared_ptrT_PricingEngine_t', contains = 'C++Reference')
setClass('_p_boost__shared_ptrT_Instrument_t', contains = 'C++Reference')
setClass('_p_StockPtr', contains = c('_p_boost__shared_ptrT_Instrument_t'))
setClass('_p_CompositeInstrumentPtr', contains = c('_p_boost__shared_ptrT_Instrument_t'))
setClass('_p_Option', contains = 'C++Reference')
setClass('_p_Barrier', contains = 'ExternalReference')
setClass("Barrier",
    representation(
),
        contains = "RSWIGStruct")


# End class Barrier

setClass('_p_boost__shared_ptrT_Payoff_t', contains = 'C++Reference')
setClass('_p_VanillaOptionPtr', contains = c('_p_boost__shared_ptrT_Instrument_t'))
setClass('_p_EuropeanOptionPtr', contains = c('_p_VanillaOptionPtr'))
setClass('_p_ForwardVanillaOptionPtr', contains = c('_p_VanillaOptionPtr'))
setClass('_p_QuantoVanillaOptionPtr', contains = c('_p_VanillaOptionPtr'))
setClass('_p_QuantoForwardVanillaOptionPtr', contains = c('_p_QuantoVanillaOptionPtr'))
setClass('_p_MultiAssetOptionPtr', contains = c('_p_boost__shared_ptrT_Instrument_t'))
setClass('_p_AnalyticEuropeanEnginePtr', contains = c('_p_boost__shared_ptrT_PricingEngine_t'))
setClass('_p_boost__shared_ptrT_CalibratedModel_t', contains = 'C++Reference')
setClass('_p_HestonModelPtr', contains = c('_p_boost__shared_ptrT_CalibratedModel_t'))
setClass('_p_AnalyticHestonEnginePtr', contains = c('_p_boost__shared_ptrT_PricingEngine_t'))
setClass('_p_BatesModelPtr', contains = c('_p_boost__shared_ptrT_CalibratedModel_t'))
setClass('_p_BatesEnginePtr', contains = c('_p_boost__shared_ptrT_PricingEngine_t'))
setClass('_p_IntegralEnginePtr', contains = c('_p_boost__shared_ptrT_PricingEngine_t'))
setClass('_p_FDBermudanEnginePtr', contains = c('_p_boost__shared_ptrT_PricingEngine_t'))
setClass('_p_FDEuropeanEnginePtr', contains = c('_p_boost__shared_ptrT_PricingEngine_t'))
setClass('_p_BinomialVanillaEnginePtr', contains = c('_p_boost__shared_ptrT_PricingEngine_t'))
setClass('_p_MCEuropeanEnginePtr', contains = c('_p_boost__shared_ptrT_PricingEngine_t'))
setClass('_p_FDAmericanEnginePtr', contains = c('_p_boost__shared_ptrT_PricingEngine_t'))
setClass('_p_FDShoutEnginePtr', contains = c('_p_boost__shared_ptrT_PricingEngine_t'))
setClass('_p_BaroneAdesiWhaleyApproximationEnginePtr', contains = c('_p_boost__shared_ptrT_PricingEngine_t'))
setClass('_p_BjerksundStenslandApproximationEnginePtr', contains = c('_p_boost__shared_ptrT_PricingEngine_t'))
setClass('_p_AnalyticDigitalAmericanEnginePtr', contains = c('_p_boost__shared_ptrT_PricingEngine_t'))
setClass('_p_DividendVanillaOptionPtr', contains = c('_p_boost__shared_ptrT_Instrument_t'))
setClass('_p_AnalyticDividendEuropeanEnginePtr', contains = c('_p_boost__shared_ptrT_PricingEngine_t'))
setClass('_p_FDDividendEuropeanEnginePtr', contains = c('_p_boost__shared_ptrT_PricingEngine_t'))
setClass('_p_FDDividendAmericanEnginePtr', contains = c('_p_boost__shared_ptrT_PricingEngine_t'))
setClass('_p_BarrierOptionPtr', contains = c('_p_boost__shared_ptrT_Instrument_t'))
setClass('_p_AnalyticBarrierEnginePtr', contains = c('_p_boost__shared_ptrT_PricingEngine_t'))
setClass('_p_MCBarrierEnginePtr', contains = c('_p_boost__shared_ptrT_PricingEngine_t'))
setClass('_p_ForwardEuropeanEnginePtr', contains = c('_p_boost__shared_ptrT_PricingEngine_t'))
setClass('_p_QuantoEuropeanEnginePtr', contains = c('_p_boost__shared_ptrT_PricingEngine_t'))
setClass('_p_QuantoForwardEuropeanEnginePtr', contains = c('_p_boost__shared_ptrT_PricingEngine_t'))
setClass('_p_BlackCalculator', contains = 'C++Reference')
setClass('_p_Average', contains = 'ExternalReference')
setClass("Average",
    representation(
),
        contains = "RSWIGStruct")


# End class Average

setClass('_p_ContinuousAveragingAsianOptionPtr', contains = c('_p_boost__shared_ptrT_Instrument_t'))
setClass('_p_DiscreteAveragingAsianOptionPtr', contains = c('_p_boost__shared_ptrT_Instrument_t'))
setClass('_p_AnalyticContinuousGeometricAveragePriceAsianEnginePtr', contains = c('_p_boost__shared_ptrT_PricingEngine_t'))
setClass('_p_AnalyticDiscreteGeometricAveragePriceAsianEnginePtr', contains = c('_p_boost__shared_ptrT_PricingEngine_t'))
setClass('_p_AnalyticDiscreteGeometricAverageStrikeAsianEnginePtr', contains = c('_p_boost__shared_ptrT_PricingEngine_t'))
setClass('_p_MCDiscreteArithmeticAPEnginePtr', contains = c('_p_boost__shared_ptrT_PricingEngine_t'))
setClass('_p_MCDiscreteArithmeticASEnginePtr', contains = c('_p_boost__shared_ptrT_PricingEngine_t'))
setClass('_p_MCDiscreteGeometricAPEnginePtr', contains = c('_p_boost__shared_ptrT_PricingEngine_t'))
setClass('_p_VarianceGammaEnginePtr', contains = c('_p_boost__shared_ptrT_PricingEngine_t'))
setClass('_p_std__vectorT_boost__shared_ptrT_Instrument_t_std__allocatorT_boost__shared_ptrT_Instrument_t_t_t', contains = 'C++Reference')
setClass('_p_FFTVarianceGammaEnginePtr', contains = c('_p_boost__shared_ptrT_PricingEngine_t'))
setClass('_p_PlainVanillaPayoffPtr', contains = c('_p_boost__shared_ptrT_Payoff_t'))
setClass('_p_PercentageStrikePayoffPtr', contains = c('_p_boost__shared_ptrT_Payoff_t'))
setClass('_p_CashOrNothingPayoffPtr', contains = c('_p_boost__shared_ptrT_Payoff_t'))
setClass('_p_AssetOrNothingPayoffPtr', contains = c('_p_boost__shared_ptrT_Payoff_t'))
setClass('_p_SuperSharePayoffPtr', contains = c('_p_boost__shared_ptrT_Payoff_t'))
setClass('_p_GapPayoffPtr', contains = c('_p_boost__shared_ptrT_Payoff_t'))
setClass('_p_BasketPayoffPtr', contains = c('_p_boost__shared_ptrT_Payoff_t'))
setClass('_p_MinBasketPayoffPtr', contains = c('_p_BasketPayoffPtr'))
setClass('_p_MaxBasketPayoffPtr', contains = c('_p_BasketPayoffPtr'))
setClass('_p_AverageBasketPayoffPtr', contains = c('_p_BasketPayoffPtr'))
setClass('_p_BasketOptionPtr', contains = c('_p_MultiAssetOptionPtr'))
setClass('_p_MCEuropeanBasketEnginePtr', contains = c('_p_boost__shared_ptrT_PricingEngine_t'))
setClass('_p_MCAmericanBasketEnginePtr', contains = c('_p_boost__shared_ptrT_PricingEngine_t'))
setClass('_p_StulzEnginePtr', contains = c('_p_boost__shared_ptrT_PricingEngine_t'))
setClass('_p_EverestOptionPtr', contains = c('_p_MultiAssetOptionPtr'))
setClass('_p_MCEverestEnginePtr', contains = c('_p_boost__shared_ptrT_PricingEngine_t'))
setClass('_p_HimalayaOptionPtr', contains = c('_p_MultiAssetOptionPtr'))
setClass('_p_MCHimalayaEnginePtr', contains = c('_p_boost__shared_ptrT_PricingEngine_t'))
setClass('_p_DateGeneration', contains = 'ExternalReference')
setClass("DateGeneration",
    representation(
),
        contains = "RSWIGStruct")


# End class DateGeneration

setClass('_p_Schedule', contains = 'C++Reference')
setClass('_p_boost__shared_ptrT_CashFlow_t', contains = 'C++Reference')
setClass('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', contains = 'C++Reference')
setClass('_p_SimpleCashFlowPtr', contains = c('_p_boost__shared_ptrT_CashFlow_t'))
setClass('_p_CouponPtr', contains = c('_p_boost__shared_ptrT_CashFlow_t'))
setClass('_p_FixedRateCouponPtr', contains = c('_p_CouponPtr'))
setClass('_p_boost__shared_ptrT_FloatingRateCouponPricer_t', contains = 'C++Reference')
setClass('_p_FloatingRateCouponPtr', contains = c('_p_CouponPtr'))
setClass('_p_CappedFlooredCouponPtr', contains = c('_p_FloatingRateCouponPtr'))
setClass('_p_IborCouponPtr', contains = c('_p_FloatingRateCouponPtr'))
setClass('_p_IborCouponPricerPtr', contains = c('_p_boost__shared_ptrT_FloatingRateCouponPricer_t'))
setClass('_p_BlackIborCouponPricerPtr', contains = c('_p_IborCouponPricerPtr'))
setClass('_p_CmsCouponPtr', contains = c('_p_FloatingRateCouponPtr'))
setClass('_p_CmsCouponPricerPtr', contains = c('_p_boost__shared_ptrT_FloatingRateCouponPricer_t'))
setClass('_p_GFunctionFactory', contains = 'C++Reference')
setClass('_p_AnalyticHaganPricerPtr', contains = c('_p_CmsCouponPricerPtr'))
setClass('_p_NumericHaganPricerPtr', contains = c('_p_CmsCouponPricerPtr'))
setClass('_p_CappedFlooredCmsCouponPtr', contains = c('_p_CappedFlooredCouponPtr'))
setClass('_p_Duration', contains = 'ExternalReference')
setClass("Duration",
    representation(
),
        contains = "RSWIGStruct")


# End class Duration

setClass('_p_CashFlows', contains = 'C++Reference')
setClass('_p_BondPtr', contains = c('_p_boost__shared_ptrT_Instrument_t'))
setClass('_p_ZeroCouponBondPtr', contains = c('_p_BondPtr'))
setClass('_p_FixedRateBondPtr', contains = c('_p_BondPtr'))
setClass('_p_FloatingRateBondPtr', contains = c('_p_BondPtr'))
setClass('_p_CmsRateBondPtr', contains = c('_p_BondPtr'))
setClass('_p_DiscountingBondEnginePtr', contains = c('_p_boost__shared_ptrT_PricingEngine_t'))
setClass('_p_CallabilityPrice', contains = 'C++Reference')
setClass('_p_boost__shared_ptrT_Callability_t', contains = 'C++Reference')
setClass('_p_SoftCallabilityPtr', contains = c('_p_boost__shared_ptrT_Callability_t'))
setClass('_p_std__vectorT_boost__shared_ptrT_Callability_t_std__allocatorT_boost__shared_ptrT_Callability_t_t_t', contains = 'C++Reference')
setClass('_p_CapFloorPtr', contains = c('_p_boost__shared_ptrT_Instrument_t'))
setClass('_p_CapPtr', contains = c('_p_CapFloorPtr'))
setClass('_p_FloorPtr', contains = c('_p_CapFloorPtr'))
setClass('_p_CollarPtr', contains = c('_p_CapFloorPtr'))
setClass('_p_BlackCapFloorEnginePtr', contains = c('_p_boost__shared_ptrT_PricingEngine_t'))
setClass('_p_boost__shared_ptrT_Dividend_t', contains = 'C++Reference')
setClass('_p_FixedDividendPtr', contains = c('_p_boost__shared_ptrT_Dividend_t'))
setClass('_p_FractionalDividendPtr', contains = c('_p_boost__shared_ptrT_Dividend_t'))
setClass('_p_std__vectorT_boost__shared_ptrT_Dividend_t_std__allocatorT_boost__shared_ptrT_Dividend_t_t_t', contains = 'C++Reference')
setClass('_p_ConvertibleZeroCouponBondPtr', contains = c('_p_BondPtr'))
setClass('_p_ConvertibleFixedCouponBondPtr', contains = c('_p_BondPtr'))
setClass('_p_ConvertibleFloatingRateBondPtr', contains = c('_p_BondPtr'))
setClass('_p_BinomialConvertibleEnginePtr', contains = c('_p_boost__shared_ptrT_PricingEngine_t'))
setClass('_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t', contains = 'C++Reference')
setClass('_p_HandleT_DefaultProbabilityTermStructure_t', contains = 'C++Reference')
setClass('_p_RelinkableHandleT_DefaultProbabilityTermStructure_t', contains = c('_p_HandleT_DefaultProbabilityTermStructure_t'))
setClass('_p_FlatHazardRatePtr', contains = c('_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t'))
setClass('_p_HazardRateCurvePtr', contains = c('_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t'))
setClass('_p_DefaultDensityCurvePtr', contains = c('_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t'))
setClass('_p_boost__shared_ptrT_DefaultProbabilityHelper_t', contains = 'C++Reference')
setClass('_p_std__vectorT_boost__shared_ptrT_DefaultProbabilityHelper_t_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t_t', contains = 'C++Reference')
setClass('_p_SpreadCdsHelperPtr', contains = c('_p_boost__shared_ptrT_DefaultProbabilityHelper_t'))
setClass('_p_UpfrontCdsHelperPtr', contains = c('_p_boost__shared_ptrT_DefaultProbabilityHelper_t'))
setClass('_p_HazardRate', contains = 'ExternalReference')
setClass("HazardRate",
    representation(
),
        contains = "RSWIGStruct")


# End class HazardRate

setClass('_p_DefaultDensity', contains = 'ExternalReference')
setClass("DefaultDensity",
    representation(
),
        contains = "RSWIGStruct")


# End class DefaultDensity

setClass('_p_PiecewiseFlatHazardRatePtr', contains = c('_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t'))
setClass('_p_Protection', contains = 'ExternalReference')
setClass("Protection",
    representation(
),
        contains = "RSWIGStruct")


# End class Protection

setClass('_p_CreditDefaultSwapPtr', contains = c('_p_boost__shared_ptrT_Instrument_t'))
setClass('_p_MidPointCdsEnginePtr', contains = c('_p_boost__shared_ptrT_PricingEngine_t'))
setClass('_p_DiscountCurvePtr', contains = c('_p_boost__shared_ptrT_YieldTermStructure_t'))
setClass('_p_NormalDistribution', contains = 'C++Reference')
setClass('_p_CumulativeNormalDistribution', contains = 'C++Reference')
setClass('_p_InverseCumulativeNormal', contains = 'C++Reference')
setClass('_p_MoroInverseCumulativeNormal', contains = 'C++Reference')
setClass('_p_BivariateCumulativeNormalDistribution', contains = 'C++Reference')
setClass('_p_BinomialDistribution', contains = 'C++Reference')
setClass('_p_CumulativeBinomialDistribution', contains = 'C++Reference')
setClass('_p_BivariateCumulativeNormalDistributionDr78', contains = 'C++Reference')
setClass('_p_BivariateCumulativeNormalDistributionWe04DP', contains = 'C++Reference')
setClass('_p_ChiSquareDistribution', contains = 'C++Reference')
setClass('_p_NonCentralChiSquareDistribution', contains = 'C++Reference')
setClass('_p_InverseNonCentralChiSquareDistribution', contains = 'C++Reference')
setClass('_p_GammaDistribution', contains = 'C++Reference')
setClass('_p_GammaFunction', contains = 'C++Reference')
setClass('_p_PoissonDistribution', contains = 'C++Reference')
setClass('_p_CumulativePoissonDistribution', contains = 'C++Reference')
setClass('_p_InverseCumulativePoisson', contains = 'C++Reference')
setClass('_p_StudentDistribution', contains = 'C++Reference')
setClass('_p_CumulativeStudentDistribution', contains = 'C++Reference')
setClass('_p_InverseCumulativeStudent', contains = 'C++Reference')
setClass('_p_Money', contains = 'C++Reference')
setClass('_p_ExchangeRate', contains = 'C++Reference')
setClass('_p_ExchangeRateManager', contains = 'C++Reference')
setClass('_p_ForwardCurvePtr', contains = c('_p_boost__shared_ptrT_YieldTermStructure_t'))
setClass('_p_TimeGrid', contains = 'C++Reference')
setClass('_p_boost__shared_ptrT_Seasonality_t', contains = 'C++Reference')
setClass('_p_MultiplicativePriceSeasonalityPtr', contains = c('_p_boost__shared_ptrT_Seasonality_t'))
setClass('_p_boost__shared_ptrT_YoYInflationTermStructure_t', contains = 'C++Reference')
setClass('_p_HandleT_YoYInflationTermStructure_t', contains = 'C++Reference')
setClass('_p_RelinkableHandleT_YoYInflationTermStructure_t', contains = c('_p_HandleT_YoYInflationTermStructure_t'))
setClass('_p_boost__shared_ptrT_ZeroInflationTermStructure_t', contains = 'C++Reference')
setClass('_p_HandleT_ZeroInflationTermStructure_t', contains = 'C++Reference')
setClass('_p_RelinkableHandleT_ZeroInflationTermStructure_t', contains = c('_p_HandleT_ZeroInflationTermStructure_t'))
setClass('_p_InflationIndexPtr', contains = c('_p_boost__shared_ptrT_Index_t'))
setClass('_p_ZeroInflationIndexPtr', contains = c('_p_InflationIndexPtr'))
setClass('_p_YoYInflationIndexPtr', contains = c('_p_InflationIndexPtr'))
setClass('_p_EUHICPPtr', contains = c('_p_ZeroInflationIndexPtr'))
setClass('_p_EUHICPXTPtr', contains = c('_p_ZeroInflationIndexPtr'))
setClass('_p_FRHICPPtr', contains = c('_p_ZeroInflationIndexPtr'))
setClass('_p_UKRPIPtr', contains = c('_p_ZeroInflationIndexPtr'))
setClass('_p_USCPIPtr', contains = c('_p_ZeroInflationIndexPtr'))
setClass('_p_YYEUHICPPtr', contains = c('_p_YoYInflationIndexPtr'))
setClass('_p_YYEUHICPXTPtr', contains = c('_p_YoYInflationIndexPtr'))
setClass('_p_YYFRHICPPtr', contains = c('_p_YoYInflationIndexPtr'))
setClass('_p_YYUKRPIPtr', contains = c('_p_YoYInflationIndexPtr'))
setClass('_p_YYUSCPIPtr', contains = c('_p_YoYInflationIndexPtr'))
setClass('_p_boost__shared_ptrT_ZeroHelper_t', contains = 'C++Reference')
setClass('_p_boost__shared_ptrT_YoYHelper_t', contains = 'C++Reference')
setClass('_p_std__vectorT_boost__shared_ptrT_ZeroHelper_t_std__allocatorT_boost__shared_ptrT_ZeroHelper_t_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_boost__shared_ptrT_YoYHelper_t_std__allocatorT_boost__shared_ptrT_YoYHelper_t_t_t', contains = 'C++Reference')
setClass('_p_ZeroCouponInflationSwapHelperPtr', contains = c('_p_boost__shared_ptrT_ZeroHelper_t'))
setClass('_p_YearOnYearInflationSwapHelperPtr', contains = c('_p_boost__shared_ptrT_YoYHelper_t'))
setClass('_p_PiecewiseZeroInflationPtr', contains = c('_p_boost__shared_ptrT_ZeroInflationTermStructure_t'))
setClass('_p_PiecewiseYoYInflationPtr', contains = c('_p_boost__shared_ptrT_YoYInflationTermStructure_t'))
setClass('_p_ZeroCouponInflationSwapPtr', contains = c('_p_boost__shared_ptrT_Instrument_t'))
setClass('_p_YearOnYearInflationSwapPtr', contains = c('_p_boost__shared_ptrT_Instrument_t'))
setClass('_p_YoYInflationCapFloorPtr', contains = c('_p_boost__shared_ptrT_Instrument_t'))
setClass('_p_YoYInflationCapPtr', contains = c('_p_YoYInflationCapFloorPtr'))
setClass('_p_YoYInflationFloorPtr', contains = c('_p_YoYInflationCapFloorPtr'))
setClass('_p_YoYInflationCollarPtr', contains = c('_p_YoYInflationCapFloorPtr'))
setClass('_p_SegmentIntegral', contains = 'C++Reference')
setClass('_p_TrapezoidIntegralT_Default_t', contains = 'C++Reference')
setClass('_p_TrapezoidIntegralT_MidPoint_t', contains = 'C++Reference')
setClass('_p_SimpsonIntegral', contains = 'C++Reference')
setClass('_p_GaussKronrodAdaptive', contains = 'C++Reference')
setClass('_p_GaussKronrodNonAdaptive', contains = 'C++Reference')
setClass('_p_SampleT_double_t', contains = 'C++Reference')
setClass('_p_SampleT_Array_t', contains = 'C++Reference')
setClass('_p_SampleT_std__vectorT_double_std__allocatorT_double_t_t_t', contains = 'C++Reference')
setClass('_p_LecuyerUniformRng', contains = 'C++Reference')
setClass('_p_KnuthUniformRng', contains = 'C++Reference')
setClass('_p_MersenneTwisterUniformRng', contains = 'C++Reference')
setClass('_p_UniformRandomGenerator', contains = 'C++Reference')
setClass('_p_CLGaussianRngT_LecuyerUniformRng_t', contains = 'C++Reference')
setClass('_p_CLGaussianRngT_KnuthUniformRng_t', contains = 'C++Reference')
setClass('_p_CLGaussianRngT_MersenneTwisterUniformRng_t', contains = 'C++Reference')
setClass('_p_BoxMullerGaussianRngT_LecuyerUniformRng_t', contains = 'C++Reference')
setClass('_p_BoxMullerGaussianRngT_KnuthUniformRng_t', contains = 'C++Reference')
setClass('_p_BoxMullerGaussianRngT_MersenneTwisterUniformRng_t', contains = 'C++Reference')
setClass('_p_InverseCumulativeRngT_LecuyerUniformRng_MoroInverseCumulativeNormal_t', contains = 'C++Reference')
setClass('_p_InverseCumulativeRngT_KnuthUniformRng_MoroInverseCumulativeNormal_t', contains = 'C++Reference')
setClass('_p_InverseCumulativeRngT_MersenneTwisterUniformRng_MoroInverseCumulativeNormal_t', contains = 'C++Reference')
setClass('_p_InverseCumulativeRngT_LecuyerUniformRng_InverseCumulativeNormal_t', contains = 'C++Reference')
setClass('_p_InverseCumulativeRngT_KnuthUniformRng_InverseCumulativeNormal_t', contains = 'C++Reference')
setClass('_p_InverseCumulativeRngT_MersenneTwisterUniformRng_InverseCumulativeNormal_t', contains = 'C++Reference')
setClass('_p_GaussianRandomGenerator', contains = 'C++Reference')
setClass('_p_HaltonRsg', contains = 'C++Reference')
setClass('_p_SobolRsg', contains = 'C++Reference')
setClass('_p_RandomSequenceGeneratorT_LecuyerUniformRng_t', contains = 'C++Reference')
setClass('_p_RandomSequenceGeneratorT_KnuthUniformRng_t', contains = 'C++Reference')
setClass('_p_RandomSequenceGeneratorT_MersenneTwisterUniformRng_t', contains = 'C++Reference')
setClass('_p_UniformRandomSequenceGenerator', contains = 'C++Reference')
setClass('_p_UniformLowDiscrepancySequenceGenerator', contains = 'C++Reference')
setClass('_p_InverseCumulativeRsgT_RandomSequenceGeneratorT_LecuyerUniformRng_t_MoroInverseCumulativeNormal_t', contains = 'C++Reference')
setClass('_p_InverseCumulativeRsgT_RandomSequenceGeneratorT_KnuthUniformRng_t_MoroInverseCumulativeNormal_t', contains = 'C++Reference')
setClass('_p_InverseCumulativeRsgT_RandomSequenceGeneratorT_MersenneTwisterUniformRng_t_MoroInverseCumulativeNormal_t', contains = 'C++Reference')
setClass('_p_InverseCumulativeRsgT_HaltonRsg_MoroInverseCumulativeNormal_t', contains = 'C++Reference')
setClass('_p_InverseCumulativeRsgT_RandomSequenceGeneratorT_LecuyerUniformRng_t_InverseCumulativeNormal_t', contains = 'C++Reference')
setClass('_p_InverseCumulativeRsgT_RandomSequenceGeneratorT_KnuthUniformRng_t_InverseCumulativeNormal_t', contains = 'C++Reference')
setClass('_p_InverseCumulativeRsgT_RandomSequenceGeneratorT_MersenneTwisterUniformRng_t_InverseCumulativeNormal_t', contains = 'C++Reference')
setClass('_p_InverseCumulativeRsgT_HaltonRsg_InverseCumulativeNormal_t', contains = 'C++Reference')
setClass('_p_GaussianRandomSequenceGenerator', contains = 'C++Reference')
setClass('_p_GaussianLowDiscrepancySequenceGenerator', contains = 'C++Reference')
setClass('_p_Path', contains = 'C++Reference')
setClass('_p_SampleT_Path_t', contains = 'C++Reference')
setClass('_p_GaussianPathGenerator', contains = 'C++Reference')
setClass('_p_GaussianSobolPathGenerator', contains = 'C++Reference')
setClass('_p_MultiPath', contains = 'C++Reference')
setClass('_p_SampleT_MultiPath_t', contains = 'C++Reference')
setClass('_p_GaussianMultiPathGenerator', contains = 'C++Reference')
setClass('_p_boost__shared_ptrT_DefaultBoundaryCondition_t', contains = 'C++Reference')
setClass('_p_NeumannBCPtr', contains = c('_p_boost__shared_ptrT_DefaultBoundaryCondition_t'))
setClass('_p_DirichletBCPtr', contains = c('_p_boost__shared_ptrT_DefaultBoundaryCondition_t'))
setClass('_p_TridiagonalOperator', contains = 'C++Reference')
setClass('_p_DPlus', contains = c('_p_TridiagonalOperator'))
setClass('_p_DMinus', contains = c('_p_TridiagonalOperator'))
setClass('_p_DZero', contains = c('_p_TridiagonalOperator'))
setClass('_p_DPlusDMinus', contains = c('_p_TridiagonalOperator'))
setClass('_p_TimeBasket', contains = 'C++Reference')
setClass('_p_SwapPtr', contains = c('_p_boost__shared_ptrT_Instrument_t'))
setClass('_p_VanillaSwapPtr', contains = c('_p_SwapPtr'))
setClass('_p_DiscountingSwapEnginePtr', contains = c('_p_boost__shared_ptrT_PricingEngine_t'))
setClass('_p_AssetSwapPtr', contains = c('_p_SwapPtr'))
setClass('_p_boost__shared_ptrT_RateHelper_t', contains = 'C++Reference')
setClass('_p_DepositRateHelperPtr', contains = c('_p_boost__shared_ptrT_RateHelper_t'))
setClass('_p_FraRateHelperPtr', contains = c('_p_boost__shared_ptrT_RateHelper_t'))
setClass('_p_FuturesRateHelperPtr', contains = c('_p_boost__shared_ptrT_RateHelper_t'))
setClass('_p_SwapRateHelperPtr', contains = c('_p_boost__shared_ptrT_RateHelper_t'))
setClass('_p_FixedRateBondHelperPtr', contains = c('_p_boost__shared_ptrT_RateHelper_t'))
setClass('_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t', contains = 'C++Reference')
setClass('_p_Discount', contains = 'ExternalReference')
setClass("Discount",
    representation(
),
        contains = "RSWIGStruct")


# End class Discount

setClass('_p_ZeroYield', contains = 'ExternalReference')
setClass("ZeroYield",
    representation(
),
        contains = "RSWIGStruct")


# End class ZeroYield

setClass('_p_ForwardRate', contains = 'ExternalReference')
setClass("ForwardRate",
    representation(
),
        contains = "RSWIGStruct")


# End class ForwardRate

setClass('_p_PiecewiseFlatForwardPtr', contains = c('_p_boost__shared_ptrT_YieldTermStructure_t'))
setClass('_p_SampledCurve', contains = 'C++Reference')
setClass('_p_Settings', contains = 'C++Reference')
setClass('_p_boost__shared_ptrT_CalibrationHelper_t', contains = 'C++Reference')
setClass('_p_SwaptionHelperPtr', contains = c('_p_boost__shared_ptrT_CalibrationHelper_t'))
setClass('_p_CapHelperPtr', contains = c('_p_boost__shared_ptrT_CalibrationHelper_t'))
setClass('_p_std__vectorT_boost__shared_ptrT_CalibrationHelper_t_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t_t', contains = 'C++Reference')
setClass('_p_boost__shared_ptrT_ShortRateModel_t', contains = 'C++Reference')
setClass('_p_HandleT_ShortRateModel_t', contains = 'C++Reference')
setClass('_p_RelinkableHandleT_ShortRateModel_t', contains = c('_p_HandleT_ShortRateModel_t'))
setClass('_p_VasicekPtr', contains = c('_p_boost__shared_ptrT_ShortRateModel_t'))
setClass('_p_HullWhitePtr', contains = c('_p_boost__shared_ptrT_ShortRateModel_t'))
setClass('_p_BlackKarasinskiPtr', contains = c('_p_boost__shared_ptrT_ShortRateModel_t'))
setClass('_p_G2Ptr', contains = c('_p_boost__shared_ptrT_ShortRateModel_t'))
setClass('_p_JamshidianSwaptionEnginePtr', contains = c('_p_boost__shared_ptrT_PricingEngine_t'))
setClass('_p_TreeSwaptionEnginePtr', contains = c('_p_boost__shared_ptrT_PricingEngine_t'))
setClass('_p_AnalyticCapFloorEnginePtr', contains = c('_p_boost__shared_ptrT_PricingEngine_t'))
setClass('_p_TreeCapFloorEnginePtr', contains = c('_p_boost__shared_ptrT_PricingEngine_t'))
setClass('_p_G2SwaptionEnginePtr', contains = c('_p_boost__shared_ptrT_PricingEngine_t'))
setClass('_p_Statistics', contains = 'C++Reference')
setClass('_p_IncrementalStatistics', contains = 'C++Reference')
setClass('_p_RiskStatistics', contains = c('_p_Statistics'))
setClass('_p_GenericSequenceStatisticsT_Statistics_t', contains = 'C++Reference')
setClass('_p_GenericSequenceStatisticsT_RiskStatistics_t', contains = 'C++Reference')
setClass('_p_GenericSequenceStatisticsT_IncrementalStatistics_t', contains = 'C++Reference')
setClass('_p_boost__shared_ptrT_CapFloorTermVolatilityStructure_t', contains = 'C++Reference')
setClass('_p_HandleT_CapFloorTermVolatilityStructure_t', contains = 'C++Reference')
setClass('_p_RelinkableHandleT_CapFloorTermVolatilityStructure_t', contains = c('_p_HandleT_CapFloorTermVolatilityStructure_t'))
setClass('_p_CapFloorTermVolCurvePtr', contains = c('_p_boost__shared_ptrT_CapFloorTermVolatilityStructure_t'))
setClass('_p_Settlement', contains = 'ExternalReference')
setClass("Settlement",
    representation(
),
        contains = "RSWIGStruct")


# End class Settlement

setClass('_p_SwaptionPtr', contains = c('_p_boost__shared_ptrT_Instrument_t'))
setClass('_p_BlackSwaptionEnginePtr', contains = c('_p_boost__shared_ptrT_PricingEngine_t'))
setClass('_p_boost__shared_ptrT_Surface_t', contains = 'C++Reference')
setClass('_p_TestSurfacePtr', contains = c('_p_boost__shared_ptrT_Surface_t'))
setClass('_p_ConstantEstimator', contains = 'C++Reference')
setClass('_p_ParkinsonSigma', contains = 'C++Reference')
setClass('_p_GarmanKlassSigma1', contains = 'C++Reference')
setClass('_p_GarmanKlassSigma3', contains = 'C++Reference')
setClass('_p_GarmanKlassSigma4', contains = 'C++Reference')
setClass('_p_GarmanKlassSigma5', contains = 'C++Reference')
setClass('_p_GarmanKlassSigma6', contains = 'C++Reference')
setClass('_p_ZeroCurvePtr', contains = c('_p_boost__shared_ptrT_YieldTermStructure_t'))



setMethod('[', "ExternalReference",
function(x,i,j, ..., drop=TRUE) 
if (!is.null(x$"__getitem__")) 
sapply(i, function(n) x$"__getitem__"(i=as.integer(n-1))))

setMethod('[<-' , "ExternalReference",
function(x,i,j, ..., value) 
if (!is.null(x$"__setitem__")) {
sapply(1:length(i), function(n) 
x$"__setitem__"(i=as.integer(i[n]-1), x=value[n]))
x
})

setAs('ExternalReference', 'character',
function(from) {if (!is.null(from$"__str__")) from$"__str__"()})

setMethod('print', 'ExternalReference',
function(x) {print(as(x, "character"))})

defineEnumeration('_Weekday',
                    .values = c(
                        'Sunday' = 1, 
                        'Monday' = 2, 
                        'Tuesday' = 3, 
                        'Wednesday' = 4, 
                        'Thursday' = 5, 
                        'Friday' = 6, 
                        'Saturday' = 7
))
defineEnumeration('_Month',
                    .values = c(
                        'January' = 1, 
                        'February' = 2, 
                        'March' = 3, 
                        'April' = 4, 
                        'May' = 5, 
                        'June' = 6, 
                        'July' = 7, 
                        'August' = 8, 
                        'September' = 9, 
                        'October' = 10, 
                        'November' = 11, 
                        'December' = 12
))
defineEnumeration('_TimeUnit',
                    .values = c(
                        'Days' = 0, 
                        'Weeks' = 1, 
                        'Months' = 2, 
                        'Years' = 3
))
defineEnumeration('_Frequency',
                    .values = c(
                        'NoFrequency' = -1, 
                        'Once' = 0, 
                        'Annual' = 1, 
                        'Semiannual' = 2, 
                        'EveryFourthMonth' = 3, 
                        'Quarterly' = 4, 
                        'Bimonthly' = 6, 
                        'Monthly' = 12, 
                        'EveryFourthWeek' = 13, 
                        'Biweekly' = 26, 
                        'Weekly' = 52, 
                        'Daily' = 365, 
                        'OtherFrequency' = 999
))
# Start of new_Period

`Period__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_Period__SWIG_0', PACKAGE='QuantLib');
  class(ans) <- "_p_Period";
  
  reg.finalizer(ans, delete_Period)
  ans
  
}

attr(`Period__SWIG_0`, 'returnType') = '_p_Period'
class(`Period__SWIG_0`) = c("SWIGFunction", class('Period__SWIG_0'))

# Start of new_Period

`Period__SWIG_1` = function(n, units)
{
  n = as.integer(n); 
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  units = enumToInteger(units, "_TimeUnit"); 
  
  if(length(units) > 1) {
    warning("using only the first element of units");
  };
  
  ;ans = .Call('R_swig_new_Period__SWIG_1', n, units, PACKAGE='QuantLib');
  class(ans) <- "_p_Period";
  
  reg.finalizer(ans, delete_Period)
  ans
  
}

attr(`Period__SWIG_1`, 'returnType') = '_p_Period'
attr(`Period__SWIG_1`, "inputTypes") = c('integer', 'character')
class(`Period__SWIG_1`) = c("SWIGFunction", class('Period__SWIG_1'))

# Start of new_Period

`Period__SWIG_2` = function(s_arg1)
{
  s_arg1 = enumToInteger(s_arg1, "_Frequency"); 
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  ;ans = .Call('R_swig_new_Period__SWIG_2', s_arg1, PACKAGE='QuantLib');
  class(ans) <- "_p_Period";
  
  reg.finalizer(ans, delete_Period)
  ans
  
}

attr(`Period__SWIG_2`, 'returnType') = '_p_Period'
attr(`Period__SWIG_2`, "inputTypes") = c('character')
class(`Period__SWIG_2`) = c("SWIGFunction", class('Period__SWIG_2'))

# Start of Period_length

`Period_length` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Period_length', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Period_length`, 'returnType') = 'integer'
attr(`Period_length`, "inputTypes") = c('_p_Period')
class(`Period_length`) = c("SWIGFunction", class('Period_length'))

# Start of Period_units

`Period_units` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_Period_units', self, as.logical(.copy), PACKAGE='QuantLib');
  ans = enumFromInteger(ans, "_TimeUnit");
  
  ans
  
}

attr(`Period_units`, 'returnType') = 'character'
attr(`Period_units`, "inputTypes") = c('_p_Period')
class(`Period_units`) = c("SWIGFunction", class('Period_units'))

# Start of Period_frequency

`Period_frequency` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_Period_frequency', self, as.logical(.copy), PACKAGE='QuantLib');
  ans = enumFromInteger(ans, "_Frequency");
  
  ans
  
}

attr(`Period_frequency`, 'returnType') = 'character'
attr(`Period_frequency`, "inputTypes") = c('_p_Period')
class(`Period_frequency`) = c("SWIGFunction", class('Period_frequency'))

# Start of new_Period

`Period__SWIG_3` = function(str)
{
  str = as(str, "character"); 
  ;ans = .Call('R_swig_new_Period__SWIG_3', str, PACKAGE='QuantLib');
  class(ans) <- "_p_Period";
  
  reg.finalizer(ans, delete_Period)
  ans
  
}

attr(`Period__SWIG_3`, 'returnType') = '_p_Period'
attr(`Period__SWIG_3`, "inputTypes") = c('character')
class(`Period__SWIG_3`) = c("SWIGFunction", class('Period__SWIG_3'))

`Period` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- Period__SWIG_0; 
  } else if (argc == 1) {
    if (is.character(argv[[1]])) {
      f <- Period__SWIG_2; 
    }
    else if (is.character(argv[[1]])) {
      f <- Period__SWIG_3; 
    }
  } else if (argc == 2) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && is.character(argv[[2]])) {
      f <- Period__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for Period with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of Period___str__

`Period___str__` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Period___str__', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Period___str__`, 'returnType') = 'character'
attr(`Period___str__`, "inputTypes") = c('_p_Period')
class(`Period___str__`) = c("SWIGFunction", class('Period___str__'))

# Start of Period___repr__

`Period___repr__` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Period___repr__', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Period___repr__`, 'returnType') = 'character'
attr(`Period___repr__`, "inputTypes") = c('_p_Period')
class(`Period___repr__`) = c("SWIGFunction", class('Period___repr__'))

# Start of Period___neg__

`Period___neg__` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_Period___neg__', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Period";
  
  ans
  
}

attr(`Period___neg__`, 'returnType') = '_p_Period'
attr(`Period___neg__`, "inputTypes") = c('_p_Period')
class(`Period___neg__`) = c("SWIGFunction", class('Period___neg__'))

# Start of Period___mul__

`Period___mul__` = function(self, n, .copy = FALSE)
{
  n = as.integer(n); 
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;ans = .Call('R_swig_Period___mul__', self, n, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Period";
  
  ans
  
}

attr(`Period___mul__`, 'returnType') = '_p_Period'
attr(`Period___mul__`, "inputTypes") = c('_p_Period', 'integer')
class(`Period___mul__`) = c("SWIGFunction", class('Period___mul__'))

# Start of Period___eq__

`Period___eq__` = function(self, other, .copy = FALSE)
{
  ;.Call('R_swig_Period___eq__', self, other, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Period___eq__`, 'returnType') = 'logical'
attr(`Period___eq__`, "inputTypes") = c('_p_Period', '_p_Period')
class(`Period___eq__`) = c("SWIGFunction", class('Period___eq__'))

# Start of Period___cmp__

`Period___cmp__` = function(self, other, .copy = FALSE)
{
  ;.Call('R_swig_Period___cmp__', self, other, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Period___cmp__`, 'returnType') = 'integer'
attr(`Period___cmp__`, "inputTypes") = c('_p_Period', '_p_Period')
class(`Period___cmp__`) = c("SWIGFunction", class('Period___cmp__'))

# Start of delete_Period

`delete_Period` = function(self)
{
  ;.Call('R_swig_delete_Period', self, PACKAGE='QuantLib');
  
}

attr(`delete_Period`, 'returnType') = 'void'
attr(`delete_Period`, "inputTypes") = c('_p_Period')
class(`delete_Period`) = c("SWIGFunction", class('delete_Period'))

# Start of accessor method for Period
setMethod('$', '_p_Period', function(x, name)

{
  accessorFuns = list('length' = Period_length, 'units' = Period_units, 'frequency' = Period_frequency, '__str__' = Period___str__, '__repr__' = Period___repr__, '__neg__' = Period___neg__, '__mul__' = Period___mul__, '__eq__' = Period___eq__, '__cmp__' = Period___cmp__);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for Period
setMethod('delete', '_p_Period', function(obj) {delete_Period(obj)})
# Start of PeriodVector___nonzero__

`PeriodVector___nonzero__` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_PeriodVector___nonzero__', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`PeriodVector___nonzero__`, 'returnType') = 'logical'
attr(`PeriodVector___nonzero__`, "inputTypes") = c('_p_std__vectorT_Period_std__allocatorT_Period_t_t')
class(`PeriodVector___nonzero__`) = c("SWIGFunction", class('PeriodVector___nonzero__'))

# Start of PeriodVector___len__

`PeriodVector___len__` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_PeriodVector___len__', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`PeriodVector___len__`, 'returnType') = 'integer'
attr(`PeriodVector___len__`, "inputTypes") = c('_p_std__vectorT_Period_std__allocatorT_Period_t_t')
class(`PeriodVector___len__`) = c("SWIGFunction", class('PeriodVector___len__'))

# Start of PeriodVector_pop

`PeriodVector_pop` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_PeriodVector_pop', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Period";
  
  ans
  
}

attr(`PeriodVector_pop`, 'returnType') = '_p_Period'
attr(`PeriodVector_pop`, "inputTypes") = c('_p_std__vectorT_Period_std__allocatorT_Period_t_t')
class(`PeriodVector_pop`) = c("SWIGFunction", class('PeriodVector_pop'))

# Start of PeriodVector___getslice__

`PeriodVector___getslice__` = function(self, i, j)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;ans = .Call('R_swig_PeriodVector___getslice__', self, i, j, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_Period_std__allocatorT_Period_t_t";
  
  ans
  
}

attr(`PeriodVector___getslice__`, 'returnType') = '_p_std__vectorT_Period_std__allocatorT_Period_t_t'
attr(`PeriodVector___getslice__`, "inputTypes") = c('_p_std__vectorT_Period_std__allocatorT_Period_t_t', 'integer', 'integer')
class(`PeriodVector___getslice__`) = c("SWIGFunction", class('PeriodVector___getslice__'))

# Start of PeriodVector___setslice__

`PeriodVector___setslice__` = function(self, i, j, v)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  
  ;.Call('R_swig_PeriodVector___setslice__', self, i, j, v, PACKAGE='QuantLib');
  
}

attr(`PeriodVector___setslice__`, 'returnType') = 'void'
attr(`PeriodVector___setslice__`, "inputTypes") = c('_p_std__vectorT_Period_std__allocatorT_Period_t_t', 'integer', 'integer', '_p_std__vectorT_Period_std__allocatorT_Period_t_t')
class(`PeriodVector___setslice__`) = c("SWIGFunction", class('PeriodVector___setslice__'))

# Start of PeriodVector___delslice__

`PeriodVector___delslice__` = function(self, i, j)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_PeriodVector___delslice__', self, i, j, PACKAGE='QuantLib');
  
}

attr(`PeriodVector___delslice__`, 'returnType') = 'void'
attr(`PeriodVector___delslice__`, "inputTypes") = c('_p_std__vectorT_Period_std__allocatorT_Period_t_t', 'integer', 'integer')
class(`PeriodVector___delslice__`) = c("SWIGFunction", class('PeriodVector___delslice__'))

# Start of PeriodVector___delitem__

`PeriodVector___delitem__` = function(self, i)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_PeriodVector___delitem__', self, i, PACKAGE='QuantLib');
  
}

attr(`PeriodVector___delitem__`, 'returnType') = 'void'
attr(`PeriodVector___delitem__`, "inputTypes") = c('_p_std__vectorT_Period_std__allocatorT_Period_t_t', 'integer')
class(`PeriodVector___delitem__`) = c("SWIGFunction", class('PeriodVector___delitem__'))

# Start of PeriodVector___getitem__

`PeriodVector___getitem__` = function(self, i, .copy = FALSE)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;ans = .Call('R_swig_PeriodVector___getitem__', self, i, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Period";
  
  ans
  
}

attr(`PeriodVector___getitem__`, 'returnType') = '_p_Period'
attr(`PeriodVector___getitem__`, "inputTypes") = c('_p_std__vectorT_Period_std__allocatorT_Period_t_t', 'integer')
class(`PeriodVector___getitem__`) = c("SWIGFunction", class('PeriodVector___getitem__'))

# Start of PeriodVector___setitem__

`PeriodVector___setitem__` = function(self, i, x)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  ;.Call('R_swig_PeriodVector___setitem__', self, i, x, PACKAGE='QuantLib');
  
}

attr(`PeriodVector___setitem__`, 'returnType') = 'void'
attr(`PeriodVector___setitem__`, "inputTypes") = c('_p_std__vectorT_Period_std__allocatorT_Period_t_t', 'integer', '_p_Period')
class(`PeriodVector___setitem__`) = c("SWIGFunction", class('PeriodVector___setitem__'))

# Start of PeriodVector_append

`PeriodVector_append` = function(self, x)
{
  ;.Call('R_swig_PeriodVector_append', self, x, PACKAGE='QuantLib');
  
}

attr(`PeriodVector_append`, 'returnType') = 'void'
attr(`PeriodVector_append`, "inputTypes") = c('_p_std__vectorT_Period_std__allocatorT_Period_t_t', '_p_Period')
class(`PeriodVector_append`) = c("SWIGFunction", class('PeriodVector_append'))

# Start of new_PeriodVector

`PeriodVector__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_PeriodVector__SWIG_0', PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_Period_std__allocatorT_Period_t_t";
  
  reg.finalizer(ans, delete_PeriodVector)
  ans
  
}

attr(`PeriodVector__SWIG_0`, 'returnType') = '_p_std__vectorT_Period_std__allocatorT_Period_t_t'
class(`PeriodVector__SWIG_0`) = c("SWIGFunction", class('PeriodVector__SWIG_0'))

# Start of new_PeriodVector

`PeriodVector__SWIG_1` = function(s_arg1)
{
  ;ans = .Call('R_swig_new_PeriodVector__SWIG_1', s_arg1, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_Period_std__allocatorT_Period_t_t";
  
  reg.finalizer(ans, delete_PeriodVector)
  ans
  
}

attr(`PeriodVector__SWIG_1`, 'returnType') = '_p_std__vectorT_Period_std__allocatorT_Period_t_t'
attr(`PeriodVector__SWIG_1`, "inputTypes") = c('_p_std__vectorT_Period_std__allocatorT_Period_t_t')
class(`PeriodVector__SWIG_1`) = c("SWIGFunction", class('PeriodVector__SWIG_1'))

# Start of PeriodVector_empty

`PeriodVector_empty` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_PeriodVector_empty', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`PeriodVector_empty`, 'returnType') = 'logical'
attr(`PeriodVector_empty`, "inputTypes") = c('_p_std__vectorT_Period_std__allocatorT_Period_t_t')
class(`PeriodVector_empty`) = c("SWIGFunction", class('PeriodVector_empty'))

# Start of PeriodVector_size

`PeriodVector_size` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_PeriodVector_size', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`PeriodVector_size`, 'returnType') = 'integer'
attr(`PeriodVector_size`, "inputTypes") = c('_p_std__vectorT_Period_std__allocatorT_Period_t_t')
class(`PeriodVector_size`) = c("SWIGFunction", class('PeriodVector_size'))

# Start of PeriodVector_clear

`PeriodVector_clear` = function(self)
{
  ;.Call('R_swig_PeriodVector_clear', self, PACKAGE='QuantLib');
  
}

attr(`PeriodVector_clear`, 'returnType') = 'void'
attr(`PeriodVector_clear`, "inputTypes") = c('_p_std__vectorT_Period_std__allocatorT_Period_t_t')
class(`PeriodVector_clear`) = c("SWIGFunction", class('PeriodVector_clear'))

# Start of PeriodVector_swap

`PeriodVector_swap` = function(self, v)
{
  ;.Call('R_swig_PeriodVector_swap', self, v, PACKAGE='QuantLib');
  
}

attr(`PeriodVector_swap`, 'returnType') = 'void'
attr(`PeriodVector_swap`, "inputTypes") = c('_p_std__vectorT_Period_std__allocatorT_Period_t_t', '_p_std__vectorT_Period_std__allocatorT_Period_t_t')
class(`PeriodVector_swap`) = c("SWIGFunction", class('PeriodVector_swap'))

# Start of PeriodVector_get_allocator

`PeriodVector_get_allocator` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_PeriodVector_get_allocator', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__allocatorT_Period_t";
  
  ans
  
}

attr(`PeriodVector_get_allocator`, 'returnType') = '_p_std__allocatorT_Period_t'
attr(`PeriodVector_get_allocator`, "inputTypes") = c('_p_std__vectorT_Period_std__allocatorT_Period_t_t')
class(`PeriodVector_get_allocator`) = c("SWIGFunction", class('PeriodVector_get_allocator'))

# Start of new_PeriodVector

`PeriodVector__SWIG_2` = function(size)
{
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_new_PeriodVector__SWIG_2', size, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_Period_std__allocatorT_Period_t_t";
  
  reg.finalizer(ans, delete_PeriodVector)
  ans
  
}

attr(`PeriodVector__SWIG_2`, 'returnType') = '_p_std__vectorT_Period_std__allocatorT_Period_t_t'
attr(`PeriodVector__SWIG_2`, "inputTypes") = c('integer')
class(`PeriodVector__SWIG_2`) = c("SWIGFunction", class('PeriodVector__SWIG_2'))

# Start of PeriodVector_pop_back

`PeriodVector_pop_back` = function(self)
{
  ;.Call('R_swig_PeriodVector_pop_back', self, PACKAGE='QuantLib');
  
}

attr(`PeriodVector_pop_back`, 'returnType') = 'void'
attr(`PeriodVector_pop_back`, "inputTypes") = c('_p_std__vectorT_Period_std__allocatorT_Period_t_t')
class(`PeriodVector_pop_back`) = c("SWIGFunction", class('PeriodVector_pop_back'))

# Start of PeriodVector_resize

`PeriodVector_resize__SWIG_0` = function(self, new_size)
{
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_PeriodVector_resize__SWIG_0', self, new_size, PACKAGE='QuantLib');
  
}

attr(`PeriodVector_resize__SWIG_0`, 'returnType') = 'void'
attr(`PeriodVector_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_Period_std__allocatorT_Period_t_t', 'integer')
class(`PeriodVector_resize__SWIG_0`) = c("SWIGFunction", class('PeriodVector_resize__SWIG_0'))

# Start of new_PeriodVector

`PeriodVector__SWIG_3` = function(size, value)
{
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  
  ;ans = .Call('R_swig_new_PeriodVector__SWIG_3', size, value, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_Period_std__allocatorT_Period_t_t";
  
  reg.finalizer(ans, delete_PeriodVector)
  ans
  
}

attr(`PeriodVector__SWIG_3`, 'returnType') = '_p_std__vectorT_Period_std__allocatorT_Period_t_t'
attr(`PeriodVector__SWIG_3`, "inputTypes") = c('integer', '_p_Period')
class(`PeriodVector__SWIG_3`) = c("SWIGFunction", class('PeriodVector__SWIG_3'))

`PeriodVector` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- PeriodVector__SWIG_0; 
  } else if (argc == 1) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]]))) {
      f <- PeriodVector__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_Period_std__allocatorT_Period_t_t')) {
      f <- PeriodVector__SWIG_1; 
    }
  } else if (argc == 2) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && extends(argtypes[2], '_p_Period')) {
      f <- PeriodVector__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for PeriodVector with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of PeriodVector_push_back

`PeriodVector_push_back` = function(self, x)
{
  ;.Call('R_swig_PeriodVector_push_back', self, x, PACKAGE='QuantLib');
  
}

attr(`PeriodVector_push_back`, 'returnType') = 'void'
attr(`PeriodVector_push_back`, "inputTypes") = c('_p_std__vectorT_Period_std__allocatorT_Period_t_t', '_p_Period')
class(`PeriodVector_push_back`) = c("SWIGFunction", class('PeriodVector_push_back'))

# Start of PeriodVector_front

`PeriodVector_front` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_PeriodVector_front', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Period";
  
  ans
  
}

attr(`PeriodVector_front`, 'returnType') = '_p_Period'
attr(`PeriodVector_front`, "inputTypes") = c('_p_std__vectorT_Period_std__allocatorT_Period_t_t')
class(`PeriodVector_front`) = c("SWIGFunction", class('PeriodVector_front'))

# Start of PeriodVector_back

`PeriodVector_back` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_PeriodVector_back', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Period";
  
  ans
  
}

attr(`PeriodVector_back`, 'returnType') = '_p_Period'
attr(`PeriodVector_back`, "inputTypes") = c('_p_std__vectorT_Period_std__allocatorT_Period_t_t')
class(`PeriodVector_back`) = c("SWIGFunction", class('PeriodVector_back'))

# Start of PeriodVector_assign

`PeriodVector_assign` = function(self, n, x)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  
  ;.Call('R_swig_PeriodVector_assign', self, n, x, PACKAGE='QuantLib');
  
}

attr(`PeriodVector_assign`, 'returnType') = 'void'
attr(`PeriodVector_assign`, "inputTypes") = c('_p_std__vectorT_Period_std__allocatorT_Period_t_t', 'integer', '_p_Period')
class(`PeriodVector_assign`) = c("SWIGFunction", class('PeriodVector_assign'))

# Start of PeriodVector_resize

`PeriodVector_resize__SWIG_1` = function(self, new_size, x)
{
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  
  ;.Call('R_swig_PeriodVector_resize__SWIG_1', self, new_size, x, PACKAGE='QuantLib');
  
}

attr(`PeriodVector_resize__SWIG_1`, 'returnType') = 'void'
attr(`PeriodVector_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_Period_std__allocatorT_Period_t_t', 'integer', '_p_Period')
class(`PeriodVector_resize__SWIG_1`) = c("SWIGFunction", class('PeriodVector_resize__SWIG_1'))

`PeriodVector_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_std__vectorT_Period_std__allocatorT_Period_t_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]]))) {
      f <- PeriodVector_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_std__vectorT_Period_std__allocatorT_Period_t_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && extends(argtypes[3], '_p_Period')) {
      f <- PeriodVector_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for PeriodVector_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of PeriodVector_reserve

`PeriodVector_reserve` = function(self, n)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_PeriodVector_reserve', self, n, PACKAGE='QuantLib');
  
}

attr(`PeriodVector_reserve`, 'returnType') = 'void'
attr(`PeriodVector_reserve`, "inputTypes") = c('_p_std__vectorT_Period_std__allocatorT_Period_t_t', 'integer')
class(`PeriodVector_reserve`) = c("SWIGFunction", class('PeriodVector_reserve'))

# Start of PeriodVector_capacity

`PeriodVector_capacity` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_PeriodVector_capacity', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`PeriodVector_capacity`, 'returnType') = 'integer'
attr(`PeriodVector_capacity`, "inputTypes") = c('_p_std__vectorT_Period_std__allocatorT_Period_t_t')
class(`PeriodVector_capacity`) = c("SWIGFunction", class('PeriodVector_capacity'))

# Start of delete_PeriodVector

`delete_PeriodVector` = function(self)
{
  ;.Call('R_swig_delete_PeriodVector', self, PACKAGE='QuantLib');
  
}

attr(`delete_PeriodVector`, 'returnType') = 'void'
attr(`delete_PeriodVector`, "inputTypes") = c('_p_std__vectorT_Period_std__allocatorT_Period_t_t')
class(`delete_PeriodVector`) = c("SWIGFunction", class('delete_PeriodVector'))

# Start of accessor method for std::vector<(Period)>
setMethod('$', '_p_std__vectorT_Period_std__allocatorT_Period_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = PeriodVector___nonzero__, '__len__' = PeriodVector___len__, 'pop' = PeriodVector_pop, '__getslice__' = PeriodVector___getslice__, '__setslice__' = PeriodVector___setslice__, '__delslice__' = PeriodVector___delslice__, '__delitem__' = PeriodVector___delitem__, '__getitem__' = PeriodVector___getitem__, '__setitem__' = PeriodVector___setitem__, 'append' = PeriodVector_append, 'empty' = PeriodVector_empty, 'size' = PeriodVector_size, 'clear' = PeriodVector_clear, 'swap' = PeriodVector_swap, 'get_allocator' = PeriodVector_get_allocator, 'pop_back' = PeriodVector_pop_back, 'resize' = PeriodVector_resize, 'push_back' = PeriodVector_push_back, 'front' = PeriodVector_front, 'back' = PeriodVector_back, 'assign' = PeriodVector_assign, 'reserve' = PeriodVector_reserve, 'capacity' = PeriodVector_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for std::vector<(Period)>
setMethod('delete', '_p_std__vectorT_Period_std__allocatorT_Period_t_t', function(obj) {delete_std__vectorT_Period_std__allocatorT_Period_t_t(obj)})

setAs("_p_Date", "character",
function(from) {from$ISO()})

setAs("character", "_p_Date",
function(from) { DateParser_parseISO(from) })


setMethod("as.numeric", "_p_Date",
    function(x) x$serialNumber())
setMethod("+", c("_p_Date", "numeric"),
    function(e1,e2) Date___add__(e1,e2))
setMethod("-", c("_p_Date", "numeric"),
    function(e1,e2) Date___sub__(e1,e2))
setMethod("+", c("_p_Date", "_p_Period"),
    function(e1,e2) Date___add__(e1,e2))
setMethod("-", c("_p_Date", "_p_Period"),
    function(e1,e2) Date___sub__(e1,e2))

setAs("character", "_p_Period",
function(from) {Period(from)})

# Start of new_Date

`Date__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_Date__SWIG_0', PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  reg.finalizer(ans, delete_Date)
  ans
  
}

attr(`Date__SWIG_0`, 'returnType') = '_p_Date'
class(`Date__SWIG_0`) = c("SWIGFunction", class('Date__SWIG_0'))

# Start of new_Date

`Date__SWIG_1` = function(d, m, y)
{
  d = as.integer(d); 
  
  if(length(d) > 1) {
    warning("using only the first element of d");
  };
  
  m = enumToInteger(m, "_Month"); 
  
  if(length(m) > 1) {
    warning("using only the first element of m");
  };
  
  y = as.integer(y); 
  
  if(length(y) > 1) {
    warning("using only the first element of y");
  };
  
  ;ans = .Call('R_swig_new_Date__SWIG_1', d, m, y, PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  reg.finalizer(ans, delete_Date)
  ans
  
}

attr(`Date__SWIG_1`, 'returnType') = '_p_Date'
attr(`Date__SWIG_1`, "inputTypes") = c('integer', 'character', 'integer')
class(`Date__SWIG_1`) = c("SWIGFunction", class('Date__SWIG_1'))

# Start of new_Date

`Date__SWIG_2` = function(serialNumber)
{
  serialNumber = as.integer(serialNumber); 
  
  if(length(serialNumber) > 1) {
    warning("using only the first element of serialNumber");
  };
  
  ;ans = .Call('R_swig_new_Date__SWIG_2', serialNumber, PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  reg.finalizer(ans, delete_Date)
  ans
  
}

attr(`Date__SWIG_2`, 'returnType') = '_p_Date'
attr(`Date__SWIG_2`, "inputTypes") = c('integer')
class(`Date__SWIG_2`) = c("SWIGFunction", class('Date__SWIG_2'))

# Start of Date_weekday

`Date_weekday` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_Date_weekday', self, as.logical(.copy), PACKAGE='QuantLib');
  ans = enumFromInteger(ans, "_Weekday");
  
  ans
  
}

attr(`Date_weekday`, 'returnType') = 'character'
attr(`Date_weekday`, "inputTypes") = c('_p_Date')
class(`Date_weekday`) = c("SWIGFunction", class('Date_weekday'))

# Start of Date_dayOfMonth

`Date_dayOfMonth` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Date_dayOfMonth', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Date_dayOfMonth`, 'returnType') = 'integer'
attr(`Date_dayOfMonth`, "inputTypes") = c('_p_Date')
class(`Date_dayOfMonth`) = c("SWIGFunction", class('Date_dayOfMonth'))

# Start of Date_dayOfYear

`Date_dayOfYear` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Date_dayOfYear', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Date_dayOfYear`, 'returnType') = 'integer'
attr(`Date_dayOfYear`, "inputTypes") = c('_p_Date')
class(`Date_dayOfYear`) = c("SWIGFunction", class('Date_dayOfYear'))

# Start of Date_month

`Date_month` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_Date_month', self, as.logical(.copy), PACKAGE='QuantLib');
  ans = enumFromInteger(ans, "_Month");
  
  ans
  
}

attr(`Date_month`, 'returnType') = 'character'
attr(`Date_month`, "inputTypes") = c('_p_Date')
class(`Date_month`) = c("SWIGFunction", class('Date_month'))

# Start of Date_year

`Date_year` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Date_year', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Date_year`, 'returnType') = 'integer'
attr(`Date_year`, "inputTypes") = c('_p_Date')
class(`Date_year`) = c("SWIGFunction", class('Date_year'))

# Start of Date_serialNumber

`Date_serialNumber` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Date_serialNumber', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Date_serialNumber`, 'returnType') = 'integer'
attr(`Date_serialNumber`, "inputTypes") = c('_p_Date')
class(`Date_serialNumber`) = c("SWIGFunction", class('Date_serialNumber'))

# Start of Date_isLeap

`Date_isLeap` = function(y, .copy = FALSE)
{
  y = as.integer(y); 
  
  if(length(y) > 1) {
    warning("using only the first element of y");
  };
  
  ;.Call('R_swig_Date_isLeap', y, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Date_isLeap`, 'returnType') = 'logical'
attr(`Date_isLeap`, "inputTypes") = c('integer')
class(`Date_isLeap`) = c("SWIGFunction", class('Date_isLeap'))

# Start of Date_minDate

`Date_minDate` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_Date_minDate', as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`Date_minDate`, 'returnType') = '_p_Date'
class(`Date_minDate`) = c("SWIGFunction", class('Date_minDate'))

# Start of Date_maxDate

`Date_maxDate` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_Date_maxDate', as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`Date_maxDate`, 'returnType') = '_p_Date'
class(`Date_maxDate`) = c("SWIGFunction", class('Date_maxDate'))

# Start of Date_todaysDate

`Date_todaysDate` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_Date_todaysDate', as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`Date_todaysDate`, 'returnType') = '_p_Date'
class(`Date_todaysDate`) = c("SWIGFunction", class('Date_todaysDate'))

# Start of Date_endOfMonth

`Date_endOfMonth` = function(s_arg1, .copy = FALSE)
{
  ;ans = .Call('R_swig_Date_endOfMonth', s_arg1, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`Date_endOfMonth`, 'returnType') = '_p_Date'
attr(`Date_endOfMonth`, "inputTypes") = c('_p_Date')
class(`Date_endOfMonth`) = c("SWIGFunction", class('Date_endOfMonth'))

# Start of Date_isEndOfMonth

`Date_isEndOfMonth` = function(s_arg1, .copy = FALSE)
{
  ;.Call('R_swig_Date_isEndOfMonth', s_arg1, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Date_isEndOfMonth`, 'returnType') = 'logical'
attr(`Date_isEndOfMonth`, "inputTypes") = c('_p_Date')
class(`Date_isEndOfMonth`) = c("SWIGFunction", class('Date_isEndOfMonth'))

# Start of Date_nextWeekday

`Date_nextWeekday` = function(s_arg1, s_arg2, .copy = FALSE)
{
  s_arg2 = enumToInteger(s_arg2, "_Weekday"); 
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  ;ans = .Call('R_swig_Date_nextWeekday', s_arg1, s_arg2, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`Date_nextWeekday`, 'returnType') = '_p_Date'
attr(`Date_nextWeekday`, "inputTypes") = c('_p_Date', 'character')
class(`Date_nextWeekday`) = c("SWIGFunction", class('Date_nextWeekday'))

# Start of Date_nthWeekday

`Date_nthWeekday` = function(n, s_arg2, m, y, .copy = FALSE)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  s_arg2 = enumToInteger(s_arg2, "_Weekday"); 
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  m = enumToInteger(m, "_Month"); 
  
  if(length(m) > 1) {
    warning("using only the first element of m");
  };
  
  y = as.integer(y); 
  
  if(length(y) > 1) {
    warning("using only the first element of y");
  };
  
  ;ans = .Call('R_swig_Date_nthWeekday', n, s_arg2, m, y, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`Date_nthWeekday`, 'returnType') = '_p_Date'
attr(`Date_nthWeekday`, "inputTypes") = c('integer', 'character', 'character', 'integer')
class(`Date_nthWeekday`) = c("SWIGFunction", class('Date_nthWeekday'))

# Start of Date___add__

`Date___add____SWIG_0` = function(self, days, .copy = FALSE)
{
  days = as.integer(days); 
  
  if(length(days) > 1) {
    warning("using only the first element of days");
  };
  
  ;ans = .Call('R_swig_Date___add____SWIG_0', self, days, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`Date___add____SWIG_0`, 'returnType') = '_p_Date'
attr(`Date___add____SWIG_0`, "inputTypes") = c('_p_Date', 'integer')
class(`Date___add____SWIG_0`) = c("SWIGFunction", class('Date___add____SWIG_0'))

# Start of Date___sub__

`Date___sub____SWIG_0` = function(self, days, .copy = FALSE)
{
  days = as.integer(days); 
  
  if(length(days) > 1) {
    warning("using only the first element of days");
  };
  
  ;ans = .Call('R_swig_Date___sub____SWIG_0', self, days, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`Date___sub____SWIG_0`, 'returnType') = '_p_Date'
attr(`Date___sub____SWIG_0`, "inputTypes") = c('_p_Date', 'integer')
class(`Date___sub____SWIG_0`) = c("SWIGFunction", class('Date___sub____SWIG_0'))

# Start of Date___add__

`Date___add____SWIG_1` = function(self, s_arg2, .copy = FALSE)
{
  ;ans = .Call('R_swig_Date___add____SWIG_1', self, s_arg2, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`Date___add____SWIG_1`, 'returnType') = '_p_Date'
attr(`Date___add____SWIG_1`, "inputTypes") = c('_p_Date', '_p_Period')
class(`Date___add____SWIG_1`) = c("SWIGFunction", class('Date___add____SWIG_1'))

`Date___add__` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_Date') && extends(argtypes[2], '_p_Period')) {
      f <- Date___add____SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_Date') && (is.integer(argv[[2]]) || is.numeric(argv[[2]]))) {
      f <- Date___add____SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Date___add__ with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of Date___sub__

`Date___sub____SWIG_1` = function(self, s_arg2, .copy = FALSE)
{
  ;ans = .Call('R_swig_Date___sub____SWIG_1', self, s_arg2, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`Date___sub____SWIG_1`, 'returnType') = '_p_Date'
attr(`Date___sub____SWIG_1`, "inputTypes") = c('_p_Date', '_p_Period')
class(`Date___sub____SWIG_1`) = c("SWIGFunction", class('Date___sub____SWIG_1'))

# Start of new_Date

`Date__SWIG_3` = function(str, fmt)
{
  str = as(str, "character"); 
  fmt = as(fmt, "character"); 
  ;ans = .Call('R_swig_new_Date__SWIG_3', str, fmt, PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  reg.finalizer(ans, delete_Date)
  ans
  
}

attr(`Date__SWIG_3`, 'returnType') = '_p_Date'
attr(`Date__SWIG_3`, "inputTypes") = c('character', 'character')
class(`Date__SWIG_3`) = c("SWIGFunction", class('Date__SWIG_3'))

`Date` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- Date__SWIG_0; 
  } else if (argc == 1) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]]))) {
      f <- Date__SWIG_2; 
    }
  } else if (argc == 2) {
    if (is.character(argv[[1]]) && is.character(argv[[2]])) {
      f <- Date__SWIG_3; 
    }
  } else if (argc == 3) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && is.character(argv[[2]]) && (is.integer(argv[[3]]) || is.numeric(argv[[3]]))) {
      f <- Date__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for Date with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of Date_weekdayNumber

`Date_weekdayNumber` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Date_weekdayNumber', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Date_weekdayNumber`, 'returnType') = 'integer'
attr(`Date_weekdayNumber`, "inputTypes") = c('_p_Date')
class(`Date_weekdayNumber`) = c("SWIGFunction", class('Date_weekdayNumber'))

# Start of Date___str__

`Date___str__` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Date___str__', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Date___str__`, 'returnType') = 'character'
attr(`Date___str__`, "inputTypes") = c('_p_Date')
class(`Date___str__`) = c("SWIGFunction", class('Date___str__'))

# Start of Date___repr__

`Date___repr__` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Date___repr__', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Date___repr__`, 'returnType') = 'character'
attr(`Date___repr__`, "inputTypes") = c('_p_Date')
class(`Date___repr__`) = c("SWIGFunction", class('Date___repr__'))

# Start of Date_ISO

`Date_ISO` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Date_ISO', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Date_ISO`, 'returnType') = 'character'
attr(`Date_ISO`, "inputTypes") = c('_p_Date')
class(`Date_ISO`) = c("SWIGFunction", class('Date_ISO'))

# Start of Date___sub__

`Date___sub____SWIG_2` = function(self, other, .copy = FALSE)
{
  ;.Call('R_swig_Date___sub____SWIG_2', self, other, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Date___sub____SWIG_2`, 'returnType') = 'integer'
attr(`Date___sub____SWIG_2`, "inputTypes") = c('_p_Date', '_p_Date')
class(`Date___sub____SWIG_2`) = c("SWIGFunction", class('Date___sub____SWIG_2'))

`Date___sub__` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 2) {
    if (extends(argtypes[1], '_p_Date') && extends(argtypes[2], '_p_Period')) {
      f <- Date___sub____SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_Date') && extends(argtypes[2], '_p_Date')) {
      f <- Date___sub____SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_Date') && (is.integer(argv[[2]]) || is.numeric(argv[[2]]))) {
      f <- Date___sub____SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Date___sub__ with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of Date___eq__

`Date___eq__` = function(self, other, .copy = FALSE)
{
  ;.Call('R_swig_Date___eq__', self, other, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Date___eq__`, 'returnType') = 'logical'
attr(`Date___eq__`, "inputTypes") = c('_p_Date', '_p_Date')
class(`Date___eq__`) = c("SWIGFunction", class('Date___eq__'))

# Start of Date___cmp__

`Date___cmp__` = function(self, other, .copy = FALSE)
{
  ;.Call('R_swig_Date___cmp__', self, other, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Date___cmp__`, 'returnType') = 'integer'
attr(`Date___cmp__`, "inputTypes") = c('_p_Date', '_p_Date')
class(`Date___cmp__`) = c("SWIGFunction", class('Date___cmp__'))

# Start of delete_Date

`delete_Date` = function(self)
{
  ;.Call('R_swig_delete_Date', self, PACKAGE='QuantLib');
  
}

attr(`delete_Date`, 'returnType') = 'void'
attr(`delete_Date`, "inputTypes") = c('_p_Date')
class(`delete_Date`) = c("SWIGFunction", class('delete_Date'))

# Start of accessor method for Date
setMethod('$', '_p_Date', function(x, name)

{
  accessorFuns = list('weekday' = Date_weekday, 'dayOfMonth' = Date_dayOfMonth, 'dayOfYear' = Date_dayOfYear, 'month' = Date_month, 'year' = Date_year, 'serialNumber' = Date_serialNumber, '__add__' = Date___add__, '__sub__' = Date___sub__, 'weekdayNumber' = Date_weekdayNumber, '__str__' = Date___str__, '__repr__' = Date___repr__, 'ISO' = Date_ISO, '__eq__' = Date___eq__, '__cmp__' = Date___cmp__);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for Date
setMethod('delete', '_p_Date', function(obj) {delete_Date(obj)})
# Start of DateParser_parse

`DateParser_parse` = function(str, fmt, .copy = FALSE)
{
  str = as(str, "character"); 
  fmt = as(fmt, "character"); 
  ;ans = .Call('R_swig_DateParser_parse', str, fmt, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`DateParser_parse`, 'returnType') = '_p_Date'
attr(`DateParser_parse`, "inputTypes") = c('character', 'character')
class(`DateParser_parse`) = c("SWIGFunction", class('DateParser_parse'))

# Start of DateParser_parseISO

`DateParser_parseISO` = function(str, .copy = FALSE)
{
  str = as(str, "character"); 
  ;ans = .Call('R_swig_DateParser_parseISO', str, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`DateParser_parseISO`, 'returnType') = '_p_Date'
attr(`DateParser_parseISO`, "inputTypes") = c('character')
class(`DateParser_parseISO`) = c("SWIGFunction", class('DateParser_parseISO'))

# Start of new_DateParser

`DateParser` = function()
{
  ;ans = .Call('R_swig_new_DateParser', PACKAGE='QuantLib');
  class(ans) <- "_p_DateParser";
  
  reg.finalizer(ans, delete_DateParser)
  ans
  
}

attr(`DateParser`, 'returnType') = '_p_DateParser'
class(`DateParser`) = c("SWIGFunction", class('DateParser'))

# Start of delete_DateParser

`delete_DateParser` = function(self)
{
  ;.Call('R_swig_delete_DateParser', self, PACKAGE='QuantLib');
  
}

attr(`delete_DateParser`, 'returnType') = 'void'
attr(`delete_DateParser`, "inputTypes") = c('_p_DateParser')
class(`delete_DateParser`) = c("SWIGFunction", class('delete_DateParser'))

setMethod('delete', '_p_DateParser', function(obj) {delete_DateParser(obj)})
# Start of PeriodParser_parse

`PeriodParser_parse` = function(str, .copy = FALSE)
{
  str = as(str, "character"); 
  ;ans = .Call('R_swig_PeriodParser_parse', str, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Period";
  
  ans
  
}

attr(`PeriodParser_parse`, 'returnType') = '_p_Period'
attr(`PeriodParser_parse`, "inputTypes") = c('character')
class(`PeriodParser_parse`) = c("SWIGFunction", class('PeriodParser_parse'))

# Start of new_PeriodParser

`PeriodParser` = function()
{
  ;ans = .Call('R_swig_new_PeriodParser', PACKAGE='QuantLib');
  class(ans) <- "_p_PeriodParser";
  
  reg.finalizer(ans, delete_PeriodParser)
  ans
  
}

attr(`PeriodParser`, 'returnType') = '_p_PeriodParser'
class(`PeriodParser`) = c("SWIGFunction", class('PeriodParser'))

# Start of delete_PeriodParser

`delete_PeriodParser` = function(self)
{
  ;.Call('R_swig_delete_PeriodParser', self, PACKAGE='QuantLib');
  
}

attr(`delete_PeriodParser`, 'returnType') = 'void'
attr(`delete_PeriodParser`, "inputTypes") = c('_p_PeriodParser')
class(`delete_PeriodParser`) = c("SWIGFunction", class('delete_PeriodParser'))

setMethod('delete', '_p_PeriodParser', function(obj) {delete_PeriodParser(obj)})
# Start of DateVector___nonzero__

`DateVector___nonzero__` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_DateVector___nonzero__', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DateVector___nonzero__`, 'returnType') = 'logical'
attr(`DateVector___nonzero__`, "inputTypes") = c('_p_std__vectorT_Date_std__allocatorT_Date_t_t')
class(`DateVector___nonzero__`) = c("SWIGFunction", class('DateVector___nonzero__'))

# Start of DateVector___len__

`DateVector___len__` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_DateVector___len__', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`DateVector___len__`, 'returnType') = 'integer'
attr(`DateVector___len__`, "inputTypes") = c('_p_std__vectorT_Date_std__allocatorT_Date_t_t')
class(`DateVector___len__`) = c("SWIGFunction", class('DateVector___len__'))

# Start of DateVector_pop

`DateVector_pop` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_DateVector_pop', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`DateVector_pop`, 'returnType') = '_p_Date'
attr(`DateVector_pop`, "inputTypes") = c('_p_std__vectorT_Date_std__allocatorT_Date_t_t')
class(`DateVector_pop`) = c("SWIGFunction", class('DateVector_pop'))

# Start of DateVector___getslice__

`DateVector___getslice__` = function(self, i, j)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;ans = .Call('R_swig_DateVector___getslice__', self, i, j, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_Date_std__allocatorT_Date_t_t";
  
  ans
  
}

attr(`DateVector___getslice__`, 'returnType') = '_p_std__vectorT_Date_std__allocatorT_Date_t_t'
attr(`DateVector___getslice__`, "inputTypes") = c('_p_std__vectorT_Date_std__allocatorT_Date_t_t', 'integer', 'integer')
class(`DateVector___getslice__`) = c("SWIGFunction", class('DateVector___getslice__'))

# Start of DateVector___setslice__

`DateVector___setslice__` = function(self, i, j, v)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  
  ;.Call('R_swig_DateVector___setslice__', self, i, j, v, PACKAGE='QuantLib');
  
}

attr(`DateVector___setslice__`, 'returnType') = 'void'
attr(`DateVector___setslice__`, "inputTypes") = c('_p_std__vectorT_Date_std__allocatorT_Date_t_t', 'integer', 'integer', '_p_std__vectorT_Date_std__allocatorT_Date_t_t')
class(`DateVector___setslice__`) = c("SWIGFunction", class('DateVector___setslice__'))

# Start of DateVector___delslice__

`DateVector___delslice__` = function(self, i, j)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_DateVector___delslice__', self, i, j, PACKAGE='QuantLib');
  
}

attr(`DateVector___delslice__`, 'returnType') = 'void'
attr(`DateVector___delslice__`, "inputTypes") = c('_p_std__vectorT_Date_std__allocatorT_Date_t_t', 'integer', 'integer')
class(`DateVector___delslice__`) = c("SWIGFunction", class('DateVector___delslice__'))

# Start of DateVector___delitem__

`DateVector___delitem__` = function(self, i)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_DateVector___delitem__', self, i, PACKAGE='QuantLib');
  
}

attr(`DateVector___delitem__`, 'returnType') = 'void'
attr(`DateVector___delitem__`, "inputTypes") = c('_p_std__vectorT_Date_std__allocatorT_Date_t_t', 'integer')
class(`DateVector___delitem__`) = c("SWIGFunction", class('DateVector___delitem__'))

# Start of DateVector___getitem__

`DateVector___getitem__` = function(self, i, .copy = FALSE)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;ans = .Call('R_swig_DateVector___getitem__', self, i, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`DateVector___getitem__`, 'returnType') = '_p_Date'
attr(`DateVector___getitem__`, "inputTypes") = c('_p_std__vectorT_Date_std__allocatorT_Date_t_t', 'integer')
class(`DateVector___getitem__`) = c("SWIGFunction", class('DateVector___getitem__'))

# Start of DateVector___setitem__

`DateVector___setitem__` = function(self, i, x)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  ;.Call('R_swig_DateVector___setitem__', self, i, x, PACKAGE='QuantLib');
  
}

attr(`DateVector___setitem__`, 'returnType') = 'void'
attr(`DateVector___setitem__`, "inputTypes") = c('_p_std__vectorT_Date_std__allocatorT_Date_t_t', 'integer', '_p_Date')
class(`DateVector___setitem__`) = c("SWIGFunction", class('DateVector___setitem__'))

# Start of DateVector_append

`DateVector_append` = function(self, x)
{
  ;.Call('R_swig_DateVector_append', self, x, PACKAGE='QuantLib');
  
}

attr(`DateVector_append`, 'returnType') = 'void'
attr(`DateVector_append`, "inputTypes") = c('_p_std__vectorT_Date_std__allocatorT_Date_t_t', '_p_Date')
class(`DateVector_append`) = c("SWIGFunction", class('DateVector_append'))

# Start of new_DateVector

`DateVector__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_DateVector__SWIG_0', PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_Date_std__allocatorT_Date_t_t";
  
  reg.finalizer(ans, delete_DateVector)
  ans
  
}

attr(`DateVector__SWIG_0`, 'returnType') = '_p_std__vectorT_Date_std__allocatorT_Date_t_t'
class(`DateVector__SWIG_0`) = c("SWIGFunction", class('DateVector__SWIG_0'))

# Start of new_DateVector

`DateVector__SWIG_1` = function(s_arg1)
{
  ;ans = .Call('R_swig_new_DateVector__SWIG_1', s_arg1, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_Date_std__allocatorT_Date_t_t";
  
  reg.finalizer(ans, delete_DateVector)
  ans
  
}

attr(`DateVector__SWIG_1`, 'returnType') = '_p_std__vectorT_Date_std__allocatorT_Date_t_t'
attr(`DateVector__SWIG_1`, "inputTypes") = c('_p_std__vectorT_Date_std__allocatorT_Date_t_t')
class(`DateVector__SWIG_1`) = c("SWIGFunction", class('DateVector__SWIG_1'))

# Start of DateVector_empty

`DateVector_empty` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_DateVector_empty', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DateVector_empty`, 'returnType') = 'logical'
attr(`DateVector_empty`, "inputTypes") = c('_p_std__vectorT_Date_std__allocatorT_Date_t_t')
class(`DateVector_empty`) = c("SWIGFunction", class('DateVector_empty'))

# Start of DateVector_size

`DateVector_size` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_DateVector_size', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`DateVector_size`, 'returnType') = 'integer'
attr(`DateVector_size`, "inputTypes") = c('_p_std__vectorT_Date_std__allocatorT_Date_t_t')
class(`DateVector_size`) = c("SWIGFunction", class('DateVector_size'))

# Start of DateVector_clear

`DateVector_clear` = function(self)
{
  ;.Call('R_swig_DateVector_clear', self, PACKAGE='QuantLib');
  
}

attr(`DateVector_clear`, 'returnType') = 'void'
attr(`DateVector_clear`, "inputTypes") = c('_p_std__vectorT_Date_std__allocatorT_Date_t_t')
class(`DateVector_clear`) = c("SWIGFunction", class('DateVector_clear'))

# Start of DateVector_swap

`DateVector_swap` = function(self, v)
{
  ;.Call('R_swig_DateVector_swap', self, v, PACKAGE='QuantLib');
  
}

attr(`DateVector_swap`, 'returnType') = 'void'
attr(`DateVector_swap`, "inputTypes") = c('_p_std__vectorT_Date_std__allocatorT_Date_t_t', '_p_std__vectorT_Date_std__allocatorT_Date_t_t')
class(`DateVector_swap`) = c("SWIGFunction", class('DateVector_swap'))

# Start of DateVector_get_allocator

`DateVector_get_allocator` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_DateVector_get_allocator', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__allocatorT_Date_t";
  
  ans
  
}

attr(`DateVector_get_allocator`, 'returnType') = '_p_std__allocatorT_Date_t'
attr(`DateVector_get_allocator`, "inputTypes") = c('_p_std__vectorT_Date_std__allocatorT_Date_t_t')
class(`DateVector_get_allocator`) = c("SWIGFunction", class('DateVector_get_allocator'))

# Start of new_DateVector

`DateVector__SWIG_2` = function(size)
{
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_new_DateVector__SWIG_2', size, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_Date_std__allocatorT_Date_t_t";
  
  reg.finalizer(ans, delete_DateVector)
  ans
  
}

attr(`DateVector__SWIG_2`, 'returnType') = '_p_std__vectorT_Date_std__allocatorT_Date_t_t'
attr(`DateVector__SWIG_2`, "inputTypes") = c('integer')
class(`DateVector__SWIG_2`) = c("SWIGFunction", class('DateVector__SWIG_2'))

# Start of DateVector_pop_back

`DateVector_pop_back` = function(self)
{
  ;.Call('R_swig_DateVector_pop_back', self, PACKAGE='QuantLib');
  
}

attr(`DateVector_pop_back`, 'returnType') = 'void'
attr(`DateVector_pop_back`, "inputTypes") = c('_p_std__vectorT_Date_std__allocatorT_Date_t_t')
class(`DateVector_pop_back`) = c("SWIGFunction", class('DateVector_pop_back'))

# Start of DateVector_resize

`DateVector_resize__SWIG_0` = function(self, new_size)
{
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_DateVector_resize__SWIG_0', self, new_size, PACKAGE='QuantLib');
  
}

attr(`DateVector_resize__SWIG_0`, 'returnType') = 'void'
attr(`DateVector_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_Date_std__allocatorT_Date_t_t', 'integer')
class(`DateVector_resize__SWIG_0`) = c("SWIGFunction", class('DateVector_resize__SWIG_0'))

# Start of new_DateVector

`DateVector__SWIG_3` = function(size, value)
{
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  
  ;ans = .Call('R_swig_new_DateVector__SWIG_3', size, value, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_Date_std__allocatorT_Date_t_t";
  
  reg.finalizer(ans, delete_DateVector)
  ans
  
}

attr(`DateVector__SWIG_3`, 'returnType') = '_p_std__vectorT_Date_std__allocatorT_Date_t_t'
attr(`DateVector__SWIG_3`, "inputTypes") = c('integer', '_p_Date')
class(`DateVector__SWIG_3`) = c("SWIGFunction", class('DateVector__SWIG_3'))

`DateVector` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- DateVector__SWIG_0; 
  } else if (argc == 1) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]]))) {
      f <- DateVector__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_Date_std__allocatorT_Date_t_t')) {
      f <- DateVector__SWIG_1; 
    }
  } else if (argc == 2) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && extends(argtypes[2], '_p_Date')) {
      f <- DateVector__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for DateVector with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of DateVector_push_back

`DateVector_push_back` = function(self, x)
{
  ;.Call('R_swig_DateVector_push_back', self, x, PACKAGE='QuantLib');
  
}

attr(`DateVector_push_back`, 'returnType') = 'void'
attr(`DateVector_push_back`, "inputTypes") = c('_p_std__vectorT_Date_std__allocatorT_Date_t_t', '_p_Date')
class(`DateVector_push_back`) = c("SWIGFunction", class('DateVector_push_back'))

# Start of DateVector_front

`DateVector_front` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_DateVector_front', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`DateVector_front`, 'returnType') = '_p_Date'
attr(`DateVector_front`, "inputTypes") = c('_p_std__vectorT_Date_std__allocatorT_Date_t_t')
class(`DateVector_front`) = c("SWIGFunction", class('DateVector_front'))

# Start of DateVector_back

`DateVector_back` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_DateVector_back', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`DateVector_back`, 'returnType') = '_p_Date'
attr(`DateVector_back`, "inputTypes") = c('_p_std__vectorT_Date_std__allocatorT_Date_t_t')
class(`DateVector_back`) = c("SWIGFunction", class('DateVector_back'))

# Start of DateVector_assign

`DateVector_assign` = function(self, n, x)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  
  ;.Call('R_swig_DateVector_assign', self, n, x, PACKAGE='QuantLib');
  
}

attr(`DateVector_assign`, 'returnType') = 'void'
attr(`DateVector_assign`, "inputTypes") = c('_p_std__vectorT_Date_std__allocatorT_Date_t_t', 'integer', '_p_Date')
class(`DateVector_assign`) = c("SWIGFunction", class('DateVector_assign'))

# Start of DateVector_resize

`DateVector_resize__SWIG_1` = function(self, new_size, x)
{
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  
  ;.Call('R_swig_DateVector_resize__SWIG_1', self, new_size, x, PACKAGE='QuantLib');
  
}

attr(`DateVector_resize__SWIG_1`, 'returnType') = 'void'
attr(`DateVector_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_Date_std__allocatorT_Date_t_t', 'integer', '_p_Date')
class(`DateVector_resize__SWIG_1`) = c("SWIGFunction", class('DateVector_resize__SWIG_1'))

`DateVector_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_std__vectorT_Date_std__allocatorT_Date_t_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]]))) {
      f <- DateVector_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_std__vectorT_Date_std__allocatorT_Date_t_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && extends(argtypes[3], '_p_Date')) {
      f <- DateVector_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for DateVector_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of DateVector_reserve

`DateVector_reserve` = function(self, n)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_DateVector_reserve', self, n, PACKAGE='QuantLib');
  
}

attr(`DateVector_reserve`, 'returnType') = 'void'
attr(`DateVector_reserve`, "inputTypes") = c('_p_std__vectorT_Date_std__allocatorT_Date_t_t', 'integer')
class(`DateVector_reserve`) = c("SWIGFunction", class('DateVector_reserve'))

# Start of DateVector_capacity

`DateVector_capacity` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_DateVector_capacity', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`DateVector_capacity`, 'returnType') = 'integer'
attr(`DateVector_capacity`, "inputTypes") = c('_p_std__vectorT_Date_std__allocatorT_Date_t_t')
class(`DateVector_capacity`) = c("SWIGFunction", class('DateVector_capacity'))

# Start of delete_DateVector

`delete_DateVector` = function(self)
{
  ;.Call('R_swig_delete_DateVector', self, PACKAGE='QuantLib');
  
}

attr(`delete_DateVector`, 'returnType') = 'void'
attr(`delete_DateVector`, "inputTypes") = c('_p_std__vectorT_Date_std__allocatorT_Date_t_t')
class(`delete_DateVector`) = c("SWIGFunction", class('delete_DateVector'))

# Start of accessor method for std::vector<(Date)>
setMethod('$', '_p_std__vectorT_Date_std__allocatorT_Date_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = DateVector___nonzero__, '__len__' = DateVector___len__, 'pop' = DateVector_pop, '__getslice__' = DateVector___getslice__, '__setslice__' = DateVector___setslice__, '__delslice__' = DateVector___delslice__, '__delitem__' = DateVector___delitem__, '__getitem__' = DateVector___getitem__, '__setitem__' = DateVector___setitem__, 'append' = DateVector_append, 'empty' = DateVector_empty, 'size' = DateVector_size, 'clear' = DateVector_clear, 'swap' = DateVector_swap, 'get_allocator' = DateVector_get_allocator, 'pop_back' = DateVector_pop_back, 'resize' = DateVector_resize, 'push_back' = DateVector_push_back, 'front' = DateVector_front, 'back' = DateVector_back, 'assign' = DateVector_assign, 'reserve' = DateVector_reserve, 'capacity' = DateVector_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for std::vector<(Date)>
setMethod('delete', '_p_std__vectorT_Date_std__allocatorT_Date_t_t', function(obj) {delete_std__vectorT_Date_std__allocatorT_Date_t_t(obj)})

setAs("_p_std__vectorTDate_std__allocatorTDate_t_t",
    "character",
function(from) {if (from$size())
sapply(1:from$size(), function(y) from$"__getitem__"(i=y-1)$ISO())} )

setAs("character", "_p_std__vectorTDate_std__allocatorTDate_t_t",
function(from) { a <- DateVector(length(from));
sapply(1:length(from), function(n) {
a[n] <- from[n] } )
a
})


# Start of EqualEqual

`EqualEqual` = function(s_arg1, s_arg2, .copy = FALSE)
{
  ;.Call('R_swig_EqualEqual', s_arg1, s_arg2, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`EqualEqual`, 'returnType') = 'logical'
attr(`EqualEqual`, "inputTypes") = c('_p_Date', '_p_Date')
class(`EqualEqual`) = c("SWIGFunction", class('EqualEqual'))

# Start of NotEqual

`NotEqual` = function(s_arg1, s_arg2, .copy = FALSE)
{
  ;.Call('R_swig_NotEqual', s_arg1, s_arg2, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`NotEqual`, 'returnType') = 'logical'
attr(`NotEqual`, "inputTypes") = c('_p_Date', '_p_Date')
class(`NotEqual`) = c("SWIGFunction", class('NotEqual'))

# Start of LessThan

`LessThan` = function(s_arg1, s_arg2, .copy = FALSE)
{
  ;.Call('R_swig_LessThan', s_arg1, s_arg2, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`LessThan`, 'returnType') = 'logical'
attr(`LessThan`, "inputTypes") = c('_p_Date', '_p_Date')
class(`LessThan`) = c("SWIGFunction", class('LessThan'))

# Start of LessThanEqual

`LessThanEqual` = function(s_arg1, s_arg2, .copy = FALSE)
{
  ;.Call('R_swig_LessThanEqual', s_arg1, s_arg2, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`LessThanEqual`, 'returnType') = 'logical'
attr(`LessThanEqual`, "inputTypes") = c('_p_Date', '_p_Date')
class(`LessThanEqual`) = c("SWIGFunction", class('LessThanEqual'))

# Start of GreaterThan

`GreaterThan` = function(s_arg1, s_arg2, .copy = FALSE)
{
  ;.Call('R_swig_GreaterThan', s_arg1, s_arg2, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`GreaterThan`, 'returnType') = 'logical'
attr(`GreaterThan`, "inputTypes") = c('_p_Date', '_p_Date')
class(`GreaterThan`) = c("SWIGFunction", class('GreaterThan'))

# Start of GreaterThanEqual

`GreaterThanEqual` = function(s_arg1, s_arg2, .copy = FALSE)
{
  ;.Call('R_swig_GreaterThanEqual', s_arg1, s_arg2, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`GreaterThanEqual`, 'returnType') = 'logical'
attr(`GreaterThanEqual`, "inputTypes") = c('_p_Date', '_p_Date')
class(`GreaterThanEqual`) = c("SWIGFunction", class('GreaterThanEqual'))

defineEnumeration('_IMM__Month',
                    .values = c(
                        'F' = 1, 
                        'G' = 2, 
                        'H' = 3, 
                        'J' = 4, 
                        'K' = 5, 
                        'M' = 6, 
                        'N' = 7, 
                        'Q' = 8, 
                        'U' = 9, 
                        'V' = 10, 
                        'X' = 11, 
                        'Z' = 12
))
# Start of IMM_isIMMdate

`IMM_isIMMdate__SWIG_0` = function(d, mainCycle, .copy = FALSE)
{
  mainCycle = as.logical(mainCycle);
  ;.Call('R_swig_IMM_isIMMdate__SWIG_0', d, mainCycle, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`IMM_isIMMdate__SWIG_0`, 'returnType') = 'logical'
attr(`IMM_isIMMdate__SWIG_0`, "inputTypes") = c('_p_Date', 'logical')
class(`IMM_isIMMdate__SWIG_0`) = c("SWIGFunction", class('IMM_isIMMdate__SWIG_0'))

# Start of IMM_isIMMdate

`IMM_isIMMdate__SWIG_1` = function(d, .copy = FALSE)
{
  ;.Call('R_swig_IMM_isIMMdate__SWIG_1', d, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`IMM_isIMMdate__SWIG_1`, 'returnType') = 'logical'
attr(`IMM_isIMMdate__SWIG_1`, "inputTypes") = c('_p_Date')
class(`IMM_isIMMdate__SWIG_1`) = c("SWIGFunction", class('IMM_isIMMdate__SWIG_1'))

`IMM_isIMMdate` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_Date')) {
      f <- IMM_isIMMdate__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_Date') && extends(argtypes[2], 'logical')) {
      f <- IMM_isIMMdate__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for IMM_isIMMdate with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of IMM_isIMMcode

`IMM_isIMMcode__SWIG_0` = function(code, mainCycle, .copy = FALSE)
{
  code = as(code, "character"); 
  mainCycle = as.logical(mainCycle);
  ;.Call('R_swig_IMM_isIMMcode__SWIG_0', code, mainCycle, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`IMM_isIMMcode__SWIG_0`, 'returnType') = 'logical'
attr(`IMM_isIMMcode__SWIG_0`, "inputTypes") = c('character', 'logical')
class(`IMM_isIMMcode__SWIG_0`) = c("SWIGFunction", class('IMM_isIMMcode__SWIG_0'))

# Start of IMM_isIMMcode

`IMM_isIMMcode__SWIG_1` = function(code, .copy = FALSE)
{
  code = as(code, "character"); 
  ;.Call('R_swig_IMM_isIMMcode__SWIG_1', code, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`IMM_isIMMcode__SWIG_1`, 'returnType') = 'logical'
attr(`IMM_isIMMcode__SWIG_1`, "inputTypes") = c('character')
class(`IMM_isIMMcode__SWIG_1`) = c("SWIGFunction", class('IMM_isIMMcode__SWIG_1'))

`IMM_isIMMcode` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (is.character(argv[[1]])) {
      f <- IMM_isIMMcode__SWIG_1; 
    }
  } else if (argc == 2) {
    if (is.character(argv[[1]]) && extends(argtypes[2], 'logical')) {
      f <- IMM_isIMMcode__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for IMM_isIMMcode with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of IMM_code

`IMM_code` = function(immDate, .copy = FALSE)
{
  ;.Call('R_swig_IMM_code', immDate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`IMM_code`, 'returnType') = 'character'
attr(`IMM_code`, "inputTypes") = c('_p_Date')
class(`IMM_code`) = c("SWIGFunction", class('IMM_code'))

# Start of IMM_date

`IMM_date__SWIG_0` = function(immCode, referenceDate, .copy = FALSE)
{
  immCode = as(immCode, "character"); 
  
  ;ans = .Call('R_swig_IMM_date__SWIG_0', immCode, referenceDate, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`IMM_date__SWIG_0`, 'returnType') = '_p_Date'
attr(`IMM_date__SWIG_0`, "inputTypes") = c('character', '_p_Date')
class(`IMM_date__SWIG_0`) = c("SWIGFunction", class('IMM_date__SWIG_0'))

# Start of IMM_date

`IMM_date__SWIG_1` = function(immCode, .copy = FALSE)
{
  immCode = as(immCode, "character"); 
  ;ans = .Call('R_swig_IMM_date__SWIG_1', immCode, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`IMM_date__SWIG_1`, 'returnType') = '_p_Date'
attr(`IMM_date__SWIG_1`, "inputTypes") = c('character')
class(`IMM_date__SWIG_1`) = c("SWIGFunction", class('IMM_date__SWIG_1'))

`IMM_date` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (is.character(argv[[1]])) {
      f <- IMM_date__SWIG_1; 
    }
  } else if (argc == 2) {
    if (is.character(argv[[1]]) && extends(argtypes[2], '_p_Date')) {
      f <- IMM_date__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for IMM_date with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of IMM_nextDate

`IMM_nextDate__SWIG_0` = function(d, mainCycle, .copy = FALSE)
{
  mainCycle = as.logical(mainCycle);
  ;ans = .Call('R_swig_IMM_nextDate__SWIG_0', d, mainCycle, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`IMM_nextDate__SWIG_0`, 'returnType') = '_p_Date'
attr(`IMM_nextDate__SWIG_0`, "inputTypes") = c('_p_Date', 'logical')
class(`IMM_nextDate__SWIG_0`) = c("SWIGFunction", class('IMM_nextDate__SWIG_0'))

# Start of IMM_nextDate

`IMM_nextDate__SWIG_1` = function(d, .copy = FALSE)
{
  ;ans = .Call('R_swig_IMM_nextDate__SWIG_1', d, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`IMM_nextDate__SWIG_1`, 'returnType') = '_p_Date'
attr(`IMM_nextDate__SWIG_1`, "inputTypes") = c('_p_Date')
class(`IMM_nextDate__SWIG_1`) = c("SWIGFunction", class('IMM_nextDate__SWIG_1'))

# Start of IMM_nextDate

`IMM_nextDate__SWIG_2` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_IMM_nextDate__SWIG_2', as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`IMM_nextDate__SWIG_2`, 'returnType') = '_p_Date'
class(`IMM_nextDate__SWIG_2`) = c("SWIGFunction", class('IMM_nextDate__SWIG_2'))

# Start of IMM_nextDate

`IMM_nextDate__SWIG_3` = function(immCode, mainCycle, referenceDate, .copy = FALSE)
{
  immCode = as(immCode, "character"); 
  mainCycle = as.logical(mainCycle);
  
  ;ans = .Call('R_swig_IMM_nextDate__SWIG_3', immCode, mainCycle, referenceDate, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`IMM_nextDate__SWIG_3`, 'returnType') = '_p_Date'
attr(`IMM_nextDate__SWIG_3`, "inputTypes") = c('character', 'logical', '_p_Date')
class(`IMM_nextDate__SWIG_3`) = c("SWIGFunction", class('IMM_nextDate__SWIG_3'))

# Start of IMM_nextDate

`IMM_nextDate__SWIG_4` = function(immCode, mainCycle, .copy = FALSE)
{
  immCode = as(immCode, "character"); 
  mainCycle = as.logical(mainCycle);
  ;ans = .Call('R_swig_IMM_nextDate__SWIG_4', immCode, mainCycle, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`IMM_nextDate__SWIG_4`, 'returnType') = '_p_Date'
attr(`IMM_nextDate__SWIG_4`, "inputTypes") = c('character', 'logical')
class(`IMM_nextDate__SWIG_4`) = c("SWIGFunction", class('IMM_nextDate__SWIG_4'))

# Start of IMM_nextDate

`IMM_nextDate__SWIG_5` = function(immCode, .copy = FALSE)
{
  immCode = as(immCode, "character"); 
  ;ans = .Call('R_swig_IMM_nextDate__SWIG_5', immCode, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`IMM_nextDate__SWIG_5`, 'returnType') = '_p_Date'
attr(`IMM_nextDate__SWIG_5`, "inputTypes") = c('character')
class(`IMM_nextDate__SWIG_5`) = c("SWIGFunction", class('IMM_nextDate__SWIG_5'))

`IMM_nextDate` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 6
  if (argc == 0) {
    f <- IMM_nextDate__SWIG_2; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_Date')) {
      f <- IMM_nextDate__SWIG_1; 
    }
    else if (is.character(argv[[1]])) {
      f <- IMM_nextDate__SWIG_5; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_Date') && extends(argtypes[2], 'logical')) {
      f <- IMM_nextDate__SWIG_0; 
    }
    else if (is.character(argv[[1]]) && extends(argtypes[2], 'logical')) {
      f <- IMM_nextDate__SWIG_4; 
    }
  } else if (argc == 3) {
    if (is.character(argv[[1]]) && extends(argtypes[2], 'logical') && extends(argtypes[3], '_p_Date')) {
      f <- IMM_nextDate__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for IMM_nextDate with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of IMM_nextCode

`IMM_nextCode__SWIG_0` = function(d, mainCycle, .copy = FALSE)
{
  mainCycle = as.logical(mainCycle);
  ;.Call('R_swig_IMM_nextCode__SWIG_0', d, mainCycle, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`IMM_nextCode__SWIG_0`, 'returnType') = 'character'
attr(`IMM_nextCode__SWIG_0`, "inputTypes") = c('_p_Date', 'logical')
class(`IMM_nextCode__SWIG_0`) = c("SWIGFunction", class('IMM_nextCode__SWIG_0'))

# Start of IMM_nextCode

`IMM_nextCode__SWIG_1` = function(d, .copy = FALSE)
{
  ;.Call('R_swig_IMM_nextCode__SWIG_1', d, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`IMM_nextCode__SWIG_1`, 'returnType') = 'character'
attr(`IMM_nextCode__SWIG_1`, "inputTypes") = c('_p_Date')
class(`IMM_nextCode__SWIG_1`) = c("SWIGFunction", class('IMM_nextCode__SWIG_1'))

# Start of IMM_nextCode

`IMM_nextCode__SWIG_2` = function(.copy = FALSE)
{
  ;.Call('R_swig_IMM_nextCode__SWIG_2', as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`IMM_nextCode__SWIG_2`, 'returnType') = 'character'
class(`IMM_nextCode__SWIG_2`) = c("SWIGFunction", class('IMM_nextCode__SWIG_2'))

# Start of IMM_nextCode

`IMM_nextCode__SWIG_3` = function(immCode, mainCycle, referenceDate, .copy = FALSE)
{
  immCode = as(immCode, "character"); 
  mainCycle = as.logical(mainCycle);
  
  ;.Call('R_swig_IMM_nextCode__SWIG_3', immCode, mainCycle, referenceDate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`IMM_nextCode__SWIG_3`, 'returnType') = 'character'
attr(`IMM_nextCode__SWIG_3`, "inputTypes") = c('character', 'logical', '_p_Date')
class(`IMM_nextCode__SWIG_3`) = c("SWIGFunction", class('IMM_nextCode__SWIG_3'))

# Start of IMM_nextCode

`IMM_nextCode__SWIG_4` = function(immCode, mainCycle, .copy = FALSE)
{
  immCode = as(immCode, "character"); 
  mainCycle = as.logical(mainCycle);
  ;.Call('R_swig_IMM_nextCode__SWIG_4', immCode, mainCycle, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`IMM_nextCode__SWIG_4`, 'returnType') = 'character'
attr(`IMM_nextCode__SWIG_4`, "inputTypes") = c('character', 'logical')
class(`IMM_nextCode__SWIG_4`) = c("SWIGFunction", class('IMM_nextCode__SWIG_4'))

# Start of IMM_nextCode

`IMM_nextCode__SWIG_5` = function(immCode, .copy = FALSE)
{
  immCode = as(immCode, "character"); 
  ;.Call('R_swig_IMM_nextCode__SWIG_5', immCode, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`IMM_nextCode__SWIG_5`, 'returnType') = 'character'
attr(`IMM_nextCode__SWIG_5`, "inputTypes") = c('character')
class(`IMM_nextCode__SWIG_5`) = c("SWIGFunction", class('IMM_nextCode__SWIG_5'))

`IMM_nextCode` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 6
  if (argc == 0) {
    f <- IMM_nextCode__SWIG_2; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_Date')) {
      f <- IMM_nextCode__SWIG_1; 
    }
    else if (is.character(argv[[1]])) {
      f <- IMM_nextCode__SWIG_5; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_Date') && extends(argtypes[2], 'logical')) {
      f <- IMM_nextCode__SWIG_0; 
    }
    else if (is.character(argv[[1]]) && extends(argtypes[2], 'logical')) {
      f <- IMM_nextCode__SWIG_4; 
    }
  } else if (argc == 3) {
    if (is.character(argv[[1]]) && extends(argtypes[2], 'logical') && extends(argtypes[3], '_p_Date')) {
      f <- IMM_nextCode__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for IMM_nextCode with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of new_IMM

`IMM` = function()
{
  ;ans = .Call('R_swig_new_IMM', PACKAGE='QuantLib');
  class(ans) <- "_p_IMM";
  
  reg.finalizer(ans, delete_IMM)
  ans
  
}

attr(`IMM`, 'returnType') = '_p_IMM'
class(`IMM`) = c("SWIGFunction", class('IMM'))

# Start of delete_IMM

`delete_IMM` = function(self)
{
  ;.Call('R_swig_delete_IMM', self, PACKAGE='QuantLib');
  
}

attr(`delete_IMM`, 'returnType') = 'void'
attr(`delete_IMM`, "inputTypes") = c('_p_IMM')
class(`delete_IMM`) = c("SWIGFunction", class('delete_IMM'))

setMethod('delete', '_p_IMM', function(obj) {delete_IMM(obj)})
# Start definition of copy functions & methods for IMM
CopyToR_IMM = function(value, obj = new("IMM"))
{
  obj;
}



CopyToC_IMM = function(value, obj)
{
  obj
}



# Start definition of copy methods for IMM
setMethod('copyToR', '_p_IMM', CopyToR_IMM);
setMethod('copyToC', 'IMM', CopyToC_IMM);

# End definition of copy methods for IMM
# End definition of copy functions & methods for IMM
# Start of IntVector___nonzero__

`IntVector___nonzero__` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_IntVector___nonzero__', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`IntVector___nonzero__`, 'returnType') = 'logical'
attr(`IntVector___nonzero__`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`IntVector___nonzero__`) = c("SWIGFunction", class('IntVector___nonzero__'))

# Start of IntVector___len__

`IntVector___len__` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_IntVector___len__', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`IntVector___len__`, 'returnType') = 'integer'
attr(`IntVector___len__`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`IntVector___len__`) = c("SWIGFunction", class('IntVector___len__'))

# Start of IntVector_pop

`IntVector_pop` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_IntVector_pop', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`IntVector_pop`, 'returnType') = 'integer'
attr(`IntVector_pop`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`IntVector_pop`) = c("SWIGFunction", class('IntVector_pop'))

# Start of IntVector___getslice__

`IntVector___getslice__` = function(self, i, j)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;ans = .Call('R_swig_IntVector___getslice__', self, i, j, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_int_std__allocatorT_int_t_t";
  
  ans
  
}

attr(`IntVector___getslice__`, 'returnType') = '_p_std__vectorT_int_std__allocatorT_int_t_t'
attr(`IntVector___getslice__`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer', 'integer')
class(`IntVector___getslice__`) = c("SWIGFunction", class('IntVector___getslice__'))

# Start of IntVector___setslice__

`IntVector___setslice__` = function(self, i, j, v)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  
  ;.Call('R_swig_IntVector___setslice__', self, i, j, v, PACKAGE='QuantLib');
  
}

attr(`IntVector___setslice__`, 'returnType') = 'void'
attr(`IntVector___setslice__`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer', 'integer', '_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`IntVector___setslice__`) = c("SWIGFunction", class('IntVector___setslice__'))

# Start of IntVector___delslice__

`IntVector___delslice__` = function(self, i, j)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_IntVector___delslice__', self, i, j, PACKAGE='QuantLib');
  
}

attr(`IntVector___delslice__`, 'returnType') = 'void'
attr(`IntVector___delslice__`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer', 'integer')
class(`IntVector___delslice__`) = c("SWIGFunction", class('IntVector___delslice__'))

# Start of IntVector___delitem__

`IntVector___delitem__` = function(self, i)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_IntVector___delitem__', self, i, PACKAGE='QuantLib');
  
}

attr(`IntVector___delitem__`, 'returnType') = 'void'
attr(`IntVector___delitem__`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer')
class(`IntVector___delitem__`) = c("SWIGFunction", class('IntVector___delitem__'))

# Start of IntVector___getitem__

`IntVector___getitem__` = function(self, i, .copy = FALSE)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_IntVector___getitem__', self, i, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`IntVector___getitem__`, 'returnType') = 'integer'
attr(`IntVector___getitem__`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer')
class(`IntVector___getitem__`) = c("SWIGFunction", class('IntVector___getitem__'))

# Start of IntVector___setitem__

`IntVector___setitem__` = function(self, i, x)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  x = as.integer(x); 
  ;.Call('R_swig_IntVector___setitem__', self, i, x, PACKAGE='QuantLib');
  
}

attr(`IntVector___setitem__`, 'returnType') = 'void'
attr(`IntVector___setitem__`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer', 'integer')
class(`IntVector___setitem__`) = c("SWIGFunction", class('IntVector___setitem__'))

# Start of IntVector_append

`IntVector_append` = function(self, x)
{
  x = as.integer(x); 
  ;.Call('R_swig_IntVector_append', self, x, PACKAGE='QuantLib');
  
}

attr(`IntVector_append`, 'returnType') = 'void'
attr(`IntVector_append`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer')
class(`IntVector_append`) = c("SWIGFunction", class('IntVector_append'))

# Start of new_IntVector

`IntVector__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_IntVector__SWIG_0', PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_int_std__allocatorT_int_t_t";
  
  reg.finalizer(ans, delete_IntVector)
  ans
  
}

attr(`IntVector__SWIG_0`, 'returnType') = '_p_std__vectorT_int_std__allocatorT_int_t_t'
class(`IntVector__SWIG_0`) = c("SWIGFunction", class('IntVector__SWIG_0'))

# Start of new_IntVector

`IntVector__SWIG_1` = function(s_arg1)
{
  ;ans = .Call('R_swig_new_IntVector__SWIG_1', s_arg1, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_int_std__allocatorT_int_t_t";
  
  reg.finalizer(ans, delete_IntVector)
  ans
  
}

attr(`IntVector__SWIG_1`, 'returnType') = '_p_std__vectorT_int_std__allocatorT_int_t_t'
attr(`IntVector__SWIG_1`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`IntVector__SWIG_1`) = c("SWIGFunction", class('IntVector__SWIG_1'))

# Start of IntVector_empty

`IntVector_empty` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_IntVector_empty', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`IntVector_empty`, 'returnType') = 'logical'
attr(`IntVector_empty`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`IntVector_empty`) = c("SWIGFunction", class('IntVector_empty'))

# Start of IntVector_size

`IntVector_size` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_IntVector_size', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`IntVector_size`, 'returnType') = 'integer'
attr(`IntVector_size`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`IntVector_size`) = c("SWIGFunction", class('IntVector_size'))

# Start of IntVector_clear

`IntVector_clear` = function(self)
{
  ;.Call('R_swig_IntVector_clear', self, PACKAGE='QuantLib');
  
}

attr(`IntVector_clear`, 'returnType') = 'void'
attr(`IntVector_clear`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`IntVector_clear`) = c("SWIGFunction", class('IntVector_clear'))

# Start of IntVector_swap

`IntVector_swap` = function(self, v)
{
  ;.Call('R_swig_IntVector_swap', self, v, PACKAGE='QuantLib');
  
}

attr(`IntVector_swap`, 'returnType') = 'void'
attr(`IntVector_swap`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', '_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`IntVector_swap`) = c("SWIGFunction", class('IntVector_swap'))

# Start of IntVector_get_allocator

`IntVector_get_allocator` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_IntVector_get_allocator', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__allocatorT_int_t";
  
  ans
  
}

attr(`IntVector_get_allocator`, 'returnType') = '_p_std__allocatorT_int_t'
attr(`IntVector_get_allocator`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`IntVector_get_allocator`) = c("SWIGFunction", class('IntVector_get_allocator'))

# Start of new_IntVector

`IntVector__SWIG_2` = function(size)
{
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_new_IntVector__SWIG_2', size, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_int_std__allocatorT_int_t_t";
  
  reg.finalizer(ans, delete_IntVector)
  ans
  
}

attr(`IntVector__SWIG_2`, 'returnType') = '_p_std__vectorT_int_std__allocatorT_int_t_t'
attr(`IntVector__SWIG_2`, "inputTypes") = c('integer')
class(`IntVector__SWIG_2`) = c("SWIGFunction", class('IntVector__SWIG_2'))

# Start of IntVector_pop_back

`IntVector_pop_back` = function(self)
{
  ;.Call('R_swig_IntVector_pop_back', self, PACKAGE='QuantLib');
  
}

attr(`IntVector_pop_back`, 'returnType') = 'void'
attr(`IntVector_pop_back`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`IntVector_pop_back`) = c("SWIGFunction", class('IntVector_pop_back'))

# Start of IntVector_resize

`IntVector_resize__SWIG_0` = function(self, new_size)
{
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_IntVector_resize__SWIG_0', self, new_size, PACKAGE='QuantLib');
  
}

attr(`IntVector_resize__SWIG_0`, 'returnType') = 'void'
attr(`IntVector_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer')
class(`IntVector_resize__SWIG_0`) = c("SWIGFunction", class('IntVector_resize__SWIG_0'))

# Start of new_IntVector

`IntVector__SWIG_3` = function(size, value)
{
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  value = as.integer(value); 
  ;ans = .Call('R_swig_new_IntVector__SWIG_3', size, value, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_int_std__allocatorT_int_t_t";
  
  reg.finalizer(ans, delete_IntVector)
  ans
  
}

attr(`IntVector__SWIG_3`, 'returnType') = '_p_std__vectorT_int_std__allocatorT_int_t_t'
attr(`IntVector__SWIG_3`, "inputTypes") = c('integer', 'integer')
class(`IntVector__SWIG_3`) = c("SWIGFunction", class('IntVector__SWIG_3'))

`IntVector` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- IntVector__SWIG_0; 
  } else if (argc == 1) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]]))) {
      f <- IntVector__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_int_std__allocatorT_int_t_t')) {
      f <- IntVector__SWIG_1; 
    }
  } else if (argc == 2) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && (is.integer(argv[[2]]) || is.numeric(argv[[2]]))) {
      f <- IntVector__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for IntVector with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of IntVector_push_back

`IntVector_push_back` = function(self, x)
{
  x = as.integer(x); 
  ;.Call('R_swig_IntVector_push_back', self, x, PACKAGE='QuantLib');
  
}

attr(`IntVector_push_back`, 'returnType') = 'void'
attr(`IntVector_push_back`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer')
class(`IntVector_push_back`) = c("SWIGFunction", class('IntVector_push_back'))

# Start of IntVector_front

`IntVector_front` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_IntVector_front', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`IntVector_front`, 'returnType') = 'integer'
attr(`IntVector_front`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`IntVector_front`) = c("SWIGFunction", class('IntVector_front'))

# Start of IntVector_back

`IntVector_back` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_IntVector_back', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`IntVector_back`, 'returnType') = 'integer'
attr(`IntVector_back`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`IntVector_back`) = c("SWIGFunction", class('IntVector_back'))

# Start of IntVector_assign

`IntVector_assign` = function(self, n, x)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  x = as.integer(x); 
  ;.Call('R_swig_IntVector_assign', self, n, x, PACKAGE='QuantLib');
  
}

attr(`IntVector_assign`, 'returnType') = 'void'
attr(`IntVector_assign`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer', 'integer')
class(`IntVector_assign`) = c("SWIGFunction", class('IntVector_assign'))

# Start of IntVector_resize

`IntVector_resize__SWIG_1` = function(self, new_size, x)
{
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  x = as.integer(x); 
  ;.Call('R_swig_IntVector_resize__SWIG_1', self, new_size, x, PACKAGE='QuantLib');
  
}

attr(`IntVector_resize__SWIG_1`, 'returnType') = 'void'
attr(`IntVector_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer', 'integer')
class(`IntVector_resize__SWIG_1`) = c("SWIGFunction", class('IntVector_resize__SWIG_1'))

`IntVector_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_std__vectorT_int_std__allocatorT_int_t_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]]))) {
      f <- IntVector_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_std__vectorT_int_std__allocatorT_int_t_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && (is.integer(argv[[3]]) || is.numeric(argv[[3]]))) {
      f <- IntVector_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for IntVector_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of IntVector_reserve

`IntVector_reserve` = function(self, n)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_IntVector_reserve', self, n, PACKAGE='QuantLib');
  
}

attr(`IntVector_reserve`, 'returnType') = 'void'
attr(`IntVector_reserve`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer')
class(`IntVector_reserve`) = c("SWIGFunction", class('IntVector_reserve'))

# Start of IntVector_capacity

`IntVector_capacity` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_IntVector_capacity', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`IntVector_capacity`, 'returnType') = 'integer'
attr(`IntVector_capacity`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`IntVector_capacity`) = c("SWIGFunction", class('IntVector_capacity'))

# Start of delete_IntVector

`delete_IntVector` = function(self)
{
  ;.Call('R_swig_delete_IntVector', self, PACKAGE='QuantLib');
  
}

attr(`delete_IntVector`, 'returnType') = 'void'
attr(`delete_IntVector`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`delete_IntVector`) = c("SWIGFunction", class('delete_IntVector'))

# Start of accessor method for std::vector<(int)>
setMethod('$', '_p_std__vectorT_int_std__allocatorT_int_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = IntVector___nonzero__, '__len__' = IntVector___len__, 'pop' = IntVector_pop, '__getslice__' = IntVector___getslice__, '__setslice__' = IntVector___setslice__, '__delslice__' = IntVector___delslice__, '__delitem__' = IntVector___delitem__, '__getitem__' = IntVector___getitem__, '__setitem__' = IntVector___setitem__, 'append' = IntVector_append, 'empty' = IntVector_empty, 'size' = IntVector_size, 'clear' = IntVector_clear, 'swap' = IntVector_swap, 'get_allocator' = IntVector_get_allocator, 'pop_back' = IntVector_pop_back, 'resize' = IntVector_resize, 'push_back' = IntVector_push_back, 'front' = IntVector_front, 'back' = IntVector_back, 'assign' = IntVector_assign, 'reserve' = IntVector_reserve, 'capacity' = IntVector_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for std::vector<(int)>
setMethod('delete', '_p_std__vectorT_int_std__allocatorT_int_t_t', function(obj) {delete_std__vectorT_int_std__allocatorT_int_t_t(obj)})
# Start of UnsignedIntVector___nonzero__

`UnsignedIntVector___nonzero__` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_UnsignedIntVector___nonzero__', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`UnsignedIntVector___nonzero__`, 'returnType') = 'logical'
attr(`UnsignedIntVector___nonzero__`, "inputTypes") = c('_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t')
class(`UnsignedIntVector___nonzero__`) = c("SWIGFunction", class('UnsignedIntVector___nonzero__'))

# Start of UnsignedIntVector___len__

`UnsignedIntVector___len__` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_UnsignedIntVector___len__', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`UnsignedIntVector___len__`, 'returnType') = 'integer'
attr(`UnsignedIntVector___len__`, "inputTypes") = c('_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t')
class(`UnsignedIntVector___len__`) = c("SWIGFunction", class('UnsignedIntVector___len__'))

# Start of UnsignedIntVector_pop

`UnsignedIntVector_pop` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_UnsignedIntVector_pop', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`UnsignedIntVector_pop`, 'returnType') = 'integer'
attr(`UnsignedIntVector_pop`, "inputTypes") = c('_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t')
class(`UnsignedIntVector_pop`) = c("SWIGFunction", class('UnsignedIntVector_pop'))

# Start of UnsignedIntVector___getslice__

`UnsignedIntVector___getslice__` = function(self, i, j)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;ans = .Call('R_swig_UnsignedIntVector___getslice__', self, i, j, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t";
  
  ans
  
}

attr(`UnsignedIntVector___getslice__`, 'returnType') = '_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t'
attr(`UnsignedIntVector___getslice__`, "inputTypes") = c('_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t', 'integer', 'integer')
class(`UnsignedIntVector___getslice__`) = c("SWIGFunction", class('UnsignedIntVector___getslice__'))

# Start of UnsignedIntVector___setslice__

`UnsignedIntVector___setslice__` = function(self, i, j, v)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  
  ;.Call('R_swig_UnsignedIntVector___setslice__', self, i, j, v, PACKAGE='QuantLib');
  
}

attr(`UnsignedIntVector___setslice__`, 'returnType') = 'void'
attr(`UnsignedIntVector___setslice__`, "inputTypes") = c('_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t', 'integer', 'integer', '_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t')
class(`UnsignedIntVector___setslice__`) = c("SWIGFunction", class('UnsignedIntVector___setslice__'))

# Start of UnsignedIntVector___delslice__

`UnsignedIntVector___delslice__` = function(self, i, j)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_UnsignedIntVector___delslice__', self, i, j, PACKAGE='QuantLib');
  
}

attr(`UnsignedIntVector___delslice__`, 'returnType') = 'void'
attr(`UnsignedIntVector___delslice__`, "inputTypes") = c('_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t', 'integer', 'integer')
class(`UnsignedIntVector___delslice__`) = c("SWIGFunction", class('UnsignedIntVector___delslice__'))

# Start of UnsignedIntVector___delitem__

`UnsignedIntVector___delitem__` = function(self, i)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_UnsignedIntVector___delitem__', self, i, PACKAGE='QuantLib');
  
}

attr(`UnsignedIntVector___delitem__`, 'returnType') = 'void'
attr(`UnsignedIntVector___delitem__`, "inputTypes") = c('_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t', 'integer')
class(`UnsignedIntVector___delitem__`) = c("SWIGFunction", class('UnsignedIntVector___delitem__'))

# Start of UnsignedIntVector___getitem__

`UnsignedIntVector___getitem__` = function(self, i, .copy = FALSE)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_UnsignedIntVector___getitem__', self, i, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`UnsignedIntVector___getitem__`, 'returnType') = '_p_unsigned_int'
attr(`UnsignedIntVector___getitem__`, "inputTypes") = c('_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t', 'integer')
class(`UnsignedIntVector___getitem__`) = c("SWIGFunction", class('UnsignedIntVector___getitem__'))

# Start of UnsignedIntVector___setitem__

`UnsignedIntVector___setitem__` = function(self, i, x)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  ;.Call('R_swig_UnsignedIntVector___setitem__', self, i, x, PACKAGE='QuantLib');
  
}

attr(`UnsignedIntVector___setitem__`, 'returnType') = 'void'
attr(`UnsignedIntVector___setitem__`, "inputTypes") = c('_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t', 'integer', '_p_unsigned_int')
class(`UnsignedIntVector___setitem__`) = c("SWIGFunction", class('UnsignedIntVector___setitem__'))

# Start of UnsignedIntVector_append

`UnsignedIntVector_append` = function(self, x)
{
  ;.Call('R_swig_UnsignedIntVector_append', self, x, PACKAGE='QuantLib');
  
}

attr(`UnsignedIntVector_append`, 'returnType') = 'void'
attr(`UnsignedIntVector_append`, "inputTypes") = c('_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t', '_p_unsigned_int')
class(`UnsignedIntVector_append`) = c("SWIGFunction", class('UnsignedIntVector_append'))

# Start of new_UnsignedIntVector

`UnsignedIntVector__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_UnsignedIntVector__SWIG_0', PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t";
  
  reg.finalizer(ans, delete_UnsignedIntVector)
  ans
  
}

attr(`UnsignedIntVector__SWIG_0`, 'returnType') = '_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t'
class(`UnsignedIntVector__SWIG_0`) = c("SWIGFunction", class('UnsignedIntVector__SWIG_0'))

# Start of new_UnsignedIntVector

`UnsignedIntVector__SWIG_1` = function(s_arg1)
{
  ;ans = .Call('R_swig_new_UnsignedIntVector__SWIG_1', s_arg1, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t";
  
  reg.finalizer(ans, delete_UnsignedIntVector)
  ans
  
}

attr(`UnsignedIntVector__SWIG_1`, 'returnType') = '_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t'
attr(`UnsignedIntVector__SWIG_1`, "inputTypes") = c('_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t')
class(`UnsignedIntVector__SWIG_1`) = c("SWIGFunction", class('UnsignedIntVector__SWIG_1'))

# Start of UnsignedIntVector_empty

`UnsignedIntVector_empty` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_UnsignedIntVector_empty', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`UnsignedIntVector_empty`, 'returnType') = 'logical'
attr(`UnsignedIntVector_empty`, "inputTypes") = c('_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t')
class(`UnsignedIntVector_empty`) = c("SWIGFunction", class('UnsignedIntVector_empty'))

# Start of UnsignedIntVector_size

`UnsignedIntVector_size` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_UnsignedIntVector_size', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`UnsignedIntVector_size`, 'returnType') = 'integer'
attr(`UnsignedIntVector_size`, "inputTypes") = c('_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t')
class(`UnsignedIntVector_size`) = c("SWIGFunction", class('UnsignedIntVector_size'))

# Start of UnsignedIntVector_clear

`UnsignedIntVector_clear` = function(self)
{
  ;.Call('R_swig_UnsignedIntVector_clear', self, PACKAGE='QuantLib');
  
}

attr(`UnsignedIntVector_clear`, 'returnType') = 'void'
attr(`UnsignedIntVector_clear`, "inputTypes") = c('_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t')
class(`UnsignedIntVector_clear`) = c("SWIGFunction", class('UnsignedIntVector_clear'))

# Start of UnsignedIntVector_swap

`UnsignedIntVector_swap` = function(self, v)
{
  ;.Call('R_swig_UnsignedIntVector_swap', self, v, PACKAGE='QuantLib');
  
}

attr(`UnsignedIntVector_swap`, 'returnType') = 'void'
attr(`UnsignedIntVector_swap`, "inputTypes") = c('_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t', '_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t')
class(`UnsignedIntVector_swap`) = c("SWIGFunction", class('UnsignedIntVector_swap'))

# Start of UnsignedIntVector_get_allocator

`UnsignedIntVector_get_allocator` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_UnsignedIntVector_get_allocator', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__allocatorT_unsigned_int_t";
  
  ans
  
}

attr(`UnsignedIntVector_get_allocator`, 'returnType') = '_p_std__allocatorT_unsigned_int_t'
attr(`UnsignedIntVector_get_allocator`, "inputTypes") = c('_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t')
class(`UnsignedIntVector_get_allocator`) = c("SWIGFunction", class('UnsignedIntVector_get_allocator'))

# Start of new_UnsignedIntVector

`UnsignedIntVector__SWIG_2` = function(size)
{
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_new_UnsignedIntVector__SWIG_2', size, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t";
  
  reg.finalizer(ans, delete_UnsignedIntVector)
  ans
  
}

attr(`UnsignedIntVector__SWIG_2`, 'returnType') = '_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t'
attr(`UnsignedIntVector__SWIG_2`, "inputTypes") = c('integer')
class(`UnsignedIntVector__SWIG_2`) = c("SWIGFunction", class('UnsignedIntVector__SWIG_2'))

# Start of UnsignedIntVector_pop_back

`UnsignedIntVector_pop_back` = function(self)
{
  ;.Call('R_swig_UnsignedIntVector_pop_back', self, PACKAGE='QuantLib');
  
}

attr(`UnsignedIntVector_pop_back`, 'returnType') = 'void'
attr(`UnsignedIntVector_pop_back`, "inputTypes") = c('_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t')
class(`UnsignedIntVector_pop_back`) = c("SWIGFunction", class('UnsignedIntVector_pop_back'))

# Start of UnsignedIntVector_resize

`UnsignedIntVector_resize__SWIG_0` = function(self, new_size)
{
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_UnsignedIntVector_resize__SWIG_0', self, new_size, PACKAGE='QuantLib');
  
}

attr(`UnsignedIntVector_resize__SWIG_0`, 'returnType') = 'void'
attr(`UnsignedIntVector_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t', 'integer')
class(`UnsignedIntVector_resize__SWIG_0`) = c("SWIGFunction", class('UnsignedIntVector_resize__SWIG_0'))

# Start of new_UnsignedIntVector

`UnsignedIntVector__SWIG_3` = function(size, value)
{
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  
  ;ans = .Call('R_swig_new_UnsignedIntVector__SWIG_3', size, value, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t";
  
  reg.finalizer(ans, delete_UnsignedIntVector)
  ans
  
}

attr(`UnsignedIntVector__SWIG_3`, 'returnType') = '_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t'
attr(`UnsignedIntVector__SWIG_3`, "inputTypes") = c('integer', '_p_unsigned_int')
class(`UnsignedIntVector__SWIG_3`) = c("SWIGFunction", class('UnsignedIntVector__SWIG_3'))

`UnsignedIntVector` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- UnsignedIntVector__SWIG_0; 
  } else if (argc == 1) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]]))) {
      f <- UnsignedIntVector__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t')) {
      f <- UnsignedIntVector__SWIG_1; 
    }
  } else if (argc == 2) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && extends(argtypes[2], '_p_unsigned_int')) {
      f <- UnsignedIntVector__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for UnsignedIntVector with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of UnsignedIntVector_push_back

`UnsignedIntVector_push_back` = function(self, x)
{
  ;.Call('R_swig_UnsignedIntVector_push_back', self, x, PACKAGE='QuantLib');
  
}

attr(`UnsignedIntVector_push_back`, 'returnType') = 'void'
attr(`UnsignedIntVector_push_back`, "inputTypes") = c('_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t', '_p_unsigned_int')
class(`UnsignedIntVector_push_back`) = c("SWIGFunction", class('UnsignedIntVector_push_back'))

# Start of UnsignedIntVector_front

`UnsignedIntVector_front` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_UnsignedIntVector_front', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`UnsignedIntVector_front`, 'returnType') = '_p_unsigned_int'
attr(`UnsignedIntVector_front`, "inputTypes") = c('_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t')
class(`UnsignedIntVector_front`) = c("SWIGFunction", class('UnsignedIntVector_front'))

# Start of UnsignedIntVector_back

`UnsignedIntVector_back` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_UnsignedIntVector_back', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`UnsignedIntVector_back`, 'returnType') = '_p_unsigned_int'
attr(`UnsignedIntVector_back`, "inputTypes") = c('_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t')
class(`UnsignedIntVector_back`) = c("SWIGFunction", class('UnsignedIntVector_back'))

# Start of UnsignedIntVector_assign

`UnsignedIntVector_assign` = function(self, n, x)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  
  ;.Call('R_swig_UnsignedIntVector_assign', self, n, x, PACKAGE='QuantLib');
  
}

attr(`UnsignedIntVector_assign`, 'returnType') = 'void'
attr(`UnsignedIntVector_assign`, "inputTypes") = c('_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t', 'integer', '_p_unsigned_int')
class(`UnsignedIntVector_assign`) = c("SWIGFunction", class('UnsignedIntVector_assign'))

# Start of UnsignedIntVector_resize

`UnsignedIntVector_resize__SWIG_1` = function(self, new_size, x)
{
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  
  ;.Call('R_swig_UnsignedIntVector_resize__SWIG_1', self, new_size, x, PACKAGE='QuantLib');
  
}

attr(`UnsignedIntVector_resize__SWIG_1`, 'returnType') = 'void'
attr(`UnsignedIntVector_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t', 'integer', '_p_unsigned_int')
class(`UnsignedIntVector_resize__SWIG_1`) = c("SWIGFunction", class('UnsignedIntVector_resize__SWIG_1'))

`UnsignedIntVector_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]]))) {
      f <- UnsignedIntVector_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && extends(argtypes[3], '_p_unsigned_int')) {
      f <- UnsignedIntVector_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for UnsignedIntVector_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of UnsignedIntVector_reserve

`UnsignedIntVector_reserve` = function(self, n)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_UnsignedIntVector_reserve', self, n, PACKAGE='QuantLib');
  
}

attr(`UnsignedIntVector_reserve`, 'returnType') = 'void'
attr(`UnsignedIntVector_reserve`, "inputTypes") = c('_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t', 'integer')
class(`UnsignedIntVector_reserve`) = c("SWIGFunction", class('UnsignedIntVector_reserve'))

# Start of UnsignedIntVector_capacity

`UnsignedIntVector_capacity` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_UnsignedIntVector_capacity', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`UnsignedIntVector_capacity`, 'returnType') = 'integer'
attr(`UnsignedIntVector_capacity`, "inputTypes") = c('_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t')
class(`UnsignedIntVector_capacity`) = c("SWIGFunction", class('UnsignedIntVector_capacity'))

# Start of delete_UnsignedIntVector

`delete_UnsignedIntVector` = function(self)
{
  ;.Call('R_swig_delete_UnsignedIntVector', self, PACKAGE='QuantLib');
  
}

attr(`delete_UnsignedIntVector`, 'returnType') = 'void'
attr(`delete_UnsignedIntVector`, "inputTypes") = c('_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t')
class(`delete_UnsignedIntVector`) = c("SWIGFunction", class('delete_UnsignedIntVector'))

# Start of accessor method for std::vector<(unsigned int)>
setMethod('$', '_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = UnsignedIntVector___nonzero__, '__len__' = UnsignedIntVector___len__, 'pop' = UnsignedIntVector_pop, '__getslice__' = UnsignedIntVector___getslice__, '__setslice__' = UnsignedIntVector___setslice__, '__delslice__' = UnsignedIntVector___delslice__, '__delitem__' = UnsignedIntVector___delitem__, '__getitem__' = UnsignedIntVector___getitem__, '__setitem__' = UnsignedIntVector___setitem__, 'append' = UnsignedIntVector_append, 'empty' = UnsignedIntVector_empty, 'size' = UnsignedIntVector_size, 'clear' = UnsignedIntVector_clear, 'swap' = UnsignedIntVector_swap, 'get_allocator' = UnsignedIntVector_get_allocator, 'pop_back' = UnsignedIntVector_pop_back, 'resize' = UnsignedIntVector_resize, 'push_back' = UnsignedIntVector_push_back, 'front' = UnsignedIntVector_front, 'back' = UnsignedIntVector_back, 'assign' = UnsignedIntVector_assign, 'reserve' = UnsignedIntVector_reserve, 'capacity' = UnsignedIntVector_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for std::vector<(unsigned int)>
setMethod('delete', '_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t', function(obj) {delete_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t(obj)})
# Start of DoubleVector___nonzero__

`DoubleVector___nonzero__` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_DoubleVector___nonzero__', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DoubleVector___nonzero__`, 'returnType') = 'logical'
attr(`DoubleVector___nonzero__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`DoubleVector___nonzero__`) = c("SWIGFunction", class('DoubleVector___nonzero__'))

# Start of DoubleVector___len__

`DoubleVector___len__` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_DoubleVector___len__', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`DoubleVector___len__`, 'returnType') = 'integer'
attr(`DoubleVector___len__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`DoubleVector___len__`) = c("SWIGFunction", class('DoubleVector___len__'))

# Start of DoubleVector_pop

`DoubleVector_pop` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_DoubleVector_pop', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DoubleVector_pop`, 'returnType') = 'numeric'
attr(`DoubleVector_pop`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`DoubleVector_pop`) = c("SWIGFunction", class('DoubleVector_pop'))

# Start of DoubleVector___getslice__

`DoubleVector___getslice__` = function(self, i, j)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;ans = .Call('R_swig_DoubleVector___getslice__', self, i, j, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_double_std__allocatorT_double_t_t";
  
  ans
  
}

attr(`DoubleVector___getslice__`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`DoubleVector___getslice__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'integer')
class(`DoubleVector___getslice__`) = c("SWIGFunction", class('DoubleVector___getslice__'))

# Start of DoubleVector___setslice__

`DoubleVector___setslice__` = function(self, i, j, v)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  
  ;.Call('R_swig_DoubleVector___setslice__', self, i, j, v, PACKAGE='QuantLib');
  
}

attr(`DoubleVector___setslice__`, 'returnType') = 'void'
attr(`DoubleVector___setslice__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'integer', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`DoubleVector___setslice__`) = c("SWIGFunction", class('DoubleVector___setslice__'))

# Start of DoubleVector___delslice__

`DoubleVector___delslice__` = function(self, i, j)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_DoubleVector___delslice__', self, i, j, PACKAGE='QuantLib');
  
}

attr(`DoubleVector___delslice__`, 'returnType') = 'void'
attr(`DoubleVector___delslice__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'integer')
class(`DoubleVector___delslice__`) = c("SWIGFunction", class('DoubleVector___delslice__'))

# Start of DoubleVector___delitem__

`DoubleVector___delitem__` = function(self, i)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_DoubleVector___delitem__', self, i, PACKAGE='QuantLib');
  
}

attr(`DoubleVector___delitem__`, 'returnType') = 'void'
attr(`DoubleVector___delitem__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer')
class(`DoubleVector___delitem__`) = c("SWIGFunction", class('DoubleVector___delitem__'))

# Start of DoubleVector___getitem__

`DoubleVector___getitem__` = function(self, i, .copy = FALSE)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_DoubleVector___getitem__', self, i, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DoubleVector___getitem__`, 'returnType') = 'numeric'
attr(`DoubleVector___getitem__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer')
class(`DoubleVector___getitem__`) = c("SWIGFunction", class('DoubleVector___getitem__'))

# Start of DoubleVector___setitem__

`DoubleVector___setitem__` = function(self, i, x)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  ;.Call('R_swig_DoubleVector___setitem__', self, i, x, PACKAGE='QuantLib');
  
}

attr(`DoubleVector___setitem__`, 'returnType') = 'void'
attr(`DoubleVector___setitem__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'numeric')
class(`DoubleVector___setitem__`) = c("SWIGFunction", class('DoubleVector___setitem__'))

# Start of DoubleVector_append

`DoubleVector_append` = function(self, x)
{
  ;.Call('R_swig_DoubleVector_append', self, x, PACKAGE='QuantLib');
  
}

attr(`DoubleVector_append`, 'returnType') = 'void'
attr(`DoubleVector_append`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'numeric')
class(`DoubleVector_append`) = c("SWIGFunction", class('DoubleVector_append'))

# Start of new_DoubleVector

`DoubleVector__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_DoubleVector__SWIG_0', PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_double_std__allocatorT_double_t_t";
  
  reg.finalizer(ans, delete_DoubleVector)
  ans
  
}

attr(`DoubleVector__SWIG_0`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
class(`DoubleVector__SWIG_0`) = c("SWIGFunction", class('DoubleVector__SWIG_0'))

# Start of new_DoubleVector

`DoubleVector__SWIG_1` = function(s_arg1)
{
  ;ans = .Call('R_swig_new_DoubleVector__SWIG_1', s_arg1, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_double_std__allocatorT_double_t_t";
  
  reg.finalizer(ans, delete_DoubleVector)
  ans
  
}

attr(`DoubleVector__SWIG_1`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`DoubleVector__SWIG_1`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`DoubleVector__SWIG_1`) = c("SWIGFunction", class('DoubleVector__SWIG_1'))

# Start of DoubleVector_empty

`DoubleVector_empty` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_DoubleVector_empty', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DoubleVector_empty`, 'returnType') = 'logical'
attr(`DoubleVector_empty`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`DoubleVector_empty`) = c("SWIGFunction", class('DoubleVector_empty'))

# Start of DoubleVector_size

`DoubleVector_size` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_DoubleVector_size', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`DoubleVector_size`, 'returnType') = 'integer'
attr(`DoubleVector_size`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`DoubleVector_size`) = c("SWIGFunction", class('DoubleVector_size'))

# Start of DoubleVector_clear

`DoubleVector_clear` = function(self)
{
  ;.Call('R_swig_DoubleVector_clear', self, PACKAGE='QuantLib');
  
}

attr(`DoubleVector_clear`, 'returnType') = 'void'
attr(`DoubleVector_clear`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`DoubleVector_clear`) = c("SWIGFunction", class('DoubleVector_clear'))

# Start of DoubleVector_swap

`DoubleVector_swap` = function(self, v)
{
  ;.Call('R_swig_DoubleVector_swap', self, v, PACKAGE='QuantLib');
  
}

attr(`DoubleVector_swap`, 'returnType') = 'void'
attr(`DoubleVector_swap`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`DoubleVector_swap`) = c("SWIGFunction", class('DoubleVector_swap'))

# Start of DoubleVector_get_allocator

`DoubleVector_get_allocator` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_DoubleVector_get_allocator', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__allocatorT_double_t";
  
  ans
  
}

attr(`DoubleVector_get_allocator`, 'returnType') = '_p_std__allocatorT_double_t'
attr(`DoubleVector_get_allocator`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`DoubleVector_get_allocator`) = c("SWIGFunction", class('DoubleVector_get_allocator'))

# Start of new_DoubleVector

`DoubleVector__SWIG_2` = function(size)
{
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_new_DoubleVector__SWIG_2', size, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_double_std__allocatorT_double_t_t";
  
  reg.finalizer(ans, delete_DoubleVector)
  ans
  
}

attr(`DoubleVector__SWIG_2`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`DoubleVector__SWIG_2`, "inputTypes") = c('integer')
class(`DoubleVector__SWIG_2`) = c("SWIGFunction", class('DoubleVector__SWIG_2'))

# Start of DoubleVector_pop_back

`DoubleVector_pop_back` = function(self)
{
  ;.Call('R_swig_DoubleVector_pop_back', self, PACKAGE='QuantLib');
  
}

attr(`DoubleVector_pop_back`, 'returnType') = 'void'
attr(`DoubleVector_pop_back`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`DoubleVector_pop_back`) = c("SWIGFunction", class('DoubleVector_pop_back'))

# Start of DoubleVector_resize

`DoubleVector_resize__SWIG_0` = function(self, new_size)
{
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_DoubleVector_resize__SWIG_0', self, new_size, PACKAGE='QuantLib');
  
}

attr(`DoubleVector_resize__SWIG_0`, 'returnType') = 'void'
attr(`DoubleVector_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer')
class(`DoubleVector_resize__SWIG_0`) = c("SWIGFunction", class('DoubleVector_resize__SWIG_0'))

# Start of new_DoubleVector

`DoubleVector__SWIG_3` = function(size, value)
{
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  
  ;ans = .Call('R_swig_new_DoubleVector__SWIG_3', size, value, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_double_std__allocatorT_double_t_t";
  
  reg.finalizer(ans, delete_DoubleVector)
  ans
  
}

attr(`DoubleVector__SWIG_3`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`DoubleVector__SWIG_3`, "inputTypes") = c('integer', 'numeric')
class(`DoubleVector__SWIG_3`) = c("SWIGFunction", class('DoubleVector__SWIG_3'))

`DoubleVector` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- DoubleVector__SWIG_0; 
  } else if (argc == 1) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]]))) {
      f <- DoubleVector__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_double_std__allocatorT_double_t_t')) {
      f <- DoubleVector__SWIG_1; 
    }
  } else if (argc == 2) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && is.numeric(argv[[2]])) {
      f <- DoubleVector__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for DoubleVector with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of DoubleVector_push_back

`DoubleVector_push_back` = function(self, x)
{
  ;.Call('R_swig_DoubleVector_push_back', self, x, PACKAGE='QuantLib');
  
}

attr(`DoubleVector_push_back`, 'returnType') = 'void'
attr(`DoubleVector_push_back`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'numeric')
class(`DoubleVector_push_back`) = c("SWIGFunction", class('DoubleVector_push_back'))

# Start of DoubleVector_front

`DoubleVector_front` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_DoubleVector_front', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DoubleVector_front`, 'returnType') = 'numeric'
attr(`DoubleVector_front`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`DoubleVector_front`) = c("SWIGFunction", class('DoubleVector_front'))

# Start of DoubleVector_back

`DoubleVector_back` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_DoubleVector_back', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DoubleVector_back`, 'returnType') = 'numeric'
attr(`DoubleVector_back`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`DoubleVector_back`) = c("SWIGFunction", class('DoubleVector_back'))

# Start of DoubleVector_assign

`DoubleVector_assign` = function(self, n, x)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  
  ;.Call('R_swig_DoubleVector_assign', self, n, x, PACKAGE='QuantLib');
  
}

attr(`DoubleVector_assign`, 'returnType') = 'void'
attr(`DoubleVector_assign`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'numeric')
class(`DoubleVector_assign`) = c("SWIGFunction", class('DoubleVector_assign'))

# Start of DoubleVector_resize

`DoubleVector_resize__SWIG_1` = function(self, new_size, x)
{
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  
  ;.Call('R_swig_DoubleVector_resize__SWIG_1', self, new_size, x, PACKAGE='QuantLib');
  
}

attr(`DoubleVector_resize__SWIG_1`, 'returnType') = 'void'
attr(`DoubleVector_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'numeric')
class(`DoubleVector_resize__SWIG_1`) = c("SWIGFunction", class('DoubleVector_resize__SWIG_1'))

`DoubleVector_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_std__vectorT_double_std__allocatorT_double_t_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]]))) {
      f <- DoubleVector_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_std__vectorT_double_std__allocatorT_double_t_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && is.numeric(argv[[3]])) {
      f <- DoubleVector_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for DoubleVector_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of DoubleVector_reserve

`DoubleVector_reserve` = function(self, n)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_DoubleVector_reserve', self, n, PACKAGE='QuantLib');
  
}

attr(`DoubleVector_reserve`, 'returnType') = 'void'
attr(`DoubleVector_reserve`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer')
class(`DoubleVector_reserve`) = c("SWIGFunction", class('DoubleVector_reserve'))

# Start of DoubleVector_capacity

`DoubleVector_capacity` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_DoubleVector_capacity', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`DoubleVector_capacity`, 'returnType') = 'integer'
attr(`DoubleVector_capacity`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`DoubleVector_capacity`) = c("SWIGFunction", class('DoubleVector_capacity'))

# Start of delete_DoubleVector

`delete_DoubleVector` = function(self)
{
  ;.Call('R_swig_delete_DoubleVector', self, PACKAGE='QuantLib');
  
}

attr(`delete_DoubleVector`, 'returnType') = 'void'
attr(`delete_DoubleVector`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`delete_DoubleVector`) = c("SWIGFunction", class('delete_DoubleVector'))

# Start of accessor method for std::vector<(double)>
setMethod('$', '_p_std__vectorT_double_std__allocatorT_double_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = DoubleVector___nonzero__, '__len__' = DoubleVector___len__, 'pop' = DoubleVector_pop, '__getslice__' = DoubleVector___getslice__, '__setslice__' = DoubleVector___setslice__, '__delslice__' = DoubleVector___delslice__, '__delitem__' = DoubleVector___delitem__, '__getitem__' = DoubleVector___getitem__, '__setitem__' = DoubleVector___setitem__, 'append' = DoubleVector_append, 'empty' = DoubleVector_empty, 'size' = DoubleVector_size, 'clear' = DoubleVector_clear, 'swap' = DoubleVector_swap, 'get_allocator' = DoubleVector_get_allocator, 'pop_back' = DoubleVector_pop_back, 'resize' = DoubleVector_resize, 'push_back' = DoubleVector_push_back, 'front' = DoubleVector_front, 'back' = DoubleVector_back, 'assign' = DoubleVector_assign, 'reserve' = DoubleVector_reserve, 'capacity' = DoubleVector_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for std::vector<(double)>
setMethod('delete', '_p_std__vectorT_double_std__allocatorT_double_t_t', function(obj) {delete_std__vectorT_double_std__allocatorT_double_t_t(obj)})
# Start of StrVector___nonzero__

`StrVector___nonzero__` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_StrVector___nonzero__', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`StrVector___nonzero__`, 'returnType') = 'logical'
attr(`StrVector___nonzero__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StrVector___nonzero__`) = c("SWIGFunction", class('StrVector___nonzero__'))

# Start of StrVector___len__

`StrVector___len__` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_StrVector___len__', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`StrVector___len__`, 'returnType') = 'integer'
attr(`StrVector___len__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StrVector___len__`) = c("SWIGFunction", class('StrVector___len__'))

# Start of StrVector_pop

`StrVector_pop` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_StrVector_pop', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`StrVector_pop`, 'returnType') = 'character'
attr(`StrVector_pop`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StrVector_pop`) = c("SWIGFunction", class('StrVector_pop'))

# Start of StrVector___getslice__

`StrVector___getslice__` = function(self, i, j)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;ans = .Call('R_swig_StrVector___getslice__', self, i, j, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_std__string_std__allocatorT_std__string_t_t";
  
  ans
  
}

attr(`StrVector___getslice__`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
attr(`StrVector___getslice__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'integer')
class(`StrVector___getslice__`) = c("SWIGFunction", class('StrVector___getslice__'))

# Start of StrVector___setslice__

`StrVector___setslice__` = function(self, i, j, v)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  
  ;.Call('R_swig_StrVector___setslice__', self, i, j, v, PACKAGE='QuantLib');
  
}

attr(`StrVector___setslice__`, 'returnType') = 'void'
attr(`StrVector___setslice__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'integer', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StrVector___setslice__`) = c("SWIGFunction", class('StrVector___setslice__'))

# Start of StrVector___delslice__

`StrVector___delslice__` = function(self, i, j)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_StrVector___delslice__', self, i, j, PACKAGE='QuantLib');
  
}

attr(`StrVector___delslice__`, 'returnType') = 'void'
attr(`StrVector___delslice__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'integer')
class(`StrVector___delslice__`) = c("SWIGFunction", class('StrVector___delslice__'))

# Start of StrVector___delitem__

`StrVector___delitem__` = function(self, i)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_StrVector___delitem__', self, i, PACKAGE='QuantLib');
  
}

attr(`StrVector___delitem__`, 'returnType') = 'void'
attr(`StrVector___delitem__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer')
class(`StrVector___delitem__`) = c("SWIGFunction", class('StrVector___delitem__'))

# Start of StrVector___getitem__

`StrVector___getitem__` = function(self, i, .copy = FALSE)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_StrVector___getitem__', self, i, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`StrVector___getitem__`, 'returnType') = 'character'
attr(`StrVector___getitem__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer')
class(`StrVector___getitem__`) = c("SWIGFunction", class('StrVector___getitem__'))

# Start of StrVector___setitem__

`StrVector___setitem__` = function(self, i, x)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  x = as(x, "character"); 
  ;.Call('R_swig_StrVector___setitem__', self, i, x, PACKAGE='QuantLib');
  
}

attr(`StrVector___setitem__`, 'returnType') = 'void'
attr(`StrVector___setitem__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'character')
class(`StrVector___setitem__`) = c("SWIGFunction", class('StrVector___setitem__'))

# Start of StrVector_append

`StrVector_append` = function(self, x)
{
  x = as(x, "character"); 
  ;.Call('R_swig_StrVector_append', self, x, PACKAGE='QuantLib');
  
}

attr(`StrVector_append`, 'returnType') = 'void'
attr(`StrVector_append`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'character')
class(`StrVector_append`) = c("SWIGFunction", class('StrVector_append'))

# Start of new_StrVector

`StrVector__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_StrVector__SWIG_0', PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_std__string_std__allocatorT_std__string_t_t";
  
  reg.finalizer(ans, delete_StrVector)
  ans
  
}

attr(`StrVector__SWIG_0`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
class(`StrVector__SWIG_0`) = c("SWIGFunction", class('StrVector__SWIG_0'))

# Start of new_StrVector

`StrVector__SWIG_1` = function(s_arg1)
{
  ;ans = .Call('R_swig_new_StrVector__SWIG_1', s_arg1, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_std__string_std__allocatorT_std__string_t_t";
  
  reg.finalizer(ans, delete_StrVector)
  ans
  
}

attr(`StrVector__SWIG_1`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
attr(`StrVector__SWIG_1`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StrVector__SWIG_1`) = c("SWIGFunction", class('StrVector__SWIG_1'))

# Start of StrVector_empty

`StrVector_empty` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_StrVector_empty', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`StrVector_empty`, 'returnType') = 'logical'
attr(`StrVector_empty`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StrVector_empty`) = c("SWIGFunction", class('StrVector_empty'))

# Start of StrVector_size

`StrVector_size` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_StrVector_size', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`StrVector_size`, 'returnType') = 'integer'
attr(`StrVector_size`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StrVector_size`) = c("SWIGFunction", class('StrVector_size'))

# Start of StrVector_clear

`StrVector_clear` = function(self)
{
  ;.Call('R_swig_StrVector_clear', self, PACKAGE='QuantLib');
  
}

attr(`StrVector_clear`, 'returnType') = 'void'
attr(`StrVector_clear`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StrVector_clear`) = c("SWIGFunction", class('StrVector_clear'))

# Start of StrVector_swap

`StrVector_swap` = function(self, v)
{
  ;.Call('R_swig_StrVector_swap', self, v, PACKAGE='QuantLib');
  
}

attr(`StrVector_swap`, 'returnType') = 'void'
attr(`StrVector_swap`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StrVector_swap`) = c("SWIGFunction", class('StrVector_swap'))

# Start of StrVector_get_allocator

`StrVector_get_allocator` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_StrVector_get_allocator', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__allocatorT_std__string_t";
  
  ans
  
}

attr(`StrVector_get_allocator`, 'returnType') = '_p_std__allocatorT_std__string_t'
attr(`StrVector_get_allocator`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StrVector_get_allocator`) = c("SWIGFunction", class('StrVector_get_allocator'))

# Start of new_StrVector

`StrVector__SWIG_2` = function(size)
{
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_new_StrVector__SWIG_2', size, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_std__string_std__allocatorT_std__string_t_t";
  
  reg.finalizer(ans, delete_StrVector)
  ans
  
}

attr(`StrVector__SWIG_2`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
attr(`StrVector__SWIG_2`, "inputTypes") = c('integer')
class(`StrVector__SWIG_2`) = c("SWIGFunction", class('StrVector__SWIG_2'))

# Start of StrVector_pop_back

`StrVector_pop_back` = function(self)
{
  ;.Call('R_swig_StrVector_pop_back', self, PACKAGE='QuantLib');
  
}

attr(`StrVector_pop_back`, 'returnType') = 'void'
attr(`StrVector_pop_back`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StrVector_pop_back`) = c("SWIGFunction", class('StrVector_pop_back'))

# Start of StrVector_resize

`StrVector_resize__SWIG_0` = function(self, new_size)
{
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_StrVector_resize__SWIG_0', self, new_size, PACKAGE='QuantLib');
  
}

attr(`StrVector_resize__SWIG_0`, 'returnType') = 'void'
attr(`StrVector_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer')
class(`StrVector_resize__SWIG_0`) = c("SWIGFunction", class('StrVector_resize__SWIG_0'))

# Start of new_StrVector

`StrVector__SWIG_3` = function(size, value)
{
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  value = as(value, "character"); 
  ;ans = .Call('R_swig_new_StrVector__SWIG_3', size, value, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_std__string_std__allocatorT_std__string_t_t";
  
  reg.finalizer(ans, delete_StrVector)
  ans
  
}

attr(`StrVector__SWIG_3`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
attr(`StrVector__SWIG_3`, "inputTypes") = c('integer', 'character')
class(`StrVector__SWIG_3`) = c("SWIGFunction", class('StrVector__SWIG_3'))

`StrVector` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- StrVector__SWIG_0; 
  } else if (argc == 1) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]]))) {
      f <- StrVector__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')) {
      f <- StrVector__SWIG_1; 
    }
  } else if (argc == 2) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && is.character(argv[[2]])) {
      f <- StrVector__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for StrVector with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of StrVector_push_back

`StrVector_push_back` = function(self, x)
{
  x = as(x, "character"); 
  ;.Call('R_swig_StrVector_push_back', self, x, PACKAGE='QuantLib');
  
}

attr(`StrVector_push_back`, 'returnType') = 'void'
attr(`StrVector_push_back`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'character')
class(`StrVector_push_back`) = c("SWIGFunction", class('StrVector_push_back'))

# Start of StrVector_front

`StrVector_front` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_StrVector_front', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`StrVector_front`, 'returnType') = 'character'
attr(`StrVector_front`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StrVector_front`) = c("SWIGFunction", class('StrVector_front'))

# Start of StrVector_back

`StrVector_back` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_StrVector_back', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`StrVector_back`, 'returnType') = 'character'
attr(`StrVector_back`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StrVector_back`) = c("SWIGFunction", class('StrVector_back'))

# Start of StrVector_assign

`StrVector_assign` = function(self, n, x)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  x = as(x, "character"); 
  ;.Call('R_swig_StrVector_assign', self, n, x, PACKAGE='QuantLib');
  
}

attr(`StrVector_assign`, 'returnType') = 'void'
attr(`StrVector_assign`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'character')
class(`StrVector_assign`) = c("SWIGFunction", class('StrVector_assign'))

# Start of StrVector_resize

`StrVector_resize__SWIG_1` = function(self, new_size, x)
{
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  x = as(x, "character"); 
  ;.Call('R_swig_StrVector_resize__SWIG_1', self, new_size, x, PACKAGE='QuantLib');
  
}

attr(`StrVector_resize__SWIG_1`, 'returnType') = 'void'
attr(`StrVector_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'character')
class(`StrVector_resize__SWIG_1`) = c("SWIGFunction", class('StrVector_resize__SWIG_1'))

`StrVector_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]]))) {
      f <- StrVector_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && is.character(argv[[3]])) {
      f <- StrVector_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for StrVector_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of StrVector_reserve

`StrVector_reserve` = function(self, n)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_StrVector_reserve', self, n, PACKAGE='QuantLib');
  
}

attr(`StrVector_reserve`, 'returnType') = 'void'
attr(`StrVector_reserve`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer')
class(`StrVector_reserve`) = c("SWIGFunction", class('StrVector_reserve'))

# Start of StrVector_capacity

`StrVector_capacity` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_StrVector_capacity', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`StrVector_capacity`, 'returnType') = 'integer'
attr(`StrVector_capacity`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StrVector_capacity`) = c("SWIGFunction", class('StrVector_capacity'))

# Start of delete_StrVector

`delete_StrVector` = function(self)
{
  ;.Call('R_swig_delete_StrVector', self, PACKAGE='QuantLib');
  
}

attr(`delete_StrVector`, 'returnType') = 'void'
attr(`delete_StrVector`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`delete_StrVector`) = c("SWIGFunction", class('delete_StrVector'))

# Start of accessor method for std::vector<(std::string)>
setMethod('$', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = StrVector___nonzero__, '__len__' = StrVector___len__, 'pop' = StrVector_pop, '__getslice__' = StrVector___getslice__, '__setslice__' = StrVector___setslice__, '__delslice__' = StrVector___delslice__, '__delitem__' = StrVector___delitem__, '__getitem__' = StrVector___getitem__, '__setitem__' = StrVector___setitem__, 'append' = StrVector_append, 'empty' = StrVector_empty, 'size' = StrVector_size, 'clear' = StrVector_clear, 'swap' = StrVector_swap, 'get_allocator' = StrVector_get_allocator, 'pop_back' = StrVector_pop_back, 'resize' = StrVector_resize, 'push_back' = StrVector_push_back, 'front' = StrVector_front, 'back' = StrVector_back, 'assign' = StrVector_assign, 'reserve' = StrVector_reserve, 'capacity' = StrVector_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for std::vector<(std::string)>
setMethod('delete', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', function(obj) {delete_std__vectorT_std__string_std__allocatorT_std__string_t_t(obj)})
# Start of BoolVector___nonzero__

`BoolVector___nonzero__` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_BoolVector___nonzero__', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BoolVector___nonzero__`, 'returnType') = 'logical'
attr(`BoolVector___nonzero__`, "inputTypes") = c('_p_std__vectorT_bool_std__allocatorT_bool_t_t')
class(`BoolVector___nonzero__`) = c("SWIGFunction", class('BoolVector___nonzero__'))

# Start of BoolVector___len__

`BoolVector___len__` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_BoolVector___len__', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`BoolVector___len__`, 'returnType') = 'integer'
attr(`BoolVector___len__`, "inputTypes") = c('_p_std__vectorT_bool_std__allocatorT_bool_t_t')
class(`BoolVector___len__`) = c("SWIGFunction", class('BoolVector___len__'))

# Start of BoolVector_pop

`BoolVector_pop` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_BoolVector_pop', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BoolVector_pop`, 'returnType') = 'logical'
attr(`BoolVector_pop`, "inputTypes") = c('_p_std__vectorT_bool_std__allocatorT_bool_t_t')
class(`BoolVector_pop`) = c("SWIGFunction", class('BoolVector_pop'))

# Start of BoolVector___getslice__

`BoolVector___getslice__` = function(self, i, j)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;ans = .Call('R_swig_BoolVector___getslice__', self, i, j, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_bool_std__allocatorT_bool_t_t";
  
  ans
  
}

attr(`BoolVector___getslice__`, 'returnType') = '_p_std__vectorT_bool_std__allocatorT_bool_t_t'
attr(`BoolVector___getslice__`, "inputTypes") = c('_p_std__vectorT_bool_std__allocatorT_bool_t_t', 'integer', 'integer')
class(`BoolVector___getslice__`) = c("SWIGFunction", class('BoolVector___getslice__'))

# Start of BoolVector___setslice__

`BoolVector___setslice__` = function(self, i, j, v)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  
  ;.Call('R_swig_BoolVector___setslice__', self, i, j, v, PACKAGE='QuantLib');
  
}

attr(`BoolVector___setslice__`, 'returnType') = 'void'
attr(`BoolVector___setslice__`, "inputTypes") = c('_p_std__vectorT_bool_std__allocatorT_bool_t_t', 'integer', 'integer', '_p_std__vectorT_bool_std__allocatorT_bool_t_t')
class(`BoolVector___setslice__`) = c("SWIGFunction", class('BoolVector___setslice__'))

# Start of BoolVector___delslice__

`BoolVector___delslice__` = function(self, i, j)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_BoolVector___delslice__', self, i, j, PACKAGE='QuantLib');
  
}

attr(`BoolVector___delslice__`, 'returnType') = 'void'
attr(`BoolVector___delslice__`, "inputTypes") = c('_p_std__vectorT_bool_std__allocatorT_bool_t_t', 'integer', 'integer')
class(`BoolVector___delslice__`) = c("SWIGFunction", class('BoolVector___delslice__'))

# Start of BoolVector___delitem__

`BoolVector___delitem__` = function(self, i)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_BoolVector___delitem__', self, i, PACKAGE='QuantLib');
  
}

attr(`BoolVector___delitem__`, 'returnType') = 'void'
attr(`BoolVector___delitem__`, "inputTypes") = c('_p_std__vectorT_bool_std__allocatorT_bool_t_t', 'integer')
class(`BoolVector___delitem__`) = c("SWIGFunction", class('BoolVector___delitem__'))

# Start of BoolVector___getitem__

`BoolVector___getitem__` = function(self, i, .copy = FALSE)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_BoolVector___getitem__', self, i, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BoolVector___getitem__`, 'returnType') = 'logical'
attr(`BoolVector___getitem__`, "inputTypes") = c('_p_std__vectorT_bool_std__allocatorT_bool_t_t', 'integer')
class(`BoolVector___getitem__`) = c("SWIGFunction", class('BoolVector___getitem__'))

# Start of BoolVector___setitem__

`BoolVector___setitem__` = function(self, i, x)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  x = as.logical(x);
  ;.Call('R_swig_BoolVector___setitem__', self, i, x, PACKAGE='QuantLib');
  
}

attr(`BoolVector___setitem__`, 'returnType') = 'void'
attr(`BoolVector___setitem__`, "inputTypes") = c('_p_std__vectorT_bool_std__allocatorT_bool_t_t', 'integer', 'logical')
class(`BoolVector___setitem__`) = c("SWIGFunction", class('BoolVector___setitem__'))

# Start of BoolVector_append

`BoolVector_append` = function(self, x)
{
  x = as.logical(x);
  ;.Call('R_swig_BoolVector_append', self, x, PACKAGE='QuantLib');
  
}

attr(`BoolVector_append`, 'returnType') = 'void'
attr(`BoolVector_append`, "inputTypes") = c('_p_std__vectorT_bool_std__allocatorT_bool_t_t', 'logical')
class(`BoolVector_append`) = c("SWIGFunction", class('BoolVector_append'))

# Start of new_BoolVector

`BoolVector__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_BoolVector__SWIG_0', PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_bool_std__allocatorT_bool_t_t";
  
  reg.finalizer(ans, delete_BoolVector)
  ans
  
}

attr(`BoolVector__SWIG_0`, 'returnType') = '_p_std__vectorT_bool_std__allocatorT_bool_t_t'
class(`BoolVector__SWIG_0`) = c("SWIGFunction", class('BoolVector__SWIG_0'))

# Start of new_BoolVector

`BoolVector__SWIG_1` = function(s_arg1)
{
  ;ans = .Call('R_swig_new_BoolVector__SWIG_1', s_arg1, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_bool_std__allocatorT_bool_t_t";
  
  reg.finalizer(ans, delete_BoolVector)
  ans
  
}

attr(`BoolVector__SWIG_1`, 'returnType') = '_p_std__vectorT_bool_std__allocatorT_bool_t_t'
attr(`BoolVector__SWIG_1`, "inputTypes") = c('_p_std__vectorT_bool_std__allocatorT_bool_t_t')
class(`BoolVector__SWIG_1`) = c("SWIGFunction", class('BoolVector__SWIG_1'))

# Start of BoolVector_empty

`BoolVector_empty` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_BoolVector_empty', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BoolVector_empty`, 'returnType') = 'logical'
attr(`BoolVector_empty`, "inputTypes") = c('_p_std__vectorT_bool_std__allocatorT_bool_t_t')
class(`BoolVector_empty`) = c("SWIGFunction", class('BoolVector_empty'))

# Start of BoolVector_size

`BoolVector_size` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_BoolVector_size', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`BoolVector_size`, 'returnType') = 'integer'
attr(`BoolVector_size`, "inputTypes") = c('_p_std__vectorT_bool_std__allocatorT_bool_t_t')
class(`BoolVector_size`) = c("SWIGFunction", class('BoolVector_size'))

# Start of BoolVector_clear

`BoolVector_clear` = function(self)
{
  ;.Call('R_swig_BoolVector_clear', self, PACKAGE='QuantLib');
  
}

attr(`BoolVector_clear`, 'returnType') = 'void'
attr(`BoolVector_clear`, "inputTypes") = c('_p_std__vectorT_bool_std__allocatorT_bool_t_t')
class(`BoolVector_clear`) = c("SWIGFunction", class('BoolVector_clear'))

# Start of BoolVector_swap

`BoolVector_swap` = function(self, v)
{
  ;.Call('R_swig_BoolVector_swap', self, v, PACKAGE='QuantLib');
  
}

attr(`BoolVector_swap`, 'returnType') = 'void'
attr(`BoolVector_swap`, "inputTypes") = c('_p_std__vectorT_bool_std__allocatorT_bool_t_t', '_p_std__vectorT_bool_std__allocatorT_bool_t_t')
class(`BoolVector_swap`) = c("SWIGFunction", class('BoolVector_swap'))

# Start of BoolVector_get_allocator

`BoolVector_get_allocator` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_BoolVector_get_allocator', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__allocatorT_bool_t";
  
  ans
  
}

attr(`BoolVector_get_allocator`, 'returnType') = '_p_std__allocatorT_bool_t'
attr(`BoolVector_get_allocator`, "inputTypes") = c('_p_std__vectorT_bool_std__allocatorT_bool_t_t')
class(`BoolVector_get_allocator`) = c("SWIGFunction", class('BoolVector_get_allocator'))

# Start of new_BoolVector

`BoolVector__SWIG_2` = function(size)
{
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_new_BoolVector__SWIG_2', size, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_bool_std__allocatorT_bool_t_t";
  
  reg.finalizer(ans, delete_BoolVector)
  ans
  
}

attr(`BoolVector__SWIG_2`, 'returnType') = '_p_std__vectorT_bool_std__allocatorT_bool_t_t'
attr(`BoolVector__SWIG_2`, "inputTypes") = c('integer')
class(`BoolVector__SWIG_2`) = c("SWIGFunction", class('BoolVector__SWIG_2'))

# Start of BoolVector_pop_back

`BoolVector_pop_back` = function(self)
{
  ;.Call('R_swig_BoolVector_pop_back', self, PACKAGE='QuantLib');
  
}

attr(`BoolVector_pop_back`, 'returnType') = 'void'
attr(`BoolVector_pop_back`, "inputTypes") = c('_p_std__vectorT_bool_std__allocatorT_bool_t_t')
class(`BoolVector_pop_back`) = c("SWIGFunction", class('BoolVector_pop_back'))

# Start of BoolVector_resize

`BoolVector_resize__SWIG_0` = function(self, new_size)
{
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_BoolVector_resize__SWIG_0', self, new_size, PACKAGE='QuantLib');
  
}

attr(`BoolVector_resize__SWIG_0`, 'returnType') = 'void'
attr(`BoolVector_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_bool_std__allocatorT_bool_t_t', 'integer')
class(`BoolVector_resize__SWIG_0`) = c("SWIGFunction", class('BoolVector_resize__SWIG_0'))

# Start of new_BoolVector

`BoolVector__SWIG_3` = function(size, value)
{
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  value = as.logical(value);
  ;ans = .Call('R_swig_new_BoolVector__SWIG_3', size, value, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_bool_std__allocatorT_bool_t_t";
  
  reg.finalizer(ans, delete_BoolVector)
  ans
  
}

attr(`BoolVector__SWIG_3`, 'returnType') = '_p_std__vectorT_bool_std__allocatorT_bool_t_t'
attr(`BoolVector__SWIG_3`, "inputTypes") = c('integer', 'logical')
class(`BoolVector__SWIG_3`) = c("SWIGFunction", class('BoolVector__SWIG_3'))

`BoolVector` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- BoolVector__SWIG_0; 
  } else if (argc == 1) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]]))) {
      f <- BoolVector__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_bool_std__allocatorT_bool_t_t')) {
      f <- BoolVector__SWIG_1; 
    }
  } else if (argc == 2) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && extends(argtypes[2], 'logical')) {
      f <- BoolVector__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for BoolVector with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of BoolVector_push_back

`BoolVector_push_back` = function(self, x)
{
  x = as.logical(x);
  ;.Call('R_swig_BoolVector_push_back', self, x, PACKAGE='QuantLib');
  
}

attr(`BoolVector_push_back`, 'returnType') = 'void'
attr(`BoolVector_push_back`, "inputTypes") = c('_p_std__vectorT_bool_std__allocatorT_bool_t_t', 'logical')
class(`BoolVector_push_back`) = c("SWIGFunction", class('BoolVector_push_back'))

# Start of BoolVector_front

`BoolVector_front` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_BoolVector_front', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BoolVector_front`, 'returnType') = 'logical'
attr(`BoolVector_front`, "inputTypes") = c('_p_std__vectorT_bool_std__allocatorT_bool_t_t')
class(`BoolVector_front`) = c("SWIGFunction", class('BoolVector_front'))

# Start of BoolVector_back

`BoolVector_back` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_BoolVector_back', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BoolVector_back`, 'returnType') = 'logical'
attr(`BoolVector_back`, "inputTypes") = c('_p_std__vectorT_bool_std__allocatorT_bool_t_t')
class(`BoolVector_back`) = c("SWIGFunction", class('BoolVector_back'))

# Start of BoolVector_assign

`BoolVector_assign` = function(self, n, x)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  x = as.logical(x);
  ;.Call('R_swig_BoolVector_assign', self, n, x, PACKAGE='QuantLib');
  
}

attr(`BoolVector_assign`, 'returnType') = 'void'
attr(`BoolVector_assign`, "inputTypes") = c('_p_std__vectorT_bool_std__allocatorT_bool_t_t', 'integer', 'logical')
class(`BoolVector_assign`) = c("SWIGFunction", class('BoolVector_assign'))

# Start of BoolVector_resize

`BoolVector_resize__SWIG_1` = function(self, new_size, x)
{
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  x = as.logical(x);
  ;.Call('R_swig_BoolVector_resize__SWIG_1', self, new_size, x, PACKAGE='QuantLib');
  
}

attr(`BoolVector_resize__SWIG_1`, 'returnType') = 'void'
attr(`BoolVector_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_bool_std__allocatorT_bool_t_t', 'integer', 'logical')
class(`BoolVector_resize__SWIG_1`) = c("SWIGFunction", class('BoolVector_resize__SWIG_1'))

`BoolVector_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_std__vectorT_bool_std__allocatorT_bool_t_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]]))) {
      f <- BoolVector_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_std__vectorT_bool_std__allocatorT_bool_t_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && extends(argtypes[3], 'logical')) {
      f <- BoolVector_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for BoolVector_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of BoolVector_reserve

`BoolVector_reserve` = function(self, n)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_BoolVector_reserve', self, n, PACKAGE='QuantLib');
  
}

attr(`BoolVector_reserve`, 'returnType') = 'void'
attr(`BoolVector_reserve`, "inputTypes") = c('_p_std__vectorT_bool_std__allocatorT_bool_t_t', 'integer')
class(`BoolVector_reserve`) = c("SWIGFunction", class('BoolVector_reserve'))

# Start of BoolVector_capacity

`BoolVector_capacity` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_BoolVector_capacity', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`BoolVector_capacity`, 'returnType') = 'integer'
attr(`BoolVector_capacity`, "inputTypes") = c('_p_std__vectorT_bool_std__allocatorT_bool_t_t')
class(`BoolVector_capacity`) = c("SWIGFunction", class('BoolVector_capacity'))

# Start of delete_BoolVector

`delete_BoolVector` = function(self)
{
  ;.Call('R_swig_delete_BoolVector', self, PACKAGE='QuantLib');
  
}

attr(`delete_BoolVector`, 'returnType') = 'void'
attr(`delete_BoolVector`, "inputTypes") = c('_p_std__vectorT_bool_std__allocatorT_bool_t_t')
class(`delete_BoolVector`) = c("SWIGFunction", class('delete_BoolVector'))

# Start of accessor method for std::vector<(bool)>
setMethod('$', '_p_std__vectorT_bool_std__allocatorT_bool_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = BoolVector___nonzero__, '__len__' = BoolVector___len__, 'pop' = BoolVector_pop, '__getslice__' = BoolVector___getslice__, '__setslice__' = BoolVector___setslice__, '__delslice__' = BoolVector___delslice__, '__delitem__' = BoolVector___delitem__, '__getitem__' = BoolVector___getitem__, '__setitem__' = BoolVector___setitem__, 'append' = BoolVector_append, 'empty' = BoolVector_empty, 'size' = BoolVector_size, 'clear' = BoolVector_clear, 'swap' = BoolVector_swap, 'get_allocator' = BoolVector_get_allocator, 'pop_back' = BoolVector_pop_back, 'resize' = BoolVector_resize, 'push_back' = BoolVector_push_back, 'front' = BoolVector_front, 'back' = BoolVector_back, 'assign' = BoolVector_assign, 'reserve' = BoolVector_reserve, 'capacity' = BoolVector_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for std::vector<(bool)>
setMethod('delete', '_p_std__vectorT_bool_std__allocatorT_bool_t_t', function(obj) {delete_std__vectorT_bool_std__allocatorT_bool_t_t(obj)})

setMethod('print', '_p_std__vectorTint_std__allocatorTint_t_t',
function(x) print(as(x, "integer")))

setAs("_p_std__vectorTint_std__allocatorTint_t_t", "integer",
function(from) {if (from$size()) from[1:from$size()] else NULL} )

setAs("integer", "_p_std__vectorTint_std__allocatorTint_t_t",
function(from) { a <- IntVector(length(from));
sapply(1:length(from), function(n) {
a[n] <- from[n] } )
a
})


setMethod('print', '_p_std__vectorTdouble_std__allocatorTdouble_t_t',
function(x) print(as(x, "numeric")))

setAs("_p_std__vectorTdouble_std__allocatorTdouble_t_t", "numeric",
function(from) {if (from$size()) from[1:from$size()] else NULL} )

setAs("numeric", "_p_std__vectorTdouble_std__allocatorTdouble_t_t",
function(from) { a <- DoubleVector(length(from));
sapply(1:length(from), function(n) {
a[n] <- from[n] } )
a
})


setMethod('print', '_p_std__vectorTstd__string_std__allocatorTstd__string_t_t',
function(x) print(as(x, "character")))

setAs("_p_std__vectorTstd__string_std__allocatorTstd__string_t_t", "character",
function(from) {if (from$size()) from[1:from$size()] else NULL} )

setAs("character", "_p_std__vectorTstd__string_std__allocatorTstd__string_t_t",
function(from) { a <- StrVector(length(from));
sapply(1:length(from), function(n) {
a[n] <- from[n] } )
a
})

# Start of Exercise___deref__

`Exercise___deref__` = function(self)
{
  ;ans = .Call('R_swig_Exercise___deref__', self, PACKAGE='QuantLib');
  class(ans) <- "_p_Exercise";
  
  ans
  
}

attr(`Exercise___deref__`, 'returnType') = '_p_Exercise'
attr(`Exercise___deref__`, "inputTypes") = c('_p_boost__shared_ptrT_Exercise_t')
class(`Exercise___deref__`) = c("SWIGFunction", class('Exercise___deref__'))

# Start of Exercise_isNull

`Exercise_isNull` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Exercise_isNull', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Exercise_isNull`, 'returnType') = 'logical'
attr(`Exercise_isNull`, "inputTypes") = c('_p_boost__shared_ptrT_Exercise_t')
class(`Exercise_isNull`) = c("SWIGFunction", class('Exercise_isNull'))

# Start of Exercise_exerciseType

`Exercise_exerciseType` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_Exercise_exerciseType', self, as.logical(.copy), PACKAGE='QuantLib');
  ans = enumFromInteger(ans, "_Exercise__Type");
  
  ans
  
}

attr(`Exercise_exerciseType`, 'returnType') = 'character'
attr(`Exercise_exerciseType`, "inputTypes") = c('_p_boost__shared_ptrT_Exercise_t')
class(`Exercise_exerciseType`) = c("SWIGFunction", class('Exercise_exerciseType'))

# Start of new_Exercise

`Exercise` = function()
{
  ;ans = .Call('R_swig_new_Exercise', PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_Exercise_t";
  
  reg.finalizer(ans, delete_Exercise)
  ans
  
}

attr(`Exercise`, 'returnType') = '_p_boost__shared_ptrT_Exercise_t'
class(`Exercise`) = c("SWIGFunction", class('Exercise'))

# Start of delete_Exercise

`delete_Exercise` = function(self)
{
  ;.Call('R_swig_delete_Exercise', self, PACKAGE='QuantLib');
  
}

attr(`delete_Exercise`, 'returnType') = 'void'
attr(`delete_Exercise`, "inputTypes") = c('_p_boost__shared_ptrT_Exercise_t')
class(`delete_Exercise`) = c("SWIGFunction", class('delete_Exercise'))

# Start of Exercise_type

`Exercise_type` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_Exercise_type', self, as.logical(.copy), PACKAGE='QuantLib');
  ans = enumFromInteger(ans, "_Exercise__Type");
  
  ans
  
}

attr(`Exercise_type`, 'returnType') = 'character'
attr(`Exercise_type`, "inputTypes") = c('_p_boost__shared_ptrT_Exercise_t')
class(`Exercise_type`) = c("SWIGFunction", class('Exercise_type'))

# Start of Exercise_dates

`Exercise_dates` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_Exercise_dates', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_Date_std__allocatorT_Date_t_t";
  
  ans
  
}

attr(`Exercise_dates`, 'returnType') = '_p_std__vectorT_Date_std__allocatorT_Date_t_t'
attr(`Exercise_dates`, "inputTypes") = c('_p_boost__shared_ptrT_Exercise_t')
class(`Exercise_dates`) = c("SWIGFunction", class('Exercise_dates'))

# Start of accessor method for boost::shared_ptr<(Exercise)>
setMethod('$', '_p_boost__shared_ptrT_Exercise_t', function(x, name)

{
  accessorFuns = list('__deref__' = Exercise___deref__, 'isNull' = Exercise_isNull, 'exerciseType' = Exercise_exerciseType, 'type' = Exercise_type, 'dates' = Exercise_dates);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for boost::shared_ptr<(Exercise)>
setMethod('delete', '_p_boost__shared_ptrT_Exercise_t', function(obj) {delete_boost__shared_ptrT_Exercise_t(obj)})
# Start of new_EuropeanExercise

`EuropeanExercise` = function(date)
{
  ;ans = .Call('R_swig_new_EuropeanExercise', date, PACKAGE='QuantLib');
  class(ans) <- "_p_EuropeanExercisePtr";
  
  reg.finalizer(ans, delete_EuropeanExercise)
  ans
  
}

attr(`EuropeanExercise`, 'returnType') = '_p_EuropeanExercisePtr'
attr(`EuropeanExercise`, "inputTypes") = c('_p_Date')
class(`EuropeanExercise`) = c("SWIGFunction", class('EuropeanExercise'))

# Start of delete_EuropeanExercise

`delete_EuropeanExercise` = function(self)
{
  ;.Call('R_swig_delete_EuropeanExercise', self, PACKAGE='QuantLib');
  
}

attr(`delete_EuropeanExercise`, 'returnType') = 'void'
attr(`delete_EuropeanExercise`, "inputTypes") = c('_p_EuropeanExercisePtr')
class(`delete_EuropeanExercise`) = c("SWIGFunction", class('delete_EuropeanExercise'))

setMethod('delete', '_p_EuropeanExercisePtr', function(obj) {delete_EuropeanExercisePtr(obj)})
# Start of new_AmericanExercise

`AmericanExercise__SWIG_0` = function(earliestDate, latestDate, payoffAtExpiry)
{
  payoffAtExpiry = as.logical(payoffAtExpiry);
  ;ans = .Call('R_swig_new_AmericanExercise__SWIG_0', earliestDate, latestDate, payoffAtExpiry, PACKAGE='QuantLib');
  class(ans) <- "_p_AmericanExercisePtr";
  
  reg.finalizer(ans, delete_AmericanExercise)
  ans
  
}

attr(`AmericanExercise__SWIG_0`, 'returnType') = '_p_AmericanExercisePtr'
attr(`AmericanExercise__SWIG_0`, "inputTypes") = c('_p_Date', '_p_Date', 'logical')
class(`AmericanExercise__SWIG_0`) = c("SWIGFunction", class('AmericanExercise__SWIG_0'))

# Start of new_AmericanExercise

`AmericanExercise__SWIG_1` = function(earliestDate, latestDate)
{
  ;ans = .Call('R_swig_new_AmericanExercise__SWIG_1', earliestDate, latestDate, PACKAGE='QuantLib');
  class(ans) <- "_p_AmericanExercisePtr";
  
  reg.finalizer(ans, delete_AmericanExercise)
  ans
  
}

attr(`AmericanExercise__SWIG_1`, 'returnType') = '_p_AmericanExercisePtr'
attr(`AmericanExercise__SWIG_1`, "inputTypes") = c('_p_Date', '_p_Date')
class(`AmericanExercise__SWIG_1`) = c("SWIGFunction", class('AmericanExercise__SWIG_1'))

`AmericanExercise` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_Date') && extends(argtypes[2], '_p_Date')) {
      f <- AmericanExercise__SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_Date') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], 'logical')) {
      f <- AmericanExercise__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for AmericanExercise with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_AmericanExercise

`delete_AmericanExercise` = function(self)
{
  ;.Call('R_swig_delete_AmericanExercise', self, PACKAGE='QuantLib');
  
}

attr(`delete_AmericanExercise`, 'returnType') = 'void'
attr(`delete_AmericanExercise`, "inputTypes") = c('_p_AmericanExercisePtr')
class(`delete_AmericanExercise`) = c("SWIGFunction", class('delete_AmericanExercise'))

setMethod('delete', '_p_AmericanExercisePtr', function(obj) {delete_AmericanExercisePtr(obj)})
# Start of new_BermudanExercise

`BermudanExercise__SWIG_0` = function(dates, payoffAtExpiry)
{
  payoffAtExpiry = as.logical(payoffAtExpiry);
  ;ans = .Call('R_swig_new_BermudanExercise__SWIG_0', dates, payoffAtExpiry, PACKAGE='QuantLib');
  class(ans) <- "_p_BermudanExercisePtr";
  
  reg.finalizer(ans, delete_BermudanExercise)
  ans
  
}

attr(`BermudanExercise__SWIG_0`, 'returnType') = '_p_BermudanExercisePtr'
attr(`BermudanExercise__SWIG_0`, "inputTypes") = c('_p_std__vectorT_Date_std__allocatorT_Date_t_t', 'logical')
class(`BermudanExercise__SWIG_0`) = c("SWIGFunction", class('BermudanExercise__SWIG_0'))

# Start of new_BermudanExercise

`BermudanExercise__SWIG_1` = function(dates)
{
  ;ans = .Call('R_swig_new_BermudanExercise__SWIG_1', dates, PACKAGE='QuantLib');
  class(ans) <- "_p_BermudanExercisePtr";
  
  reg.finalizer(ans, delete_BermudanExercise)
  ans
  
}

attr(`BermudanExercise__SWIG_1`, 'returnType') = '_p_BermudanExercisePtr'
attr(`BermudanExercise__SWIG_1`, "inputTypes") = c('_p_std__vectorT_Date_std__allocatorT_Date_t_t')
class(`BermudanExercise__SWIG_1`) = c("SWIGFunction", class('BermudanExercise__SWIG_1'))

`BermudanExercise` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_std__vectorT_Date_std__allocatorT_Date_t_t')) {
      f <- BermudanExercise__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_std__vectorT_Date_std__allocatorT_Date_t_t') && extends(argtypes[2], 'logical')) {
      f <- BermudanExercise__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for BermudanExercise with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_BermudanExercise

`delete_BermudanExercise` = function(self)
{
  ;.Call('R_swig_delete_BermudanExercise', self, PACKAGE='QuantLib');
  
}

attr(`delete_BermudanExercise`, 'returnType') = 'void'
attr(`delete_BermudanExercise`, "inputTypes") = c('_p_BermudanExercisePtr')
class(`delete_BermudanExercise`) = c("SWIGFunction", class('delete_BermudanExercise'))

setMethod('delete', '_p_BermudanExercisePtr', function(obj) {delete_BermudanExercisePtr(obj)})
# Start of Observable___deref__

`Observable___deref__` = function(self)
{
  ;ans = .Call('R_swig_Observable___deref__', self, PACKAGE='QuantLib');
  class(ans) <- "_p_Observable";
  
  ans
  
}

attr(`Observable___deref__`, 'returnType') = '_p_Observable'
attr(`Observable___deref__`, "inputTypes") = c('_p_boost__shared_ptrT_Observable_t')
class(`Observable___deref__`) = c("SWIGFunction", class('Observable___deref__'))

# Start of Observable_isNull

`Observable_isNull` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Observable_isNull', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Observable_isNull`, 'returnType') = 'logical'
attr(`Observable_isNull`, "inputTypes") = c('_p_boost__shared_ptrT_Observable_t')
class(`Observable_isNull`) = c("SWIGFunction", class('Observable_isNull'))

# Start of new_Observable

`Observable` = function()
{
  ;ans = .Call('R_swig_new_Observable', PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_Observable_t";
  
  reg.finalizer(ans, delete_Observable)
  ans
  
}

attr(`Observable`, 'returnType') = '_p_boost__shared_ptrT_Observable_t'
class(`Observable`) = c("SWIGFunction", class('Observable'))

# Start of delete_Observable

`delete_Observable` = function(self)
{
  ;.Call('R_swig_delete_Observable', self, PACKAGE='QuantLib');
  
}

attr(`delete_Observable`, 'returnType') = 'void'
attr(`delete_Observable`, "inputTypes") = c('_p_boost__shared_ptrT_Observable_t')
class(`delete_Observable`) = c("SWIGFunction", class('delete_Observable'))

# Start of accessor method for boost::shared_ptr<(Observable)>
setMethod('$', '_p_boost__shared_ptrT_Observable_t', function(x, name)

{
  accessorFuns = list('__deref__' = Observable___deref__, 'isNull' = Observable_isNull);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for boost::shared_ptr<(Observable)>
setMethod('delete', '_p_boost__shared_ptrT_Observable_t', function(obj) {delete_boost__shared_ptrT_Observable_t(obj)})

setMethod('print', '_p_Array',
function(x) print(as(x, "numeric")))

setAs("_p_Array", "numeric",
function(from) {if (from$size()) from[1:from$size()] else NULL} )

setAs("numeric", "_p_Array",
function(from) { a <- Array(length(from));
sapply(1:length(from), function(n) {
a[n] <- from[n] } )
a
})


setMethod('print', '_p_Matrix',
function(x) print(as.matrix(x)))

setMethod("as.matrix", "_p_Matrix",
function(x) matrix(data=as.numeric(x$dataVector),
        nrow=x$rows(), ncol=x$columns()))

setMethod("print", "_p_SampledCurve",
function(x) print(as.data.frame(x))
)

setMethod("as.data.frame", "_p_SampledCurve",
function(x,row.names,optional)
data.frame("grid"=as(x$grid(), "numeric"),
"values"=as(x$values(), "numeric")))

setMethod("plot", "_p_SampledCurve",
function(x,y) plot(as.data.frame(x)))


# Start of new_Array

`Array__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_Array__SWIG_0', PACKAGE='QuantLib');
  class(ans) <- "_p_Array";
  
  reg.finalizer(ans, delete_Array)
  ans
  
}

attr(`Array__SWIG_0`, 'returnType') = '_p_Array'
class(`Array__SWIG_0`) = c("SWIGFunction", class('Array__SWIG_0'))

# Start of new_Array

`Array__SWIG_1` = function(n, fill)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  
  ;ans = .Call('R_swig_new_Array__SWIG_1', n, fill, PACKAGE='QuantLib');
  class(ans) <- "_p_Array";
  
  reg.finalizer(ans, delete_Array)
  ans
  
}

attr(`Array__SWIG_1`, 'returnType') = '_p_Array'
attr(`Array__SWIG_1`, "inputTypes") = c('integer', 'numeric')
class(`Array__SWIG_1`) = c("SWIGFunction", class('Array__SWIG_1'))

# Start of new_Array

`Array__SWIG_2` = function(n)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;ans = .Call('R_swig_new_Array__SWIG_2', n, PACKAGE='QuantLib');
  class(ans) <- "_p_Array";
  
  reg.finalizer(ans, delete_Array)
  ans
  
}

attr(`Array__SWIG_2`, 'returnType') = '_p_Array'
attr(`Array__SWIG_2`, "inputTypes") = c('integer')
class(`Array__SWIG_2`) = c("SWIGFunction", class('Array__SWIG_2'))

# Start of new_Array

`Array__SWIG_3` = function(s_arg1)
{
  ;ans = .Call('R_swig_new_Array__SWIG_3', s_arg1, PACKAGE='QuantLib');
  class(ans) <- "_p_Array";
  
  reg.finalizer(ans, delete_Array)
  ans
  
}

attr(`Array__SWIG_3`, 'returnType') = '_p_Array'
attr(`Array__SWIG_3`, "inputTypes") = c('_p_Array')
class(`Array__SWIG_3`) = c("SWIGFunction", class('Array__SWIG_3'))

`Array` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- Array__SWIG_0; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_Array')) {
      f <- Array__SWIG_3; 
    }
    else if ((is.integer(argv[[1]]) || is.numeric(argv[[1]]))) {
      f <- Array__SWIG_2; 
    }
  } else if (argc == 2) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && is.numeric(argv[[2]])) {
      f <- Array__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for Array with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of Array_size

`Array_size` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_Array_size', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__size_t";
  
  ans
  
}

attr(`Array_size`, 'returnType') = 'integer'
attr(`Array_size`, "inputTypes") = c('_p_Array')
class(`Array_size`) = c("SWIGFunction", class('Array_size'))

# Start of Array___str__

`Array___str__` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Array___str__', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Array___str__`, 'returnType') = 'character'
attr(`Array___str__`, "inputTypes") = c('_p_Array')
class(`Array___str__`) = c("SWIGFunction", class('Array___str__'))

# Start of Array___add__

`Array___add__` = function(self, a, .copy = FALSE)
{
  ;ans = .Call('R_swig_Array___add__', self, a, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Array";
  
  ans
  
}

attr(`Array___add__`, 'returnType') = '_p_Array'
attr(`Array___add__`, "inputTypes") = c('_p_Array', '_p_Array')
class(`Array___add__`) = c("SWIGFunction", class('Array___add__'))

# Start of Array___sub__

`Array___sub__` = function(self, a, .copy = FALSE)
{
  ;ans = .Call('R_swig_Array___sub__', self, a, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Array";
  
  ans
  
}

attr(`Array___sub__`, 'returnType') = '_p_Array'
attr(`Array___sub__`, "inputTypes") = c('_p_Array', '_p_Array')
class(`Array___sub__`) = c("SWIGFunction", class('Array___sub__'))

# Start of Array___mul__

`Array___mul____SWIG_0` = function(self, a, .copy = FALSE)
{
  ;ans = .Call('R_swig_Array___mul____SWIG_0', self, a, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Array";
  
  ans
  
}

attr(`Array___mul____SWIG_0`, 'returnType') = '_p_Array'
attr(`Array___mul____SWIG_0`, "inputTypes") = c('_p_Array', 'numeric')
class(`Array___mul____SWIG_0`) = c("SWIGFunction", class('Array___mul____SWIG_0'))

# Start of Array___mul__

`Array___mul____SWIG_1` = function(self, a, .copy = FALSE)
{
  ;.Call('R_swig_Array___mul____SWIG_1', self, a, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Array___mul____SWIG_1`, 'returnType') = 'numeric'
attr(`Array___mul____SWIG_1`, "inputTypes") = c('_p_Array', '_p_Array')
class(`Array___mul____SWIG_1`) = c("SWIGFunction", class('Array___mul____SWIG_1'))

# Start of Array___mul__

`Array___mul____SWIG_2` = function(self, a, .copy = FALSE)
{
  ;ans = .Call('R_swig_Array___mul____SWIG_2', self, a, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Array";
  
  ans
  
}

attr(`Array___mul____SWIG_2`, 'returnType') = '_p_Array'
attr(`Array___mul____SWIG_2`, "inputTypes") = c('_p_Array', '_p_Matrix')
class(`Array___mul____SWIG_2`) = c("SWIGFunction", class('Array___mul____SWIG_2'))

`Array___mul__` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 2) {
    if (extends(argtypes[1], '_p_Array') && extends(argtypes[2], '_p_Array')) {
      f <- Array___mul____SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_Array') && extends(argtypes[2], '_p_Matrix')) {
      f <- Array___mul____SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_Array') && is.numeric(argv[[2]])) {
      f <- Array___mul____SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Array___mul__ with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of Array___div__

`Array___div__` = function(self, a, .copy = FALSE)
{
  ;ans = .Call('R_swig_Array___div__', self, a, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Array";
  
  ans
  
}

attr(`Array___div__`, 'returnType') = '_p_Array'
attr(`Array___div__`, "inputTypes") = c('_p_Array', 'numeric')
class(`Array___div__`) = c("SWIGFunction", class('Array___div__'))

# Start of Array___getitem__

`Array___getitem__` = function(self, i, .copy = FALSE)
{
  i = as.integer(i); 
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_Array___getitem__', self, i, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Array___getitem__`, 'returnType') = 'numeric'
attr(`Array___getitem__`, "inputTypes") = c('_p_Array', 'integer')
class(`Array___getitem__`) = c("SWIGFunction", class('Array___getitem__'))

# Start of Array___setitem__

`Array___setitem__` = function(self, i, x)
{
  i = as.integer(i); 
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  ;.Call('R_swig_Array___setitem__', self, i, x, PACKAGE='QuantLib');
  
}

attr(`Array___setitem__`, 'returnType') = 'void'
attr(`Array___setitem__`, "inputTypes") = c('_p_Array', 'integer', 'numeric')
class(`Array___setitem__`) = c("SWIGFunction", class('Array___setitem__'))

# Start of delete_Array

`delete_Array` = function(self)
{
  ;.Call('R_swig_delete_Array', self, PACKAGE='QuantLib');
  
}

attr(`delete_Array`, 'returnType') = 'void'
attr(`delete_Array`, "inputTypes") = c('_p_Array')
class(`delete_Array`) = c("SWIGFunction", class('delete_Array'))

# Start of accessor method for Array
setMethod('$', '_p_Array', function(x, name)

{
  accessorFuns = list('size' = Array_size, '__str__' = Array___str__, '__add__' = Array___add__, '__sub__' = Array___sub__, '__mul__' = Array___mul__, '__div__' = Array___div__, '__getitem__' = Array___getitem__, '__setitem__' = Array___setitem__);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for Array
setMethod('delete', '_p_Array', function(obj) {delete_Array(obj)})
# Start of DefaultLexicographicalViewColumn___getitem__

`DefaultLexicographicalViewColumn___getitem__` = function(self, i, .copy = FALSE)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_DefaultLexicographicalViewColumn___getitem__', self, i, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DefaultLexicographicalViewColumn___getitem__`, 'returnType') = 'numeric'
attr(`DefaultLexicographicalViewColumn___getitem__`, "inputTypes") = c('_p_DefaultLexicographicalViewColumn', 'integer')
class(`DefaultLexicographicalViewColumn___getitem__`) = c("SWIGFunction", class('DefaultLexicographicalViewColumn___getitem__'))

# Start of DefaultLexicographicalViewColumn___setitem__

`DefaultLexicographicalViewColumn___setitem__` = function(self, i, x)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  ;.Call('R_swig_DefaultLexicographicalViewColumn___setitem__', self, i, x, PACKAGE='QuantLib');
  
}

attr(`DefaultLexicographicalViewColumn___setitem__`, 'returnType') = 'void'
attr(`DefaultLexicographicalViewColumn___setitem__`, "inputTypes") = c('_p_DefaultLexicographicalViewColumn', 'integer', 'numeric')
class(`DefaultLexicographicalViewColumn___setitem__`) = c("SWIGFunction", class('DefaultLexicographicalViewColumn___setitem__'))

# Start of delete_DefaultLexicographicalViewColumn

`delete_DefaultLexicographicalViewColumn` = function(self)
{
  ;.Call('R_swig_delete_DefaultLexicographicalViewColumn', self, PACKAGE='QuantLib');
  
}

attr(`delete_DefaultLexicographicalViewColumn`, 'returnType') = 'void'
attr(`delete_DefaultLexicographicalViewColumn`, "inputTypes") = c('_p_DefaultLexicographicalViewColumn')
class(`delete_DefaultLexicographicalViewColumn`) = c("SWIGFunction", class('delete_DefaultLexicographicalViewColumn'))

# Start of accessor method for DefaultLexicographicalViewColumn
setMethod('$', '_p_DefaultLexicographicalViewColumn', function(x, name)

{
  accessorFuns = list('__getitem__' = DefaultLexicographicalViewColumn___getitem__, '__setitem__' = DefaultLexicographicalViewColumn___setitem__);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for DefaultLexicographicalViewColumn
setMethod('delete', '_p_DefaultLexicographicalViewColumn', function(obj) {delete_DefaultLexicographicalViewColumn(obj)})
# Start of LexicographicalView_xSize

`LexicographicalView_xSize` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_LexicographicalView_xSize', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__size_t";
  
  ans
  
}

attr(`LexicographicalView_xSize`, 'returnType') = 'integer'
attr(`LexicographicalView_xSize`, "inputTypes") = c('_p_DefaultLexicographicalView')
class(`LexicographicalView_xSize`) = c("SWIGFunction", class('LexicographicalView_xSize'))

# Start of LexicographicalView_ySize

`LexicographicalView_ySize` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_LexicographicalView_ySize', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__size_t";
  
  ans
  
}

attr(`LexicographicalView_ySize`, 'returnType') = 'integer'
attr(`LexicographicalView_ySize`, "inputTypes") = c('_p_DefaultLexicographicalView')
class(`LexicographicalView_ySize`) = c("SWIGFunction", class('LexicographicalView_ySize'))

# Start of new_LexicographicalView

`LexicographicalView` = function(a, xSize)
{
  if(length(xSize) > 1) {
    warning("using only the first element of xSize");
  };
  
  ;ans = .Call('R_swig_new_LexicographicalView', a, xSize, PACKAGE='QuantLib');
  class(ans) <- "_p_DefaultLexicographicalView";
  
  reg.finalizer(ans, delete_LexicographicalView)
  ans
  
}

attr(`LexicographicalView`, 'returnType') = '_p_DefaultLexicographicalView'
attr(`LexicographicalView`, "inputTypes") = c('_p_Array', 'integer')
class(`LexicographicalView`) = c("SWIGFunction", class('LexicographicalView'))

# Start of LexicographicalView___str__

`LexicographicalView___str__` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_LexicographicalView___str__', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`LexicographicalView___str__`, 'returnType') = 'character'
attr(`LexicographicalView___str__`, "inputTypes") = c('_p_DefaultLexicographicalView')
class(`LexicographicalView___str__`) = c("SWIGFunction", class('LexicographicalView___str__'))

# Start of LexicographicalView___getitem__

`LexicographicalView___getitem__` = function(self, i, .copy = FALSE)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;ans = .Call('R_swig_LexicographicalView___getitem__', self, i, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_DefaultLexicographicalViewColumn";
  
  ans
  
}

attr(`LexicographicalView___getitem__`, 'returnType') = '_p_DefaultLexicographicalViewColumn'
attr(`LexicographicalView___getitem__`, "inputTypes") = c('_p_DefaultLexicographicalView', 'integer')
class(`LexicographicalView___getitem__`) = c("SWIGFunction", class('LexicographicalView___getitem__'))

# Start of delete_LexicographicalView

`delete_LexicographicalView` = function(self)
{
  ;.Call('R_swig_delete_LexicographicalView', self, PACKAGE='QuantLib');
  
}

attr(`delete_LexicographicalView`, 'returnType') = 'void'
attr(`delete_LexicographicalView`, "inputTypes") = c('_p_DefaultLexicographicalView')
class(`delete_LexicographicalView`) = c("SWIGFunction", class('delete_LexicographicalView'))

# Start of accessor method for DefaultLexicographicalView
setMethod('$', '_p_DefaultLexicographicalView', function(x, name)

{
  accessorFuns = list('xSize' = LexicographicalView_xSize, 'ySize' = LexicographicalView_ySize, '__str__' = LexicographicalView___str__, '__getitem__' = LexicographicalView___getitem__);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for DefaultLexicographicalView
setMethod('delete', '_p_DefaultLexicographicalView', function(obj) {delete_DefaultLexicographicalView(obj)})
# Start of new_Matrix

`Matrix__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_Matrix__SWIG_0', PACKAGE='QuantLib');
  class(ans) <- "_p_Matrix";
  
  reg.finalizer(ans, delete_Matrix)
  ans
  
}

attr(`Matrix__SWIG_0`, 'returnType') = '_p_Matrix'
class(`Matrix__SWIG_0`) = c("SWIGFunction", class('Matrix__SWIG_0'))

# Start of new_Matrix

`Matrix__SWIG_1` = function(rows, columns, fill)
{
  if(length(rows) > 1) {
    warning("using only the first element of rows");
  };
  
  
  
  if(length(columns) > 1) {
    warning("using only the first element of columns");
  };
  
  
  ;ans = .Call('R_swig_new_Matrix__SWIG_1', rows, columns, fill, PACKAGE='QuantLib');
  class(ans) <- "_p_Matrix";
  
  reg.finalizer(ans, delete_Matrix)
  ans
  
}

attr(`Matrix__SWIG_1`, 'returnType') = '_p_Matrix'
attr(`Matrix__SWIG_1`, "inputTypes") = c('integer', 'integer', 'numeric')
class(`Matrix__SWIG_1`) = c("SWIGFunction", class('Matrix__SWIG_1'))

# Start of new_Matrix

`Matrix__SWIG_2` = function(rows, columns)
{
  if(length(rows) > 1) {
    warning("using only the first element of rows");
  };
  
  
  
  if(length(columns) > 1) {
    warning("using only the first element of columns");
  };
  
  ;ans = .Call('R_swig_new_Matrix__SWIG_2', rows, columns, PACKAGE='QuantLib');
  class(ans) <- "_p_Matrix";
  
  reg.finalizer(ans, delete_Matrix)
  ans
  
}

attr(`Matrix__SWIG_2`, 'returnType') = '_p_Matrix'
attr(`Matrix__SWIG_2`, "inputTypes") = c('integer', 'integer')
class(`Matrix__SWIG_2`) = c("SWIGFunction", class('Matrix__SWIG_2'))

# Start of new_Matrix

`Matrix__SWIG_3` = function(s_arg1)
{
  ;ans = .Call('R_swig_new_Matrix__SWIG_3', s_arg1, PACKAGE='QuantLib');
  class(ans) <- "_p_Matrix";
  
  reg.finalizer(ans, delete_Matrix)
  ans
  
}

attr(`Matrix__SWIG_3`, 'returnType') = '_p_Matrix'
attr(`Matrix__SWIG_3`, "inputTypes") = c('_p_Matrix')
class(`Matrix__SWIG_3`) = c("SWIGFunction", class('Matrix__SWIG_3'))

`Matrix` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- Matrix__SWIG_0; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_Matrix')) {
      f <- Matrix__SWIG_3; 
    }
  } else if (argc == 2) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && (is.integer(argv[[2]]) || is.numeric(argv[[2]]))) {
      f <- Matrix__SWIG_2; 
    }
  } else if (argc == 3) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && is.numeric(argv[[3]])) {
      f <- Matrix__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for Matrix with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of Matrix_rows

`Matrix_rows` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_Matrix_rows', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__size_t";
  
  ans
  
}

attr(`Matrix_rows`, 'returnType') = 'integer'
attr(`Matrix_rows`, "inputTypes") = c('_p_Matrix')
class(`Matrix_rows`) = c("SWIGFunction", class('Matrix_rows'))

# Start of Matrix_columns

`Matrix_columns` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_Matrix_columns', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__size_t";
  
  ans
  
}

attr(`Matrix_columns`, 'returnType') = 'integer'
attr(`Matrix_columns`, "inputTypes") = c('_p_Matrix')
class(`Matrix_columns`) = c("SWIGFunction", class('Matrix_columns'))

# Start of Matrix___str__

`Matrix___str__` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Matrix___str__', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Matrix___str__`, 'returnType') = 'character'
attr(`Matrix___str__`, "inputTypes") = c('_p_Matrix')
class(`Matrix___str__`) = c("SWIGFunction", class('Matrix___str__'))

# Start of Matrix_ref

`Matrix_ref` = function(self, i, j, .copy = FALSE)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_Matrix_ref', self, i, j, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Matrix_ref`, 'returnType') = 'numeric'
attr(`Matrix_ref`, "inputTypes") = c('_p_Matrix', 'integer', 'integer')
class(`Matrix_ref`) = c("SWIGFunction", class('Matrix_ref'))

# Start of Matrix_setitem

`Matrix_setitem` = function(self, i, j, x)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  
  ;.Call('R_swig_Matrix_setitem', self, i, j, x, PACKAGE='QuantLib');
  
}

attr(`Matrix_setitem`, 'returnType') = 'void'
attr(`Matrix_setitem`, "inputTypes") = c('_p_Matrix', 'integer', 'integer', 'numeric')
class(`Matrix_setitem`) = c("SWIGFunction", class('Matrix_setitem'))

# Start of Matrix_dataVector

`Matrix_dataVector` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_Matrix_dataVector', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Array";
  
  ans
  
}

attr(`Matrix_dataVector`, 'returnType') = '_p_Array'
attr(`Matrix_dataVector`, "inputTypes") = c('_p_Matrix')
class(`Matrix_dataVector`) = c("SWIGFunction", class('Matrix_dataVector'))

# Start of delete_Matrix

`delete_Matrix` = function(self)
{
  ;.Call('R_swig_delete_Matrix', self, PACKAGE='QuantLib');
  
}

attr(`delete_Matrix`, 'returnType') = 'void'
attr(`delete_Matrix`, "inputTypes") = c('_p_Matrix')
class(`delete_Matrix`) = c("SWIGFunction", class('delete_Matrix'))

# Start of accessor method for Matrix
setMethod('$', '_p_Matrix', function(x, name)

{
  accessorFuns = list('rows' = Matrix_rows, 'columns' = Matrix_columns, '__str__' = Matrix___str__, 'ref' = Matrix_ref, 'setitem' = Matrix_setitem, 'dataVector' = Matrix_dataVector);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for Matrix
setMethod('delete', '_p_Matrix', function(obj) {delete_Matrix(obj)})
defineEnumeration('_SalvagingAlgorithm__Type',
                    .values = c(
                        'None' = 0, 
                        'Spectral' = 1
))
# Start of new_SalvagingAlgorithm

`SalvagingAlgorithm` = function()
{
  ;ans = .Call('R_swig_new_SalvagingAlgorithm', PACKAGE='QuantLib');
  class(ans) <- "_p_SalvagingAlgorithm";
  
  reg.finalizer(ans, delete_SalvagingAlgorithm)
  ans
  
}

attr(`SalvagingAlgorithm`, 'returnType') = '_p_SalvagingAlgorithm'
class(`SalvagingAlgorithm`) = c("SWIGFunction", class('SalvagingAlgorithm'))

# Start of delete_SalvagingAlgorithm

`delete_SalvagingAlgorithm` = function(self)
{
  ;.Call('R_swig_delete_SalvagingAlgorithm', self, PACKAGE='QuantLib');
  
}

attr(`delete_SalvagingAlgorithm`, 'returnType') = 'void'
attr(`delete_SalvagingAlgorithm`, "inputTypes") = c('_p_SalvagingAlgorithm')
class(`delete_SalvagingAlgorithm`) = c("SWIGFunction", class('delete_SalvagingAlgorithm'))

setMethod('delete', '_p_SalvagingAlgorithm', function(obj) {delete_SalvagingAlgorithm(obj)})
# Start definition of copy functions & methods for SalvagingAlgorithm
CopyToR_SalvagingAlgorithm = function(value, obj = new("SalvagingAlgorithm"))
{
  obj;
}



CopyToC_SalvagingAlgorithm = function(value, obj)
{
  obj
}



# Start definition of copy methods for SalvagingAlgorithm
setMethod('copyToR', '_p_SalvagingAlgorithm', CopyToR_SalvagingAlgorithm);
setMethod('copyToC', 'SalvagingAlgorithm', CopyToC_SalvagingAlgorithm);

# End definition of copy methods for SalvagingAlgorithm
# End definition of copy functions & methods for SalvagingAlgorithm
# Start of transpose

`transpose` = function(m, .copy = FALSE)
{
  ;ans = .Call('R_swig_transpose', m, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Matrix";
  
  ans
  
}

attr(`transpose`, 'returnType') = '_p_Matrix'
attr(`transpose`, "inputTypes") = c('_p_Matrix')
class(`transpose`) = c("SWIGFunction", class('transpose'))

# Start of outerProduct

`outerProduct` = function(v1, v2, .copy = FALSE)
{
  ;ans = .Call('R_swig_outerProduct', v1, v2, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Matrix";
  
  ans
  
}

attr(`outerProduct`, 'returnType') = '_p_Matrix'
attr(`outerProduct`, "inputTypes") = c('_p_Array', '_p_Array')
class(`outerProduct`) = c("SWIGFunction", class('outerProduct'))

# Start of pseudoSqrt

`pseudoSqrt` = function(m, a, .copy = FALSE)
{
  a = enumToInteger(a, "_SalvagingAlgorithm__Type"); 
  
  if(length(a) > 1) {
    warning("using only the first element of a");
  };
  
  ;ans = .Call('R_swig_pseudoSqrt', m, a, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Matrix";
  
  ans
  
}

attr(`pseudoSqrt`, 'returnType') = '_p_Matrix'
attr(`pseudoSqrt`, "inputTypes") = c('_p_Matrix', 'character')
class(`pseudoSqrt`) = c("SWIGFunction", class('pseudoSqrt'))

# Start of new_SVD

`SVD` = function(s_arg1)
{
  ;ans = .Call('R_swig_new_SVD', s_arg1, PACKAGE='QuantLib');
  class(ans) <- "_p_SVD";
  
  reg.finalizer(ans, delete_SVD)
  ans
  
}

attr(`SVD`, 'returnType') = '_p_SVD'
attr(`SVD`, "inputTypes") = c('_p_Matrix')
class(`SVD`) = c("SWIGFunction", class('SVD'))

# Start of SVD_U

`SVD_U` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_SVD_U', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Matrix";
  
  ans
  
}

attr(`SVD_U`, 'returnType') = '_p_Matrix'
attr(`SVD_U`, "inputTypes") = c('_p_SVD')
class(`SVD_U`) = c("SWIGFunction", class('SVD_U'))

# Start of SVD_V

`SVD_V` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_SVD_V', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Matrix";
  
  ans
  
}

attr(`SVD_V`, 'returnType') = '_p_Matrix'
attr(`SVD_V`, "inputTypes") = c('_p_SVD')
class(`SVD_V`) = c("SWIGFunction", class('SVD_V'))

# Start of SVD_S

`SVD_S` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_SVD_S', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Matrix";
  
  ans
  
}

attr(`SVD_S`, 'returnType') = '_p_Matrix'
attr(`SVD_S`, "inputTypes") = c('_p_SVD')
class(`SVD_S`) = c("SWIGFunction", class('SVD_S'))

# Start of SVD_singularValues

`SVD_singularValues` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_SVD_singularValues', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Array";
  
  ans
  
}

attr(`SVD_singularValues`, 'returnType') = '_p_Array'
attr(`SVD_singularValues`, "inputTypes") = c('_p_SVD')
class(`SVD_singularValues`) = c("SWIGFunction", class('SVD_singularValues'))

# Start of delete_SVD

`delete_SVD` = function(self)
{
  ;.Call('R_swig_delete_SVD', self, PACKAGE='QuantLib');
  
}

attr(`delete_SVD`, 'returnType') = 'void'
attr(`delete_SVD`, "inputTypes") = c('_p_SVD')
class(`delete_SVD`) = c("SWIGFunction", class('delete_SVD'))

# Start of accessor method for SVD
setMethod('$', '_p_SVD', function(x, name)

{
  accessorFuns = list('U' = SVD_U, 'V' = SVD_V, 'S' = SVD_S, 'singularValues' = SVD_singularValues);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for SVD
setMethod('delete', '_p_SVD', function(obj) {delete_SVD(obj)})
# Start of Quote___deref__

`Quote___deref__` = function(self)
{
  ;ans = .Call('R_swig_Quote___deref__', self, PACKAGE='QuantLib');
  class(ans) <- "_p_Quote";
  
  ans
  
}

attr(`Quote___deref__`, 'returnType') = '_p_Quote'
attr(`Quote___deref__`, "inputTypes") = c('_p_boost__shared_ptrT_Quote_t')
class(`Quote___deref__`) = c("SWIGFunction", class('Quote___deref__'))

# Start of Quote_isNull

`Quote_isNull` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Quote_isNull', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Quote_isNull`, 'returnType') = 'logical'
attr(`Quote_isNull`, "inputTypes") = c('_p_boost__shared_ptrT_Quote_t')
class(`Quote_isNull`) = c("SWIGFunction", class('Quote_isNull'))

# Start of Quote_asObservable

`Quote_asObservable` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_Quote_asObservable', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_Observable_t";
  
  ans
  
}

attr(`Quote_asObservable`, 'returnType') = '_p_boost__shared_ptrT_Observable_t'
attr(`Quote_asObservable`, "inputTypes") = c('_p_boost__shared_ptrT_Quote_t')
class(`Quote_asObservable`) = c("SWIGFunction", class('Quote_asObservable'))

# Start of new_Quote

`Quote` = function()
{
  ;ans = .Call('R_swig_new_Quote', PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_Quote_t";
  
  reg.finalizer(ans, delete_Quote)
  ans
  
}

attr(`Quote`, 'returnType') = '_p_boost__shared_ptrT_Quote_t'
class(`Quote`) = c("SWIGFunction", class('Quote'))

# Start of delete_Quote

`delete_Quote` = function(self)
{
  ;.Call('R_swig_delete_Quote', self, PACKAGE='QuantLib');
  
}

attr(`delete_Quote`, 'returnType') = 'void'
attr(`delete_Quote`, "inputTypes") = c('_p_boost__shared_ptrT_Quote_t')
class(`delete_Quote`) = c("SWIGFunction", class('delete_Quote'))

# Start of Quote_value

`Quote_value` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Quote_value', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Quote_value`, 'returnType') = 'numeric'
attr(`Quote_value`, "inputTypes") = c('_p_boost__shared_ptrT_Quote_t')
class(`Quote_value`) = c("SWIGFunction", class('Quote_value'))

# Start of accessor method for boost::shared_ptr<(Quote)>
setMethod('$', '_p_boost__shared_ptrT_Quote_t', function(x, name)

{
  accessorFuns = list('__deref__' = Quote___deref__, 'isNull' = Quote_isNull, 'asObservable' = Quote_asObservable, 'value' = Quote_value);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for boost::shared_ptr<(Quote)>
setMethod('delete', '_p_boost__shared_ptrT_Quote_t', function(obj) {delete_boost__shared_ptrT_Quote_t(obj)})
# Start of new_QuoteHandle

`QuoteHandle__SWIG_0` = function(s_arg1)
{
  ;ans = .Call('R_swig_new_QuoteHandle__SWIG_0', s_arg1, PACKAGE='QuantLib');
  class(ans) <- "_p_HandleT_Quote_t";
  
  reg.finalizer(ans, delete_QuoteHandle)
  ans
  
}

attr(`QuoteHandle__SWIG_0`, 'returnType') = '_p_HandleT_Quote_t'
attr(`QuoteHandle__SWIG_0`, "inputTypes") = c('_p_boost__shared_ptrT_Quote_t')
class(`QuoteHandle__SWIG_0`) = c("SWIGFunction", class('QuoteHandle__SWIG_0'))

# Start of new_QuoteHandle

`QuoteHandle__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_QuoteHandle__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_HandleT_Quote_t";
  
  reg.finalizer(ans, delete_QuoteHandle)
  ans
  
}

attr(`QuoteHandle__SWIG_1`, 'returnType') = '_p_HandleT_Quote_t'
class(`QuoteHandle__SWIG_1`) = c("SWIGFunction", class('QuoteHandle__SWIG_1'))

`QuoteHandle` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- QuoteHandle__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_Quote_t')) {
      f <- QuoteHandle__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for QuoteHandle with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of QuoteHandle___deref__

`QuoteHandle___deref__` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_QuoteHandle___deref__', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_Quote_t";
  
  ans
  
}

attr(`QuoteHandle___deref__`, 'returnType') = '_p_boost__shared_ptrT_Quote_t'
attr(`QuoteHandle___deref__`, "inputTypes") = c('_p_HandleT_Quote_t')
class(`QuoteHandle___deref__`) = c("SWIGFunction", class('QuoteHandle___deref__'))

# Start of QuoteHandle_empty

`QuoteHandle_empty` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_QuoteHandle_empty', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`QuoteHandle_empty`, 'returnType') = 'logical'
attr(`QuoteHandle_empty`, "inputTypes") = c('_p_HandleT_Quote_t')
class(`QuoteHandle_empty`) = c("SWIGFunction", class('QuoteHandle_empty'))

# Start of QuoteHandle_asObservable

`QuoteHandle_asObservable` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_QuoteHandle_asObservable', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_Observable_t";
  
  ans
  
}

attr(`QuoteHandle_asObservable`, 'returnType') = '_p_boost__shared_ptrT_Observable_t'
attr(`QuoteHandle_asObservable`, "inputTypes") = c('_p_HandleT_Quote_t')
class(`QuoteHandle_asObservable`) = c("SWIGFunction", class('QuoteHandle_asObservable'))

# Start of delete_QuoteHandle

`delete_QuoteHandle` = function(self)
{
  ;.Call('R_swig_delete_QuoteHandle', self, PACKAGE='QuantLib');
  
}

attr(`delete_QuoteHandle`, 'returnType') = 'void'
attr(`delete_QuoteHandle`, "inputTypes") = c('_p_HandleT_Quote_t')
class(`delete_QuoteHandle`) = c("SWIGFunction", class('delete_QuoteHandle'))

# Start of QuoteHandle_value

`QuoteHandle_value` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_QuoteHandle_value', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`QuoteHandle_value`, 'returnType') = 'numeric'
attr(`QuoteHandle_value`, "inputTypes") = c('_p_HandleT_Quote_t')
class(`QuoteHandle_value`) = c("SWIGFunction", class('QuoteHandle_value'))

# Start of accessor method for Handle<(Quote)>
setMethod('$', '_p_HandleT_Quote_t', function(x, name)

{
  accessorFuns = list('__deref__' = QuoteHandle___deref__, 'empty' = QuoteHandle_empty, 'asObservable' = QuoteHandle_asObservable, 'value' = QuoteHandle_value);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for Handle<(Quote)>
setMethod('delete', '_p_HandleT_Quote_t', function(obj) {delete_HandleT_Quote_t(obj)})
# Start of new_RelinkableQuoteHandle

`RelinkableQuoteHandle__SWIG_0` = function(s_arg1)
{
  ;ans = .Call('R_swig_new_RelinkableQuoteHandle__SWIG_0', s_arg1, PACKAGE='QuantLib');
  class(ans) <- "_p_RelinkableHandleT_Quote_t";
  
  reg.finalizer(ans, delete_RelinkableQuoteHandle)
  ans
  
}

attr(`RelinkableQuoteHandle__SWIG_0`, 'returnType') = '_p_RelinkableHandleT_Quote_t'
attr(`RelinkableQuoteHandle__SWIG_0`, "inputTypes") = c('_p_boost__shared_ptrT_Quote_t')
class(`RelinkableQuoteHandle__SWIG_0`) = c("SWIGFunction", class('RelinkableQuoteHandle__SWIG_0'))

# Start of new_RelinkableQuoteHandle

`RelinkableQuoteHandle__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_RelinkableQuoteHandle__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_RelinkableHandleT_Quote_t";
  
  reg.finalizer(ans, delete_RelinkableQuoteHandle)
  ans
  
}

attr(`RelinkableQuoteHandle__SWIG_1`, 'returnType') = '_p_RelinkableHandleT_Quote_t'
class(`RelinkableQuoteHandle__SWIG_1`) = c("SWIGFunction", class('RelinkableQuoteHandle__SWIG_1'))

`RelinkableQuoteHandle` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- RelinkableQuoteHandle__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_Quote_t')) {
      f <- RelinkableQuoteHandle__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for RelinkableQuoteHandle with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of RelinkableQuoteHandle_linkTo

`RelinkableQuoteHandle_linkTo` = function(self, s_arg2)
{
  ;.Call('R_swig_RelinkableQuoteHandle_linkTo', self, s_arg2, PACKAGE='QuantLib');
  
}

attr(`RelinkableQuoteHandle_linkTo`, 'returnType') = 'void'
attr(`RelinkableQuoteHandle_linkTo`, "inputTypes") = c('_p_RelinkableHandleT_Quote_t', '_p_boost__shared_ptrT_Quote_t')
class(`RelinkableQuoteHandle_linkTo`) = c("SWIGFunction", class('RelinkableQuoteHandle_linkTo'))

# Start of delete_RelinkableQuoteHandle

`delete_RelinkableQuoteHandle` = function(self)
{
  ;.Call('R_swig_delete_RelinkableQuoteHandle', self, PACKAGE='QuantLib');
  
}

attr(`delete_RelinkableQuoteHandle`, 'returnType') = 'void'
attr(`delete_RelinkableQuoteHandle`, "inputTypes") = c('_p_RelinkableHandleT_Quote_t')
class(`delete_RelinkableQuoteHandle`) = c("SWIGFunction", class('delete_RelinkableQuoteHandle'))

# Start of accessor method for RelinkableHandle<(Quote)>
setMethod('$', '_p_RelinkableHandleT_Quote_t', function(x, name)

{
  accessorFuns = list('linkTo' = RelinkableQuoteHandle_linkTo);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for RelinkableHandle<(Quote)>
setMethod('delete', '_p_RelinkableHandleT_Quote_t', function(obj) {delete_RelinkableHandleT_Quote_t(obj)})
# Start of new_SimpleQuote

`SimpleQuote` = function(value)
{
  ;ans = .Call('R_swig_new_SimpleQuote', value, PACKAGE='QuantLib');
  class(ans) <- "_p_SimpleQuotePtr";
  
  reg.finalizer(ans, delete_SimpleQuote)
  ans
  
}

attr(`SimpleQuote`, 'returnType') = '_p_SimpleQuotePtr'
attr(`SimpleQuote`, "inputTypes") = c('numeric')
class(`SimpleQuote`) = c("SWIGFunction", class('SimpleQuote'))

# Start of SimpleQuote_setValue

`SimpleQuote_setValue` = function(self, value)
{
  ;.Call('R_swig_SimpleQuote_setValue', self, value, PACKAGE='QuantLib');
  
}

attr(`SimpleQuote_setValue`, 'returnType') = 'void'
attr(`SimpleQuote_setValue`, "inputTypes") = c('_p_SimpleQuotePtr', 'numeric')
class(`SimpleQuote_setValue`) = c("SWIGFunction", class('SimpleQuote_setValue'))

# Start of delete_SimpleQuote

`delete_SimpleQuote` = function(self)
{
  ;.Call('R_swig_delete_SimpleQuote', self, PACKAGE='QuantLib');
  
}

attr(`delete_SimpleQuote`, 'returnType') = 'void'
attr(`delete_SimpleQuote`, "inputTypes") = c('_p_SimpleQuotePtr')
class(`delete_SimpleQuote`) = c("SWIGFunction", class('delete_SimpleQuote'))

# Start of accessor method for SimpleQuotePtr
setMethod('$', '_p_SimpleQuotePtr', function(x, name)

{
  accessorFuns = list('setValue' = SimpleQuote_setValue);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for SimpleQuotePtr
setMethod('delete', '_p_SimpleQuotePtr', function(obj) {delete_SimpleQuotePtr(obj)})
# Start of QuoteVector___nonzero__

`QuoteVector___nonzero__` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_QuoteVector___nonzero__', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`QuoteVector___nonzero__`, 'returnType') = 'logical'
attr(`QuoteVector___nonzero__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t')
class(`QuoteVector___nonzero__`) = c("SWIGFunction", class('QuoteVector___nonzero__'))

# Start of QuoteVector___len__

`QuoteVector___len__` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_QuoteVector___len__', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`QuoteVector___len__`, 'returnType') = 'integer'
attr(`QuoteVector___len__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t')
class(`QuoteVector___len__`) = c("SWIGFunction", class('QuoteVector___len__'))

# Start of QuoteVector_pop

`QuoteVector_pop` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_QuoteVector_pop', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_Quote_t";
  
  ans
  
}

attr(`QuoteVector_pop`, 'returnType') = '_p_boost__shared_ptrT_Quote_t'
attr(`QuoteVector_pop`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t')
class(`QuoteVector_pop`) = c("SWIGFunction", class('QuoteVector_pop'))

# Start of QuoteVector___getslice__

`QuoteVector___getslice__` = function(self, i, j)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;ans = .Call('R_swig_QuoteVector___getslice__', self, i, j, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t";
  
  ans
  
}

attr(`QuoteVector___getslice__`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t'
attr(`QuoteVector___getslice__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t', 'integer', 'integer')
class(`QuoteVector___getslice__`) = c("SWIGFunction", class('QuoteVector___getslice__'))

# Start of QuoteVector___setslice__

`QuoteVector___setslice__` = function(self, i, j, v)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  
  ;.Call('R_swig_QuoteVector___setslice__', self, i, j, v, PACKAGE='QuantLib');
  
}

attr(`QuoteVector___setslice__`, 'returnType') = 'void'
attr(`QuoteVector___setslice__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t', 'integer', 'integer', '_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t')
class(`QuoteVector___setslice__`) = c("SWIGFunction", class('QuoteVector___setslice__'))

# Start of QuoteVector___delslice__

`QuoteVector___delslice__` = function(self, i, j)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_QuoteVector___delslice__', self, i, j, PACKAGE='QuantLib');
  
}

attr(`QuoteVector___delslice__`, 'returnType') = 'void'
attr(`QuoteVector___delslice__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t', 'integer', 'integer')
class(`QuoteVector___delslice__`) = c("SWIGFunction", class('QuoteVector___delslice__'))

# Start of QuoteVector___delitem__

`QuoteVector___delitem__` = function(self, i)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_QuoteVector___delitem__', self, i, PACKAGE='QuantLib');
  
}

attr(`QuoteVector___delitem__`, 'returnType') = 'void'
attr(`QuoteVector___delitem__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t', 'integer')
class(`QuoteVector___delitem__`) = c("SWIGFunction", class('QuoteVector___delitem__'))

# Start of QuoteVector___getitem__

`QuoteVector___getitem__` = function(self, i, .copy = FALSE)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;ans = .Call('R_swig_QuoteVector___getitem__', self, i, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_Quote_t";
  
  ans
  
}

attr(`QuoteVector___getitem__`, 'returnType') = '_p_boost__shared_ptrT_Quote_t'
attr(`QuoteVector___getitem__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t', 'integer')
class(`QuoteVector___getitem__`) = c("SWIGFunction", class('QuoteVector___getitem__'))

# Start of QuoteVector___setitem__

`QuoteVector___setitem__` = function(self, i, x)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  ;.Call('R_swig_QuoteVector___setitem__', self, i, x, PACKAGE='QuantLib');
  
}

attr(`QuoteVector___setitem__`, 'returnType') = 'void'
attr(`QuoteVector___setitem__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t', 'integer', '_p_boost__shared_ptrT_Quote_t')
class(`QuoteVector___setitem__`) = c("SWIGFunction", class('QuoteVector___setitem__'))

# Start of QuoteVector_append

`QuoteVector_append` = function(self, x)
{
  ;.Call('R_swig_QuoteVector_append', self, x, PACKAGE='QuantLib');
  
}

attr(`QuoteVector_append`, 'returnType') = 'void'
attr(`QuoteVector_append`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t', '_p_boost__shared_ptrT_Quote_t')
class(`QuoteVector_append`) = c("SWIGFunction", class('QuoteVector_append'))

# Start of new_QuoteVector

`QuoteVector__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_QuoteVector__SWIG_0', PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t";
  
  reg.finalizer(ans, delete_QuoteVector)
  ans
  
}

attr(`QuoteVector__SWIG_0`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t'
class(`QuoteVector__SWIG_0`) = c("SWIGFunction", class('QuoteVector__SWIG_0'))

# Start of new_QuoteVector

`QuoteVector__SWIG_1` = function(s_arg1)
{
  ;ans = .Call('R_swig_new_QuoteVector__SWIG_1', s_arg1, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t";
  
  reg.finalizer(ans, delete_QuoteVector)
  ans
  
}

attr(`QuoteVector__SWIG_1`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t'
attr(`QuoteVector__SWIG_1`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t')
class(`QuoteVector__SWIG_1`) = c("SWIGFunction", class('QuoteVector__SWIG_1'))

# Start of QuoteVector_empty

`QuoteVector_empty` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_QuoteVector_empty', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`QuoteVector_empty`, 'returnType') = 'logical'
attr(`QuoteVector_empty`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t')
class(`QuoteVector_empty`) = c("SWIGFunction", class('QuoteVector_empty'))

# Start of QuoteVector_size

`QuoteVector_size` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_QuoteVector_size', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`QuoteVector_size`, 'returnType') = 'integer'
attr(`QuoteVector_size`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t')
class(`QuoteVector_size`) = c("SWIGFunction", class('QuoteVector_size'))

# Start of QuoteVector_clear

`QuoteVector_clear` = function(self)
{
  ;.Call('R_swig_QuoteVector_clear', self, PACKAGE='QuantLib');
  
}

attr(`QuoteVector_clear`, 'returnType') = 'void'
attr(`QuoteVector_clear`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t')
class(`QuoteVector_clear`) = c("SWIGFunction", class('QuoteVector_clear'))

# Start of QuoteVector_swap

`QuoteVector_swap` = function(self, v)
{
  ;.Call('R_swig_QuoteVector_swap', self, v, PACKAGE='QuantLib');
  
}

attr(`QuoteVector_swap`, 'returnType') = 'void'
attr(`QuoteVector_swap`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t', '_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t')
class(`QuoteVector_swap`) = c("SWIGFunction", class('QuoteVector_swap'))

# Start of QuoteVector_get_allocator

`QuoteVector_get_allocator` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_QuoteVector_get_allocator', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__allocatorT_boost__shared_ptrT_Quote_t_t";
  
  ans
  
}

attr(`QuoteVector_get_allocator`, 'returnType') = '_p_std__allocatorT_boost__shared_ptrT_Quote_t_t'
attr(`QuoteVector_get_allocator`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t')
class(`QuoteVector_get_allocator`) = c("SWIGFunction", class('QuoteVector_get_allocator'))

# Start of new_QuoteVector

`QuoteVector__SWIG_2` = function(size)
{
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_new_QuoteVector__SWIG_2', size, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t";
  
  reg.finalizer(ans, delete_QuoteVector)
  ans
  
}

attr(`QuoteVector__SWIG_2`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t'
attr(`QuoteVector__SWIG_2`, "inputTypes") = c('integer')
class(`QuoteVector__SWIG_2`) = c("SWIGFunction", class('QuoteVector__SWIG_2'))

# Start of QuoteVector_pop_back

`QuoteVector_pop_back` = function(self)
{
  ;.Call('R_swig_QuoteVector_pop_back', self, PACKAGE='QuantLib');
  
}

attr(`QuoteVector_pop_back`, 'returnType') = 'void'
attr(`QuoteVector_pop_back`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t')
class(`QuoteVector_pop_back`) = c("SWIGFunction", class('QuoteVector_pop_back'))

# Start of QuoteVector_resize

`QuoteVector_resize__SWIG_0` = function(self, new_size)
{
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_QuoteVector_resize__SWIG_0', self, new_size, PACKAGE='QuantLib');
  
}

attr(`QuoteVector_resize__SWIG_0`, 'returnType') = 'void'
attr(`QuoteVector_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t', 'integer')
class(`QuoteVector_resize__SWIG_0`) = c("SWIGFunction", class('QuoteVector_resize__SWIG_0'))

# Start of new_QuoteVector

`QuoteVector__SWIG_3` = function(size, value)
{
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  
  ;ans = .Call('R_swig_new_QuoteVector__SWIG_3', size, value, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t";
  
  reg.finalizer(ans, delete_QuoteVector)
  ans
  
}

attr(`QuoteVector__SWIG_3`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t'
attr(`QuoteVector__SWIG_3`, "inputTypes") = c('integer', '_p_boost__shared_ptrT_Quote_t')
class(`QuoteVector__SWIG_3`) = c("SWIGFunction", class('QuoteVector__SWIG_3'))

`QuoteVector` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- QuoteVector__SWIG_0; 
  } else if (argc == 1) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]]))) {
      f <- QuoteVector__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t')) {
      f <- QuoteVector__SWIG_1; 
    }
  } else if (argc == 2) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && extends(argtypes[2], '_p_boost__shared_ptrT_Quote_t')) {
      f <- QuoteVector__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for QuoteVector with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of QuoteVector_push_back

`QuoteVector_push_back` = function(self, x)
{
  ;.Call('R_swig_QuoteVector_push_back', self, x, PACKAGE='QuantLib');
  
}

attr(`QuoteVector_push_back`, 'returnType') = 'void'
attr(`QuoteVector_push_back`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t', '_p_boost__shared_ptrT_Quote_t')
class(`QuoteVector_push_back`) = c("SWIGFunction", class('QuoteVector_push_back'))

# Start of QuoteVector_front

`QuoteVector_front` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_QuoteVector_front', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_Quote_t";
  
  ans
  
}

attr(`QuoteVector_front`, 'returnType') = '_p_boost__shared_ptrT_Quote_t'
attr(`QuoteVector_front`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t')
class(`QuoteVector_front`) = c("SWIGFunction", class('QuoteVector_front'))

# Start of QuoteVector_back

`QuoteVector_back` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_QuoteVector_back', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_Quote_t";
  
  ans
  
}

attr(`QuoteVector_back`, 'returnType') = '_p_boost__shared_ptrT_Quote_t'
attr(`QuoteVector_back`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t')
class(`QuoteVector_back`) = c("SWIGFunction", class('QuoteVector_back'))

# Start of QuoteVector_assign

`QuoteVector_assign` = function(self, n, x)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  
  ;.Call('R_swig_QuoteVector_assign', self, n, x, PACKAGE='QuantLib');
  
}

attr(`QuoteVector_assign`, 'returnType') = 'void'
attr(`QuoteVector_assign`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t', 'integer', '_p_boost__shared_ptrT_Quote_t')
class(`QuoteVector_assign`) = c("SWIGFunction", class('QuoteVector_assign'))

# Start of QuoteVector_resize

`QuoteVector_resize__SWIG_1` = function(self, new_size, x)
{
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  
  ;.Call('R_swig_QuoteVector_resize__SWIG_1', self, new_size, x, PACKAGE='QuantLib');
  
}

attr(`QuoteVector_resize__SWIG_1`, 'returnType') = 'void'
attr(`QuoteVector_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t', 'integer', '_p_boost__shared_ptrT_Quote_t')
class(`QuoteVector_resize__SWIG_1`) = c("SWIGFunction", class('QuoteVector_resize__SWIG_1'))

`QuoteVector_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]]))) {
      f <- QuoteVector_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && extends(argtypes[3], '_p_boost__shared_ptrT_Quote_t')) {
      f <- QuoteVector_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for QuoteVector_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of QuoteVector_reserve

`QuoteVector_reserve` = function(self, n)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_QuoteVector_reserve', self, n, PACKAGE='QuantLib');
  
}

attr(`QuoteVector_reserve`, 'returnType') = 'void'
attr(`QuoteVector_reserve`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t', 'integer')
class(`QuoteVector_reserve`) = c("SWIGFunction", class('QuoteVector_reserve'))

# Start of QuoteVector_capacity

`QuoteVector_capacity` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_QuoteVector_capacity', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`QuoteVector_capacity`, 'returnType') = 'integer'
attr(`QuoteVector_capacity`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t')
class(`QuoteVector_capacity`) = c("SWIGFunction", class('QuoteVector_capacity'))

# Start of delete_QuoteVector

`delete_QuoteVector` = function(self)
{
  ;.Call('R_swig_delete_QuoteVector', self, PACKAGE='QuantLib');
  
}

attr(`delete_QuoteVector`, 'returnType') = 'void'
attr(`delete_QuoteVector`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t')
class(`delete_QuoteVector`) = c("SWIGFunction", class('delete_QuoteVector'))

# Start of accessor method for std::vector<(boost::shared_ptr<(Quote)>)>
setMethod('$', '_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = QuoteVector___nonzero__, '__len__' = QuoteVector___len__, 'pop' = QuoteVector_pop, '__getslice__' = QuoteVector___getslice__, '__setslice__' = QuoteVector___setslice__, '__delslice__' = QuoteVector___delslice__, '__delitem__' = QuoteVector___delitem__, '__getitem__' = QuoteVector___getitem__, '__setitem__' = QuoteVector___setitem__, 'append' = QuoteVector_append, 'empty' = QuoteVector_empty, 'size' = QuoteVector_size, 'clear' = QuoteVector_clear, 'swap' = QuoteVector_swap, 'get_allocator' = QuoteVector_get_allocator, 'pop_back' = QuoteVector_pop_back, 'resize' = QuoteVector_resize, 'push_back' = QuoteVector_push_back, 'front' = QuoteVector_front, 'back' = QuoteVector_back, 'assign' = QuoteVector_assign, 'reserve' = QuoteVector_reserve, 'capacity' = QuoteVector_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for std::vector<(boost::shared_ptr<(Quote)>)>
setMethod('delete', '_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t', function(obj) {delete_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t(obj)})
# Start of QuoteVectorVector___nonzero__

`QuoteVectorVector___nonzero__` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_QuoteVectorVector___nonzero__', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`QuoteVectorVector___nonzero__`, 'returnType') = 'logical'
attr(`QuoteVectorVector___nonzero__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_std__allocatorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_t_t')
class(`QuoteVectorVector___nonzero__`) = c("SWIGFunction", class('QuoteVectorVector___nonzero__'))

# Start of QuoteVectorVector___len__

`QuoteVectorVector___len__` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_QuoteVectorVector___len__', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`QuoteVectorVector___len__`, 'returnType') = 'integer'
attr(`QuoteVectorVector___len__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_std__allocatorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_t_t')
class(`QuoteVectorVector___len__`) = c("SWIGFunction", class('QuoteVectorVector___len__'))

# Start of QuoteVectorVector_pop

`QuoteVectorVector_pop` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_QuoteVectorVector_pop', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t";
  
  ans
  
}

attr(`QuoteVectorVector_pop`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t'
attr(`QuoteVectorVector_pop`, "inputTypes") = c('_p_std__vectorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_std__allocatorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_t_t')
class(`QuoteVectorVector_pop`) = c("SWIGFunction", class('QuoteVectorVector_pop'))

# Start of QuoteVectorVector___getslice__

`QuoteVectorVector___getslice__` = function(self, i, j)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;ans = .Call('R_swig_QuoteVectorVector___getslice__', self, i, j, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_std__allocatorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_t_t";
  
  ans
  
}

attr(`QuoteVectorVector___getslice__`, 'returnType') = '_p_std__vectorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_std__allocatorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_t_t'
attr(`QuoteVectorVector___getslice__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_std__allocatorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_t_t', 'integer', 'integer')
class(`QuoteVectorVector___getslice__`) = c("SWIGFunction", class('QuoteVectorVector___getslice__'))

# Start of QuoteVectorVector___setslice__

`QuoteVectorVector___setslice__` = function(self, i, j, v)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  
  ;.Call('R_swig_QuoteVectorVector___setslice__', self, i, j, v, PACKAGE='QuantLib');
  
}

attr(`QuoteVectorVector___setslice__`, 'returnType') = 'void'
attr(`QuoteVectorVector___setslice__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_std__allocatorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_t_t', 'integer', 'integer', '_p_std__vectorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_std__allocatorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_t_t')
class(`QuoteVectorVector___setslice__`) = c("SWIGFunction", class('QuoteVectorVector___setslice__'))

# Start of QuoteVectorVector___delslice__

`QuoteVectorVector___delslice__` = function(self, i, j)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_QuoteVectorVector___delslice__', self, i, j, PACKAGE='QuantLib');
  
}

attr(`QuoteVectorVector___delslice__`, 'returnType') = 'void'
attr(`QuoteVectorVector___delslice__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_std__allocatorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_t_t', 'integer', 'integer')
class(`QuoteVectorVector___delslice__`) = c("SWIGFunction", class('QuoteVectorVector___delslice__'))

# Start of QuoteVectorVector___delitem__

`QuoteVectorVector___delitem__` = function(self, i)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_QuoteVectorVector___delitem__', self, i, PACKAGE='QuantLib');
  
}

attr(`QuoteVectorVector___delitem__`, 'returnType') = 'void'
attr(`QuoteVectorVector___delitem__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_std__allocatorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_t_t', 'integer')
class(`QuoteVectorVector___delitem__`) = c("SWIGFunction", class('QuoteVectorVector___delitem__'))

# Start of QuoteVectorVector___getitem__

`QuoteVectorVector___getitem__` = function(self, i, .copy = FALSE)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;ans = .Call('R_swig_QuoteVectorVector___getitem__', self, i, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t";
  
  ans
  
}

attr(`QuoteVectorVector___getitem__`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t'
attr(`QuoteVectorVector___getitem__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_std__allocatorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_t_t', 'integer')
class(`QuoteVectorVector___getitem__`) = c("SWIGFunction", class('QuoteVectorVector___getitem__'))

# Start of QuoteVectorVector___setitem__

`QuoteVectorVector___setitem__` = function(self, i, x)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  ;.Call('R_swig_QuoteVectorVector___setitem__', self, i, x, PACKAGE='QuantLib');
  
}

attr(`QuoteVectorVector___setitem__`, 'returnType') = 'void'
attr(`QuoteVectorVector___setitem__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_std__allocatorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_t_t', 'integer', '_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t')
class(`QuoteVectorVector___setitem__`) = c("SWIGFunction", class('QuoteVectorVector___setitem__'))

# Start of QuoteVectorVector_append

`QuoteVectorVector_append` = function(self, x)
{
  ;.Call('R_swig_QuoteVectorVector_append', self, x, PACKAGE='QuantLib');
  
}

attr(`QuoteVectorVector_append`, 'returnType') = 'void'
attr(`QuoteVectorVector_append`, "inputTypes") = c('_p_std__vectorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_std__allocatorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_t_t', '_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t')
class(`QuoteVectorVector_append`) = c("SWIGFunction", class('QuoteVectorVector_append'))

# Start of new_QuoteVectorVector

`QuoteVectorVector__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_QuoteVectorVector__SWIG_0', PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_std__allocatorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_t_t";
  
  reg.finalizer(ans, delete_QuoteVectorVector)
  ans
  
}

attr(`QuoteVectorVector__SWIG_0`, 'returnType') = '_p_std__vectorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_std__allocatorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_t_t'
class(`QuoteVectorVector__SWIG_0`) = c("SWIGFunction", class('QuoteVectorVector__SWIG_0'))

# Start of new_QuoteVectorVector

`QuoteVectorVector__SWIG_1` = function(s_arg1)
{
  ;ans = .Call('R_swig_new_QuoteVectorVector__SWIG_1', s_arg1, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_std__allocatorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_t_t";
  
  reg.finalizer(ans, delete_QuoteVectorVector)
  ans
  
}

attr(`QuoteVectorVector__SWIG_1`, 'returnType') = '_p_std__vectorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_std__allocatorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_t_t'
attr(`QuoteVectorVector__SWIG_1`, "inputTypes") = c('_p_std__vectorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_std__allocatorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_t_t')
class(`QuoteVectorVector__SWIG_1`) = c("SWIGFunction", class('QuoteVectorVector__SWIG_1'))

# Start of QuoteVectorVector_empty

`QuoteVectorVector_empty` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_QuoteVectorVector_empty', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`QuoteVectorVector_empty`, 'returnType') = 'logical'
attr(`QuoteVectorVector_empty`, "inputTypes") = c('_p_std__vectorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_std__allocatorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_t_t')
class(`QuoteVectorVector_empty`) = c("SWIGFunction", class('QuoteVectorVector_empty'))

# Start of QuoteVectorVector_size

`QuoteVectorVector_size` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_QuoteVectorVector_size', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`QuoteVectorVector_size`, 'returnType') = 'integer'
attr(`QuoteVectorVector_size`, "inputTypes") = c('_p_std__vectorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_std__allocatorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_t_t')
class(`QuoteVectorVector_size`) = c("SWIGFunction", class('QuoteVectorVector_size'))

# Start of QuoteVectorVector_clear

`QuoteVectorVector_clear` = function(self)
{
  ;.Call('R_swig_QuoteVectorVector_clear', self, PACKAGE='QuantLib');
  
}

attr(`QuoteVectorVector_clear`, 'returnType') = 'void'
attr(`QuoteVectorVector_clear`, "inputTypes") = c('_p_std__vectorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_std__allocatorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_t_t')
class(`QuoteVectorVector_clear`) = c("SWIGFunction", class('QuoteVectorVector_clear'))

# Start of QuoteVectorVector_swap

`QuoteVectorVector_swap` = function(self, v)
{
  ;.Call('R_swig_QuoteVectorVector_swap', self, v, PACKAGE='QuantLib');
  
}

attr(`QuoteVectorVector_swap`, 'returnType') = 'void'
attr(`QuoteVectorVector_swap`, "inputTypes") = c('_p_std__vectorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_std__allocatorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_t_t', '_p_std__vectorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_std__allocatorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_t_t')
class(`QuoteVectorVector_swap`) = c("SWIGFunction", class('QuoteVectorVector_swap'))

# Start of QuoteVectorVector_get_allocator

`QuoteVectorVector_get_allocator` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_QuoteVectorVector_get_allocator', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__allocatorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_t";
  
  ans
  
}

attr(`QuoteVectorVector_get_allocator`, 'returnType') = '_p_std__allocatorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_t'
attr(`QuoteVectorVector_get_allocator`, "inputTypes") = c('_p_std__vectorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_std__allocatorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_t_t')
class(`QuoteVectorVector_get_allocator`) = c("SWIGFunction", class('QuoteVectorVector_get_allocator'))

# Start of new_QuoteVectorVector

`QuoteVectorVector__SWIG_2` = function(size)
{
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_new_QuoteVectorVector__SWIG_2', size, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_std__allocatorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_t_t";
  
  reg.finalizer(ans, delete_QuoteVectorVector)
  ans
  
}

attr(`QuoteVectorVector__SWIG_2`, 'returnType') = '_p_std__vectorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_std__allocatorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_t_t'
attr(`QuoteVectorVector__SWIG_2`, "inputTypes") = c('integer')
class(`QuoteVectorVector__SWIG_2`) = c("SWIGFunction", class('QuoteVectorVector__SWIG_2'))

# Start of QuoteVectorVector_pop_back

`QuoteVectorVector_pop_back` = function(self)
{
  ;.Call('R_swig_QuoteVectorVector_pop_back', self, PACKAGE='QuantLib');
  
}

attr(`QuoteVectorVector_pop_back`, 'returnType') = 'void'
attr(`QuoteVectorVector_pop_back`, "inputTypes") = c('_p_std__vectorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_std__allocatorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_t_t')
class(`QuoteVectorVector_pop_back`) = c("SWIGFunction", class('QuoteVectorVector_pop_back'))

# Start of QuoteVectorVector_resize

`QuoteVectorVector_resize__SWIG_0` = function(self, new_size)
{
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_QuoteVectorVector_resize__SWIG_0', self, new_size, PACKAGE='QuantLib');
  
}

attr(`QuoteVectorVector_resize__SWIG_0`, 'returnType') = 'void'
attr(`QuoteVectorVector_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_std__allocatorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_t_t', 'integer')
class(`QuoteVectorVector_resize__SWIG_0`) = c("SWIGFunction", class('QuoteVectorVector_resize__SWIG_0'))

# Start of new_QuoteVectorVector

`QuoteVectorVector__SWIG_3` = function(size, value)
{
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  
  ;ans = .Call('R_swig_new_QuoteVectorVector__SWIG_3', size, value, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_std__allocatorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_t_t";
  
  reg.finalizer(ans, delete_QuoteVectorVector)
  ans
  
}

attr(`QuoteVectorVector__SWIG_3`, 'returnType') = '_p_std__vectorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_std__allocatorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_t_t'
attr(`QuoteVectorVector__SWIG_3`, "inputTypes") = c('integer', '_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t')
class(`QuoteVectorVector__SWIG_3`) = c("SWIGFunction", class('QuoteVectorVector__SWIG_3'))

`QuoteVectorVector` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- QuoteVectorVector__SWIG_0; 
  } else if (argc == 1) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]]))) {
      f <- QuoteVectorVector__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_std__allocatorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_t_t')) {
      f <- QuoteVectorVector__SWIG_1; 
    }
  } else if (argc == 2) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && extends(argtypes[2], '_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t')) {
      f <- QuoteVectorVector__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for QuoteVectorVector with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of QuoteVectorVector_push_back

`QuoteVectorVector_push_back` = function(self, x)
{
  ;.Call('R_swig_QuoteVectorVector_push_back', self, x, PACKAGE='QuantLib');
  
}

attr(`QuoteVectorVector_push_back`, 'returnType') = 'void'
attr(`QuoteVectorVector_push_back`, "inputTypes") = c('_p_std__vectorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_std__allocatorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_t_t', '_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t')
class(`QuoteVectorVector_push_back`) = c("SWIGFunction", class('QuoteVectorVector_push_back'))

# Start of QuoteVectorVector_front

`QuoteVectorVector_front` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_QuoteVectorVector_front', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t";
  
  ans
  
}

attr(`QuoteVectorVector_front`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t'
attr(`QuoteVectorVector_front`, "inputTypes") = c('_p_std__vectorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_std__allocatorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_t_t')
class(`QuoteVectorVector_front`) = c("SWIGFunction", class('QuoteVectorVector_front'))

# Start of QuoteVectorVector_back

`QuoteVectorVector_back` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_QuoteVectorVector_back', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t";
  
  ans
  
}

attr(`QuoteVectorVector_back`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t'
attr(`QuoteVectorVector_back`, "inputTypes") = c('_p_std__vectorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_std__allocatorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_t_t')
class(`QuoteVectorVector_back`) = c("SWIGFunction", class('QuoteVectorVector_back'))

# Start of QuoteVectorVector_assign

`QuoteVectorVector_assign` = function(self, n, x)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  
  ;.Call('R_swig_QuoteVectorVector_assign', self, n, x, PACKAGE='QuantLib');
  
}

attr(`QuoteVectorVector_assign`, 'returnType') = 'void'
attr(`QuoteVectorVector_assign`, "inputTypes") = c('_p_std__vectorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_std__allocatorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_t_t', 'integer', '_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t')
class(`QuoteVectorVector_assign`) = c("SWIGFunction", class('QuoteVectorVector_assign'))

# Start of QuoteVectorVector_resize

`QuoteVectorVector_resize__SWIG_1` = function(self, new_size, x)
{
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  
  ;.Call('R_swig_QuoteVectorVector_resize__SWIG_1', self, new_size, x, PACKAGE='QuantLib');
  
}

attr(`QuoteVectorVector_resize__SWIG_1`, 'returnType') = 'void'
attr(`QuoteVectorVector_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_std__allocatorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_t_t', 'integer', '_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t')
class(`QuoteVectorVector_resize__SWIG_1`) = c("SWIGFunction", class('QuoteVectorVector_resize__SWIG_1'))

`QuoteVectorVector_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_std__vectorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_std__allocatorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_t_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]]))) {
      f <- QuoteVectorVector_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_std__vectorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_std__allocatorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_t_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && extends(argtypes[3], '_p_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t')) {
      f <- QuoteVectorVector_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for QuoteVectorVector_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of QuoteVectorVector_reserve

`QuoteVectorVector_reserve` = function(self, n)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_QuoteVectorVector_reserve', self, n, PACKAGE='QuantLib');
  
}

attr(`QuoteVectorVector_reserve`, 'returnType') = 'void'
attr(`QuoteVectorVector_reserve`, "inputTypes") = c('_p_std__vectorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_std__allocatorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_t_t', 'integer')
class(`QuoteVectorVector_reserve`) = c("SWIGFunction", class('QuoteVectorVector_reserve'))

# Start of QuoteVectorVector_capacity

`QuoteVectorVector_capacity` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_QuoteVectorVector_capacity', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`QuoteVectorVector_capacity`, 'returnType') = 'integer'
attr(`QuoteVectorVector_capacity`, "inputTypes") = c('_p_std__vectorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_std__allocatorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_t_t')
class(`QuoteVectorVector_capacity`) = c("SWIGFunction", class('QuoteVectorVector_capacity'))

# Start of delete_QuoteVectorVector

`delete_QuoteVectorVector` = function(self)
{
  ;.Call('R_swig_delete_QuoteVectorVector', self, PACKAGE='QuantLib');
  
}

attr(`delete_QuoteVectorVector`, 'returnType') = 'void'
attr(`delete_QuoteVectorVector`, "inputTypes") = c('_p_std__vectorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_std__allocatorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_t_t')
class(`delete_QuoteVectorVector`) = c("SWIGFunction", class('delete_QuoteVectorVector'))

# Start of accessor method for std::vector<(std::vector<(boost::shared_ptr<(Quote)>)>)>
setMethod('$', '_p_std__vectorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_std__allocatorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = QuoteVectorVector___nonzero__, '__len__' = QuoteVectorVector___len__, 'pop' = QuoteVectorVector_pop, '__getslice__' = QuoteVectorVector___getslice__, '__setslice__' = QuoteVectorVector___setslice__, '__delslice__' = QuoteVectorVector___delslice__, '__delitem__' = QuoteVectorVector___delitem__, '__getitem__' = QuoteVectorVector___getitem__, '__setitem__' = QuoteVectorVector___setitem__, 'append' = QuoteVectorVector_append, 'empty' = QuoteVectorVector_empty, 'size' = QuoteVectorVector_size, 'clear' = QuoteVectorVector_clear, 'swap' = QuoteVectorVector_swap, 'get_allocator' = QuoteVectorVector_get_allocator, 'pop_back' = QuoteVectorVector_pop_back, 'resize' = QuoteVectorVector_resize, 'push_back' = QuoteVectorVector_push_back, 'front' = QuoteVectorVector_front, 'back' = QuoteVectorVector_back, 'assign' = QuoteVectorVector_assign, 'reserve' = QuoteVectorVector_reserve, 'capacity' = QuoteVectorVector_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for std::vector<(std::vector<(boost::shared_ptr<(Quote)>)>)>
setMethod('delete', '_p_std__vectorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_std__allocatorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_t_t', function(obj) {delete_std__vectorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_std__allocatorT_std__vectorT_boost__shared_ptrT_Quote_t_std__allocatorT_boost__shared_ptrT_Quote_t_t_t_t_t(obj)})
# Start of QuoteHandleVector___nonzero__

`QuoteHandleVector___nonzero__` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_QuoteHandleVector___nonzero__', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`QuoteHandleVector___nonzero__`, 'returnType') = 'logical'
attr(`QuoteHandleVector___nonzero__`, "inputTypes") = c('_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t')
class(`QuoteHandleVector___nonzero__`) = c("SWIGFunction", class('QuoteHandleVector___nonzero__'))

# Start of QuoteHandleVector___len__

`QuoteHandleVector___len__` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_QuoteHandleVector___len__', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`QuoteHandleVector___len__`, 'returnType') = 'integer'
attr(`QuoteHandleVector___len__`, "inputTypes") = c('_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t')
class(`QuoteHandleVector___len__`) = c("SWIGFunction", class('QuoteHandleVector___len__'))

# Start of QuoteHandleVector_pop

`QuoteHandleVector_pop` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_QuoteHandleVector_pop', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_HandleT_Quote_t";
  
  ans
  
}

attr(`QuoteHandleVector_pop`, 'returnType') = '_p_HandleT_Quote_t'
attr(`QuoteHandleVector_pop`, "inputTypes") = c('_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t')
class(`QuoteHandleVector_pop`) = c("SWIGFunction", class('QuoteHandleVector_pop'))

# Start of QuoteHandleVector___getslice__

`QuoteHandleVector___getslice__` = function(self, i, j)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;ans = .Call('R_swig_QuoteHandleVector___getslice__', self, i, j, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t";
  
  ans
  
}

attr(`QuoteHandleVector___getslice__`, 'returnType') = '_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t'
attr(`QuoteHandleVector___getslice__`, "inputTypes") = c('_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t', 'integer', 'integer')
class(`QuoteHandleVector___getslice__`) = c("SWIGFunction", class('QuoteHandleVector___getslice__'))

# Start of QuoteHandleVector___setslice__

`QuoteHandleVector___setslice__` = function(self, i, j, v)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  
  ;.Call('R_swig_QuoteHandleVector___setslice__', self, i, j, v, PACKAGE='QuantLib');
  
}

attr(`QuoteHandleVector___setslice__`, 'returnType') = 'void'
attr(`QuoteHandleVector___setslice__`, "inputTypes") = c('_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t', 'integer', 'integer', '_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t')
class(`QuoteHandleVector___setslice__`) = c("SWIGFunction", class('QuoteHandleVector___setslice__'))

# Start of QuoteHandleVector___delslice__

`QuoteHandleVector___delslice__` = function(self, i, j)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_QuoteHandleVector___delslice__', self, i, j, PACKAGE='QuantLib');
  
}

attr(`QuoteHandleVector___delslice__`, 'returnType') = 'void'
attr(`QuoteHandleVector___delslice__`, "inputTypes") = c('_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t', 'integer', 'integer')
class(`QuoteHandleVector___delslice__`) = c("SWIGFunction", class('QuoteHandleVector___delslice__'))

# Start of QuoteHandleVector___delitem__

`QuoteHandleVector___delitem__` = function(self, i)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_QuoteHandleVector___delitem__', self, i, PACKAGE='QuantLib');
  
}

attr(`QuoteHandleVector___delitem__`, 'returnType') = 'void'
attr(`QuoteHandleVector___delitem__`, "inputTypes") = c('_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t', 'integer')
class(`QuoteHandleVector___delitem__`) = c("SWIGFunction", class('QuoteHandleVector___delitem__'))

# Start of QuoteHandleVector___getitem__

`QuoteHandleVector___getitem__` = function(self, i, .copy = FALSE)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;ans = .Call('R_swig_QuoteHandleVector___getitem__', self, i, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_HandleT_Quote_t";
  
  ans
  
}

attr(`QuoteHandleVector___getitem__`, 'returnType') = '_p_HandleT_Quote_t'
attr(`QuoteHandleVector___getitem__`, "inputTypes") = c('_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t', 'integer')
class(`QuoteHandleVector___getitem__`) = c("SWIGFunction", class('QuoteHandleVector___getitem__'))

# Start of QuoteHandleVector___setitem__

`QuoteHandleVector___setitem__` = function(self, i, x)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  ;.Call('R_swig_QuoteHandleVector___setitem__', self, i, x, PACKAGE='QuantLib');
  
}

attr(`QuoteHandleVector___setitem__`, 'returnType') = 'void'
attr(`QuoteHandleVector___setitem__`, "inputTypes") = c('_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t', 'integer', '_p_HandleT_Quote_t')
class(`QuoteHandleVector___setitem__`) = c("SWIGFunction", class('QuoteHandleVector___setitem__'))

# Start of QuoteHandleVector_append

`QuoteHandleVector_append` = function(self, x)
{
  ;.Call('R_swig_QuoteHandleVector_append', self, x, PACKAGE='QuantLib');
  
}

attr(`QuoteHandleVector_append`, 'returnType') = 'void'
attr(`QuoteHandleVector_append`, "inputTypes") = c('_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t', '_p_HandleT_Quote_t')
class(`QuoteHandleVector_append`) = c("SWIGFunction", class('QuoteHandleVector_append'))

# Start of new_QuoteHandleVector

`QuoteHandleVector__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_QuoteHandleVector__SWIG_0', PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t";
  
  reg.finalizer(ans, delete_QuoteHandleVector)
  ans
  
}

attr(`QuoteHandleVector__SWIG_0`, 'returnType') = '_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t'
class(`QuoteHandleVector__SWIG_0`) = c("SWIGFunction", class('QuoteHandleVector__SWIG_0'))

# Start of new_QuoteHandleVector

`QuoteHandleVector__SWIG_1` = function(s_arg1)
{
  ;ans = .Call('R_swig_new_QuoteHandleVector__SWIG_1', s_arg1, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t";
  
  reg.finalizer(ans, delete_QuoteHandleVector)
  ans
  
}

attr(`QuoteHandleVector__SWIG_1`, 'returnType') = '_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t'
attr(`QuoteHandleVector__SWIG_1`, "inputTypes") = c('_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t')
class(`QuoteHandleVector__SWIG_1`) = c("SWIGFunction", class('QuoteHandleVector__SWIG_1'))

# Start of QuoteHandleVector_empty

`QuoteHandleVector_empty` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_QuoteHandleVector_empty', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`QuoteHandleVector_empty`, 'returnType') = 'logical'
attr(`QuoteHandleVector_empty`, "inputTypes") = c('_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t')
class(`QuoteHandleVector_empty`) = c("SWIGFunction", class('QuoteHandleVector_empty'))

# Start of QuoteHandleVector_size

`QuoteHandleVector_size` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_QuoteHandleVector_size', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`QuoteHandleVector_size`, 'returnType') = 'integer'
attr(`QuoteHandleVector_size`, "inputTypes") = c('_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t')
class(`QuoteHandleVector_size`) = c("SWIGFunction", class('QuoteHandleVector_size'))

# Start of QuoteHandleVector_clear

`QuoteHandleVector_clear` = function(self)
{
  ;.Call('R_swig_QuoteHandleVector_clear', self, PACKAGE='QuantLib');
  
}

attr(`QuoteHandleVector_clear`, 'returnType') = 'void'
attr(`QuoteHandleVector_clear`, "inputTypes") = c('_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t')
class(`QuoteHandleVector_clear`) = c("SWIGFunction", class('QuoteHandleVector_clear'))

# Start of QuoteHandleVector_swap

`QuoteHandleVector_swap` = function(self, v)
{
  ;.Call('R_swig_QuoteHandleVector_swap', self, v, PACKAGE='QuantLib');
  
}

attr(`QuoteHandleVector_swap`, 'returnType') = 'void'
attr(`QuoteHandleVector_swap`, "inputTypes") = c('_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t', '_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t')
class(`QuoteHandleVector_swap`) = c("SWIGFunction", class('QuoteHandleVector_swap'))

# Start of QuoteHandleVector_get_allocator

`QuoteHandleVector_get_allocator` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_QuoteHandleVector_get_allocator', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__allocatorT_HandleT_Quote_t_t";
  
  ans
  
}

attr(`QuoteHandleVector_get_allocator`, 'returnType') = '_p_std__allocatorT_HandleT_Quote_t_t'
attr(`QuoteHandleVector_get_allocator`, "inputTypes") = c('_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t')
class(`QuoteHandleVector_get_allocator`) = c("SWIGFunction", class('QuoteHandleVector_get_allocator'))

# Start of new_QuoteHandleVector

`QuoteHandleVector__SWIG_2` = function(size)
{
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_new_QuoteHandleVector__SWIG_2', size, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t";
  
  reg.finalizer(ans, delete_QuoteHandleVector)
  ans
  
}

attr(`QuoteHandleVector__SWIG_2`, 'returnType') = '_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t'
attr(`QuoteHandleVector__SWIG_2`, "inputTypes") = c('integer')
class(`QuoteHandleVector__SWIG_2`) = c("SWIGFunction", class('QuoteHandleVector__SWIG_2'))

# Start of QuoteHandleVector_pop_back

`QuoteHandleVector_pop_back` = function(self)
{
  ;.Call('R_swig_QuoteHandleVector_pop_back', self, PACKAGE='QuantLib');
  
}

attr(`QuoteHandleVector_pop_back`, 'returnType') = 'void'
attr(`QuoteHandleVector_pop_back`, "inputTypes") = c('_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t')
class(`QuoteHandleVector_pop_back`) = c("SWIGFunction", class('QuoteHandleVector_pop_back'))

# Start of QuoteHandleVector_resize

`QuoteHandleVector_resize__SWIG_0` = function(self, new_size)
{
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_QuoteHandleVector_resize__SWIG_0', self, new_size, PACKAGE='QuantLib');
  
}

attr(`QuoteHandleVector_resize__SWIG_0`, 'returnType') = 'void'
attr(`QuoteHandleVector_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t', 'integer')
class(`QuoteHandleVector_resize__SWIG_0`) = c("SWIGFunction", class('QuoteHandleVector_resize__SWIG_0'))

# Start of new_QuoteHandleVector

`QuoteHandleVector__SWIG_3` = function(size, value)
{
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  
  ;ans = .Call('R_swig_new_QuoteHandleVector__SWIG_3', size, value, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t";
  
  reg.finalizer(ans, delete_QuoteHandleVector)
  ans
  
}

attr(`QuoteHandleVector__SWIG_3`, 'returnType') = '_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t'
attr(`QuoteHandleVector__SWIG_3`, "inputTypes") = c('integer', '_p_HandleT_Quote_t')
class(`QuoteHandleVector__SWIG_3`) = c("SWIGFunction", class('QuoteHandleVector__SWIG_3'))

`QuoteHandleVector` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- QuoteHandleVector__SWIG_0; 
  } else if (argc == 1) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]]))) {
      f <- QuoteHandleVector__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t')) {
      f <- QuoteHandleVector__SWIG_1; 
    }
  } else if (argc == 2) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && extends(argtypes[2], '_p_HandleT_Quote_t')) {
      f <- QuoteHandleVector__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for QuoteHandleVector with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of QuoteHandleVector_push_back

`QuoteHandleVector_push_back` = function(self, x)
{
  ;.Call('R_swig_QuoteHandleVector_push_back', self, x, PACKAGE='QuantLib');
  
}

attr(`QuoteHandleVector_push_back`, 'returnType') = 'void'
attr(`QuoteHandleVector_push_back`, "inputTypes") = c('_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t', '_p_HandleT_Quote_t')
class(`QuoteHandleVector_push_back`) = c("SWIGFunction", class('QuoteHandleVector_push_back'))

# Start of QuoteHandleVector_front

`QuoteHandleVector_front` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_QuoteHandleVector_front', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_HandleT_Quote_t";
  
  ans
  
}

attr(`QuoteHandleVector_front`, 'returnType') = '_p_HandleT_Quote_t'
attr(`QuoteHandleVector_front`, "inputTypes") = c('_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t')
class(`QuoteHandleVector_front`) = c("SWIGFunction", class('QuoteHandleVector_front'))

# Start of QuoteHandleVector_back

`QuoteHandleVector_back` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_QuoteHandleVector_back', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_HandleT_Quote_t";
  
  ans
  
}

attr(`QuoteHandleVector_back`, 'returnType') = '_p_HandleT_Quote_t'
attr(`QuoteHandleVector_back`, "inputTypes") = c('_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t')
class(`QuoteHandleVector_back`) = c("SWIGFunction", class('QuoteHandleVector_back'))

# Start of QuoteHandleVector_assign

`QuoteHandleVector_assign` = function(self, n, x)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  
  ;.Call('R_swig_QuoteHandleVector_assign', self, n, x, PACKAGE='QuantLib');
  
}

attr(`QuoteHandleVector_assign`, 'returnType') = 'void'
attr(`QuoteHandleVector_assign`, "inputTypes") = c('_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t', 'integer', '_p_HandleT_Quote_t')
class(`QuoteHandleVector_assign`) = c("SWIGFunction", class('QuoteHandleVector_assign'))

# Start of QuoteHandleVector_resize

`QuoteHandleVector_resize__SWIG_1` = function(self, new_size, x)
{
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  
  ;.Call('R_swig_QuoteHandleVector_resize__SWIG_1', self, new_size, x, PACKAGE='QuantLib');
  
}

attr(`QuoteHandleVector_resize__SWIG_1`, 'returnType') = 'void'
attr(`QuoteHandleVector_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t', 'integer', '_p_HandleT_Quote_t')
class(`QuoteHandleVector_resize__SWIG_1`) = c("SWIGFunction", class('QuoteHandleVector_resize__SWIG_1'))

`QuoteHandleVector_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]]))) {
      f <- QuoteHandleVector_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && extends(argtypes[3], '_p_HandleT_Quote_t')) {
      f <- QuoteHandleVector_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for QuoteHandleVector_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of QuoteHandleVector_reserve

`QuoteHandleVector_reserve` = function(self, n)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_QuoteHandleVector_reserve', self, n, PACKAGE='QuantLib');
  
}

attr(`QuoteHandleVector_reserve`, 'returnType') = 'void'
attr(`QuoteHandleVector_reserve`, "inputTypes") = c('_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t', 'integer')
class(`QuoteHandleVector_reserve`) = c("SWIGFunction", class('QuoteHandleVector_reserve'))

# Start of QuoteHandleVector_capacity

`QuoteHandleVector_capacity` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_QuoteHandleVector_capacity', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`QuoteHandleVector_capacity`, 'returnType') = 'integer'
attr(`QuoteHandleVector_capacity`, "inputTypes") = c('_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t')
class(`QuoteHandleVector_capacity`) = c("SWIGFunction", class('QuoteHandleVector_capacity'))

# Start of delete_QuoteHandleVector

`delete_QuoteHandleVector` = function(self)
{
  ;.Call('R_swig_delete_QuoteHandleVector', self, PACKAGE='QuantLib');
  
}

attr(`delete_QuoteHandleVector`, 'returnType') = 'void'
attr(`delete_QuoteHandleVector`, "inputTypes") = c('_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t')
class(`delete_QuoteHandleVector`) = c("SWIGFunction", class('delete_QuoteHandleVector'))

# Start of accessor method for std::vector<(Handle<(Quote)>)>
setMethod('$', '_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = QuoteHandleVector___nonzero__, '__len__' = QuoteHandleVector___len__, 'pop' = QuoteHandleVector_pop, '__getslice__' = QuoteHandleVector___getslice__, '__setslice__' = QuoteHandleVector___setslice__, '__delslice__' = QuoteHandleVector___delslice__, '__delitem__' = QuoteHandleVector___delitem__, '__getitem__' = QuoteHandleVector___getitem__, '__setitem__' = QuoteHandleVector___setitem__, 'append' = QuoteHandleVector_append, 'empty' = QuoteHandleVector_empty, 'size' = QuoteHandleVector_size, 'clear' = QuoteHandleVector_clear, 'swap' = QuoteHandleVector_swap, 'get_allocator' = QuoteHandleVector_get_allocator, 'pop_back' = QuoteHandleVector_pop_back, 'resize' = QuoteHandleVector_resize, 'push_back' = QuoteHandleVector_push_back, 'front' = QuoteHandleVector_front, 'back' = QuoteHandleVector_back, 'assign' = QuoteHandleVector_assign, 'reserve' = QuoteHandleVector_reserve, 'capacity' = QuoteHandleVector_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for std::vector<(Handle<(Quote)>)>
setMethod('delete', '_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t', function(obj) {delete_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t(obj)})
# Start of QuoteHandleVectorVector___nonzero__

`QuoteHandleVectorVector___nonzero__` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_QuoteHandleVectorVector___nonzero__', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`QuoteHandleVectorVector___nonzero__`, 'returnType') = 'logical'
attr(`QuoteHandleVectorVector___nonzero__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t')
class(`QuoteHandleVectorVector___nonzero__`) = c("SWIGFunction", class('QuoteHandleVectorVector___nonzero__'))

# Start of QuoteHandleVectorVector___len__

`QuoteHandleVectorVector___len__` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_QuoteHandleVectorVector___len__', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`QuoteHandleVectorVector___len__`, 'returnType') = 'integer'
attr(`QuoteHandleVectorVector___len__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t')
class(`QuoteHandleVectorVector___len__`) = c("SWIGFunction", class('QuoteHandleVectorVector___len__'))

# Start of QuoteHandleVectorVector_pop

`QuoteHandleVectorVector_pop` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_QuoteHandleVectorVector_pop', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t";
  
  ans
  
}

attr(`QuoteHandleVectorVector_pop`, 'returnType') = '_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t'
attr(`QuoteHandleVectorVector_pop`, "inputTypes") = c('_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t')
class(`QuoteHandleVectorVector_pop`) = c("SWIGFunction", class('QuoteHandleVectorVector_pop'))

# Start of QuoteHandleVectorVector___getslice__

`QuoteHandleVectorVector___getslice__` = function(self, i, j)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;ans = .Call('R_swig_QuoteHandleVectorVector___getslice__', self, i, j, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t";
  
  ans
  
}

attr(`QuoteHandleVectorVector___getslice__`, 'returnType') = '_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t'
attr(`QuoteHandleVectorVector___getslice__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t', 'integer', 'integer')
class(`QuoteHandleVectorVector___getslice__`) = c("SWIGFunction", class('QuoteHandleVectorVector___getslice__'))

# Start of QuoteHandleVectorVector___setslice__

`QuoteHandleVectorVector___setslice__` = function(self, i, j, v)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  
  ;.Call('R_swig_QuoteHandleVectorVector___setslice__', self, i, j, v, PACKAGE='QuantLib');
  
}

attr(`QuoteHandleVectorVector___setslice__`, 'returnType') = 'void'
attr(`QuoteHandleVectorVector___setslice__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t', 'integer', 'integer', '_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t')
class(`QuoteHandleVectorVector___setslice__`) = c("SWIGFunction", class('QuoteHandleVectorVector___setslice__'))

# Start of QuoteHandleVectorVector___delslice__

`QuoteHandleVectorVector___delslice__` = function(self, i, j)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_QuoteHandleVectorVector___delslice__', self, i, j, PACKAGE='QuantLib');
  
}

attr(`QuoteHandleVectorVector___delslice__`, 'returnType') = 'void'
attr(`QuoteHandleVectorVector___delslice__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t', 'integer', 'integer')
class(`QuoteHandleVectorVector___delslice__`) = c("SWIGFunction", class('QuoteHandleVectorVector___delslice__'))

# Start of QuoteHandleVectorVector___delitem__

`QuoteHandleVectorVector___delitem__` = function(self, i)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_QuoteHandleVectorVector___delitem__', self, i, PACKAGE='QuantLib');
  
}

attr(`QuoteHandleVectorVector___delitem__`, 'returnType') = 'void'
attr(`QuoteHandleVectorVector___delitem__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t', 'integer')
class(`QuoteHandleVectorVector___delitem__`) = c("SWIGFunction", class('QuoteHandleVectorVector___delitem__'))

# Start of QuoteHandleVectorVector___getitem__

`QuoteHandleVectorVector___getitem__` = function(self, i, .copy = FALSE)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;ans = .Call('R_swig_QuoteHandleVectorVector___getitem__', self, i, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t";
  
  ans
  
}

attr(`QuoteHandleVectorVector___getitem__`, 'returnType') = '_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t'
attr(`QuoteHandleVectorVector___getitem__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t', 'integer')
class(`QuoteHandleVectorVector___getitem__`) = c("SWIGFunction", class('QuoteHandleVectorVector___getitem__'))

# Start of QuoteHandleVectorVector___setitem__

`QuoteHandleVectorVector___setitem__` = function(self, i, x)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  ;.Call('R_swig_QuoteHandleVectorVector___setitem__', self, i, x, PACKAGE='QuantLib');
  
}

attr(`QuoteHandleVectorVector___setitem__`, 'returnType') = 'void'
attr(`QuoteHandleVectorVector___setitem__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t', 'integer', '_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t')
class(`QuoteHandleVectorVector___setitem__`) = c("SWIGFunction", class('QuoteHandleVectorVector___setitem__'))

# Start of QuoteHandleVectorVector_append

`QuoteHandleVectorVector_append` = function(self, x)
{
  ;.Call('R_swig_QuoteHandleVectorVector_append', self, x, PACKAGE='QuantLib');
  
}

attr(`QuoteHandleVectorVector_append`, 'returnType') = 'void'
attr(`QuoteHandleVectorVector_append`, "inputTypes") = c('_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t', '_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t')
class(`QuoteHandleVectorVector_append`) = c("SWIGFunction", class('QuoteHandleVectorVector_append'))

# Start of new_QuoteHandleVectorVector

`QuoteHandleVectorVector__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_QuoteHandleVectorVector__SWIG_0', PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t";
  
  reg.finalizer(ans, delete_QuoteHandleVectorVector)
  ans
  
}

attr(`QuoteHandleVectorVector__SWIG_0`, 'returnType') = '_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t'
class(`QuoteHandleVectorVector__SWIG_0`) = c("SWIGFunction", class('QuoteHandleVectorVector__SWIG_0'))

# Start of new_QuoteHandleVectorVector

`QuoteHandleVectorVector__SWIG_1` = function(s_arg1)
{
  ;ans = .Call('R_swig_new_QuoteHandleVectorVector__SWIG_1', s_arg1, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t";
  
  reg.finalizer(ans, delete_QuoteHandleVectorVector)
  ans
  
}

attr(`QuoteHandleVectorVector__SWIG_1`, 'returnType') = '_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t'
attr(`QuoteHandleVectorVector__SWIG_1`, "inputTypes") = c('_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t')
class(`QuoteHandleVectorVector__SWIG_1`) = c("SWIGFunction", class('QuoteHandleVectorVector__SWIG_1'))

# Start of QuoteHandleVectorVector_empty

`QuoteHandleVectorVector_empty` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_QuoteHandleVectorVector_empty', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`QuoteHandleVectorVector_empty`, 'returnType') = 'logical'
attr(`QuoteHandleVectorVector_empty`, "inputTypes") = c('_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t')
class(`QuoteHandleVectorVector_empty`) = c("SWIGFunction", class('QuoteHandleVectorVector_empty'))

# Start of QuoteHandleVectorVector_size

`QuoteHandleVectorVector_size` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_QuoteHandleVectorVector_size', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`QuoteHandleVectorVector_size`, 'returnType') = 'integer'
attr(`QuoteHandleVectorVector_size`, "inputTypes") = c('_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t')
class(`QuoteHandleVectorVector_size`) = c("SWIGFunction", class('QuoteHandleVectorVector_size'))

# Start of QuoteHandleVectorVector_clear

`QuoteHandleVectorVector_clear` = function(self)
{
  ;.Call('R_swig_QuoteHandleVectorVector_clear', self, PACKAGE='QuantLib');
  
}

attr(`QuoteHandleVectorVector_clear`, 'returnType') = 'void'
attr(`QuoteHandleVectorVector_clear`, "inputTypes") = c('_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t')
class(`QuoteHandleVectorVector_clear`) = c("SWIGFunction", class('QuoteHandleVectorVector_clear'))

# Start of QuoteHandleVectorVector_swap

`QuoteHandleVectorVector_swap` = function(self, v)
{
  ;.Call('R_swig_QuoteHandleVectorVector_swap', self, v, PACKAGE='QuantLib');
  
}

attr(`QuoteHandleVectorVector_swap`, 'returnType') = 'void'
attr(`QuoteHandleVectorVector_swap`, "inputTypes") = c('_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t', '_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t')
class(`QuoteHandleVectorVector_swap`) = c("SWIGFunction", class('QuoteHandleVectorVector_swap'))

# Start of QuoteHandleVectorVector_get_allocator

`QuoteHandleVectorVector_get_allocator` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_QuoteHandleVectorVector_get_allocator', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t";
  
  ans
  
}

attr(`QuoteHandleVectorVector_get_allocator`, 'returnType') = '_p_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t'
attr(`QuoteHandleVectorVector_get_allocator`, "inputTypes") = c('_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t')
class(`QuoteHandleVectorVector_get_allocator`) = c("SWIGFunction", class('QuoteHandleVectorVector_get_allocator'))

# Start of new_QuoteHandleVectorVector

`QuoteHandleVectorVector__SWIG_2` = function(size)
{
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_new_QuoteHandleVectorVector__SWIG_2', size, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t";
  
  reg.finalizer(ans, delete_QuoteHandleVectorVector)
  ans
  
}

attr(`QuoteHandleVectorVector__SWIG_2`, 'returnType') = '_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t'
attr(`QuoteHandleVectorVector__SWIG_2`, "inputTypes") = c('integer')
class(`QuoteHandleVectorVector__SWIG_2`) = c("SWIGFunction", class('QuoteHandleVectorVector__SWIG_2'))

# Start of QuoteHandleVectorVector_pop_back

`QuoteHandleVectorVector_pop_back` = function(self)
{
  ;.Call('R_swig_QuoteHandleVectorVector_pop_back', self, PACKAGE='QuantLib');
  
}

attr(`QuoteHandleVectorVector_pop_back`, 'returnType') = 'void'
attr(`QuoteHandleVectorVector_pop_back`, "inputTypes") = c('_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t')
class(`QuoteHandleVectorVector_pop_back`) = c("SWIGFunction", class('QuoteHandleVectorVector_pop_back'))

# Start of QuoteHandleVectorVector_resize

`QuoteHandleVectorVector_resize__SWIG_0` = function(self, new_size)
{
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_QuoteHandleVectorVector_resize__SWIG_0', self, new_size, PACKAGE='QuantLib');
  
}

attr(`QuoteHandleVectorVector_resize__SWIG_0`, 'returnType') = 'void'
attr(`QuoteHandleVectorVector_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t', 'integer')
class(`QuoteHandleVectorVector_resize__SWIG_0`) = c("SWIGFunction", class('QuoteHandleVectorVector_resize__SWIG_0'))

# Start of new_QuoteHandleVectorVector

`QuoteHandleVectorVector__SWIG_3` = function(size, value)
{
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  
  ;ans = .Call('R_swig_new_QuoteHandleVectorVector__SWIG_3', size, value, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t";
  
  reg.finalizer(ans, delete_QuoteHandleVectorVector)
  ans
  
}

attr(`QuoteHandleVectorVector__SWIG_3`, 'returnType') = '_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t'
attr(`QuoteHandleVectorVector__SWIG_3`, "inputTypes") = c('integer', '_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t')
class(`QuoteHandleVectorVector__SWIG_3`) = c("SWIGFunction", class('QuoteHandleVectorVector__SWIG_3'))

`QuoteHandleVectorVector` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- QuoteHandleVectorVector__SWIG_0; 
  } else if (argc == 1) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]]))) {
      f <- QuoteHandleVectorVector__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t')) {
      f <- QuoteHandleVectorVector__SWIG_1; 
    }
  } else if (argc == 2) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && extends(argtypes[2], '_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t')) {
      f <- QuoteHandleVectorVector__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for QuoteHandleVectorVector with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of QuoteHandleVectorVector_push_back

`QuoteHandleVectorVector_push_back` = function(self, x)
{
  ;.Call('R_swig_QuoteHandleVectorVector_push_back', self, x, PACKAGE='QuantLib');
  
}

attr(`QuoteHandleVectorVector_push_back`, 'returnType') = 'void'
attr(`QuoteHandleVectorVector_push_back`, "inputTypes") = c('_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t', '_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t')
class(`QuoteHandleVectorVector_push_back`) = c("SWIGFunction", class('QuoteHandleVectorVector_push_back'))

# Start of QuoteHandleVectorVector_front

`QuoteHandleVectorVector_front` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_QuoteHandleVectorVector_front', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t";
  
  ans
  
}

attr(`QuoteHandleVectorVector_front`, 'returnType') = '_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t'
attr(`QuoteHandleVectorVector_front`, "inputTypes") = c('_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t')
class(`QuoteHandleVectorVector_front`) = c("SWIGFunction", class('QuoteHandleVectorVector_front'))

# Start of QuoteHandleVectorVector_back

`QuoteHandleVectorVector_back` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_QuoteHandleVectorVector_back', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t";
  
  ans
  
}

attr(`QuoteHandleVectorVector_back`, 'returnType') = '_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t'
attr(`QuoteHandleVectorVector_back`, "inputTypes") = c('_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t')
class(`QuoteHandleVectorVector_back`) = c("SWIGFunction", class('QuoteHandleVectorVector_back'))

# Start of QuoteHandleVectorVector_assign

`QuoteHandleVectorVector_assign` = function(self, n, x)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  
  ;.Call('R_swig_QuoteHandleVectorVector_assign', self, n, x, PACKAGE='QuantLib');
  
}

attr(`QuoteHandleVectorVector_assign`, 'returnType') = 'void'
attr(`QuoteHandleVectorVector_assign`, "inputTypes") = c('_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t', 'integer', '_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t')
class(`QuoteHandleVectorVector_assign`) = c("SWIGFunction", class('QuoteHandleVectorVector_assign'))

# Start of QuoteHandleVectorVector_resize

`QuoteHandleVectorVector_resize__SWIG_1` = function(self, new_size, x)
{
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  
  ;.Call('R_swig_QuoteHandleVectorVector_resize__SWIG_1', self, new_size, x, PACKAGE='QuantLib');
  
}

attr(`QuoteHandleVectorVector_resize__SWIG_1`, 'returnType') = 'void'
attr(`QuoteHandleVectorVector_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t', 'integer', '_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t')
class(`QuoteHandleVectorVector_resize__SWIG_1`) = c("SWIGFunction", class('QuoteHandleVectorVector_resize__SWIG_1'))

`QuoteHandleVectorVector_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]]))) {
      f <- QuoteHandleVectorVector_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && extends(argtypes[3], '_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t')) {
      f <- QuoteHandleVectorVector_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for QuoteHandleVectorVector_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of QuoteHandleVectorVector_reserve

`QuoteHandleVectorVector_reserve` = function(self, n)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_QuoteHandleVectorVector_reserve', self, n, PACKAGE='QuantLib');
  
}

attr(`QuoteHandleVectorVector_reserve`, 'returnType') = 'void'
attr(`QuoteHandleVectorVector_reserve`, "inputTypes") = c('_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t', 'integer')
class(`QuoteHandleVectorVector_reserve`) = c("SWIGFunction", class('QuoteHandleVectorVector_reserve'))

# Start of QuoteHandleVectorVector_capacity

`QuoteHandleVectorVector_capacity` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_QuoteHandleVectorVector_capacity', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`QuoteHandleVectorVector_capacity`, 'returnType') = 'integer'
attr(`QuoteHandleVectorVector_capacity`, "inputTypes") = c('_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t')
class(`QuoteHandleVectorVector_capacity`) = c("SWIGFunction", class('QuoteHandleVectorVector_capacity'))

# Start of delete_QuoteHandleVectorVector

`delete_QuoteHandleVectorVector` = function(self)
{
  ;.Call('R_swig_delete_QuoteHandleVectorVector', self, PACKAGE='QuantLib');
  
}

attr(`delete_QuoteHandleVectorVector`, 'returnType') = 'void'
attr(`delete_QuoteHandleVectorVector`, "inputTypes") = c('_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t')
class(`delete_QuoteHandleVectorVector`) = c("SWIGFunction", class('delete_QuoteHandleVectorVector'))

# Start of accessor method for std::vector<(std::vector<(Handle<(Quote)>)>)>
setMethod('$', '_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = QuoteHandleVectorVector___nonzero__, '__len__' = QuoteHandleVectorVector___len__, 'pop' = QuoteHandleVectorVector_pop, '__getslice__' = QuoteHandleVectorVector___getslice__, '__setslice__' = QuoteHandleVectorVector___setslice__, '__delslice__' = QuoteHandleVectorVector___delslice__, '__delitem__' = QuoteHandleVectorVector___delitem__, '__getitem__' = QuoteHandleVectorVector___getitem__, '__setitem__' = QuoteHandleVectorVector___setitem__, 'append' = QuoteHandleVectorVector_append, 'empty' = QuoteHandleVectorVector_empty, 'size' = QuoteHandleVectorVector_size, 'clear' = QuoteHandleVectorVector_clear, 'swap' = QuoteHandleVectorVector_swap, 'get_allocator' = QuoteHandleVectorVector_get_allocator, 'pop_back' = QuoteHandleVectorVector_pop_back, 'resize' = QuoteHandleVectorVector_resize, 'push_back' = QuoteHandleVectorVector_push_back, 'front' = QuoteHandleVectorVector_front, 'back' = QuoteHandleVectorVector_back, 'assign' = QuoteHandleVectorVector_assign, 'reserve' = QuoteHandleVectorVector_reserve, 'capacity' = QuoteHandleVectorVector_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for std::vector<(std::vector<(Handle<(Quote)>)>)>
setMethod('delete', '_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t', function(obj) {delete_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t(obj)})
# Start of RelinkableQuoteHandleVector___nonzero__

`RelinkableQuoteHandleVector___nonzero__` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_RelinkableQuoteHandleVector___nonzero__', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`RelinkableQuoteHandleVector___nonzero__`, 'returnType') = 'logical'
attr(`RelinkableQuoteHandleVector___nonzero__`, "inputTypes") = c('_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t')
class(`RelinkableQuoteHandleVector___nonzero__`) = c("SWIGFunction", class('RelinkableQuoteHandleVector___nonzero__'))

# Start of RelinkableQuoteHandleVector___len__

`RelinkableQuoteHandleVector___len__` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_RelinkableQuoteHandleVector___len__', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`RelinkableQuoteHandleVector___len__`, 'returnType') = 'integer'
attr(`RelinkableQuoteHandleVector___len__`, "inputTypes") = c('_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t')
class(`RelinkableQuoteHandleVector___len__`) = c("SWIGFunction", class('RelinkableQuoteHandleVector___len__'))

# Start of RelinkableQuoteHandleVector_pop

`RelinkableQuoteHandleVector_pop` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_RelinkableQuoteHandleVector_pop', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_RelinkableHandleT_Quote_t";
  
  ans
  
}

attr(`RelinkableQuoteHandleVector_pop`, 'returnType') = '_p_RelinkableHandleT_Quote_t'
attr(`RelinkableQuoteHandleVector_pop`, "inputTypes") = c('_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t')
class(`RelinkableQuoteHandleVector_pop`) = c("SWIGFunction", class('RelinkableQuoteHandleVector_pop'))

# Start of RelinkableQuoteHandleVector___getslice__

`RelinkableQuoteHandleVector___getslice__` = function(self, i, j)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;ans = .Call('R_swig_RelinkableQuoteHandleVector___getslice__', self, i, j, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t";
  
  ans
  
}

attr(`RelinkableQuoteHandleVector___getslice__`, 'returnType') = '_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t'
attr(`RelinkableQuoteHandleVector___getslice__`, "inputTypes") = c('_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t', 'integer', 'integer')
class(`RelinkableQuoteHandleVector___getslice__`) = c("SWIGFunction", class('RelinkableQuoteHandleVector___getslice__'))

# Start of RelinkableQuoteHandleVector___setslice__

`RelinkableQuoteHandleVector___setslice__` = function(self, i, j, v)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  
  ;.Call('R_swig_RelinkableQuoteHandleVector___setslice__', self, i, j, v, PACKAGE='QuantLib');
  
}

attr(`RelinkableQuoteHandleVector___setslice__`, 'returnType') = 'void'
attr(`RelinkableQuoteHandleVector___setslice__`, "inputTypes") = c('_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t', 'integer', 'integer', '_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t')
class(`RelinkableQuoteHandleVector___setslice__`) = c("SWIGFunction", class('RelinkableQuoteHandleVector___setslice__'))

# Start of RelinkableQuoteHandleVector___delslice__

`RelinkableQuoteHandleVector___delslice__` = function(self, i, j)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_RelinkableQuoteHandleVector___delslice__', self, i, j, PACKAGE='QuantLib');
  
}

attr(`RelinkableQuoteHandleVector___delslice__`, 'returnType') = 'void'
attr(`RelinkableQuoteHandleVector___delslice__`, "inputTypes") = c('_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t', 'integer', 'integer')
class(`RelinkableQuoteHandleVector___delslice__`) = c("SWIGFunction", class('RelinkableQuoteHandleVector___delslice__'))

# Start of RelinkableQuoteHandleVector___delitem__

`RelinkableQuoteHandleVector___delitem__` = function(self, i)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_RelinkableQuoteHandleVector___delitem__', self, i, PACKAGE='QuantLib');
  
}

attr(`RelinkableQuoteHandleVector___delitem__`, 'returnType') = 'void'
attr(`RelinkableQuoteHandleVector___delitem__`, "inputTypes") = c('_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t', 'integer')
class(`RelinkableQuoteHandleVector___delitem__`) = c("SWIGFunction", class('RelinkableQuoteHandleVector___delitem__'))

# Start of RelinkableQuoteHandleVector___getitem__

`RelinkableQuoteHandleVector___getitem__` = function(self, i, .copy = FALSE)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;ans = .Call('R_swig_RelinkableQuoteHandleVector___getitem__', self, i, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_RelinkableHandleT_Quote_t";
  
  ans
  
}

attr(`RelinkableQuoteHandleVector___getitem__`, 'returnType') = '_p_RelinkableHandleT_Quote_t'
attr(`RelinkableQuoteHandleVector___getitem__`, "inputTypes") = c('_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t', 'integer')
class(`RelinkableQuoteHandleVector___getitem__`) = c("SWIGFunction", class('RelinkableQuoteHandleVector___getitem__'))

# Start of RelinkableQuoteHandleVector___setitem__

`RelinkableQuoteHandleVector___setitem__` = function(self, i, x)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  ;.Call('R_swig_RelinkableQuoteHandleVector___setitem__', self, i, x, PACKAGE='QuantLib');
  
}

attr(`RelinkableQuoteHandleVector___setitem__`, 'returnType') = 'void'
attr(`RelinkableQuoteHandleVector___setitem__`, "inputTypes") = c('_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t', 'integer', '_p_RelinkableHandleT_Quote_t')
class(`RelinkableQuoteHandleVector___setitem__`) = c("SWIGFunction", class('RelinkableQuoteHandleVector___setitem__'))

# Start of RelinkableQuoteHandleVector_append

`RelinkableQuoteHandleVector_append` = function(self, x)
{
  ;.Call('R_swig_RelinkableQuoteHandleVector_append', self, x, PACKAGE='QuantLib');
  
}

attr(`RelinkableQuoteHandleVector_append`, 'returnType') = 'void'
attr(`RelinkableQuoteHandleVector_append`, "inputTypes") = c('_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t', '_p_RelinkableHandleT_Quote_t')
class(`RelinkableQuoteHandleVector_append`) = c("SWIGFunction", class('RelinkableQuoteHandleVector_append'))

# Start of new_RelinkableQuoteHandleVector

`RelinkableQuoteHandleVector__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_RelinkableQuoteHandleVector__SWIG_0', PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t";
  
  reg.finalizer(ans, delete_RelinkableQuoteHandleVector)
  ans
  
}

attr(`RelinkableQuoteHandleVector__SWIG_0`, 'returnType') = '_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t'
class(`RelinkableQuoteHandleVector__SWIG_0`) = c("SWIGFunction", class('RelinkableQuoteHandleVector__SWIG_0'))

# Start of new_RelinkableQuoteHandleVector

`RelinkableQuoteHandleVector__SWIG_1` = function(s_arg1)
{
  ;ans = .Call('R_swig_new_RelinkableQuoteHandleVector__SWIG_1', s_arg1, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t";
  
  reg.finalizer(ans, delete_RelinkableQuoteHandleVector)
  ans
  
}

attr(`RelinkableQuoteHandleVector__SWIG_1`, 'returnType') = '_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t'
attr(`RelinkableQuoteHandleVector__SWIG_1`, "inputTypes") = c('_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t')
class(`RelinkableQuoteHandleVector__SWIG_1`) = c("SWIGFunction", class('RelinkableQuoteHandleVector__SWIG_1'))

# Start of RelinkableQuoteHandleVector_empty

`RelinkableQuoteHandleVector_empty` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_RelinkableQuoteHandleVector_empty', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`RelinkableQuoteHandleVector_empty`, 'returnType') = 'logical'
attr(`RelinkableQuoteHandleVector_empty`, "inputTypes") = c('_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t')
class(`RelinkableQuoteHandleVector_empty`) = c("SWIGFunction", class('RelinkableQuoteHandleVector_empty'))

# Start of RelinkableQuoteHandleVector_size

`RelinkableQuoteHandleVector_size` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_RelinkableQuoteHandleVector_size', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`RelinkableQuoteHandleVector_size`, 'returnType') = 'integer'
attr(`RelinkableQuoteHandleVector_size`, "inputTypes") = c('_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t')
class(`RelinkableQuoteHandleVector_size`) = c("SWIGFunction", class('RelinkableQuoteHandleVector_size'))

# Start of RelinkableQuoteHandleVector_clear

`RelinkableQuoteHandleVector_clear` = function(self)
{
  ;.Call('R_swig_RelinkableQuoteHandleVector_clear', self, PACKAGE='QuantLib');
  
}

attr(`RelinkableQuoteHandleVector_clear`, 'returnType') = 'void'
attr(`RelinkableQuoteHandleVector_clear`, "inputTypes") = c('_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t')
class(`RelinkableQuoteHandleVector_clear`) = c("SWIGFunction", class('RelinkableQuoteHandleVector_clear'))

# Start of RelinkableQuoteHandleVector_swap

`RelinkableQuoteHandleVector_swap` = function(self, v)
{
  ;.Call('R_swig_RelinkableQuoteHandleVector_swap', self, v, PACKAGE='QuantLib');
  
}

attr(`RelinkableQuoteHandleVector_swap`, 'returnType') = 'void'
attr(`RelinkableQuoteHandleVector_swap`, "inputTypes") = c('_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t', '_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t')
class(`RelinkableQuoteHandleVector_swap`) = c("SWIGFunction", class('RelinkableQuoteHandleVector_swap'))

# Start of RelinkableQuoteHandleVector_get_allocator

`RelinkableQuoteHandleVector_get_allocator` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_RelinkableQuoteHandleVector_get_allocator', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__allocatorT_RelinkableHandleT_Quote_t_t";
  
  ans
  
}

attr(`RelinkableQuoteHandleVector_get_allocator`, 'returnType') = '_p_std__allocatorT_RelinkableHandleT_Quote_t_t'
attr(`RelinkableQuoteHandleVector_get_allocator`, "inputTypes") = c('_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t')
class(`RelinkableQuoteHandleVector_get_allocator`) = c("SWIGFunction", class('RelinkableQuoteHandleVector_get_allocator'))

# Start of new_RelinkableQuoteHandleVector

`RelinkableQuoteHandleVector__SWIG_2` = function(size)
{
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_new_RelinkableQuoteHandleVector__SWIG_2', size, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t";
  
  reg.finalizer(ans, delete_RelinkableQuoteHandleVector)
  ans
  
}

attr(`RelinkableQuoteHandleVector__SWIG_2`, 'returnType') = '_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t'
attr(`RelinkableQuoteHandleVector__SWIG_2`, "inputTypes") = c('integer')
class(`RelinkableQuoteHandleVector__SWIG_2`) = c("SWIGFunction", class('RelinkableQuoteHandleVector__SWIG_2'))

# Start of RelinkableQuoteHandleVector_pop_back

`RelinkableQuoteHandleVector_pop_back` = function(self)
{
  ;.Call('R_swig_RelinkableQuoteHandleVector_pop_back', self, PACKAGE='QuantLib');
  
}

attr(`RelinkableQuoteHandleVector_pop_back`, 'returnType') = 'void'
attr(`RelinkableQuoteHandleVector_pop_back`, "inputTypes") = c('_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t')
class(`RelinkableQuoteHandleVector_pop_back`) = c("SWIGFunction", class('RelinkableQuoteHandleVector_pop_back'))

# Start of RelinkableQuoteHandleVector_resize

`RelinkableQuoteHandleVector_resize__SWIG_0` = function(self, new_size)
{
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_RelinkableQuoteHandleVector_resize__SWIG_0', self, new_size, PACKAGE='QuantLib');
  
}

attr(`RelinkableQuoteHandleVector_resize__SWIG_0`, 'returnType') = 'void'
attr(`RelinkableQuoteHandleVector_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t', 'integer')
class(`RelinkableQuoteHandleVector_resize__SWIG_0`) = c("SWIGFunction", class('RelinkableQuoteHandleVector_resize__SWIG_0'))

# Start of new_RelinkableQuoteHandleVector

`RelinkableQuoteHandleVector__SWIG_3` = function(size, value)
{
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  
  ;ans = .Call('R_swig_new_RelinkableQuoteHandleVector__SWIG_3', size, value, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t";
  
  reg.finalizer(ans, delete_RelinkableQuoteHandleVector)
  ans
  
}

attr(`RelinkableQuoteHandleVector__SWIG_3`, 'returnType') = '_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t'
attr(`RelinkableQuoteHandleVector__SWIG_3`, "inputTypes") = c('integer', '_p_RelinkableHandleT_Quote_t')
class(`RelinkableQuoteHandleVector__SWIG_3`) = c("SWIGFunction", class('RelinkableQuoteHandleVector__SWIG_3'))

`RelinkableQuoteHandleVector` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- RelinkableQuoteHandleVector__SWIG_0; 
  } else if (argc == 1) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]]))) {
      f <- RelinkableQuoteHandleVector__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t')) {
      f <- RelinkableQuoteHandleVector__SWIG_1; 
    }
  } else if (argc == 2) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && extends(argtypes[2], '_p_RelinkableHandleT_Quote_t')) {
      f <- RelinkableQuoteHandleVector__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for RelinkableQuoteHandleVector with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of RelinkableQuoteHandleVector_push_back

`RelinkableQuoteHandleVector_push_back` = function(self, x)
{
  ;.Call('R_swig_RelinkableQuoteHandleVector_push_back', self, x, PACKAGE='QuantLib');
  
}

attr(`RelinkableQuoteHandleVector_push_back`, 'returnType') = 'void'
attr(`RelinkableQuoteHandleVector_push_back`, "inputTypes") = c('_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t', '_p_RelinkableHandleT_Quote_t')
class(`RelinkableQuoteHandleVector_push_back`) = c("SWIGFunction", class('RelinkableQuoteHandleVector_push_back'))

# Start of RelinkableQuoteHandleVector_front

`RelinkableQuoteHandleVector_front` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_RelinkableQuoteHandleVector_front', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_RelinkableHandleT_Quote_t";
  
  ans
  
}

attr(`RelinkableQuoteHandleVector_front`, 'returnType') = '_p_RelinkableHandleT_Quote_t'
attr(`RelinkableQuoteHandleVector_front`, "inputTypes") = c('_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t')
class(`RelinkableQuoteHandleVector_front`) = c("SWIGFunction", class('RelinkableQuoteHandleVector_front'))

# Start of RelinkableQuoteHandleVector_back

`RelinkableQuoteHandleVector_back` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_RelinkableQuoteHandleVector_back', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_RelinkableHandleT_Quote_t";
  
  ans
  
}

attr(`RelinkableQuoteHandleVector_back`, 'returnType') = '_p_RelinkableHandleT_Quote_t'
attr(`RelinkableQuoteHandleVector_back`, "inputTypes") = c('_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t')
class(`RelinkableQuoteHandleVector_back`) = c("SWIGFunction", class('RelinkableQuoteHandleVector_back'))

# Start of RelinkableQuoteHandleVector_assign

`RelinkableQuoteHandleVector_assign` = function(self, n, x)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  
  ;.Call('R_swig_RelinkableQuoteHandleVector_assign', self, n, x, PACKAGE='QuantLib');
  
}

attr(`RelinkableQuoteHandleVector_assign`, 'returnType') = 'void'
attr(`RelinkableQuoteHandleVector_assign`, "inputTypes") = c('_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t', 'integer', '_p_RelinkableHandleT_Quote_t')
class(`RelinkableQuoteHandleVector_assign`) = c("SWIGFunction", class('RelinkableQuoteHandleVector_assign'))

# Start of RelinkableQuoteHandleVector_resize

`RelinkableQuoteHandleVector_resize__SWIG_1` = function(self, new_size, x)
{
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  
  ;.Call('R_swig_RelinkableQuoteHandleVector_resize__SWIG_1', self, new_size, x, PACKAGE='QuantLib');
  
}

attr(`RelinkableQuoteHandleVector_resize__SWIG_1`, 'returnType') = 'void'
attr(`RelinkableQuoteHandleVector_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t', 'integer', '_p_RelinkableHandleT_Quote_t')
class(`RelinkableQuoteHandleVector_resize__SWIG_1`) = c("SWIGFunction", class('RelinkableQuoteHandleVector_resize__SWIG_1'))

`RelinkableQuoteHandleVector_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]]))) {
      f <- RelinkableQuoteHandleVector_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && extends(argtypes[3], '_p_RelinkableHandleT_Quote_t')) {
      f <- RelinkableQuoteHandleVector_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for RelinkableQuoteHandleVector_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of RelinkableQuoteHandleVector_reserve

`RelinkableQuoteHandleVector_reserve` = function(self, n)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_RelinkableQuoteHandleVector_reserve', self, n, PACKAGE='QuantLib');
  
}

attr(`RelinkableQuoteHandleVector_reserve`, 'returnType') = 'void'
attr(`RelinkableQuoteHandleVector_reserve`, "inputTypes") = c('_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t', 'integer')
class(`RelinkableQuoteHandleVector_reserve`) = c("SWIGFunction", class('RelinkableQuoteHandleVector_reserve'))

# Start of RelinkableQuoteHandleVector_capacity

`RelinkableQuoteHandleVector_capacity` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_RelinkableQuoteHandleVector_capacity', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`RelinkableQuoteHandleVector_capacity`, 'returnType') = 'integer'
attr(`RelinkableQuoteHandleVector_capacity`, "inputTypes") = c('_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t')
class(`RelinkableQuoteHandleVector_capacity`) = c("SWIGFunction", class('RelinkableQuoteHandleVector_capacity'))

# Start of delete_RelinkableQuoteHandleVector

`delete_RelinkableQuoteHandleVector` = function(self)
{
  ;.Call('R_swig_delete_RelinkableQuoteHandleVector', self, PACKAGE='QuantLib');
  
}

attr(`delete_RelinkableQuoteHandleVector`, 'returnType') = 'void'
attr(`delete_RelinkableQuoteHandleVector`, "inputTypes") = c('_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t')
class(`delete_RelinkableQuoteHandleVector`) = c("SWIGFunction", class('delete_RelinkableQuoteHandleVector'))

# Start of accessor method for std::vector<(RelinkableHandle<(Quote)>)>
setMethod('$', '_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = RelinkableQuoteHandleVector___nonzero__, '__len__' = RelinkableQuoteHandleVector___len__, 'pop' = RelinkableQuoteHandleVector_pop, '__getslice__' = RelinkableQuoteHandleVector___getslice__, '__setslice__' = RelinkableQuoteHandleVector___setslice__, '__delslice__' = RelinkableQuoteHandleVector___delslice__, '__delitem__' = RelinkableQuoteHandleVector___delitem__, '__getitem__' = RelinkableQuoteHandleVector___getitem__, '__setitem__' = RelinkableQuoteHandleVector___setitem__, 'append' = RelinkableQuoteHandleVector_append, 'empty' = RelinkableQuoteHandleVector_empty, 'size' = RelinkableQuoteHandleVector_size, 'clear' = RelinkableQuoteHandleVector_clear, 'swap' = RelinkableQuoteHandleVector_swap, 'get_allocator' = RelinkableQuoteHandleVector_get_allocator, 'pop_back' = RelinkableQuoteHandleVector_pop_back, 'resize' = RelinkableQuoteHandleVector_resize, 'push_back' = RelinkableQuoteHandleVector_push_back, 'front' = RelinkableQuoteHandleVector_front, 'back' = RelinkableQuoteHandleVector_back, 'assign' = RelinkableQuoteHandleVector_assign, 'reserve' = RelinkableQuoteHandleVector_reserve, 'capacity' = RelinkableQuoteHandleVector_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for std::vector<(RelinkableHandle<(Quote)>)>
setMethod('delete', '_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t', function(obj) {delete_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t(obj)})
# Start of RelinkableQuoteHandleVectorVector___nonzero__

`RelinkableQuoteHandleVectorVector___nonzero__` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_RelinkableQuoteHandleVectorVector___nonzero__', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`RelinkableQuoteHandleVectorVector___nonzero__`, 'returnType') = 'logical'
attr(`RelinkableQuoteHandleVectorVector___nonzero__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_std__allocatorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_t_t')
class(`RelinkableQuoteHandleVectorVector___nonzero__`) = c("SWIGFunction", class('RelinkableQuoteHandleVectorVector___nonzero__'))

# Start of RelinkableQuoteHandleVectorVector___len__

`RelinkableQuoteHandleVectorVector___len__` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_RelinkableQuoteHandleVectorVector___len__', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`RelinkableQuoteHandleVectorVector___len__`, 'returnType') = 'integer'
attr(`RelinkableQuoteHandleVectorVector___len__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_std__allocatorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_t_t')
class(`RelinkableQuoteHandleVectorVector___len__`) = c("SWIGFunction", class('RelinkableQuoteHandleVectorVector___len__'))

# Start of RelinkableQuoteHandleVectorVector_pop

`RelinkableQuoteHandleVectorVector_pop` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_RelinkableQuoteHandleVectorVector_pop', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t";
  
  ans
  
}

attr(`RelinkableQuoteHandleVectorVector_pop`, 'returnType') = '_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t'
attr(`RelinkableQuoteHandleVectorVector_pop`, "inputTypes") = c('_p_std__vectorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_std__allocatorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_t_t')
class(`RelinkableQuoteHandleVectorVector_pop`) = c("SWIGFunction", class('RelinkableQuoteHandleVectorVector_pop'))

# Start of RelinkableQuoteHandleVectorVector___getslice__

`RelinkableQuoteHandleVectorVector___getslice__` = function(self, i, j)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;ans = .Call('R_swig_RelinkableQuoteHandleVectorVector___getslice__', self, i, j, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_std__allocatorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_t_t";
  
  ans
  
}

attr(`RelinkableQuoteHandleVectorVector___getslice__`, 'returnType') = '_p_std__vectorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_std__allocatorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_t_t'
attr(`RelinkableQuoteHandleVectorVector___getslice__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_std__allocatorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_t_t', 'integer', 'integer')
class(`RelinkableQuoteHandleVectorVector___getslice__`) = c("SWIGFunction", class('RelinkableQuoteHandleVectorVector___getslice__'))

# Start of RelinkableQuoteHandleVectorVector___setslice__

`RelinkableQuoteHandleVectorVector___setslice__` = function(self, i, j, v)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  
  ;.Call('R_swig_RelinkableQuoteHandleVectorVector___setslice__', self, i, j, v, PACKAGE='QuantLib');
  
}

attr(`RelinkableQuoteHandleVectorVector___setslice__`, 'returnType') = 'void'
attr(`RelinkableQuoteHandleVectorVector___setslice__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_std__allocatorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_t_t', 'integer', 'integer', '_p_std__vectorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_std__allocatorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_t_t')
class(`RelinkableQuoteHandleVectorVector___setslice__`) = c("SWIGFunction", class('RelinkableQuoteHandleVectorVector___setslice__'))

# Start of RelinkableQuoteHandleVectorVector___delslice__

`RelinkableQuoteHandleVectorVector___delslice__` = function(self, i, j)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_RelinkableQuoteHandleVectorVector___delslice__', self, i, j, PACKAGE='QuantLib');
  
}

attr(`RelinkableQuoteHandleVectorVector___delslice__`, 'returnType') = 'void'
attr(`RelinkableQuoteHandleVectorVector___delslice__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_std__allocatorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_t_t', 'integer', 'integer')
class(`RelinkableQuoteHandleVectorVector___delslice__`) = c("SWIGFunction", class('RelinkableQuoteHandleVectorVector___delslice__'))

# Start of RelinkableQuoteHandleVectorVector___delitem__

`RelinkableQuoteHandleVectorVector___delitem__` = function(self, i)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_RelinkableQuoteHandleVectorVector___delitem__', self, i, PACKAGE='QuantLib');
  
}

attr(`RelinkableQuoteHandleVectorVector___delitem__`, 'returnType') = 'void'
attr(`RelinkableQuoteHandleVectorVector___delitem__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_std__allocatorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_t_t', 'integer')
class(`RelinkableQuoteHandleVectorVector___delitem__`) = c("SWIGFunction", class('RelinkableQuoteHandleVectorVector___delitem__'))

# Start of RelinkableQuoteHandleVectorVector___getitem__

`RelinkableQuoteHandleVectorVector___getitem__` = function(self, i, .copy = FALSE)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;ans = .Call('R_swig_RelinkableQuoteHandleVectorVector___getitem__', self, i, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t";
  
  ans
  
}

attr(`RelinkableQuoteHandleVectorVector___getitem__`, 'returnType') = '_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t'
attr(`RelinkableQuoteHandleVectorVector___getitem__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_std__allocatorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_t_t', 'integer')
class(`RelinkableQuoteHandleVectorVector___getitem__`) = c("SWIGFunction", class('RelinkableQuoteHandleVectorVector___getitem__'))

# Start of RelinkableQuoteHandleVectorVector___setitem__

`RelinkableQuoteHandleVectorVector___setitem__` = function(self, i, x)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  ;.Call('R_swig_RelinkableQuoteHandleVectorVector___setitem__', self, i, x, PACKAGE='QuantLib');
  
}

attr(`RelinkableQuoteHandleVectorVector___setitem__`, 'returnType') = 'void'
attr(`RelinkableQuoteHandleVectorVector___setitem__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_std__allocatorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_t_t', 'integer', '_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t')
class(`RelinkableQuoteHandleVectorVector___setitem__`) = c("SWIGFunction", class('RelinkableQuoteHandleVectorVector___setitem__'))

# Start of RelinkableQuoteHandleVectorVector_append

`RelinkableQuoteHandleVectorVector_append` = function(self, x)
{
  ;.Call('R_swig_RelinkableQuoteHandleVectorVector_append', self, x, PACKAGE='QuantLib');
  
}

attr(`RelinkableQuoteHandleVectorVector_append`, 'returnType') = 'void'
attr(`RelinkableQuoteHandleVectorVector_append`, "inputTypes") = c('_p_std__vectorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_std__allocatorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_t_t', '_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t')
class(`RelinkableQuoteHandleVectorVector_append`) = c("SWIGFunction", class('RelinkableQuoteHandleVectorVector_append'))

# Start of new_RelinkableQuoteHandleVectorVector

`RelinkableQuoteHandleVectorVector__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_RelinkableQuoteHandleVectorVector__SWIG_0', PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_std__allocatorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_t_t";
  
  reg.finalizer(ans, delete_RelinkableQuoteHandleVectorVector)
  ans
  
}

attr(`RelinkableQuoteHandleVectorVector__SWIG_0`, 'returnType') = '_p_std__vectorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_std__allocatorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_t_t'
class(`RelinkableQuoteHandleVectorVector__SWIG_0`) = c("SWIGFunction", class('RelinkableQuoteHandleVectorVector__SWIG_0'))

# Start of new_RelinkableQuoteHandleVectorVector

`RelinkableQuoteHandleVectorVector__SWIG_1` = function(s_arg1)
{
  ;ans = .Call('R_swig_new_RelinkableQuoteHandleVectorVector__SWIG_1', s_arg1, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_std__allocatorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_t_t";
  
  reg.finalizer(ans, delete_RelinkableQuoteHandleVectorVector)
  ans
  
}

attr(`RelinkableQuoteHandleVectorVector__SWIG_1`, 'returnType') = '_p_std__vectorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_std__allocatorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_t_t'
attr(`RelinkableQuoteHandleVectorVector__SWIG_1`, "inputTypes") = c('_p_std__vectorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_std__allocatorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_t_t')
class(`RelinkableQuoteHandleVectorVector__SWIG_1`) = c("SWIGFunction", class('RelinkableQuoteHandleVectorVector__SWIG_1'))

# Start of RelinkableQuoteHandleVectorVector_empty

`RelinkableQuoteHandleVectorVector_empty` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_RelinkableQuoteHandleVectorVector_empty', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`RelinkableQuoteHandleVectorVector_empty`, 'returnType') = 'logical'
attr(`RelinkableQuoteHandleVectorVector_empty`, "inputTypes") = c('_p_std__vectorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_std__allocatorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_t_t')
class(`RelinkableQuoteHandleVectorVector_empty`) = c("SWIGFunction", class('RelinkableQuoteHandleVectorVector_empty'))

# Start of RelinkableQuoteHandleVectorVector_size

`RelinkableQuoteHandleVectorVector_size` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_RelinkableQuoteHandleVectorVector_size', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`RelinkableQuoteHandleVectorVector_size`, 'returnType') = 'integer'
attr(`RelinkableQuoteHandleVectorVector_size`, "inputTypes") = c('_p_std__vectorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_std__allocatorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_t_t')
class(`RelinkableQuoteHandleVectorVector_size`) = c("SWIGFunction", class('RelinkableQuoteHandleVectorVector_size'))

# Start of RelinkableQuoteHandleVectorVector_clear

`RelinkableQuoteHandleVectorVector_clear` = function(self)
{
  ;.Call('R_swig_RelinkableQuoteHandleVectorVector_clear', self, PACKAGE='QuantLib');
  
}

attr(`RelinkableQuoteHandleVectorVector_clear`, 'returnType') = 'void'
attr(`RelinkableQuoteHandleVectorVector_clear`, "inputTypes") = c('_p_std__vectorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_std__allocatorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_t_t')
class(`RelinkableQuoteHandleVectorVector_clear`) = c("SWIGFunction", class('RelinkableQuoteHandleVectorVector_clear'))

# Start of RelinkableQuoteHandleVectorVector_swap

`RelinkableQuoteHandleVectorVector_swap` = function(self, v)
{
  ;.Call('R_swig_RelinkableQuoteHandleVectorVector_swap', self, v, PACKAGE='QuantLib');
  
}

attr(`RelinkableQuoteHandleVectorVector_swap`, 'returnType') = 'void'
attr(`RelinkableQuoteHandleVectorVector_swap`, "inputTypes") = c('_p_std__vectorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_std__allocatorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_t_t', '_p_std__vectorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_std__allocatorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_t_t')
class(`RelinkableQuoteHandleVectorVector_swap`) = c("SWIGFunction", class('RelinkableQuoteHandleVectorVector_swap'))

# Start of RelinkableQuoteHandleVectorVector_get_allocator

`RelinkableQuoteHandleVectorVector_get_allocator` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_RelinkableQuoteHandleVectorVector_get_allocator', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__allocatorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_t";
  
  ans
  
}

attr(`RelinkableQuoteHandleVectorVector_get_allocator`, 'returnType') = '_p_std__allocatorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_t'
attr(`RelinkableQuoteHandleVectorVector_get_allocator`, "inputTypes") = c('_p_std__vectorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_std__allocatorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_t_t')
class(`RelinkableQuoteHandleVectorVector_get_allocator`) = c("SWIGFunction", class('RelinkableQuoteHandleVectorVector_get_allocator'))

# Start of new_RelinkableQuoteHandleVectorVector

`RelinkableQuoteHandleVectorVector__SWIG_2` = function(size)
{
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_new_RelinkableQuoteHandleVectorVector__SWIG_2', size, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_std__allocatorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_t_t";
  
  reg.finalizer(ans, delete_RelinkableQuoteHandleVectorVector)
  ans
  
}

attr(`RelinkableQuoteHandleVectorVector__SWIG_2`, 'returnType') = '_p_std__vectorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_std__allocatorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_t_t'
attr(`RelinkableQuoteHandleVectorVector__SWIG_2`, "inputTypes") = c('integer')
class(`RelinkableQuoteHandleVectorVector__SWIG_2`) = c("SWIGFunction", class('RelinkableQuoteHandleVectorVector__SWIG_2'))

# Start of RelinkableQuoteHandleVectorVector_pop_back

`RelinkableQuoteHandleVectorVector_pop_back` = function(self)
{
  ;.Call('R_swig_RelinkableQuoteHandleVectorVector_pop_back', self, PACKAGE='QuantLib');
  
}

attr(`RelinkableQuoteHandleVectorVector_pop_back`, 'returnType') = 'void'
attr(`RelinkableQuoteHandleVectorVector_pop_back`, "inputTypes") = c('_p_std__vectorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_std__allocatorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_t_t')
class(`RelinkableQuoteHandleVectorVector_pop_back`) = c("SWIGFunction", class('RelinkableQuoteHandleVectorVector_pop_back'))

# Start of RelinkableQuoteHandleVectorVector_resize

`RelinkableQuoteHandleVectorVector_resize__SWIG_0` = function(self, new_size)
{
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_RelinkableQuoteHandleVectorVector_resize__SWIG_0', self, new_size, PACKAGE='QuantLib');
  
}

attr(`RelinkableQuoteHandleVectorVector_resize__SWIG_0`, 'returnType') = 'void'
attr(`RelinkableQuoteHandleVectorVector_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_std__allocatorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_t_t', 'integer')
class(`RelinkableQuoteHandleVectorVector_resize__SWIG_0`) = c("SWIGFunction", class('RelinkableQuoteHandleVectorVector_resize__SWIG_0'))

# Start of new_RelinkableQuoteHandleVectorVector

`RelinkableQuoteHandleVectorVector__SWIG_3` = function(size, value)
{
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  
  ;ans = .Call('R_swig_new_RelinkableQuoteHandleVectorVector__SWIG_3', size, value, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_std__allocatorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_t_t";
  
  reg.finalizer(ans, delete_RelinkableQuoteHandleVectorVector)
  ans
  
}

attr(`RelinkableQuoteHandleVectorVector__SWIG_3`, 'returnType') = '_p_std__vectorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_std__allocatorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_t_t'
attr(`RelinkableQuoteHandleVectorVector__SWIG_3`, "inputTypes") = c('integer', '_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t')
class(`RelinkableQuoteHandleVectorVector__SWIG_3`) = c("SWIGFunction", class('RelinkableQuoteHandleVectorVector__SWIG_3'))

`RelinkableQuoteHandleVectorVector` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- RelinkableQuoteHandleVectorVector__SWIG_0; 
  } else if (argc == 1) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]]))) {
      f <- RelinkableQuoteHandleVectorVector__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_std__allocatorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_t_t')) {
      f <- RelinkableQuoteHandleVectorVector__SWIG_1; 
    }
  } else if (argc == 2) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && extends(argtypes[2], '_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t')) {
      f <- RelinkableQuoteHandleVectorVector__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for RelinkableQuoteHandleVectorVector with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of RelinkableQuoteHandleVectorVector_push_back

`RelinkableQuoteHandleVectorVector_push_back` = function(self, x)
{
  ;.Call('R_swig_RelinkableQuoteHandleVectorVector_push_back', self, x, PACKAGE='QuantLib');
  
}

attr(`RelinkableQuoteHandleVectorVector_push_back`, 'returnType') = 'void'
attr(`RelinkableQuoteHandleVectorVector_push_back`, "inputTypes") = c('_p_std__vectorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_std__allocatorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_t_t', '_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t')
class(`RelinkableQuoteHandleVectorVector_push_back`) = c("SWIGFunction", class('RelinkableQuoteHandleVectorVector_push_back'))

# Start of RelinkableQuoteHandleVectorVector_front

`RelinkableQuoteHandleVectorVector_front` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_RelinkableQuoteHandleVectorVector_front', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t";
  
  ans
  
}

attr(`RelinkableQuoteHandleVectorVector_front`, 'returnType') = '_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t'
attr(`RelinkableQuoteHandleVectorVector_front`, "inputTypes") = c('_p_std__vectorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_std__allocatorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_t_t')
class(`RelinkableQuoteHandleVectorVector_front`) = c("SWIGFunction", class('RelinkableQuoteHandleVectorVector_front'))

# Start of RelinkableQuoteHandleVectorVector_back

`RelinkableQuoteHandleVectorVector_back` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_RelinkableQuoteHandleVectorVector_back', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t";
  
  ans
  
}

attr(`RelinkableQuoteHandleVectorVector_back`, 'returnType') = '_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t'
attr(`RelinkableQuoteHandleVectorVector_back`, "inputTypes") = c('_p_std__vectorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_std__allocatorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_t_t')
class(`RelinkableQuoteHandleVectorVector_back`) = c("SWIGFunction", class('RelinkableQuoteHandleVectorVector_back'))

# Start of RelinkableQuoteHandleVectorVector_assign

`RelinkableQuoteHandleVectorVector_assign` = function(self, n, x)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  
  ;.Call('R_swig_RelinkableQuoteHandleVectorVector_assign', self, n, x, PACKAGE='QuantLib');
  
}

attr(`RelinkableQuoteHandleVectorVector_assign`, 'returnType') = 'void'
attr(`RelinkableQuoteHandleVectorVector_assign`, "inputTypes") = c('_p_std__vectorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_std__allocatorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_t_t', 'integer', '_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t')
class(`RelinkableQuoteHandleVectorVector_assign`) = c("SWIGFunction", class('RelinkableQuoteHandleVectorVector_assign'))

# Start of RelinkableQuoteHandleVectorVector_resize

`RelinkableQuoteHandleVectorVector_resize__SWIG_1` = function(self, new_size, x)
{
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  
  ;.Call('R_swig_RelinkableQuoteHandleVectorVector_resize__SWIG_1', self, new_size, x, PACKAGE='QuantLib');
  
}

attr(`RelinkableQuoteHandleVectorVector_resize__SWIG_1`, 'returnType') = 'void'
attr(`RelinkableQuoteHandleVectorVector_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_std__allocatorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_t_t', 'integer', '_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t')
class(`RelinkableQuoteHandleVectorVector_resize__SWIG_1`) = c("SWIGFunction", class('RelinkableQuoteHandleVectorVector_resize__SWIG_1'))

`RelinkableQuoteHandleVectorVector_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_std__vectorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_std__allocatorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_t_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]]))) {
      f <- RelinkableQuoteHandleVectorVector_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_std__vectorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_std__allocatorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_t_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && extends(argtypes[3], '_p_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t')) {
      f <- RelinkableQuoteHandleVectorVector_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for RelinkableQuoteHandleVectorVector_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of RelinkableQuoteHandleVectorVector_reserve

`RelinkableQuoteHandleVectorVector_reserve` = function(self, n)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_RelinkableQuoteHandleVectorVector_reserve', self, n, PACKAGE='QuantLib');
  
}

attr(`RelinkableQuoteHandleVectorVector_reserve`, 'returnType') = 'void'
attr(`RelinkableQuoteHandleVectorVector_reserve`, "inputTypes") = c('_p_std__vectorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_std__allocatorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_t_t', 'integer')
class(`RelinkableQuoteHandleVectorVector_reserve`) = c("SWIGFunction", class('RelinkableQuoteHandleVectorVector_reserve'))

# Start of RelinkableQuoteHandleVectorVector_capacity

`RelinkableQuoteHandleVectorVector_capacity` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_RelinkableQuoteHandleVectorVector_capacity', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`RelinkableQuoteHandleVectorVector_capacity`, 'returnType') = 'integer'
attr(`RelinkableQuoteHandleVectorVector_capacity`, "inputTypes") = c('_p_std__vectorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_std__allocatorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_t_t')
class(`RelinkableQuoteHandleVectorVector_capacity`) = c("SWIGFunction", class('RelinkableQuoteHandleVectorVector_capacity'))

# Start of delete_RelinkableQuoteHandleVectorVector

`delete_RelinkableQuoteHandleVectorVector` = function(self)
{
  ;.Call('R_swig_delete_RelinkableQuoteHandleVectorVector', self, PACKAGE='QuantLib');
  
}

attr(`delete_RelinkableQuoteHandleVectorVector`, 'returnType') = 'void'
attr(`delete_RelinkableQuoteHandleVectorVector`, "inputTypes") = c('_p_std__vectorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_std__allocatorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_t_t')
class(`delete_RelinkableQuoteHandleVectorVector`) = c("SWIGFunction", class('delete_RelinkableQuoteHandleVectorVector'))

# Start of accessor method for std::vector<(std::vector<(RelinkableHandle<(Quote)>)>)>
setMethod('$', '_p_std__vectorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_std__allocatorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = RelinkableQuoteHandleVectorVector___nonzero__, '__len__' = RelinkableQuoteHandleVectorVector___len__, 'pop' = RelinkableQuoteHandleVectorVector_pop, '__getslice__' = RelinkableQuoteHandleVectorVector___getslice__, '__setslice__' = RelinkableQuoteHandleVectorVector___setslice__, '__delslice__' = RelinkableQuoteHandleVectorVector___delslice__, '__delitem__' = RelinkableQuoteHandleVectorVector___delitem__, '__getitem__' = RelinkableQuoteHandleVectorVector___getitem__, '__setitem__' = RelinkableQuoteHandleVectorVector___setitem__, 'append' = RelinkableQuoteHandleVectorVector_append, 'empty' = RelinkableQuoteHandleVectorVector_empty, 'size' = RelinkableQuoteHandleVectorVector_size, 'clear' = RelinkableQuoteHandleVectorVector_clear, 'swap' = RelinkableQuoteHandleVectorVector_swap, 'get_allocator' = RelinkableQuoteHandleVectorVector_get_allocator, 'pop_back' = RelinkableQuoteHandleVectorVector_pop_back, 'resize' = RelinkableQuoteHandleVectorVector_resize, 'push_back' = RelinkableQuoteHandleVectorVector_push_back, 'front' = RelinkableQuoteHandleVectorVector_front, 'back' = RelinkableQuoteHandleVectorVector_back, 'assign' = RelinkableQuoteHandleVectorVector_assign, 'reserve' = RelinkableQuoteHandleVectorVector_reserve, 'capacity' = RelinkableQuoteHandleVectorVector_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for std::vector<(std::vector<(RelinkableHandle<(Quote)>)>)>
setMethod('delete', '_p_std__vectorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_std__allocatorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_t_t', function(obj) {delete_std__vectorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_std__allocatorT_std__vectorT_RelinkableHandleT_Quote_t_std__allocatorT_RelinkableHandleT_Quote_t_t_t_t_t(obj)})
# Start of nullInt

`nullInt` = function(.copy = FALSE)
{
  ;.Call('R_swig_nullInt', as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`nullInt`, 'returnType') = 'integer'
class(`nullInt`) = c("SWIGFunction", class('nullInt'))

# Start of nullDouble

`nullDouble` = function(.copy = FALSE)
{
  ;.Call('R_swig_nullDouble', as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`nullDouble`, 'returnType') = 'numeric'
class(`nullDouble`) = c("SWIGFunction", class('nullDouble'))

# Start of DayCounter_dayCount

`DayCounter_dayCount` = function(self, d1, d2, .copy = FALSE)
{
  ;.Call('R_swig_DayCounter_dayCount', self, d1, d2, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DayCounter_dayCount`, 'returnType') = 'integer'
attr(`DayCounter_dayCount`, "inputTypes") = c('_p_DayCounter', '_p_Date', '_p_Date')
class(`DayCounter_dayCount`) = c("SWIGFunction", class('DayCounter_dayCount'))

# Start of DayCounter_yearFraction

`DayCounter_yearFraction__SWIG_0` = function(self, d1, d2, startRef, endRef, .copy = FALSE)
{
  ;.Call('R_swig_DayCounter_yearFraction__SWIG_0', self, d1, d2, startRef, endRef, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DayCounter_yearFraction__SWIG_0`, 'returnType') = 'numeric'
attr(`DayCounter_yearFraction__SWIG_0`, "inputTypes") = c('_p_DayCounter', '_p_Date', '_p_Date', '_p_Date', '_p_Date')
class(`DayCounter_yearFraction__SWIG_0`) = c("SWIGFunction", class('DayCounter_yearFraction__SWIG_0'))

# Start of DayCounter_yearFraction

`DayCounter_yearFraction__SWIG_1` = function(self, d1, d2, startRef, .copy = FALSE)
{
  ;.Call('R_swig_DayCounter_yearFraction__SWIG_1', self, d1, d2, startRef, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DayCounter_yearFraction__SWIG_1`, 'returnType') = 'numeric'
attr(`DayCounter_yearFraction__SWIG_1`, "inputTypes") = c('_p_DayCounter', '_p_Date', '_p_Date', '_p_Date')
class(`DayCounter_yearFraction__SWIG_1`) = c("SWIGFunction", class('DayCounter_yearFraction__SWIG_1'))

# Start of DayCounter_yearFraction

`DayCounter_yearFraction__SWIG_2` = function(self, d1, d2, .copy = FALSE)
{
  ;.Call('R_swig_DayCounter_yearFraction__SWIG_2', self, d1, d2, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DayCounter_yearFraction__SWIG_2`, 'returnType') = 'numeric'
attr(`DayCounter_yearFraction__SWIG_2`, "inputTypes") = c('_p_DayCounter', '_p_Date', '_p_Date')
class(`DayCounter_yearFraction__SWIG_2`) = c("SWIGFunction", class('DayCounter_yearFraction__SWIG_2'))

`DayCounter_yearFraction` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 3) {
    if (extends(argtypes[1], '_p_DayCounter') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_Date')) {
      f <- DayCounter_yearFraction__SWIG_2; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_DayCounter') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_Date') && extends(argtypes[4], '_p_Date')) {
      f <- DayCounter_yearFraction__SWIG_1; 
    }
  } else if (argc == 5) {
    if (extends(argtypes[1], '_p_DayCounter') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_Date') && extends(argtypes[4], '_p_Date') && extends(argtypes[5], '_p_Date')) {
      f <- DayCounter_yearFraction__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for DayCounter_yearFraction with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of DayCounter_name

`DayCounter_name` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_DayCounter_name', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DayCounter_name`, 'returnType') = 'character'
attr(`DayCounter_name`, "inputTypes") = c('_p_DayCounter')
class(`DayCounter_name`) = c("SWIGFunction", class('DayCounter_name'))

# Start of DayCounter___str__

`DayCounter___str__` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_DayCounter___str__', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DayCounter___str__`, 'returnType') = 'character'
attr(`DayCounter___str__`, "inputTypes") = c('_p_DayCounter')
class(`DayCounter___str__`) = c("SWIGFunction", class('DayCounter___str__'))

# Start of delete_DayCounter

`delete_DayCounter` = function(self)
{
  ;.Call('R_swig_delete_DayCounter', self, PACKAGE='QuantLib');
  
}

attr(`delete_DayCounter`, 'returnType') = 'void'
attr(`delete_DayCounter`, "inputTypes") = c('_p_DayCounter')
class(`delete_DayCounter`) = c("SWIGFunction", class('delete_DayCounter'))

# Start of accessor method for DayCounter
setMethod('$', '_p_DayCounter', function(x, name)

{
  accessorFuns = list('dayCount' = DayCounter_dayCount, 'yearFraction' = DayCounter_yearFraction, 'name' = DayCounter_name, '__str__' = DayCounter___str__);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for DayCounter
setMethod('delete', '_p_DayCounter', function(obj) {delete_DayCounter(obj)})
# Start of new_Actual360

`Actual360` = function()
{
  ;ans = .Call('R_swig_new_Actual360', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__Actual360";
  
  reg.finalizer(ans, delete_Actual360)
  ans
  
}

attr(`Actual360`, 'returnType') = '_p_QuantLib__Actual360'
class(`Actual360`) = c("SWIGFunction", class('Actual360'))

# Start of delete_Actual360

`delete_Actual360` = function(self)
{
  ;.Call('R_swig_delete_Actual360', self, PACKAGE='QuantLib');
  
}

attr(`delete_Actual360`, 'returnType') = 'void'
attr(`delete_Actual360`, "inputTypes") = c('_p_QuantLib__Actual360')
class(`delete_Actual360`) = c("SWIGFunction", class('delete_Actual360'))

setMethod('delete', '_p_QuantLib__Actual360', function(obj) {delete_QuantLib__Actual360(obj)})
# Start of new_Actual365Fixed

`Actual365Fixed` = function()
{
  ;ans = .Call('R_swig_new_Actual365Fixed', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__Actual365Fixed";
  
  reg.finalizer(ans, delete_Actual365Fixed)
  ans
  
}

attr(`Actual365Fixed`, 'returnType') = '_p_QuantLib__Actual365Fixed'
class(`Actual365Fixed`) = c("SWIGFunction", class('Actual365Fixed'))

# Start of delete_Actual365Fixed

`delete_Actual365Fixed` = function(self)
{
  ;.Call('R_swig_delete_Actual365Fixed', self, PACKAGE='QuantLib');
  
}

attr(`delete_Actual365Fixed`, 'returnType') = 'void'
attr(`delete_Actual365Fixed`, "inputTypes") = c('_p_QuantLib__Actual365Fixed')
class(`delete_Actual365Fixed`) = c("SWIGFunction", class('delete_Actual365Fixed'))

setMethod('delete', '_p_QuantLib__Actual365Fixed', function(obj) {delete_QuantLib__Actual365Fixed(obj)})
defineEnumeration('_QuantLib__Thirty360__Convention',
                    .values = c(
                        'USA' = 0, 
                        'BondBasis' = 1, 
                        'European' = 2, 
                        'EurobondBasis' = 3, 
                        'Italian' = 4
))
# Start of new_Thirty360

`Thirty360__SWIG_0` = function(c)
{
  c = enumToInteger(c, "_QuantLib__Thirty360__Convention"); 
  
  if(length(c) > 1) {
    warning("using only the first element of c");
  };
  
  ;ans = .Call('R_swig_new_Thirty360__SWIG_0', c, PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__Thirty360";
  
  reg.finalizer(ans, delete_Thirty360)
  ans
  
}

attr(`Thirty360__SWIG_0`, 'returnType') = '_p_QuantLib__Thirty360'
attr(`Thirty360__SWIG_0`, "inputTypes") = c('character')
class(`Thirty360__SWIG_0`) = c("SWIGFunction", class('Thirty360__SWIG_0'))

# Start of new_Thirty360

`Thirty360__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_Thirty360__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__Thirty360";
  
  reg.finalizer(ans, delete_Thirty360)
  ans
  
}

attr(`Thirty360__SWIG_1`, 'returnType') = '_p_QuantLib__Thirty360'
class(`Thirty360__SWIG_1`) = c("SWIGFunction", class('Thirty360__SWIG_1'))

`Thirty360` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- Thirty360__SWIG_1; 
  } else if (argc == 1) {
    if (is.character(argv[[1]])) {
      f <- Thirty360__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Thirty360 with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_Thirty360

`delete_Thirty360` = function(self)
{
  ;.Call('R_swig_delete_Thirty360', self, PACKAGE='QuantLib');
  
}

attr(`delete_Thirty360`, 'returnType') = 'void'
attr(`delete_Thirty360`, "inputTypes") = c('_p_QuantLib__Thirty360')
class(`delete_Thirty360`) = c("SWIGFunction", class('delete_Thirty360'))

setMethod('delete', '_p_QuantLib__Thirty360', function(obj) {delete_QuantLib__Thirty360(obj)})
defineEnumeration('_QuantLib__ActualActual__Convention',
                    .values = c(
                        'ISMA' = 0, 
                        'Bond' = 1, 
                        'ISDA' = 2, 
                        'Historical' = 3, 
                        'Actual365' = 4, 
                        'AFB' = 5, 
                        'Euro' = 6
))
# Start of new_ActualActual

`ActualActual__SWIG_0` = function(c)
{
  c = enumToInteger(c, "_QuantLib__ActualActual__Convention"); 
  
  if(length(c) > 1) {
    warning("using only the first element of c");
  };
  
  ;ans = .Call('R_swig_new_ActualActual__SWIG_0', c, PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__ActualActual";
  
  reg.finalizer(ans, delete_ActualActual)
  ans
  
}

attr(`ActualActual__SWIG_0`, 'returnType') = '_p_QuantLib__ActualActual'
attr(`ActualActual__SWIG_0`, "inputTypes") = c('character')
class(`ActualActual__SWIG_0`) = c("SWIGFunction", class('ActualActual__SWIG_0'))

# Start of new_ActualActual

`ActualActual__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_ActualActual__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__ActualActual";
  
  reg.finalizer(ans, delete_ActualActual)
  ans
  
}

attr(`ActualActual__SWIG_1`, 'returnType') = '_p_QuantLib__ActualActual'
class(`ActualActual__SWIG_1`) = c("SWIGFunction", class('ActualActual__SWIG_1'))

`ActualActual` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- ActualActual__SWIG_1; 
  } else if (argc == 1) {
    if (is.character(argv[[1]])) {
      f <- ActualActual__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for ActualActual with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_ActualActual

`delete_ActualActual` = function(self)
{
  ;.Call('R_swig_delete_ActualActual', self, PACKAGE='QuantLib');
  
}

attr(`delete_ActualActual`, 'returnType') = 'void'
attr(`delete_ActualActual`, "inputTypes") = c('_p_QuantLib__ActualActual')
class(`delete_ActualActual`) = c("SWIGFunction", class('delete_ActualActual'))

setMethod('delete', '_p_QuantLib__ActualActual', function(obj) {delete_QuantLib__ActualActual(obj)})
# Start of new_OneDayCounter

`OneDayCounter` = function()
{
  ;ans = .Call('R_swig_new_OneDayCounter', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__OneDayCounter";
  
  reg.finalizer(ans, delete_OneDayCounter)
  ans
  
}

attr(`OneDayCounter`, 'returnType') = '_p_QuantLib__OneDayCounter'
class(`OneDayCounter`) = c("SWIGFunction", class('OneDayCounter'))

# Start of delete_OneDayCounter

`delete_OneDayCounter` = function(self)
{
  ;.Call('R_swig_delete_OneDayCounter', self, PACKAGE='QuantLib');
  
}

attr(`delete_OneDayCounter`, 'returnType') = 'void'
attr(`delete_OneDayCounter`, "inputTypes") = c('_p_QuantLib__OneDayCounter')
class(`delete_OneDayCounter`) = c("SWIGFunction", class('delete_OneDayCounter'))

setMethod('delete', '_p_QuantLib__OneDayCounter', function(obj) {delete_QuantLib__OneDayCounter(obj)})
# Start of new_SimpleDayCounter

`SimpleDayCounter` = function()
{
  ;ans = .Call('R_swig_new_SimpleDayCounter', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__SimpleDayCounter";
  
  reg.finalizer(ans, delete_SimpleDayCounter)
  ans
  
}

attr(`SimpleDayCounter`, 'returnType') = '_p_QuantLib__SimpleDayCounter'
class(`SimpleDayCounter`) = c("SWIGFunction", class('SimpleDayCounter'))

# Start of delete_SimpleDayCounter

`delete_SimpleDayCounter` = function(self)
{
  ;.Call('R_swig_delete_SimpleDayCounter', self, PACKAGE='QuantLib');
  
}

attr(`delete_SimpleDayCounter`, 'returnType') = 'void'
attr(`delete_SimpleDayCounter`, "inputTypes") = c('_p_QuantLib__SimpleDayCounter')
class(`delete_SimpleDayCounter`) = c("SWIGFunction", class('delete_SimpleDayCounter'))

setMethod('delete', '_p_QuantLib__SimpleDayCounter', function(obj) {delete_QuantLib__SimpleDayCounter(obj)})
# Start of new_Business252

`Business252` = function()
{
  ;ans = .Call('R_swig_new_Business252', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__Business252";
  
  reg.finalizer(ans, delete_Business252)
  ans
  
}

attr(`Business252`, 'returnType') = '_p_QuantLib__Business252'
class(`Business252`) = c("SWIGFunction", class('Business252'))

# Start of delete_Business252

`delete_Business252` = function(self)
{
  ;.Call('R_swig_delete_Business252', self, PACKAGE='QuantLib');
  
}

attr(`delete_Business252`, 'returnType') = 'void'
attr(`delete_Business252`, "inputTypes") = c('_p_QuantLib__Business252')
class(`delete_Business252`) = c("SWIGFunction", class('delete_Business252'))

setMethod('delete', '_p_QuantLib__Business252', function(obj) {delete_QuantLib__Business252(obj)})
defineEnumeration('_Compounding',
                    .values = c(
                        'Simple' = 0, 
                        'Compounded' = 1, 
                        'Continuous' = 2, 
                        'SimpleThenCompounded' = 3
))
# Start of new_InterestRate

`InterestRate__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_InterestRate__SWIG_0', PACKAGE='QuantLib');
  class(ans) <- "_p_InterestRate";
  
  reg.finalizer(ans, delete_InterestRate)
  ans
  
}

attr(`InterestRate__SWIG_0`, 'returnType') = '_p_InterestRate'
class(`InterestRate__SWIG_0`) = c("SWIGFunction", class('InterestRate__SWIG_0'))

# Start of new_InterestRate

`InterestRate__SWIG_1` = function(r, dc, comp, freq)
{
  comp = enumToInteger(comp, "_Compounding"); 
  
  if(length(comp) > 1) {
    warning("using only the first element of comp");
  };
  
  freq = enumToInteger(freq, "_Frequency"); 
  
  if(length(freq) > 1) {
    warning("using only the first element of freq");
  };
  
  ;ans = .Call('R_swig_new_InterestRate__SWIG_1', r, dc, comp, freq, PACKAGE='QuantLib');
  class(ans) <- "_p_InterestRate";
  
  reg.finalizer(ans, delete_InterestRate)
  ans
  
}

attr(`InterestRate__SWIG_1`, 'returnType') = '_p_InterestRate'
attr(`InterestRate__SWIG_1`, "inputTypes") = c('numeric', '_p_DayCounter', 'character', 'character')
class(`InterestRate__SWIG_1`) = c("SWIGFunction", class('InterestRate__SWIG_1'))

`InterestRate` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- InterestRate__SWIG_0; 
  } else if (argc == 4) {
    if (is.numeric(argv[[1]]) && extends(argtypes[2], '_p_DayCounter') && is.character(argv[[3]]) && is.character(argv[[4]])) {
      f <- InterestRate__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for InterestRate with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InterestRate_rate

`InterestRate_rate` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_InterestRate_rate', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`InterestRate_rate`, 'returnType') = 'numeric'
attr(`InterestRate_rate`, "inputTypes") = c('_p_InterestRate')
class(`InterestRate_rate`) = c("SWIGFunction", class('InterestRate_rate'))

# Start of InterestRate_dayCounter

`InterestRate_dayCounter` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_InterestRate_dayCounter', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_DayCounter";
  
  ans
  
}

attr(`InterestRate_dayCounter`, 'returnType') = '_p_DayCounter'
attr(`InterestRate_dayCounter`, "inputTypes") = c('_p_InterestRate')
class(`InterestRate_dayCounter`) = c("SWIGFunction", class('InterestRate_dayCounter'))

# Start of InterestRate_compounding

`InterestRate_compounding` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_InterestRate_compounding', self, as.logical(.copy), PACKAGE='QuantLib');
  ans = enumFromInteger(ans, "_Compounding");
  
  ans
  
}

attr(`InterestRate_compounding`, 'returnType') = 'character'
attr(`InterestRate_compounding`, "inputTypes") = c('_p_InterestRate')
class(`InterestRate_compounding`) = c("SWIGFunction", class('InterestRate_compounding'))

# Start of InterestRate_frequency

`InterestRate_frequency` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_InterestRate_frequency', self, as.logical(.copy), PACKAGE='QuantLib');
  ans = enumFromInteger(ans, "_Frequency");
  
  ans
  
}

attr(`InterestRate_frequency`, 'returnType') = 'character'
attr(`InterestRate_frequency`, "inputTypes") = c('_p_InterestRate')
class(`InterestRate_frequency`) = c("SWIGFunction", class('InterestRate_frequency'))

# Start of InterestRate_discountFactor

`InterestRate_discountFactor__SWIG_0` = function(self, t, .copy = FALSE)
{
  ;.Call('R_swig_InterestRate_discountFactor__SWIG_0', self, t, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`InterestRate_discountFactor__SWIG_0`, 'returnType') = 'numeric'
attr(`InterestRate_discountFactor__SWIG_0`, "inputTypes") = c('_p_InterestRate', 'numeric')
class(`InterestRate_discountFactor__SWIG_0`) = c("SWIGFunction", class('InterestRate_discountFactor__SWIG_0'))

# Start of InterestRate_discountFactor

`InterestRate_discountFactor__SWIG_1` = function(self, d1, d2, refStart, refEnd, .copy = FALSE)
{
  ;.Call('R_swig_InterestRate_discountFactor__SWIG_1', self, d1, d2, refStart, refEnd, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`InterestRate_discountFactor__SWIG_1`, 'returnType') = 'numeric'
attr(`InterestRate_discountFactor__SWIG_1`, "inputTypes") = c('_p_InterestRate', '_p_Date', '_p_Date', '_p_Date', '_p_Date')
class(`InterestRate_discountFactor__SWIG_1`) = c("SWIGFunction", class('InterestRate_discountFactor__SWIG_1'))

# Start of InterestRate_discountFactor

`InterestRate_discountFactor__SWIG_2` = function(self, d1, d2, refStart, .copy = FALSE)
{
  ;.Call('R_swig_InterestRate_discountFactor__SWIG_2', self, d1, d2, refStart, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`InterestRate_discountFactor__SWIG_2`, 'returnType') = 'numeric'
attr(`InterestRate_discountFactor__SWIG_2`, "inputTypes") = c('_p_InterestRate', '_p_Date', '_p_Date', '_p_Date')
class(`InterestRate_discountFactor__SWIG_2`) = c("SWIGFunction", class('InterestRate_discountFactor__SWIG_2'))

# Start of InterestRate_discountFactor

`InterestRate_discountFactor__SWIG_3` = function(self, d1, d2, .copy = FALSE)
{
  ;.Call('R_swig_InterestRate_discountFactor__SWIG_3', self, d1, d2, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`InterestRate_discountFactor__SWIG_3`, 'returnType') = 'numeric'
attr(`InterestRate_discountFactor__SWIG_3`, "inputTypes") = c('_p_InterestRate', '_p_Date', '_p_Date')
class(`InterestRate_discountFactor__SWIG_3`) = c("SWIGFunction", class('InterestRate_discountFactor__SWIG_3'))

`InterestRate_discountFactor` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 2) {
    if (extends(argtypes[1], '_p_InterestRate') && is.numeric(argv[[2]])) {
      f <- InterestRate_discountFactor__SWIG_0; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_InterestRate') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_Date')) {
      f <- InterestRate_discountFactor__SWIG_3; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_InterestRate') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_Date') && extends(argtypes[4], '_p_Date')) {
      f <- InterestRate_discountFactor__SWIG_2; 
    }
  } else if (argc == 5) {
    if (extends(argtypes[1], '_p_InterestRate') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_Date') && extends(argtypes[4], '_p_Date') && extends(argtypes[5], '_p_Date')) {
      f <- InterestRate_discountFactor__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for InterestRate_discountFactor with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InterestRate_compoundFactor

`InterestRate_compoundFactor__SWIG_0` = function(self, t, .copy = FALSE)
{
  ;.Call('R_swig_InterestRate_compoundFactor__SWIG_0', self, t, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`InterestRate_compoundFactor__SWIG_0`, 'returnType') = 'numeric'
attr(`InterestRate_compoundFactor__SWIG_0`, "inputTypes") = c('_p_InterestRate', 'numeric')
class(`InterestRate_compoundFactor__SWIG_0`) = c("SWIGFunction", class('InterestRate_compoundFactor__SWIG_0'))

# Start of InterestRate_compoundFactor

`InterestRate_compoundFactor__SWIG_1` = function(self, d1, d2, refStart, refEnd, .copy = FALSE)
{
  ;.Call('R_swig_InterestRate_compoundFactor__SWIG_1', self, d1, d2, refStart, refEnd, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`InterestRate_compoundFactor__SWIG_1`, 'returnType') = 'numeric'
attr(`InterestRate_compoundFactor__SWIG_1`, "inputTypes") = c('_p_InterestRate', '_p_Date', '_p_Date', '_p_Date', '_p_Date')
class(`InterestRate_compoundFactor__SWIG_1`) = c("SWIGFunction", class('InterestRate_compoundFactor__SWIG_1'))

# Start of InterestRate_compoundFactor

`InterestRate_compoundFactor__SWIG_2` = function(self, d1, d2, refStart, .copy = FALSE)
{
  ;.Call('R_swig_InterestRate_compoundFactor__SWIG_2', self, d1, d2, refStart, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`InterestRate_compoundFactor__SWIG_2`, 'returnType') = 'numeric'
attr(`InterestRate_compoundFactor__SWIG_2`, "inputTypes") = c('_p_InterestRate', '_p_Date', '_p_Date', '_p_Date')
class(`InterestRate_compoundFactor__SWIG_2`) = c("SWIGFunction", class('InterestRate_compoundFactor__SWIG_2'))

# Start of InterestRate_compoundFactor

`InterestRate_compoundFactor__SWIG_3` = function(self, d1, d2, .copy = FALSE)
{
  ;.Call('R_swig_InterestRate_compoundFactor__SWIG_3', self, d1, d2, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`InterestRate_compoundFactor__SWIG_3`, 'returnType') = 'numeric'
attr(`InterestRate_compoundFactor__SWIG_3`, "inputTypes") = c('_p_InterestRate', '_p_Date', '_p_Date')
class(`InterestRate_compoundFactor__SWIG_3`) = c("SWIGFunction", class('InterestRate_compoundFactor__SWIG_3'))

`InterestRate_compoundFactor` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 2) {
    if (extends(argtypes[1], '_p_InterestRate') && is.numeric(argv[[2]])) {
      f <- InterestRate_compoundFactor__SWIG_0; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_InterestRate') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_Date')) {
      f <- InterestRate_compoundFactor__SWIG_3; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_InterestRate') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_Date') && extends(argtypes[4], '_p_Date')) {
      f <- InterestRate_compoundFactor__SWIG_2; 
    }
  } else if (argc == 5) {
    if (extends(argtypes[1], '_p_InterestRate') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_Date') && extends(argtypes[4], '_p_Date') && extends(argtypes[5], '_p_Date')) {
      f <- InterestRate_compoundFactor__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for InterestRate_compoundFactor with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InterestRate_impliedRate

`InterestRate_impliedRate__SWIG_0` = function(compound, resultDC, comp, freq, t, .copy = FALSE)
{
  comp = enumToInteger(comp, "_Compounding"); 
  
  if(length(comp) > 1) {
    warning("using only the first element of comp");
  };
  
  freq = enumToInteger(freq, "_Frequency"); 
  
  if(length(freq) > 1) {
    warning("using only the first element of freq");
  };
  
  
  ;ans = .Call('R_swig_InterestRate_impliedRate__SWIG_0', compound, resultDC, comp, freq, t, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_InterestRate";
  
  ans
  
}

attr(`InterestRate_impliedRate__SWIG_0`, 'returnType') = '_p_InterestRate'
attr(`InterestRate_impliedRate__SWIG_0`, "inputTypes") = c('numeric', '_p_DayCounter', 'character', 'character', 'numeric')
class(`InterestRate_impliedRate__SWIG_0`) = c("SWIGFunction", class('InterestRate_impliedRate__SWIG_0'))

# Start of InterestRate_impliedRate

`InterestRate_impliedRate__SWIG_1` = function(compound, resultDC, comp, freq, d1, d2, refStart, refEnd, .copy = FALSE)
{
  comp = enumToInteger(comp, "_Compounding"); 
  
  if(length(comp) > 1) {
    warning("using only the first element of comp");
  };
  
  freq = enumToInteger(freq, "_Frequency"); 
  
  if(length(freq) > 1) {
    warning("using only the first element of freq");
  };
  
  
  
  
  
  ;ans = .Call('R_swig_InterestRate_impliedRate__SWIG_1', compound, resultDC, comp, freq, d1, d2, refStart, refEnd, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_InterestRate";
  
  ans
  
}

attr(`InterestRate_impliedRate__SWIG_1`, 'returnType') = '_p_InterestRate'
attr(`InterestRate_impliedRate__SWIG_1`, "inputTypes") = c('numeric', '_p_DayCounter', 'character', 'character', '_p_Date', '_p_Date', '_p_Date', '_p_Date')
class(`InterestRate_impliedRate__SWIG_1`) = c("SWIGFunction", class('InterestRate_impliedRate__SWIG_1'))

# Start of InterestRate_impliedRate

`InterestRate_impliedRate__SWIG_2` = function(compound, resultDC, comp, freq, d1, d2, refStart, .copy = FALSE)
{
  comp = enumToInteger(comp, "_Compounding"); 
  
  if(length(comp) > 1) {
    warning("using only the first element of comp");
  };
  
  freq = enumToInteger(freq, "_Frequency"); 
  
  if(length(freq) > 1) {
    warning("using only the first element of freq");
  };
  
  
  
  
  ;ans = .Call('R_swig_InterestRate_impliedRate__SWIG_2', compound, resultDC, comp, freq, d1, d2, refStart, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_InterestRate";
  
  ans
  
}

attr(`InterestRate_impliedRate__SWIG_2`, 'returnType') = '_p_InterestRate'
attr(`InterestRate_impliedRate__SWIG_2`, "inputTypes") = c('numeric', '_p_DayCounter', 'character', 'character', '_p_Date', '_p_Date', '_p_Date')
class(`InterestRate_impliedRate__SWIG_2`) = c("SWIGFunction", class('InterestRate_impliedRate__SWIG_2'))

# Start of InterestRate_impliedRate

`InterestRate_impliedRate__SWIG_3` = function(compound, resultDC, comp, freq, d1, d2, .copy = FALSE)
{
  comp = enumToInteger(comp, "_Compounding"); 
  
  if(length(comp) > 1) {
    warning("using only the first element of comp");
  };
  
  freq = enumToInteger(freq, "_Frequency"); 
  
  if(length(freq) > 1) {
    warning("using only the first element of freq");
  };
  
  
  
  ;ans = .Call('R_swig_InterestRate_impliedRate__SWIG_3', compound, resultDC, comp, freq, d1, d2, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_InterestRate";
  
  ans
  
}

attr(`InterestRate_impliedRate__SWIG_3`, 'returnType') = '_p_InterestRate'
attr(`InterestRate_impliedRate__SWIG_3`, "inputTypes") = c('numeric', '_p_DayCounter', 'character', 'character', '_p_Date', '_p_Date')
class(`InterestRate_impliedRate__SWIG_3`) = c("SWIGFunction", class('InterestRate_impliedRate__SWIG_3'))

`InterestRate_impliedRate` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 5) {
    if (is.numeric(argv[[1]]) && extends(argtypes[2], '_p_DayCounter') && is.character(argv[[3]]) && is.character(argv[[4]]) && is.numeric(argv[[5]])) {
      f <- InterestRate_impliedRate__SWIG_0; 
    }
  } else if (argc == 6) {
    if (is.numeric(argv[[1]]) && extends(argtypes[2], '_p_DayCounter') && is.character(argv[[3]]) && is.character(argv[[4]]) && extends(argtypes[5], '_p_Date') && extends(argtypes[6], '_p_Date')) {
      f <- InterestRate_impliedRate__SWIG_3; 
    }
  } else if (argc == 7) {
    if (is.numeric(argv[[1]]) && extends(argtypes[2], '_p_DayCounter') && is.character(argv[[3]]) && is.character(argv[[4]]) && extends(argtypes[5], '_p_Date') && extends(argtypes[6], '_p_Date') && extends(argtypes[7], '_p_Date')) {
      f <- InterestRate_impliedRate__SWIG_2; 
    }
  } else if (argc == 8) {
    if (is.numeric(argv[[1]]) && extends(argtypes[2], '_p_DayCounter') && is.character(argv[[3]]) && is.character(argv[[4]]) && extends(argtypes[5], '_p_Date') && extends(argtypes[6], '_p_Date') && extends(argtypes[7], '_p_Date') && extends(argtypes[8], '_p_Date')) {
      f <- InterestRate_impliedRate__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for InterestRate_impliedRate with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InterestRate_equivalentRate

`InterestRate_equivalentRate__SWIG_0` = function(self, comp, freq, t, .copy = FALSE)
{
  comp = enumToInteger(comp, "_Compounding"); 
  
  if(length(comp) > 1) {
    warning("using only the first element of comp");
  };
  
  freq = enumToInteger(freq, "_Frequency"); 
  
  if(length(freq) > 1) {
    warning("using only the first element of freq");
  };
  
  
  ;ans = .Call('R_swig_InterestRate_equivalentRate__SWIG_0', self, comp, freq, t, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_InterestRate";
  
  ans
  
}

attr(`InterestRate_equivalentRate__SWIG_0`, 'returnType') = '_p_InterestRate'
attr(`InterestRate_equivalentRate__SWIG_0`, "inputTypes") = c('_p_InterestRate', 'character', 'character', 'numeric')
class(`InterestRate_equivalentRate__SWIG_0`) = c("SWIGFunction", class('InterestRate_equivalentRate__SWIG_0'))

# Start of InterestRate_equivalentRate

`InterestRate_equivalentRate__SWIG_1` = function(self, resultDayCounter, comp, freq, d1, d2, refStart, refEnd, .copy = FALSE)
{
  comp = enumToInteger(comp, "_Compounding"); 
  
  if(length(comp) > 1) {
    warning("using only the first element of comp");
  };
  
  freq = enumToInteger(freq, "_Frequency"); 
  
  if(length(freq) > 1) {
    warning("using only the first element of freq");
  };
  
  
  
  
  
  ;ans = .Call('R_swig_InterestRate_equivalentRate__SWIG_1', self, resultDayCounter, comp, freq, d1, d2, refStart, refEnd, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_InterestRate";
  
  ans
  
}

attr(`InterestRate_equivalentRate__SWIG_1`, 'returnType') = '_p_InterestRate'
attr(`InterestRate_equivalentRate__SWIG_1`, "inputTypes") = c('_p_InterestRate', '_p_DayCounter', 'character', 'character', '_p_Date', '_p_Date', '_p_Date', '_p_Date')
class(`InterestRate_equivalentRate__SWIG_1`) = c("SWIGFunction", class('InterestRate_equivalentRate__SWIG_1'))

# Start of InterestRate_equivalentRate

`InterestRate_equivalentRate__SWIG_2` = function(self, resultDayCounter, comp, freq, d1, d2, refStart, .copy = FALSE)
{
  comp = enumToInteger(comp, "_Compounding"); 
  
  if(length(comp) > 1) {
    warning("using only the first element of comp");
  };
  
  freq = enumToInteger(freq, "_Frequency"); 
  
  if(length(freq) > 1) {
    warning("using only the first element of freq");
  };
  
  
  
  
  ;ans = .Call('R_swig_InterestRate_equivalentRate__SWIG_2', self, resultDayCounter, comp, freq, d1, d2, refStart, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_InterestRate";
  
  ans
  
}

attr(`InterestRate_equivalentRate__SWIG_2`, 'returnType') = '_p_InterestRate'
attr(`InterestRate_equivalentRate__SWIG_2`, "inputTypes") = c('_p_InterestRate', '_p_DayCounter', 'character', 'character', '_p_Date', '_p_Date', '_p_Date')
class(`InterestRate_equivalentRate__SWIG_2`) = c("SWIGFunction", class('InterestRate_equivalentRate__SWIG_2'))

# Start of InterestRate_equivalentRate

`InterestRate_equivalentRate__SWIG_3` = function(self, resultDayCounter, comp, freq, d1, d2, .copy = FALSE)
{
  comp = enumToInteger(comp, "_Compounding"); 
  
  if(length(comp) > 1) {
    warning("using only the first element of comp");
  };
  
  freq = enumToInteger(freq, "_Frequency"); 
  
  if(length(freq) > 1) {
    warning("using only the first element of freq");
  };
  
  
  
  ;ans = .Call('R_swig_InterestRate_equivalentRate__SWIG_3', self, resultDayCounter, comp, freq, d1, d2, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_InterestRate";
  
  ans
  
}

attr(`InterestRate_equivalentRate__SWIG_3`, 'returnType') = '_p_InterestRate'
attr(`InterestRate_equivalentRate__SWIG_3`, "inputTypes") = c('_p_InterestRate', '_p_DayCounter', 'character', 'character', '_p_Date', '_p_Date')
class(`InterestRate_equivalentRate__SWIG_3`) = c("SWIGFunction", class('InterestRate_equivalentRate__SWIG_3'))

`InterestRate_equivalentRate` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 4) {
    if (extends(argtypes[1], '_p_InterestRate') && is.character(argv[[2]]) && is.character(argv[[3]]) && is.numeric(argv[[4]])) {
      f <- InterestRate_equivalentRate__SWIG_0; 
    }
  } else if (argc == 6) {
    if (extends(argtypes[1], '_p_InterestRate') && extends(argtypes[2], '_p_DayCounter') && is.character(argv[[3]]) && is.character(argv[[4]]) && extends(argtypes[5], '_p_Date') && extends(argtypes[6], '_p_Date')) {
      f <- InterestRate_equivalentRate__SWIG_3; 
    }
  } else if (argc == 7) {
    if (extends(argtypes[1], '_p_InterestRate') && extends(argtypes[2], '_p_DayCounter') && is.character(argv[[3]]) && is.character(argv[[4]]) && extends(argtypes[5], '_p_Date') && extends(argtypes[6], '_p_Date') && extends(argtypes[7], '_p_Date')) {
      f <- InterestRate_equivalentRate__SWIG_2; 
    }
  } else if (argc == 8) {
    if (extends(argtypes[1], '_p_InterestRate') && extends(argtypes[2], '_p_DayCounter') && is.character(argv[[3]]) && is.character(argv[[4]]) && extends(argtypes[5], '_p_Date') && extends(argtypes[6], '_p_Date') && extends(argtypes[7], '_p_Date') && extends(argtypes[8], '_p_Date')) {
      f <- InterestRate_equivalentRate__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for InterestRate_equivalentRate with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InterestRate___str__

`InterestRate___str__` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_InterestRate___str__', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`InterestRate___str__`, 'returnType') = 'character'
attr(`InterestRate___str__`, "inputTypes") = c('_p_InterestRate')
class(`InterestRate___str__`) = c("SWIGFunction", class('InterestRate___str__'))

# Start of delete_InterestRate

`delete_InterestRate` = function(self)
{
  ;.Call('R_swig_delete_InterestRate', self, PACKAGE='QuantLib');
  
}

attr(`delete_InterestRate`, 'returnType') = 'void'
attr(`delete_InterestRate`, "inputTypes") = c('_p_InterestRate')
class(`delete_InterestRate`) = c("SWIGFunction", class('delete_InterestRate'))

# Start of accessor method for InterestRate
setMethod('$', '_p_InterestRate', function(x, name)

{
  accessorFuns = list('rate' = InterestRate_rate, 'dayCounter' = InterestRate_dayCounter, 'compounding' = InterestRate_compounding, 'frequency' = InterestRate_frequency, 'discountFactor' = InterestRate_discountFactor, 'compoundFactor' = InterestRate_compoundFactor, 'equivalentRate' = InterestRate_equivalentRate, '__str__' = InterestRate___str__);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for InterestRate
setMethod('delete', '_p_InterestRate', function(obj) {delete_InterestRate(obj)})
defineEnumeration('_BusinessDayConvention',
                    .values = c(
                        'Following' = 0, 
                        'ModifiedFollowing' = 1, 
                        'Preceding' = 2, 
                        'ModifiedPreceding' = 3, 
                        'Unadjusted' = 4
))
defineEnumeration('_JointCalendarRule',
                    .values = c(
                        'JoinHolidays' = 0, 
                        'JoinBusinessDays' = 1
))
# Start of Calendar_isBusinessDay

`Calendar_isBusinessDay` = function(self, s_arg2, .copy = FALSE)
{
  ;.Call('R_swig_Calendar_isBusinessDay', self, s_arg2, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Calendar_isBusinessDay`, 'returnType') = 'logical'
attr(`Calendar_isBusinessDay`, "inputTypes") = c('_p_Calendar', '_p_Date')
class(`Calendar_isBusinessDay`) = c("SWIGFunction", class('Calendar_isBusinessDay'))

# Start of Calendar_isHoliday

`Calendar_isHoliday` = function(self, s_arg2, .copy = FALSE)
{
  ;.Call('R_swig_Calendar_isHoliday', self, s_arg2, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Calendar_isHoliday`, 'returnType') = 'logical'
attr(`Calendar_isHoliday`, "inputTypes") = c('_p_Calendar', '_p_Date')
class(`Calendar_isHoliday`) = c("SWIGFunction", class('Calendar_isHoliday'))

# Start of Calendar_isEndOfMonth

`Calendar_isEndOfMonth` = function(self, s_arg2, .copy = FALSE)
{
  ;.Call('R_swig_Calendar_isEndOfMonth', self, s_arg2, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Calendar_isEndOfMonth`, 'returnType') = 'logical'
attr(`Calendar_isEndOfMonth`, "inputTypes") = c('_p_Calendar', '_p_Date')
class(`Calendar_isEndOfMonth`) = c("SWIGFunction", class('Calendar_isEndOfMonth'))

# Start of Calendar_addHoliday

`Calendar_addHoliday` = function(self, s_arg2)
{
  ;.Call('R_swig_Calendar_addHoliday', self, s_arg2, PACKAGE='QuantLib');
  
}

attr(`Calendar_addHoliday`, 'returnType') = 'void'
attr(`Calendar_addHoliday`, "inputTypes") = c('_p_Calendar', '_p_Date')
class(`Calendar_addHoliday`) = c("SWIGFunction", class('Calendar_addHoliday'))

# Start of Calendar_removeHoliday

`Calendar_removeHoliday` = function(self, s_arg2)
{
  ;.Call('R_swig_Calendar_removeHoliday', self, s_arg2, PACKAGE='QuantLib');
  
}

attr(`Calendar_removeHoliday`, 'returnType') = 'void'
attr(`Calendar_removeHoliday`, "inputTypes") = c('_p_Calendar', '_p_Date')
class(`Calendar_removeHoliday`) = c("SWIGFunction", class('Calendar_removeHoliday'))

# Start of Calendar_adjust

`Calendar_adjust__SWIG_0` = function(self, d, convention, .copy = FALSE)
{
  convention = enumToInteger(convention, "_BusinessDayConvention"); 
  
  if(length(convention) > 1) {
    warning("using only the first element of convention");
  };
  
  ;ans = .Call('R_swig_Calendar_adjust__SWIG_0', self, d, convention, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`Calendar_adjust__SWIG_0`, 'returnType') = '_p_Date'
attr(`Calendar_adjust__SWIG_0`, "inputTypes") = c('_p_Calendar', '_p_Date', 'character')
class(`Calendar_adjust__SWIG_0`) = c("SWIGFunction", class('Calendar_adjust__SWIG_0'))

# Start of Calendar_adjust

`Calendar_adjust__SWIG_1` = function(self, d, .copy = FALSE)
{
  ;ans = .Call('R_swig_Calendar_adjust__SWIG_1', self, d, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`Calendar_adjust__SWIG_1`, 'returnType') = '_p_Date'
attr(`Calendar_adjust__SWIG_1`, "inputTypes") = c('_p_Calendar', '_p_Date')
class(`Calendar_adjust__SWIG_1`) = c("SWIGFunction", class('Calendar_adjust__SWIG_1'))

`Calendar_adjust` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_Calendar') && extends(argtypes[2], '_p_Date')) {
      f <- Calendar_adjust__SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_Calendar') && extends(argtypes[2], '_p_Date') && is.character(argv[[3]])) {
      f <- Calendar_adjust__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Calendar_adjust with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of Calendar_advance

`Calendar_advance__SWIG_0` = function(self, d, n, unit, convention, endOfMonth, .copy = FALSE)
{
  n = as.integer(n); 
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  unit = enumToInteger(unit, "_TimeUnit"); 
  
  if(length(unit) > 1) {
    warning("using only the first element of unit");
  };
  
  convention = enumToInteger(convention, "_BusinessDayConvention"); 
  
  if(length(convention) > 1) {
    warning("using only the first element of convention");
  };
  
  endOfMonth = as.logical(endOfMonth);
  ;ans = .Call('R_swig_Calendar_advance__SWIG_0', self, d, n, unit, convention, endOfMonth, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`Calendar_advance__SWIG_0`, 'returnType') = '_p_Date'
attr(`Calendar_advance__SWIG_0`, "inputTypes") = c('_p_Calendar', '_p_Date', 'integer', 'character', 'character', 'logical')
class(`Calendar_advance__SWIG_0`) = c("SWIGFunction", class('Calendar_advance__SWIG_0'))

# Start of Calendar_advance

`Calendar_advance__SWIG_1` = function(self, d, n, unit, convention, .copy = FALSE)
{
  n = as.integer(n); 
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  unit = enumToInteger(unit, "_TimeUnit"); 
  
  if(length(unit) > 1) {
    warning("using only the first element of unit");
  };
  
  convention = enumToInteger(convention, "_BusinessDayConvention"); 
  
  if(length(convention) > 1) {
    warning("using only the first element of convention");
  };
  
  ;ans = .Call('R_swig_Calendar_advance__SWIG_1', self, d, n, unit, convention, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`Calendar_advance__SWIG_1`, 'returnType') = '_p_Date'
attr(`Calendar_advance__SWIG_1`, "inputTypes") = c('_p_Calendar', '_p_Date', 'integer', 'character', 'character')
class(`Calendar_advance__SWIG_1`) = c("SWIGFunction", class('Calendar_advance__SWIG_1'))

# Start of Calendar_advance

`Calendar_advance__SWIG_2` = function(self, d, n, unit, .copy = FALSE)
{
  n = as.integer(n); 
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  unit = enumToInteger(unit, "_TimeUnit"); 
  
  if(length(unit) > 1) {
    warning("using only the first element of unit");
  };
  
  ;ans = .Call('R_swig_Calendar_advance__SWIG_2', self, d, n, unit, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`Calendar_advance__SWIG_2`, 'returnType') = '_p_Date'
attr(`Calendar_advance__SWIG_2`, "inputTypes") = c('_p_Calendar', '_p_Date', 'integer', 'character')
class(`Calendar_advance__SWIG_2`) = c("SWIGFunction", class('Calendar_advance__SWIG_2'))

# Start of Calendar_advance

`Calendar_advance__SWIG_3` = function(self, d, period, convention, endOfMonth, .copy = FALSE)
{
  convention = enumToInteger(convention, "_BusinessDayConvention"); 
  
  if(length(convention) > 1) {
    warning("using only the first element of convention");
  };
  
  endOfMonth = as.logical(endOfMonth);
  ;ans = .Call('R_swig_Calendar_advance__SWIG_3', self, d, period, convention, endOfMonth, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`Calendar_advance__SWIG_3`, 'returnType') = '_p_Date'
attr(`Calendar_advance__SWIG_3`, "inputTypes") = c('_p_Calendar', '_p_Date', '_p_Period', 'character', 'logical')
class(`Calendar_advance__SWIG_3`) = c("SWIGFunction", class('Calendar_advance__SWIG_3'))

# Start of Calendar_advance

`Calendar_advance__SWIG_4` = function(self, d, period, convention, .copy = FALSE)
{
  convention = enumToInteger(convention, "_BusinessDayConvention"); 
  
  if(length(convention) > 1) {
    warning("using only the first element of convention");
  };
  
  ;ans = .Call('R_swig_Calendar_advance__SWIG_4', self, d, period, convention, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`Calendar_advance__SWIG_4`, 'returnType') = '_p_Date'
attr(`Calendar_advance__SWIG_4`, "inputTypes") = c('_p_Calendar', '_p_Date', '_p_Period', 'character')
class(`Calendar_advance__SWIG_4`) = c("SWIGFunction", class('Calendar_advance__SWIG_4'))

# Start of Calendar_advance

`Calendar_advance__SWIG_5` = function(self, d, period, .copy = FALSE)
{
  ;ans = .Call('R_swig_Calendar_advance__SWIG_5', self, d, period, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`Calendar_advance__SWIG_5`, 'returnType') = '_p_Date'
attr(`Calendar_advance__SWIG_5`, "inputTypes") = c('_p_Calendar', '_p_Date', '_p_Period')
class(`Calendar_advance__SWIG_5`) = c("SWIGFunction", class('Calendar_advance__SWIG_5'))

`Calendar_advance` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 6
  if (argc == 3) {
    if (extends(argtypes[1], '_p_Calendar') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_Period')) {
      f <- Calendar_advance__SWIG_5; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_Calendar') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_Period') && is.character(argv[[4]])) {
      f <- Calendar_advance__SWIG_4; 
    }
    else if (extends(argtypes[1], '_p_Calendar') && extends(argtypes[2], '_p_Date') && (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && is.character(argv[[4]])) {
      f <- Calendar_advance__SWIG_2; 
    }
  } else if (argc == 5) {
    if (extends(argtypes[1], '_p_Calendar') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_Period') && is.character(argv[[4]]) && extends(argtypes[5], 'logical')) {
      f <- Calendar_advance__SWIG_3; 
    }
    else if (extends(argtypes[1], '_p_Calendar') && extends(argtypes[2], '_p_Date') && (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && is.character(argv[[4]]) && is.character(argv[[5]])) {
      f <- Calendar_advance__SWIG_1; 
    }
  } else if (argc == 6) {
    if (extends(argtypes[1], '_p_Calendar') && extends(argtypes[2], '_p_Date') && (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && is.character(argv[[4]]) && is.character(argv[[5]]) && extends(argtypes[6], 'logical')) {
      f <- Calendar_advance__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Calendar_advance with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of Calendar_businessDaysBetween

`Calendar_businessDaysBetween__SWIG_0` = function(self, from, to, includeFirst, includeLast, .copy = FALSE)
{
  includeFirst = as.logical(includeFirst);
  includeLast = as.logical(includeLast);
  ;.Call('R_swig_Calendar_businessDaysBetween__SWIG_0', self, from, to, includeFirst, includeLast, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Calendar_businessDaysBetween__SWIG_0`, 'returnType') = 'integer'
attr(`Calendar_businessDaysBetween__SWIG_0`, "inputTypes") = c('_p_Calendar', '_p_Date', '_p_Date', 'logical', 'logical')
class(`Calendar_businessDaysBetween__SWIG_0`) = c("SWIGFunction", class('Calendar_businessDaysBetween__SWIG_0'))

# Start of Calendar_businessDaysBetween

`Calendar_businessDaysBetween__SWIG_1` = function(self, from, to, includeFirst, .copy = FALSE)
{
  includeFirst = as.logical(includeFirst);
  ;.Call('R_swig_Calendar_businessDaysBetween__SWIG_1', self, from, to, includeFirst, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Calendar_businessDaysBetween__SWIG_1`, 'returnType') = 'integer'
attr(`Calendar_businessDaysBetween__SWIG_1`, "inputTypes") = c('_p_Calendar', '_p_Date', '_p_Date', 'logical')
class(`Calendar_businessDaysBetween__SWIG_1`) = c("SWIGFunction", class('Calendar_businessDaysBetween__SWIG_1'))

# Start of Calendar_businessDaysBetween

`Calendar_businessDaysBetween__SWIG_2` = function(self, from, to, .copy = FALSE)
{
  ;.Call('R_swig_Calendar_businessDaysBetween__SWIG_2', self, from, to, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Calendar_businessDaysBetween__SWIG_2`, 'returnType') = 'integer'
attr(`Calendar_businessDaysBetween__SWIG_2`, "inputTypes") = c('_p_Calendar', '_p_Date', '_p_Date')
class(`Calendar_businessDaysBetween__SWIG_2`) = c("SWIGFunction", class('Calendar_businessDaysBetween__SWIG_2'))

`Calendar_businessDaysBetween` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 3) {
    if (extends(argtypes[1], '_p_Calendar') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_Date')) {
      f <- Calendar_businessDaysBetween__SWIG_2; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_Calendar') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_Date') && extends(argtypes[4], 'logical')) {
      f <- Calendar_businessDaysBetween__SWIG_1; 
    }
  } else if (argc == 5) {
    if (extends(argtypes[1], '_p_Calendar') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_Date') && extends(argtypes[4], 'logical') && extends(argtypes[5], 'logical')) {
      f <- Calendar_businessDaysBetween__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Calendar_businessDaysBetween with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of Calendar_name

`Calendar_name` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Calendar_name', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Calendar_name`, 'returnType') = 'character'
attr(`Calendar_name`, "inputTypes") = c('_p_Calendar')
class(`Calendar_name`) = c("SWIGFunction", class('Calendar_name'))

# Start of Calendar___str__

`Calendar___str__` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Calendar___str__', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Calendar___str__`, 'returnType') = 'character'
attr(`Calendar___str__`, "inputTypes") = c('_p_Calendar')
class(`Calendar___str__`) = c("SWIGFunction", class('Calendar___str__'))

# Start of delete_Calendar

`delete_Calendar` = function(self)
{
  ;.Call('R_swig_delete_Calendar', self, PACKAGE='QuantLib');
  
}

attr(`delete_Calendar`, 'returnType') = 'void'
attr(`delete_Calendar`, "inputTypes") = c('_p_Calendar')
class(`delete_Calendar`) = c("SWIGFunction", class('delete_Calendar'))

# Start of accessor method for Calendar
setMethod('$', '_p_Calendar', function(x, name)

{
  accessorFuns = list('isBusinessDay' = Calendar_isBusinessDay, 'isHoliday' = Calendar_isHoliday, 'isEndOfMonth' = Calendar_isEndOfMonth, 'addHoliday' = Calendar_addHoliday, 'removeHoliday' = Calendar_removeHoliday, 'adjust' = Calendar_adjust, 'advance' = Calendar_advance, 'businessDaysBetween' = Calendar_businessDaysBetween, 'name' = Calendar_name, '__str__' = Calendar___str__);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for Calendar
setMethod('delete', '_p_Calendar', function(obj) {delete_Calendar(obj)})
defineEnumeration('_QuantLib__Argentina__Market',
                    .values = c(
                        'Merval' = 0
))
# Start of new_Argentina

`Argentina__SWIG_0` = function(m)
{
  m = enumToInteger(m, "_QuantLib__Argentina__Market"); 
  
  if(length(m) > 1) {
    warning("using only the first element of m");
  };
  
  ;ans = .Call('R_swig_new_Argentina__SWIG_0', m, PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__Argentina";
  
  reg.finalizer(ans, delete_Argentina)
  ans
  
}

attr(`Argentina__SWIG_0`, 'returnType') = '_p_QuantLib__Argentina'
attr(`Argentina__SWIG_0`, "inputTypes") = c('character')
class(`Argentina__SWIG_0`) = c("SWIGFunction", class('Argentina__SWIG_0'))

# Start of new_Argentina

`Argentina__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_Argentina__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__Argentina";
  
  reg.finalizer(ans, delete_Argentina)
  ans
  
}

attr(`Argentina__SWIG_1`, 'returnType') = '_p_QuantLib__Argentina'
class(`Argentina__SWIG_1`) = c("SWIGFunction", class('Argentina__SWIG_1'))

`Argentina` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- Argentina__SWIG_1; 
  } else if (argc == 1) {
    if (is.character(argv[[1]])) {
      f <- Argentina__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Argentina with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_Argentina

`delete_Argentina` = function(self)
{
  ;.Call('R_swig_delete_Argentina', self, PACKAGE='QuantLib');
  
}

attr(`delete_Argentina`, 'returnType') = 'void'
attr(`delete_Argentina`, "inputTypes") = c('_p_QuantLib__Argentina')
class(`delete_Argentina`) = c("SWIGFunction", class('delete_Argentina'))

setMethod('delete', '_p_QuantLib__Argentina', function(obj) {delete_QuantLib__Argentina(obj)})
# Start of new_Australia

`Australia` = function()
{
  ;ans = .Call('R_swig_new_Australia', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__Australia";
  
  reg.finalizer(ans, delete_Australia)
  ans
  
}

attr(`Australia`, 'returnType') = '_p_QuantLib__Australia'
class(`Australia`) = c("SWIGFunction", class('Australia'))

# Start of delete_Australia

`delete_Australia` = function(self)
{
  ;.Call('R_swig_delete_Australia', self, PACKAGE='QuantLib');
  
}

attr(`delete_Australia`, 'returnType') = 'void'
attr(`delete_Australia`, "inputTypes") = c('_p_QuantLib__Australia')
class(`delete_Australia`) = c("SWIGFunction", class('delete_Australia'))

setMethod('delete', '_p_QuantLib__Australia', function(obj) {delete_QuantLib__Australia(obj)})
defineEnumeration('_QuantLib__Brazil__Market',
                    .values = c(
                        'Settlement' = 0, 
                        'Exchange' = 1
))
# Start of new_Brazil

`Brazil__SWIG_0` = function(m)
{
  m = enumToInteger(m, "_QuantLib__Brazil__Market"); 
  
  if(length(m) > 1) {
    warning("using only the first element of m");
  };
  
  ;ans = .Call('R_swig_new_Brazil__SWIG_0', m, PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__Brazil";
  
  reg.finalizer(ans, delete_Brazil)
  ans
  
}

attr(`Brazil__SWIG_0`, 'returnType') = '_p_QuantLib__Brazil'
attr(`Brazil__SWIG_0`, "inputTypes") = c('character')
class(`Brazil__SWIG_0`) = c("SWIGFunction", class('Brazil__SWIG_0'))

# Start of new_Brazil

`Brazil__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_Brazil__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__Brazil";
  
  reg.finalizer(ans, delete_Brazil)
  ans
  
}

attr(`Brazil__SWIG_1`, 'returnType') = '_p_QuantLib__Brazil'
class(`Brazil__SWIG_1`) = c("SWIGFunction", class('Brazil__SWIG_1'))

`Brazil` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- Brazil__SWIG_1; 
  } else if (argc == 1) {
    if (is.character(argv[[1]])) {
      f <- Brazil__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Brazil with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_Brazil

`delete_Brazil` = function(self)
{
  ;.Call('R_swig_delete_Brazil', self, PACKAGE='QuantLib');
  
}

attr(`delete_Brazil`, 'returnType') = 'void'
attr(`delete_Brazil`, "inputTypes") = c('_p_QuantLib__Brazil')
class(`delete_Brazil`) = c("SWIGFunction", class('delete_Brazil'))

setMethod('delete', '_p_QuantLib__Brazil', function(obj) {delete_QuantLib__Brazil(obj)})
defineEnumeration('_QuantLib__Canada__Market',
                    .values = c(
                        'Settlement' = 0, 
                        'TSX' = 1
))
# Start of new_Canada

`Canada__SWIG_0` = function(m)
{
  m = enumToInteger(m, "_QuantLib__Canada__Market"); 
  
  if(length(m) > 1) {
    warning("using only the first element of m");
  };
  
  ;ans = .Call('R_swig_new_Canada__SWIG_0', m, PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__Canada";
  
  reg.finalizer(ans, delete_Canada)
  ans
  
}

attr(`Canada__SWIG_0`, 'returnType') = '_p_QuantLib__Canada'
attr(`Canada__SWIG_0`, "inputTypes") = c('character')
class(`Canada__SWIG_0`) = c("SWIGFunction", class('Canada__SWIG_0'))

# Start of new_Canada

`Canada__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_Canada__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__Canada";
  
  reg.finalizer(ans, delete_Canada)
  ans
  
}

attr(`Canada__SWIG_1`, 'returnType') = '_p_QuantLib__Canada'
class(`Canada__SWIG_1`) = c("SWIGFunction", class('Canada__SWIG_1'))

`Canada` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- Canada__SWIG_1; 
  } else if (argc == 1) {
    if (is.character(argv[[1]])) {
      f <- Canada__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Canada with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_Canada

`delete_Canada` = function(self)
{
  ;.Call('R_swig_delete_Canada', self, PACKAGE='QuantLib');
  
}

attr(`delete_Canada`, 'returnType') = 'void'
attr(`delete_Canada`, "inputTypes") = c('_p_QuantLib__Canada')
class(`delete_Canada`) = c("SWIGFunction", class('delete_Canada'))

setMethod('delete', '_p_QuantLib__Canada', function(obj) {delete_QuantLib__Canada(obj)})
# Start of new_China

`China` = function()
{
  ;ans = .Call('R_swig_new_China', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__China";
  
  reg.finalizer(ans, delete_China)
  ans
  
}

attr(`China`, 'returnType') = '_p_QuantLib__China'
class(`China`) = c("SWIGFunction", class('China'))

# Start of delete_China

`delete_China` = function(self)
{
  ;.Call('R_swig_delete_China', self, PACKAGE='QuantLib');
  
}

attr(`delete_China`, 'returnType') = 'void'
attr(`delete_China`, "inputTypes") = c('_p_QuantLib__China')
class(`delete_China`) = c("SWIGFunction", class('delete_China'))

setMethod('delete', '_p_QuantLib__China', function(obj) {delete_QuantLib__China(obj)})
defineEnumeration('_QuantLib__CzechRepublic__Market',
                    .values = c(
                        'PSE' = 0
))
# Start of new_CzechRepublic

`CzechRepublic__SWIG_0` = function(m)
{
  m = enumToInteger(m, "_QuantLib__CzechRepublic__Market"); 
  
  if(length(m) > 1) {
    warning("using only the first element of m");
  };
  
  ;ans = .Call('R_swig_new_CzechRepublic__SWIG_0', m, PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__CzechRepublic";
  
  reg.finalizer(ans, delete_CzechRepublic)
  ans
  
}

attr(`CzechRepublic__SWIG_0`, 'returnType') = '_p_QuantLib__CzechRepublic'
attr(`CzechRepublic__SWIG_0`, "inputTypes") = c('character')
class(`CzechRepublic__SWIG_0`) = c("SWIGFunction", class('CzechRepublic__SWIG_0'))

# Start of new_CzechRepublic

`CzechRepublic__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_CzechRepublic__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__CzechRepublic";
  
  reg.finalizer(ans, delete_CzechRepublic)
  ans
  
}

attr(`CzechRepublic__SWIG_1`, 'returnType') = '_p_QuantLib__CzechRepublic'
class(`CzechRepublic__SWIG_1`) = c("SWIGFunction", class('CzechRepublic__SWIG_1'))

`CzechRepublic` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- CzechRepublic__SWIG_1; 
  } else if (argc == 1) {
    if (is.character(argv[[1]])) {
      f <- CzechRepublic__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for CzechRepublic with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_CzechRepublic

`delete_CzechRepublic` = function(self)
{
  ;.Call('R_swig_delete_CzechRepublic', self, PACKAGE='QuantLib');
  
}

attr(`delete_CzechRepublic`, 'returnType') = 'void'
attr(`delete_CzechRepublic`, "inputTypes") = c('_p_QuantLib__CzechRepublic')
class(`delete_CzechRepublic`) = c("SWIGFunction", class('delete_CzechRepublic'))

setMethod('delete', '_p_QuantLib__CzechRepublic', function(obj) {delete_QuantLib__CzechRepublic(obj)})
# Start of new_Denmark

`Denmark` = function()
{
  ;ans = .Call('R_swig_new_Denmark', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__Denmark";
  
  reg.finalizer(ans, delete_Denmark)
  ans
  
}

attr(`Denmark`, 'returnType') = '_p_QuantLib__Denmark'
class(`Denmark`) = c("SWIGFunction", class('Denmark'))

# Start of delete_Denmark

`delete_Denmark` = function(self)
{
  ;.Call('R_swig_delete_Denmark', self, PACKAGE='QuantLib');
  
}

attr(`delete_Denmark`, 'returnType') = 'void'
attr(`delete_Denmark`, "inputTypes") = c('_p_QuantLib__Denmark')
class(`delete_Denmark`) = c("SWIGFunction", class('delete_Denmark'))

setMethod('delete', '_p_QuantLib__Denmark', function(obj) {delete_QuantLib__Denmark(obj)})
# Start of new_Finland

`Finland` = function()
{
  ;ans = .Call('R_swig_new_Finland', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__Finland";
  
  reg.finalizer(ans, delete_Finland)
  ans
  
}

attr(`Finland`, 'returnType') = '_p_QuantLib__Finland'
class(`Finland`) = c("SWIGFunction", class('Finland'))

# Start of delete_Finland

`delete_Finland` = function(self)
{
  ;.Call('R_swig_delete_Finland', self, PACKAGE='QuantLib');
  
}

attr(`delete_Finland`, 'returnType') = 'void'
attr(`delete_Finland`, "inputTypes") = c('_p_QuantLib__Finland')
class(`delete_Finland`) = c("SWIGFunction", class('delete_Finland'))

setMethod('delete', '_p_QuantLib__Finland', function(obj) {delete_QuantLib__Finland(obj)})
defineEnumeration('_QuantLib__Germany__Market',
                    .values = c(
                        'Settlement' = 0, 
                        'FrankfurtStockExchange' = 1, 
                        'Xetra' = 2, 
                        'Eurex' = 3
))
# Start of new_Germany

`Germany__SWIG_0` = function(m)
{
  m = enumToInteger(m, "_QuantLib__Germany__Market"); 
  
  if(length(m) > 1) {
    warning("using only the first element of m");
  };
  
  ;ans = .Call('R_swig_new_Germany__SWIG_0', m, PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__Germany";
  
  reg.finalizer(ans, delete_Germany)
  ans
  
}

attr(`Germany__SWIG_0`, 'returnType') = '_p_QuantLib__Germany'
attr(`Germany__SWIG_0`, "inputTypes") = c('character')
class(`Germany__SWIG_0`) = c("SWIGFunction", class('Germany__SWIG_0'))

# Start of new_Germany

`Germany__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_Germany__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__Germany";
  
  reg.finalizer(ans, delete_Germany)
  ans
  
}

attr(`Germany__SWIG_1`, 'returnType') = '_p_QuantLib__Germany'
class(`Germany__SWIG_1`) = c("SWIGFunction", class('Germany__SWIG_1'))

`Germany` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- Germany__SWIG_1; 
  } else if (argc == 1) {
    if (is.character(argv[[1]])) {
      f <- Germany__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Germany with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_Germany

`delete_Germany` = function(self)
{
  ;.Call('R_swig_delete_Germany', self, PACKAGE='QuantLib');
  
}

attr(`delete_Germany`, 'returnType') = 'void'
attr(`delete_Germany`, "inputTypes") = c('_p_QuantLib__Germany')
class(`delete_Germany`) = c("SWIGFunction", class('delete_Germany'))

setMethod('delete', '_p_QuantLib__Germany', function(obj) {delete_QuantLib__Germany(obj)})
defineEnumeration('_QuantLib__HongKong__Market',
                    .values = c(
                        'HKEx' = 0
))
# Start of new_HongKong

`HongKong__SWIG_0` = function(m)
{
  m = enumToInteger(m, "_QuantLib__HongKong__Market"); 
  
  if(length(m) > 1) {
    warning("using only the first element of m");
  };
  
  ;ans = .Call('R_swig_new_HongKong__SWIG_0', m, PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__HongKong";
  
  reg.finalizer(ans, delete_HongKong)
  ans
  
}

attr(`HongKong__SWIG_0`, 'returnType') = '_p_QuantLib__HongKong'
attr(`HongKong__SWIG_0`, "inputTypes") = c('character')
class(`HongKong__SWIG_0`) = c("SWIGFunction", class('HongKong__SWIG_0'))

# Start of new_HongKong

`HongKong__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_HongKong__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__HongKong";
  
  reg.finalizer(ans, delete_HongKong)
  ans
  
}

attr(`HongKong__SWIG_1`, 'returnType') = '_p_QuantLib__HongKong'
class(`HongKong__SWIG_1`) = c("SWIGFunction", class('HongKong__SWIG_1'))

`HongKong` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- HongKong__SWIG_1; 
  } else if (argc == 1) {
    if (is.character(argv[[1]])) {
      f <- HongKong__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for HongKong with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_HongKong

`delete_HongKong` = function(self)
{
  ;.Call('R_swig_delete_HongKong', self, PACKAGE='QuantLib');
  
}

attr(`delete_HongKong`, 'returnType') = 'void'
attr(`delete_HongKong`, "inputTypes") = c('_p_QuantLib__HongKong')
class(`delete_HongKong`) = c("SWIGFunction", class('delete_HongKong'))

setMethod('delete', '_p_QuantLib__HongKong', function(obj) {delete_QuantLib__HongKong(obj)})
# Start of new_Hungary

`Hungary` = function()
{
  ;ans = .Call('R_swig_new_Hungary', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__Hungary";
  
  reg.finalizer(ans, delete_Hungary)
  ans
  
}

attr(`Hungary`, 'returnType') = '_p_QuantLib__Hungary'
class(`Hungary`) = c("SWIGFunction", class('Hungary'))

# Start of delete_Hungary

`delete_Hungary` = function(self)
{
  ;.Call('R_swig_delete_Hungary', self, PACKAGE='QuantLib');
  
}

attr(`delete_Hungary`, 'returnType') = 'void'
attr(`delete_Hungary`, "inputTypes") = c('_p_QuantLib__Hungary')
class(`delete_Hungary`) = c("SWIGFunction", class('delete_Hungary'))

setMethod('delete', '_p_QuantLib__Hungary', function(obj) {delete_QuantLib__Hungary(obj)})
defineEnumeration('_QuantLib__Iceland__Market',
                    .values = c(
                        'ICEX' = 0
))
# Start of new_Iceland

`Iceland__SWIG_0` = function(m)
{
  m = enumToInteger(m, "_QuantLib__Iceland__Market"); 
  
  if(length(m) > 1) {
    warning("using only the first element of m");
  };
  
  ;ans = .Call('R_swig_new_Iceland__SWIG_0', m, PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__Iceland";
  
  reg.finalizer(ans, delete_Iceland)
  ans
  
}

attr(`Iceland__SWIG_0`, 'returnType') = '_p_QuantLib__Iceland'
attr(`Iceland__SWIG_0`, "inputTypes") = c('character')
class(`Iceland__SWIG_0`) = c("SWIGFunction", class('Iceland__SWIG_0'))

# Start of new_Iceland

`Iceland__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_Iceland__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__Iceland";
  
  reg.finalizer(ans, delete_Iceland)
  ans
  
}

attr(`Iceland__SWIG_1`, 'returnType') = '_p_QuantLib__Iceland'
class(`Iceland__SWIG_1`) = c("SWIGFunction", class('Iceland__SWIG_1'))

`Iceland` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- Iceland__SWIG_1; 
  } else if (argc == 1) {
    if (is.character(argv[[1]])) {
      f <- Iceland__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Iceland with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_Iceland

`delete_Iceland` = function(self)
{
  ;.Call('R_swig_delete_Iceland', self, PACKAGE='QuantLib');
  
}

attr(`delete_Iceland`, 'returnType') = 'void'
attr(`delete_Iceland`, "inputTypes") = c('_p_QuantLib__Iceland')
class(`delete_Iceland`) = c("SWIGFunction", class('delete_Iceland'))

setMethod('delete', '_p_QuantLib__Iceland', function(obj) {delete_QuantLib__Iceland(obj)})
defineEnumeration('_QuantLib__India__Market',
                    .values = c(
                        'NSE' = 0
))
# Start of new_India

`India__SWIG_0` = function(m)
{
  m = enumToInteger(m, "_QuantLib__India__Market"); 
  
  if(length(m) > 1) {
    warning("using only the first element of m");
  };
  
  ;ans = .Call('R_swig_new_India__SWIG_0', m, PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__India";
  
  reg.finalizer(ans, delete_India)
  ans
  
}

attr(`India__SWIG_0`, 'returnType') = '_p_QuantLib__India'
attr(`India__SWIG_0`, "inputTypes") = c('character')
class(`India__SWIG_0`) = c("SWIGFunction", class('India__SWIG_0'))

# Start of new_India

`India__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_India__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__India";
  
  reg.finalizer(ans, delete_India)
  ans
  
}

attr(`India__SWIG_1`, 'returnType') = '_p_QuantLib__India'
class(`India__SWIG_1`) = c("SWIGFunction", class('India__SWIG_1'))

`India` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- India__SWIG_1; 
  } else if (argc == 1) {
    if (is.character(argv[[1]])) {
      f <- India__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for India with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_India

`delete_India` = function(self)
{
  ;.Call('R_swig_delete_India', self, PACKAGE='QuantLib');
  
}

attr(`delete_India`, 'returnType') = 'void'
attr(`delete_India`, "inputTypes") = c('_p_QuantLib__India')
class(`delete_India`) = c("SWIGFunction", class('delete_India'))

setMethod('delete', '_p_QuantLib__India', function(obj) {delete_QuantLib__India(obj)})
defineEnumeration('_QuantLib__Indonesia__Market',
                    .values = c(
                        'BEJ' = 0, 
                        'JSX' = 1
))
# Start of new_Indonesia

`Indonesia__SWIG_0` = function(m)
{
  m = enumToInteger(m, "_QuantLib__Indonesia__Market"); 
  
  if(length(m) > 1) {
    warning("using only the first element of m");
  };
  
  ;ans = .Call('R_swig_new_Indonesia__SWIG_0', m, PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__Indonesia";
  
  reg.finalizer(ans, delete_Indonesia)
  ans
  
}

attr(`Indonesia__SWIG_0`, 'returnType') = '_p_QuantLib__Indonesia'
attr(`Indonesia__SWIG_0`, "inputTypes") = c('character')
class(`Indonesia__SWIG_0`) = c("SWIGFunction", class('Indonesia__SWIG_0'))

# Start of new_Indonesia

`Indonesia__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_Indonesia__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__Indonesia";
  
  reg.finalizer(ans, delete_Indonesia)
  ans
  
}

attr(`Indonesia__SWIG_1`, 'returnType') = '_p_QuantLib__Indonesia'
class(`Indonesia__SWIG_1`) = c("SWIGFunction", class('Indonesia__SWIG_1'))

`Indonesia` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- Indonesia__SWIG_1; 
  } else if (argc == 1) {
    if (is.character(argv[[1]])) {
      f <- Indonesia__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Indonesia with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_Indonesia

`delete_Indonesia` = function(self)
{
  ;.Call('R_swig_delete_Indonesia', self, PACKAGE='QuantLib');
  
}

attr(`delete_Indonesia`, 'returnType') = 'void'
attr(`delete_Indonesia`, "inputTypes") = c('_p_QuantLib__Indonesia')
class(`delete_Indonesia`) = c("SWIGFunction", class('delete_Indonesia'))

setMethod('delete', '_p_QuantLib__Indonesia', function(obj) {delete_QuantLib__Indonesia(obj)})
defineEnumeration('_QuantLib__Italy__Market',
                    .values = c(
                        'Settlement' = 0, 
                        'Exchange' = 1
))
# Start of new_Italy

`Italy__SWIG_0` = function(m)
{
  m = enumToInteger(m, "_QuantLib__Italy__Market"); 
  
  if(length(m) > 1) {
    warning("using only the first element of m");
  };
  
  ;ans = .Call('R_swig_new_Italy__SWIG_0', m, PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__Italy";
  
  reg.finalizer(ans, delete_Italy)
  ans
  
}

attr(`Italy__SWIG_0`, 'returnType') = '_p_QuantLib__Italy'
attr(`Italy__SWIG_0`, "inputTypes") = c('character')
class(`Italy__SWIG_0`) = c("SWIGFunction", class('Italy__SWIG_0'))

# Start of new_Italy

`Italy__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_Italy__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__Italy";
  
  reg.finalizer(ans, delete_Italy)
  ans
  
}

attr(`Italy__SWIG_1`, 'returnType') = '_p_QuantLib__Italy'
class(`Italy__SWIG_1`) = c("SWIGFunction", class('Italy__SWIG_1'))

`Italy` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- Italy__SWIG_1; 
  } else if (argc == 1) {
    if (is.character(argv[[1]])) {
      f <- Italy__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Italy with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_Italy

`delete_Italy` = function(self)
{
  ;.Call('R_swig_delete_Italy', self, PACKAGE='QuantLib');
  
}

attr(`delete_Italy`, 'returnType') = 'void'
attr(`delete_Italy`, "inputTypes") = c('_p_QuantLib__Italy')
class(`delete_Italy`) = c("SWIGFunction", class('delete_Italy'))

setMethod('delete', '_p_QuantLib__Italy', function(obj) {delete_QuantLib__Italy(obj)})
# Start of new_Japan

`Japan` = function()
{
  ;ans = .Call('R_swig_new_Japan', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__Japan";
  
  reg.finalizer(ans, delete_Japan)
  ans
  
}

attr(`Japan`, 'returnType') = '_p_QuantLib__Japan'
class(`Japan`) = c("SWIGFunction", class('Japan'))

# Start of delete_Japan

`delete_Japan` = function(self)
{
  ;.Call('R_swig_delete_Japan', self, PACKAGE='QuantLib');
  
}

attr(`delete_Japan`, 'returnType') = 'void'
attr(`delete_Japan`, "inputTypes") = c('_p_QuantLib__Japan')
class(`delete_Japan`) = c("SWIGFunction", class('delete_Japan'))

setMethod('delete', '_p_QuantLib__Japan', function(obj) {delete_QuantLib__Japan(obj)})
defineEnumeration('_QuantLib__Mexico__Market',
                    .values = c(
                        'BMV' = 0
))
# Start of new_Mexico

`Mexico__SWIG_0` = function(m)
{
  m = enumToInteger(m, "_QuantLib__Mexico__Market"); 
  
  if(length(m) > 1) {
    warning("using only the first element of m");
  };
  
  ;ans = .Call('R_swig_new_Mexico__SWIG_0', m, PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__Mexico";
  
  reg.finalizer(ans, delete_Mexico)
  ans
  
}

attr(`Mexico__SWIG_0`, 'returnType') = '_p_QuantLib__Mexico'
attr(`Mexico__SWIG_0`, "inputTypes") = c('character')
class(`Mexico__SWIG_0`) = c("SWIGFunction", class('Mexico__SWIG_0'))

# Start of new_Mexico

`Mexico__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_Mexico__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__Mexico";
  
  reg.finalizer(ans, delete_Mexico)
  ans
  
}

attr(`Mexico__SWIG_1`, 'returnType') = '_p_QuantLib__Mexico'
class(`Mexico__SWIG_1`) = c("SWIGFunction", class('Mexico__SWIG_1'))

`Mexico` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- Mexico__SWIG_1; 
  } else if (argc == 1) {
    if (is.character(argv[[1]])) {
      f <- Mexico__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Mexico with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_Mexico

`delete_Mexico` = function(self)
{
  ;.Call('R_swig_delete_Mexico', self, PACKAGE='QuantLib');
  
}

attr(`delete_Mexico`, 'returnType') = 'void'
attr(`delete_Mexico`, "inputTypes") = c('_p_QuantLib__Mexico')
class(`delete_Mexico`) = c("SWIGFunction", class('delete_Mexico'))

setMethod('delete', '_p_QuantLib__Mexico', function(obj) {delete_QuantLib__Mexico(obj)})
# Start of new_NewZealand

`NewZealand` = function()
{
  ;ans = .Call('R_swig_new_NewZealand', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__NewZealand";
  
  reg.finalizer(ans, delete_NewZealand)
  ans
  
}

attr(`NewZealand`, 'returnType') = '_p_QuantLib__NewZealand'
class(`NewZealand`) = c("SWIGFunction", class('NewZealand'))

# Start of delete_NewZealand

`delete_NewZealand` = function(self)
{
  ;.Call('R_swig_delete_NewZealand', self, PACKAGE='QuantLib');
  
}

attr(`delete_NewZealand`, 'returnType') = 'void'
attr(`delete_NewZealand`, "inputTypes") = c('_p_QuantLib__NewZealand')
class(`delete_NewZealand`) = c("SWIGFunction", class('delete_NewZealand'))

setMethod('delete', '_p_QuantLib__NewZealand', function(obj) {delete_QuantLib__NewZealand(obj)})
# Start of new_Norway

`Norway` = function()
{
  ;ans = .Call('R_swig_new_Norway', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__Norway";
  
  reg.finalizer(ans, delete_Norway)
  ans
  
}

attr(`Norway`, 'returnType') = '_p_QuantLib__Norway'
class(`Norway`) = c("SWIGFunction", class('Norway'))

# Start of delete_Norway

`delete_Norway` = function(self)
{
  ;.Call('R_swig_delete_Norway', self, PACKAGE='QuantLib');
  
}

attr(`delete_Norway`, 'returnType') = 'void'
attr(`delete_Norway`, "inputTypes") = c('_p_QuantLib__Norway')
class(`delete_Norway`) = c("SWIGFunction", class('delete_Norway'))

setMethod('delete', '_p_QuantLib__Norway', function(obj) {delete_QuantLib__Norway(obj)})
# Start of new_Poland

`Poland` = function()
{
  ;ans = .Call('R_swig_new_Poland', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__Poland";
  
  reg.finalizer(ans, delete_Poland)
  ans
  
}

attr(`Poland`, 'returnType') = '_p_QuantLib__Poland'
class(`Poland`) = c("SWIGFunction", class('Poland'))

# Start of delete_Poland

`delete_Poland` = function(self)
{
  ;.Call('R_swig_delete_Poland', self, PACKAGE='QuantLib');
  
}

attr(`delete_Poland`, 'returnType') = 'void'
attr(`delete_Poland`, "inputTypes") = c('_p_QuantLib__Poland')
class(`delete_Poland`) = c("SWIGFunction", class('delete_Poland'))

setMethod('delete', '_p_QuantLib__Poland', function(obj) {delete_QuantLib__Poland(obj)})
# Start of new_Russia

`Russia` = function()
{
  ;ans = .Call('R_swig_new_Russia', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__Russia";
  
  reg.finalizer(ans, delete_Russia)
  ans
  
}

attr(`Russia`, 'returnType') = '_p_QuantLib__Russia'
class(`Russia`) = c("SWIGFunction", class('Russia'))

# Start of delete_Russia

`delete_Russia` = function(self)
{
  ;.Call('R_swig_delete_Russia', self, PACKAGE='QuantLib');
  
}

attr(`delete_Russia`, 'returnType') = 'void'
attr(`delete_Russia`, "inputTypes") = c('_p_QuantLib__Russia')
class(`delete_Russia`) = c("SWIGFunction", class('delete_Russia'))

setMethod('delete', '_p_QuantLib__Russia', function(obj) {delete_QuantLib__Russia(obj)})
defineEnumeration('_QuantLib__SaudiArabia__Market',
                    .values = c(
                        'Tadawul' = 0
))
# Start of new_SaudiArabia

`SaudiArabia__SWIG_0` = function(m)
{
  m = enumToInteger(m, "_QuantLib__SaudiArabia__Market"); 
  
  if(length(m) > 1) {
    warning("using only the first element of m");
  };
  
  ;ans = .Call('R_swig_new_SaudiArabia__SWIG_0', m, PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__SaudiArabia";
  
  reg.finalizer(ans, delete_SaudiArabia)
  ans
  
}

attr(`SaudiArabia__SWIG_0`, 'returnType') = '_p_QuantLib__SaudiArabia'
attr(`SaudiArabia__SWIG_0`, "inputTypes") = c('character')
class(`SaudiArabia__SWIG_0`) = c("SWIGFunction", class('SaudiArabia__SWIG_0'))

# Start of new_SaudiArabia

`SaudiArabia__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_SaudiArabia__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__SaudiArabia";
  
  reg.finalizer(ans, delete_SaudiArabia)
  ans
  
}

attr(`SaudiArabia__SWIG_1`, 'returnType') = '_p_QuantLib__SaudiArabia'
class(`SaudiArabia__SWIG_1`) = c("SWIGFunction", class('SaudiArabia__SWIG_1'))

`SaudiArabia` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- SaudiArabia__SWIG_1; 
  } else if (argc == 1) {
    if (is.character(argv[[1]])) {
      f <- SaudiArabia__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for SaudiArabia with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_SaudiArabia

`delete_SaudiArabia` = function(self)
{
  ;.Call('R_swig_delete_SaudiArabia', self, PACKAGE='QuantLib');
  
}

attr(`delete_SaudiArabia`, 'returnType') = 'void'
attr(`delete_SaudiArabia`, "inputTypes") = c('_p_QuantLib__SaudiArabia')
class(`delete_SaudiArabia`) = c("SWIGFunction", class('delete_SaudiArabia'))

setMethod('delete', '_p_QuantLib__SaudiArabia', function(obj) {delete_QuantLib__SaudiArabia(obj)})
defineEnumeration('_QuantLib__Singapore__Market',
                    .values = c(
                        'SGX' = 0
))
# Start of new_Singapore

`Singapore__SWIG_0` = function(m)
{
  m = enumToInteger(m, "_QuantLib__Singapore__Market"); 
  
  if(length(m) > 1) {
    warning("using only the first element of m");
  };
  
  ;ans = .Call('R_swig_new_Singapore__SWIG_0', m, PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__Singapore";
  
  reg.finalizer(ans, delete_Singapore)
  ans
  
}

attr(`Singapore__SWIG_0`, 'returnType') = '_p_QuantLib__Singapore'
attr(`Singapore__SWIG_0`, "inputTypes") = c('character')
class(`Singapore__SWIG_0`) = c("SWIGFunction", class('Singapore__SWIG_0'))

# Start of new_Singapore

`Singapore__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_Singapore__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__Singapore";
  
  reg.finalizer(ans, delete_Singapore)
  ans
  
}

attr(`Singapore__SWIG_1`, 'returnType') = '_p_QuantLib__Singapore'
class(`Singapore__SWIG_1`) = c("SWIGFunction", class('Singapore__SWIG_1'))

`Singapore` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- Singapore__SWIG_1; 
  } else if (argc == 1) {
    if (is.character(argv[[1]])) {
      f <- Singapore__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Singapore with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_Singapore

`delete_Singapore` = function(self)
{
  ;.Call('R_swig_delete_Singapore', self, PACKAGE='QuantLib');
  
}

attr(`delete_Singapore`, 'returnType') = 'void'
attr(`delete_Singapore`, "inputTypes") = c('_p_QuantLib__Singapore')
class(`delete_Singapore`) = c("SWIGFunction", class('delete_Singapore'))

setMethod('delete', '_p_QuantLib__Singapore', function(obj) {delete_QuantLib__Singapore(obj)})
defineEnumeration('_QuantLib__Slovakia__Market',
                    .values = c(
                        'BSSE' = 0
))
# Start of new_Slovakia

`Slovakia__SWIG_0` = function(m)
{
  m = enumToInteger(m, "_QuantLib__Slovakia__Market"); 
  
  if(length(m) > 1) {
    warning("using only the first element of m");
  };
  
  ;ans = .Call('R_swig_new_Slovakia__SWIG_0', m, PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__Slovakia";
  
  reg.finalizer(ans, delete_Slovakia)
  ans
  
}

attr(`Slovakia__SWIG_0`, 'returnType') = '_p_QuantLib__Slovakia'
attr(`Slovakia__SWIG_0`, "inputTypes") = c('character')
class(`Slovakia__SWIG_0`) = c("SWIGFunction", class('Slovakia__SWIG_0'))

# Start of new_Slovakia

`Slovakia__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_Slovakia__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__Slovakia";
  
  reg.finalizer(ans, delete_Slovakia)
  ans
  
}

attr(`Slovakia__SWIG_1`, 'returnType') = '_p_QuantLib__Slovakia'
class(`Slovakia__SWIG_1`) = c("SWIGFunction", class('Slovakia__SWIG_1'))

`Slovakia` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- Slovakia__SWIG_1; 
  } else if (argc == 1) {
    if (is.character(argv[[1]])) {
      f <- Slovakia__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Slovakia with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_Slovakia

`delete_Slovakia` = function(self)
{
  ;.Call('R_swig_delete_Slovakia', self, PACKAGE='QuantLib');
  
}

attr(`delete_Slovakia`, 'returnType') = 'void'
attr(`delete_Slovakia`, "inputTypes") = c('_p_QuantLib__Slovakia')
class(`delete_Slovakia`) = c("SWIGFunction", class('delete_Slovakia'))

setMethod('delete', '_p_QuantLib__Slovakia', function(obj) {delete_QuantLib__Slovakia(obj)})
# Start of new_SouthAfrica

`SouthAfrica` = function()
{
  ;ans = .Call('R_swig_new_SouthAfrica', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__SouthAfrica";
  
  reg.finalizer(ans, delete_SouthAfrica)
  ans
  
}

attr(`SouthAfrica`, 'returnType') = '_p_QuantLib__SouthAfrica'
class(`SouthAfrica`) = c("SWIGFunction", class('SouthAfrica'))

# Start of delete_SouthAfrica

`delete_SouthAfrica` = function(self)
{
  ;.Call('R_swig_delete_SouthAfrica', self, PACKAGE='QuantLib');
  
}

attr(`delete_SouthAfrica`, 'returnType') = 'void'
attr(`delete_SouthAfrica`, "inputTypes") = c('_p_QuantLib__SouthAfrica')
class(`delete_SouthAfrica`) = c("SWIGFunction", class('delete_SouthAfrica'))

setMethod('delete', '_p_QuantLib__SouthAfrica', function(obj) {delete_QuantLib__SouthAfrica(obj)})
defineEnumeration('_QuantLib__SouthKorea__Market',
                    .values = c(
                        'Settlement' = 0, 
                        'KRX' = 1
))
# Start of new_SouthKorea

`SouthKorea__SWIG_0` = function(m)
{
  m = enumToInteger(m, "_QuantLib__SouthKorea__Market"); 
  
  if(length(m) > 1) {
    warning("using only the first element of m");
  };
  
  ;ans = .Call('R_swig_new_SouthKorea__SWIG_0', m, PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__SouthKorea";
  
  reg.finalizer(ans, delete_SouthKorea)
  ans
  
}

attr(`SouthKorea__SWIG_0`, 'returnType') = '_p_QuantLib__SouthKorea'
attr(`SouthKorea__SWIG_0`, "inputTypes") = c('character')
class(`SouthKorea__SWIG_0`) = c("SWIGFunction", class('SouthKorea__SWIG_0'))

# Start of new_SouthKorea

`SouthKorea__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_SouthKorea__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__SouthKorea";
  
  reg.finalizer(ans, delete_SouthKorea)
  ans
  
}

attr(`SouthKorea__SWIG_1`, 'returnType') = '_p_QuantLib__SouthKorea'
class(`SouthKorea__SWIG_1`) = c("SWIGFunction", class('SouthKorea__SWIG_1'))

`SouthKorea` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- SouthKorea__SWIG_1; 
  } else if (argc == 1) {
    if (is.character(argv[[1]])) {
      f <- SouthKorea__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for SouthKorea with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_SouthKorea

`delete_SouthKorea` = function(self)
{
  ;.Call('R_swig_delete_SouthKorea', self, PACKAGE='QuantLib');
  
}

attr(`delete_SouthKorea`, 'returnType') = 'void'
attr(`delete_SouthKorea`, "inputTypes") = c('_p_QuantLib__SouthKorea')
class(`delete_SouthKorea`) = c("SWIGFunction", class('delete_SouthKorea'))

setMethod('delete', '_p_QuantLib__SouthKorea', function(obj) {delete_QuantLib__SouthKorea(obj)})
# Start of new_Sweden

`Sweden` = function()
{
  ;ans = .Call('R_swig_new_Sweden', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__Sweden";
  
  reg.finalizer(ans, delete_Sweden)
  ans
  
}

attr(`Sweden`, 'returnType') = '_p_QuantLib__Sweden'
class(`Sweden`) = c("SWIGFunction", class('Sweden'))

# Start of delete_Sweden

`delete_Sweden` = function(self)
{
  ;.Call('R_swig_delete_Sweden', self, PACKAGE='QuantLib');
  
}

attr(`delete_Sweden`, 'returnType') = 'void'
attr(`delete_Sweden`, "inputTypes") = c('_p_QuantLib__Sweden')
class(`delete_Sweden`) = c("SWIGFunction", class('delete_Sweden'))

setMethod('delete', '_p_QuantLib__Sweden', function(obj) {delete_QuantLib__Sweden(obj)})
# Start of new_Switzerland

`Switzerland` = function()
{
  ;ans = .Call('R_swig_new_Switzerland', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__Switzerland";
  
  reg.finalizer(ans, delete_Switzerland)
  ans
  
}

attr(`Switzerland`, 'returnType') = '_p_QuantLib__Switzerland'
class(`Switzerland`) = c("SWIGFunction", class('Switzerland'))

# Start of delete_Switzerland

`delete_Switzerland` = function(self)
{
  ;.Call('R_swig_delete_Switzerland', self, PACKAGE='QuantLib');
  
}

attr(`delete_Switzerland`, 'returnType') = 'void'
attr(`delete_Switzerland`, "inputTypes") = c('_p_QuantLib__Switzerland')
class(`delete_Switzerland`) = c("SWIGFunction", class('delete_Switzerland'))

setMethod('delete', '_p_QuantLib__Switzerland', function(obj) {delete_QuantLib__Switzerland(obj)})
defineEnumeration('_QuantLib__Taiwan__Market',
                    .values = c(
                        'TSEC' = 0
))
# Start of new_Taiwan

`Taiwan__SWIG_0` = function(m)
{
  m = enumToInteger(m, "_QuantLib__Taiwan__Market"); 
  
  if(length(m) > 1) {
    warning("using only the first element of m");
  };
  
  ;ans = .Call('R_swig_new_Taiwan__SWIG_0', m, PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__Taiwan";
  
  reg.finalizer(ans, delete_Taiwan)
  ans
  
}

attr(`Taiwan__SWIG_0`, 'returnType') = '_p_QuantLib__Taiwan'
attr(`Taiwan__SWIG_0`, "inputTypes") = c('character')
class(`Taiwan__SWIG_0`) = c("SWIGFunction", class('Taiwan__SWIG_0'))

# Start of new_Taiwan

`Taiwan__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_Taiwan__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__Taiwan";
  
  reg.finalizer(ans, delete_Taiwan)
  ans
  
}

attr(`Taiwan__SWIG_1`, 'returnType') = '_p_QuantLib__Taiwan'
class(`Taiwan__SWIG_1`) = c("SWIGFunction", class('Taiwan__SWIG_1'))

`Taiwan` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- Taiwan__SWIG_1; 
  } else if (argc == 1) {
    if (is.character(argv[[1]])) {
      f <- Taiwan__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Taiwan with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_Taiwan

`delete_Taiwan` = function(self)
{
  ;.Call('R_swig_delete_Taiwan', self, PACKAGE='QuantLib');
  
}

attr(`delete_Taiwan`, 'returnType') = 'void'
attr(`delete_Taiwan`, "inputTypes") = c('_p_QuantLib__Taiwan')
class(`delete_Taiwan`) = c("SWIGFunction", class('delete_Taiwan'))

setMethod('delete', '_p_QuantLib__Taiwan', function(obj) {delete_QuantLib__Taiwan(obj)})
# Start of new_TARGET

`TARGET` = function()
{
  ;ans = .Call('R_swig_new_TARGET', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__TARGET";
  
  reg.finalizer(ans, delete_TARGET)
  ans
  
}

attr(`TARGET`, 'returnType') = '_p_QuantLib__TARGET'
class(`TARGET`) = c("SWIGFunction", class('TARGET'))

# Start of delete_TARGET

`delete_TARGET` = function(self)
{
  ;.Call('R_swig_delete_TARGET', self, PACKAGE='QuantLib');
  
}

attr(`delete_TARGET`, 'returnType') = 'void'
attr(`delete_TARGET`, "inputTypes") = c('_p_QuantLib__TARGET')
class(`delete_TARGET`) = c("SWIGFunction", class('delete_TARGET'))

setMethod('delete', '_p_QuantLib__TARGET', function(obj) {delete_QuantLib__TARGET(obj)})
# Start of new_Turkey

`Turkey` = function()
{
  ;ans = .Call('R_swig_new_Turkey', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__Turkey";
  
  reg.finalizer(ans, delete_Turkey)
  ans
  
}

attr(`Turkey`, 'returnType') = '_p_QuantLib__Turkey'
class(`Turkey`) = c("SWIGFunction", class('Turkey'))

# Start of delete_Turkey

`delete_Turkey` = function(self)
{
  ;.Call('R_swig_delete_Turkey', self, PACKAGE='QuantLib');
  
}

attr(`delete_Turkey`, 'returnType') = 'void'
attr(`delete_Turkey`, "inputTypes") = c('_p_QuantLib__Turkey')
class(`delete_Turkey`) = c("SWIGFunction", class('delete_Turkey'))

setMethod('delete', '_p_QuantLib__Turkey', function(obj) {delete_QuantLib__Turkey(obj)})
defineEnumeration('_QuantLib__Ukraine__Market',
                    .values = c(
                        'USE' = 0
))
# Start of new_Ukraine

`Ukraine__SWIG_0` = function(m)
{
  m = enumToInteger(m, "_QuantLib__Ukraine__Market"); 
  
  if(length(m) > 1) {
    warning("using only the first element of m");
  };
  
  ;ans = .Call('R_swig_new_Ukraine__SWIG_0', m, PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__Ukraine";
  
  reg.finalizer(ans, delete_Ukraine)
  ans
  
}

attr(`Ukraine__SWIG_0`, 'returnType') = '_p_QuantLib__Ukraine'
attr(`Ukraine__SWIG_0`, "inputTypes") = c('character')
class(`Ukraine__SWIG_0`) = c("SWIGFunction", class('Ukraine__SWIG_0'))

# Start of new_Ukraine

`Ukraine__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_Ukraine__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__Ukraine";
  
  reg.finalizer(ans, delete_Ukraine)
  ans
  
}

attr(`Ukraine__SWIG_1`, 'returnType') = '_p_QuantLib__Ukraine'
class(`Ukraine__SWIG_1`) = c("SWIGFunction", class('Ukraine__SWIG_1'))

`Ukraine` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- Ukraine__SWIG_1; 
  } else if (argc == 1) {
    if (is.character(argv[[1]])) {
      f <- Ukraine__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Ukraine with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_Ukraine

`delete_Ukraine` = function(self)
{
  ;.Call('R_swig_delete_Ukraine', self, PACKAGE='QuantLib');
  
}

attr(`delete_Ukraine`, 'returnType') = 'void'
attr(`delete_Ukraine`, "inputTypes") = c('_p_QuantLib__Ukraine')
class(`delete_Ukraine`) = c("SWIGFunction", class('delete_Ukraine'))

setMethod('delete', '_p_QuantLib__Ukraine', function(obj) {delete_QuantLib__Ukraine(obj)})
defineEnumeration('_QuantLib__UnitedKingdom__Market',
                    .values = c(
                        'Settlement' = 0, 
                        'Exchange' = 1, 
                        'Metals' = 2
))
# Start of new_UnitedKingdom

`UnitedKingdom__SWIG_0` = function(m)
{
  m = enumToInteger(m, "_QuantLib__UnitedKingdom__Market"); 
  
  if(length(m) > 1) {
    warning("using only the first element of m");
  };
  
  ;ans = .Call('R_swig_new_UnitedKingdom__SWIG_0', m, PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__UnitedKingdom";
  
  reg.finalizer(ans, delete_UnitedKingdom)
  ans
  
}

attr(`UnitedKingdom__SWIG_0`, 'returnType') = '_p_QuantLib__UnitedKingdom'
attr(`UnitedKingdom__SWIG_0`, "inputTypes") = c('character')
class(`UnitedKingdom__SWIG_0`) = c("SWIGFunction", class('UnitedKingdom__SWIG_0'))

# Start of new_UnitedKingdom

`UnitedKingdom__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_UnitedKingdom__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__UnitedKingdom";
  
  reg.finalizer(ans, delete_UnitedKingdom)
  ans
  
}

attr(`UnitedKingdom__SWIG_1`, 'returnType') = '_p_QuantLib__UnitedKingdom'
class(`UnitedKingdom__SWIG_1`) = c("SWIGFunction", class('UnitedKingdom__SWIG_1'))

`UnitedKingdom` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- UnitedKingdom__SWIG_1; 
  } else if (argc == 1) {
    if (is.character(argv[[1]])) {
      f <- UnitedKingdom__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for UnitedKingdom with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_UnitedKingdom

`delete_UnitedKingdom` = function(self)
{
  ;.Call('R_swig_delete_UnitedKingdom', self, PACKAGE='QuantLib');
  
}

attr(`delete_UnitedKingdom`, 'returnType') = 'void'
attr(`delete_UnitedKingdom`, "inputTypes") = c('_p_QuantLib__UnitedKingdom')
class(`delete_UnitedKingdom`) = c("SWIGFunction", class('delete_UnitedKingdom'))

setMethod('delete', '_p_QuantLib__UnitedKingdom', function(obj) {delete_QuantLib__UnitedKingdom(obj)})
defineEnumeration('_QuantLib__UnitedStates__Market',
                    .values = c(
                        'Settlement' = 0, 
                        'NYSE' = 1, 
                        'GovernmentBond' = 2, 
                        'NERC' = 3
))
# Start of new_UnitedStates

`UnitedStates__SWIG_0` = function(m)
{
  m = enumToInteger(m, "_QuantLib__UnitedStates__Market"); 
  
  if(length(m) > 1) {
    warning("using only the first element of m");
  };
  
  ;ans = .Call('R_swig_new_UnitedStates__SWIG_0', m, PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__UnitedStates";
  
  reg.finalizer(ans, delete_UnitedStates)
  ans
  
}

attr(`UnitedStates__SWIG_0`, 'returnType') = '_p_QuantLib__UnitedStates'
attr(`UnitedStates__SWIG_0`, "inputTypes") = c('character')
class(`UnitedStates__SWIG_0`) = c("SWIGFunction", class('UnitedStates__SWIG_0'))

# Start of new_UnitedStates

`UnitedStates__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_UnitedStates__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__UnitedStates";
  
  reg.finalizer(ans, delete_UnitedStates)
  ans
  
}

attr(`UnitedStates__SWIG_1`, 'returnType') = '_p_QuantLib__UnitedStates'
class(`UnitedStates__SWIG_1`) = c("SWIGFunction", class('UnitedStates__SWIG_1'))

`UnitedStates` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- UnitedStates__SWIG_1; 
  } else if (argc == 1) {
    if (is.character(argv[[1]])) {
      f <- UnitedStates__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for UnitedStates with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_UnitedStates

`delete_UnitedStates` = function(self)
{
  ;.Call('R_swig_delete_UnitedStates', self, PACKAGE='QuantLib');
  
}

attr(`delete_UnitedStates`, 'returnType') = 'void'
attr(`delete_UnitedStates`, "inputTypes") = c('_p_QuantLib__UnitedStates')
class(`delete_UnitedStates`) = c("SWIGFunction", class('delete_UnitedStates'))

setMethod('delete', '_p_QuantLib__UnitedStates', function(obj) {delete_QuantLib__UnitedStates(obj)})
# Start of new_NullCalendar

`NullCalendar` = function()
{
  ;ans = .Call('R_swig_new_NullCalendar', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__NullCalendar";
  
  reg.finalizer(ans, delete_NullCalendar)
  ans
  
}

attr(`NullCalendar`, 'returnType') = '_p_QuantLib__NullCalendar'
class(`NullCalendar`) = c("SWIGFunction", class('NullCalendar'))

# Start of delete_NullCalendar

`delete_NullCalendar` = function(self)
{
  ;.Call('R_swig_delete_NullCalendar', self, PACKAGE='QuantLib');
  
}

attr(`delete_NullCalendar`, 'returnType') = 'void'
attr(`delete_NullCalendar`, "inputTypes") = c('_p_QuantLib__NullCalendar')
class(`delete_NullCalendar`) = c("SWIGFunction", class('delete_NullCalendar'))

setMethod('delete', '_p_QuantLib__NullCalendar', function(obj) {delete_QuantLib__NullCalendar(obj)})
# Start of new_WeekendsOnly

`WeekendsOnly` = function()
{
  ;ans = .Call('R_swig_new_WeekendsOnly', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__WeekendsOnly";
  
  reg.finalizer(ans, delete_WeekendsOnly)
  ans
  
}

attr(`WeekendsOnly`, 'returnType') = '_p_QuantLib__WeekendsOnly'
class(`WeekendsOnly`) = c("SWIGFunction", class('WeekendsOnly'))

# Start of delete_WeekendsOnly

`delete_WeekendsOnly` = function(self)
{
  ;.Call('R_swig_delete_WeekendsOnly', self, PACKAGE='QuantLib');
  
}

attr(`delete_WeekendsOnly`, 'returnType') = 'void'
attr(`delete_WeekendsOnly`, "inputTypes") = c('_p_QuantLib__WeekendsOnly')
class(`delete_WeekendsOnly`) = c("SWIGFunction", class('delete_WeekendsOnly'))

setMethod('delete', '_p_QuantLib__WeekendsOnly', function(obj) {delete_QuantLib__WeekendsOnly(obj)})
# Start of new_JointCalendar

`JointCalendar__SWIG_0` = function(s_arg1, s_arg2, rule)
{
  rule = enumToInteger(rule, "_JointCalendarRule"); 
  
  if(length(rule) > 1) {
    warning("using only the first element of rule");
  };
  
  ;ans = .Call('R_swig_new_JointCalendar__SWIG_0', s_arg1, s_arg2, rule, PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__JointCalendar";
  
  reg.finalizer(ans, delete_JointCalendar)
  ans
  
}

attr(`JointCalendar__SWIG_0`, 'returnType') = '_p_QuantLib__JointCalendar'
attr(`JointCalendar__SWIG_0`, "inputTypes") = c('_p_Calendar', '_p_Calendar', 'character')
class(`JointCalendar__SWIG_0`) = c("SWIGFunction", class('JointCalendar__SWIG_0'))

# Start of new_JointCalendar

`JointCalendar__SWIG_1` = function(s_arg1, s_arg2)
{
  ;ans = .Call('R_swig_new_JointCalendar__SWIG_1', s_arg1, s_arg2, PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__JointCalendar";
  
  reg.finalizer(ans, delete_JointCalendar)
  ans
  
}

attr(`JointCalendar__SWIG_1`, 'returnType') = '_p_QuantLib__JointCalendar'
attr(`JointCalendar__SWIG_1`, "inputTypes") = c('_p_Calendar', '_p_Calendar')
class(`JointCalendar__SWIG_1`) = c("SWIGFunction", class('JointCalendar__SWIG_1'))

# Start of new_JointCalendar

`JointCalendar__SWIG_2` = function(s_arg1, s_arg2, s_arg3, rule)
{
  rule = enumToInteger(rule, "_JointCalendarRule"); 
  
  if(length(rule) > 1) {
    warning("using only the first element of rule");
  };
  
  ;ans = .Call('R_swig_new_JointCalendar__SWIG_2', s_arg1, s_arg2, s_arg3, rule, PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__JointCalendar";
  
  reg.finalizer(ans, delete_JointCalendar)
  ans
  
}

attr(`JointCalendar__SWIG_2`, 'returnType') = '_p_QuantLib__JointCalendar'
attr(`JointCalendar__SWIG_2`, "inputTypes") = c('_p_Calendar', '_p_Calendar', '_p_Calendar', 'character')
class(`JointCalendar__SWIG_2`) = c("SWIGFunction", class('JointCalendar__SWIG_2'))

# Start of new_JointCalendar

`JointCalendar__SWIG_3` = function(s_arg1, s_arg2, s_arg3)
{
  ;ans = .Call('R_swig_new_JointCalendar__SWIG_3', s_arg1, s_arg2, s_arg3, PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__JointCalendar";
  
  reg.finalizer(ans, delete_JointCalendar)
  ans
  
}

attr(`JointCalendar__SWIG_3`, 'returnType') = '_p_QuantLib__JointCalendar'
attr(`JointCalendar__SWIG_3`, "inputTypes") = c('_p_Calendar', '_p_Calendar', '_p_Calendar')
class(`JointCalendar__SWIG_3`) = c("SWIGFunction", class('JointCalendar__SWIG_3'))

# Start of new_JointCalendar

`JointCalendar__SWIG_4` = function(s_arg1, s_arg2, s_arg3, s_arg4, rule)
{
  rule = enumToInteger(rule, "_JointCalendarRule"); 
  
  if(length(rule) > 1) {
    warning("using only the first element of rule");
  };
  
  ;ans = .Call('R_swig_new_JointCalendar__SWIG_4', s_arg1, s_arg2, s_arg3, s_arg4, rule, PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__JointCalendar";
  
  reg.finalizer(ans, delete_JointCalendar)
  ans
  
}

attr(`JointCalendar__SWIG_4`, 'returnType') = '_p_QuantLib__JointCalendar'
attr(`JointCalendar__SWIG_4`, "inputTypes") = c('_p_Calendar', '_p_Calendar', '_p_Calendar', '_p_Calendar', 'character')
class(`JointCalendar__SWIG_4`) = c("SWIGFunction", class('JointCalendar__SWIG_4'))

# Start of new_JointCalendar

`JointCalendar__SWIG_5` = function(s_arg1, s_arg2, s_arg3, s_arg4)
{
  ;ans = .Call('R_swig_new_JointCalendar__SWIG_5', s_arg1, s_arg2, s_arg3, s_arg4, PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__JointCalendar";
  
  reg.finalizer(ans, delete_JointCalendar)
  ans
  
}

attr(`JointCalendar__SWIG_5`, 'returnType') = '_p_QuantLib__JointCalendar'
attr(`JointCalendar__SWIG_5`, "inputTypes") = c('_p_Calendar', '_p_Calendar', '_p_Calendar', '_p_Calendar')
class(`JointCalendar__SWIG_5`) = c("SWIGFunction", class('JointCalendar__SWIG_5'))

`JointCalendar` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 6
  if (argc == 2) {
    if (extends(argtypes[1], '_p_Calendar') && extends(argtypes[2], '_p_Calendar')) {
      f <- JointCalendar__SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_Calendar') && extends(argtypes[2], '_p_Calendar') && extends(argtypes[3], '_p_Calendar')) {
      f <- JointCalendar__SWIG_3; 
    }
    else if (extends(argtypes[1], '_p_Calendar') && extends(argtypes[2], '_p_Calendar') && is.character(argv[[3]])) {
      f <- JointCalendar__SWIG_0; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_Calendar') && extends(argtypes[2], '_p_Calendar') && extends(argtypes[3], '_p_Calendar') && extends(argtypes[4], '_p_Calendar')) {
      f <- JointCalendar__SWIG_5; 
    }
    else if (extends(argtypes[1], '_p_Calendar') && extends(argtypes[2], '_p_Calendar') && extends(argtypes[3], '_p_Calendar') && is.character(argv[[4]])) {
      f <- JointCalendar__SWIG_2; 
    }
  } else if (argc == 5) {
    if (extends(argtypes[1], '_p_Calendar') && extends(argtypes[2], '_p_Calendar') && extends(argtypes[3], '_p_Calendar') && extends(argtypes[4], '_p_Calendar') && is.character(argv[[5]])) {
      f <- JointCalendar__SWIG_4; 
    }
  } else {
    stop("cannot find overloaded function for JointCalendar with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_JointCalendar

`delete_JointCalendar` = function(self)
{
  ;.Call('R_swig_delete_JointCalendar', self, PACKAGE='QuantLib');
  
}

attr(`delete_JointCalendar`, 'returnType') = 'void'
attr(`delete_JointCalendar`, "inputTypes") = c('_p_QuantLib__JointCalendar')
class(`delete_JointCalendar`) = c("SWIGFunction", class('delete_JointCalendar'))

setMethod('delete', '_p_QuantLib__JointCalendar', function(obj) {delete_QuantLib__JointCalendar(obj)})
# Start of new_BespokeCalendar

`BespokeCalendar` = function(name)
{
  name = as(name, "character"); 
  ;ans = .Call('R_swig_new_BespokeCalendar', name, PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__BespokeCalendar";
  
  reg.finalizer(ans, delete_BespokeCalendar)
  ans
  
}

attr(`BespokeCalendar`, 'returnType') = '_p_QuantLib__BespokeCalendar'
attr(`BespokeCalendar`, "inputTypes") = c('character')
class(`BespokeCalendar`) = c("SWIGFunction", class('BespokeCalendar'))

# Start of BespokeCalendar_addWeekend

`BespokeCalendar_addWeekend` = function(self, s_arg2)
{
  s_arg2 = enumToInteger(s_arg2, "_Weekday"); 
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  ;.Call('R_swig_BespokeCalendar_addWeekend', self, s_arg2, PACKAGE='QuantLib');
  
}

attr(`BespokeCalendar_addWeekend`, 'returnType') = 'void'
attr(`BespokeCalendar_addWeekend`, "inputTypes") = c('_p_QuantLib__BespokeCalendar', 'character')
class(`BespokeCalendar_addWeekend`) = c("SWIGFunction", class('BespokeCalendar_addWeekend'))

# Start of delete_BespokeCalendar

`delete_BespokeCalendar` = function(self)
{
  ;.Call('R_swig_delete_BespokeCalendar', self, PACKAGE='QuantLib');
  
}

attr(`delete_BespokeCalendar`, 'returnType') = 'void'
attr(`delete_BespokeCalendar`, "inputTypes") = c('_p_QuantLib__BespokeCalendar')
class(`delete_BespokeCalendar`) = c("SWIGFunction", class('delete_BespokeCalendar'))

# Start of accessor method for QuantLib::BespokeCalendar
setMethod('$', '_p_QuantLib__BespokeCalendar', function(x, name)

{
  accessorFuns = list('addWeekend' = BespokeCalendar_addWeekend);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for QuantLib::BespokeCalendar
setMethod('delete', '_p_QuantLib__BespokeCalendar', function(obj) {delete_QuantLib__BespokeCalendar(obj)})
# Start of new_Rounding

`Rounding` = function()
{
  ;ans = .Call('R_swig_new_Rounding', PACKAGE='QuantLib');
  class(ans) <- "_p_Rounding";
  
  reg.finalizer(ans, delete_Rounding)
  ans
  
}

attr(`Rounding`, 'returnType') = '_p_Rounding'
class(`Rounding`) = c("SWIGFunction", class('Rounding'))

# Start of Rounding___call__

`Rounding___call__` = function(self, value, .copy = FALSE)
{
  ;.Call('R_swig_Rounding___call__', self, value, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Rounding___call__`, 'returnType') = 'numeric'
attr(`Rounding___call__`, "inputTypes") = c('_p_Rounding', 'numeric')
class(`Rounding___call__`) = c("SWIGFunction", class('Rounding___call__'))

# Start of delete_Rounding

`delete_Rounding` = function(self)
{
  ;.Call('R_swig_delete_Rounding', self, PACKAGE='QuantLib');
  
}

attr(`delete_Rounding`, 'returnType') = 'void'
attr(`delete_Rounding`, "inputTypes") = c('_p_Rounding')
class(`delete_Rounding`) = c("SWIGFunction", class('delete_Rounding'))

# Start of accessor method for Rounding
setMethod('$', '_p_Rounding', function(x, name)

{
  accessorFuns = list('__call__' = Rounding___call__);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for Rounding
setMethod('delete', '_p_Rounding', function(obj) {delete_Rounding(obj)})
# Start of new_UpRounding

`UpRounding__SWIG_0` = function(precision, digit)
{
  precision = as.integer(precision); 
  
  if(length(precision) > 1) {
    warning("using only the first element of precision");
  };
  
  digit = as.integer(digit); 
  
  if(length(digit) > 1) {
    warning("using only the first element of digit");
  };
  
  ;ans = .Call('R_swig_new_UpRounding__SWIG_0', precision, digit, PACKAGE='QuantLib');
  class(ans) <- "_p_UpRounding";
  
  reg.finalizer(ans, delete_UpRounding)
  ans
  
}

attr(`UpRounding__SWIG_0`, 'returnType') = '_p_UpRounding'
attr(`UpRounding__SWIG_0`, "inputTypes") = c('integer', 'integer')
class(`UpRounding__SWIG_0`) = c("SWIGFunction", class('UpRounding__SWIG_0'))

# Start of new_UpRounding

`UpRounding__SWIG_1` = function(precision)
{
  precision = as.integer(precision); 
  
  if(length(precision) > 1) {
    warning("using only the first element of precision");
  };
  
  ;ans = .Call('R_swig_new_UpRounding__SWIG_1', precision, PACKAGE='QuantLib');
  class(ans) <- "_p_UpRounding";
  
  reg.finalizer(ans, delete_UpRounding)
  ans
  
}

attr(`UpRounding__SWIG_1`, 'returnType') = '_p_UpRounding'
attr(`UpRounding__SWIG_1`, "inputTypes") = c('integer')
class(`UpRounding__SWIG_1`) = c("SWIGFunction", class('UpRounding__SWIG_1'))

`UpRounding` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]]))) {
      f <- UpRounding__SWIG_1; 
    }
  } else if (argc == 2) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && (is.integer(argv[[2]]) || is.numeric(argv[[2]]))) {
      f <- UpRounding__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for UpRounding with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_UpRounding

`delete_UpRounding` = function(self)
{
  ;.Call('R_swig_delete_UpRounding', self, PACKAGE='QuantLib');
  
}

attr(`delete_UpRounding`, 'returnType') = 'void'
attr(`delete_UpRounding`, "inputTypes") = c('_p_UpRounding')
class(`delete_UpRounding`) = c("SWIGFunction", class('delete_UpRounding'))

setMethod('delete', '_p_UpRounding', function(obj) {delete_UpRounding(obj)})
# Start of new_DownRounding

`DownRounding__SWIG_0` = function(precision, digit)
{
  precision = as.integer(precision); 
  
  if(length(precision) > 1) {
    warning("using only the first element of precision");
  };
  
  digit = as.integer(digit); 
  
  if(length(digit) > 1) {
    warning("using only the first element of digit");
  };
  
  ;ans = .Call('R_swig_new_DownRounding__SWIG_0', precision, digit, PACKAGE='QuantLib');
  class(ans) <- "_p_DownRounding";
  
  reg.finalizer(ans, delete_DownRounding)
  ans
  
}

attr(`DownRounding__SWIG_0`, 'returnType') = '_p_DownRounding'
attr(`DownRounding__SWIG_0`, "inputTypes") = c('integer', 'integer')
class(`DownRounding__SWIG_0`) = c("SWIGFunction", class('DownRounding__SWIG_0'))

# Start of new_DownRounding

`DownRounding__SWIG_1` = function(precision)
{
  precision = as.integer(precision); 
  
  if(length(precision) > 1) {
    warning("using only the first element of precision");
  };
  
  ;ans = .Call('R_swig_new_DownRounding__SWIG_1', precision, PACKAGE='QuantLib');
  class(ans) <- "_p_DownRounding";
  
  reg.finalizer(ans, delete_DownRounding)
  ans
  
}

attr(`DownRounding__SWIG_1`, 'returnType') = '_p_DownRounding'
attr(`DownRounding__SWIG_1`, "inputTypes") = c('integer')
class(`DownRounding__SWIG_1`) = c("SWIGFunction", class('DownRounding__SWIG_1'))

`DownRounding` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]]))) {
      f <- DownRounding__SWIG_1; 
    }
  } else if (argc == 2) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && (is.integer(argv[[2]]) || is.numeric(argv[[2]]))) {
      f <- DownRounding__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for DownRounding with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_DownRounding

`delete_DownRounding` = function(self)
{
  ;.Call('R_swig_delete_DownRounding', self, PACKAGE='QuantLib');
  
}

attr(`delete_DownRounding`, 'returnType') = 'void'
attr(`delete_DownRounding`, "inputTypes") = c('_p_DownRounding')
class(`delete_DownRounding`) = c("SWIGFunction", class('delete_DownRounding'))

setMethod('delete', '_p_DownRounding', function(obj) {delete_DownRounding(obj)})
# Start of new_ClosestRounding

`ClosestRounding__SWIG_0` = function(precision, digit)
{
  precision = as.integer(precision); 
  
  if(length(precision) > 1) {
    warning("using only the first element of precision");
  };
  
  digit = as.integer(digit); 
  
  if(length(digit) > 1) {
    warning("using only the first element of digit");
  };
  
  ;ans = .Call('R_swig_new_ClosestRounding__SWIG_0', precision, digit, PACKAGE='QuantLib');
  class(ans) <- "_p_ClosestRounding";
  
  reg.finalizer(ans, delete_ClosestRounding)
  ans
  
}

attr(`ClosestRounding__SWIG_0`, 'returnType') = '_p_ClosestRounding'
attr(`ClosestRounding__SWIG_0`, "inputTypes") = c('integer', 'integer')
class(`ClosestRounding__SWIG_0`) = c("SWIGFunction", class('ClosestRounding__SWIG_0'))

# Start of new_ClosestRounding

`ClosestRounding__SWIG_1` = function(precision)
{
  precision = as.integer(precision); 
  
  if(length(precision) > 1) {
    warning("using only the first element of precision");
  };
  
  ;ans = .Call('R_swig_new_ClosestRounding__SWIG_1', precision, PACKAGE='QuantLib');
  class(ans) <- "_p_ClosestRounding";
  
  reg.finalizer(ans, delete_ClosestRounding)
  ans
  
}

attr(`ClosestRounding__SWIG_1`, 'returnType') = '_p_ClosestRounding'
attr(`ClosestRounding__SWIG_1`, "inputTypes") = c('integer')
class(`ClosestRounding__SWIG_1`) = c("SWIGFunction", class('ClosestRounding__SWIG_1'))

`ClosestRounding` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]]))) {
      f <- ClosestRounding__SWIG_1; 
    }
  } else if (argc == 2) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && (is.integer(argv[[2]]) || is.numeric(argv[[2]]))) {
      f <- ClosestRounding__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for ClosestRounding with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_ClosestRounding

`delete_ClosestRounding` = function(self)
{
  ;.Call('R_swig_delete_ClosestRounding', self, PACKAGE='QuantLib');
  
}

attr(`delete_ClosestRounding`, 'returnType') = 'void'
attr(`delete_ClosestRounding`, "inputTypes") = c('_p_ClosestRounding')
class(`delete_ClosestRounding`) = c("SWIGFunction", class('delete_ClosestRounding'))

setMethod('delete', '_p_ClosestRounding', function(obj) {delete_ClosestRounding(obj)})
# Start of new_CeilingTruncation

`CeilingTruncation__SWIG_0` = function(precision, digit)
{
  precision = as.integer(precision); 
  
  if(length(precision) > 1) {
    warning("using only the first element of precision");
  };
  
  digit = as.integer(digit); 
  
  if(length(digit) > 1) {
    warning("using only the first element of digit");
  };
  
  ;ans = .Call('R_swig_new_CeilingTruncation__SWIG_0', precision, digit, PACKAGE='QuantLib');
  class(ans) <- "_p_CeilingTruncation";
  
  reg.finalizer(ans, delete_CeilingTruncation)
  ans
  
}

attr(`CeilingTruncation__SWIG_0`, 'returnType') = '_p_CeilingTruncation'
attr(`CeilingTruncation__SWIG_0`, "inputTypes") = c('integer', 'integer')
class(`CeilingTruncation__SWIG_0`) = c("SWIGFunction", class('CeilingTruncation__SWIG_0'))

# Start of new_CeilingTruncation

`CeilingTruncation__SWIG_1` = function(precision)
{
  precision = as.integer(precision); 
  
  if(length(precision) > 1) {
    warning("using only the first element of precision");
  };
  
  ;ans = .Call('R_swig_new_CeilingTruncation__SWIG_1', precision, PACKAGE='QuantLib');
  class(ans) <- "_p_CeilingTruncation";
  
  reg.finalizer(ans, delete_CeilingTruncation)
  ans
  
}

attr(`CeilingTruncation__SWIG_1`, 'returnType') = '_p_CeilingTruncation'
attr(`CeilingTruncation__SWIG_1`, "inputTypes") = c('integer')
class(`CeilingTruncation__SWIG_1`) = c("SWIGFunction", class('CeilingTruncation__SWIG_1'))

`CeilingTruncation` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]]))) {
      f <- CeilingTruncation__SWIG_1; 
    }
  } else if (argc == 2) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && (is.integer(argv[[2]]) || is.numeric(argv[[2]]))) {
      f <- CeilingTruncation__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for CeilingTruncation with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_CeilingTruncation

`delete_CeilingTruncation` = function(self)
{
  ;.Call('R_swig_delete_CeilingTruncation', self, PACKAGE='QuantLib');
  
}

attr(`delete_CeilingTruncation`, 'returnType') = 'void'
attr(`delete_CeilingTruncation`, "inputTypes") = c('_p_CeilingTruncation')
class(`delete_CeilingTruncation`) = c("SWIGFunction", class('delete_CeilingTruncation'))

setMethod('delete', '_p_CeilingTruncation', function(obj) {delete_CeilingTruncation(obj)})
# Start of new_FloorTruncation

`FloorTruncation__SWIG_0` = function(precision, digit)
{
  precision = as.integer(precision); 
  
  if(length(precision) > 1) {
    warning("using only the first element of precision");
  };
  
  digit = as.integer(digit); 
  
  if(length(digit) > 1) {
    warning("using only the first element of digit");
  };
  
  ;ans = .Call('R_swig_new_FloorTruncation__SWIG_0', precision, digit, PACKAGE='QuantLib');
  class(ans) <- "_p_FloorTruncation";
  
  reg.finalizer(ans, delete_FloorTruncation)
  ans
  
}

attr(`FloorTruncation__SWIG_0`, 'returnType') = '_p_FloorTruncation'
attr(`FloorTruncation__SWIG_0`, "inputTypes") = c('integer', 'integer')
class(`FloorTruncation__SWIG_0`) = c("SWIGFunction", class('FloorTruncation__SWIG_0'))

# Start of new_FloorTruncation

`FloorTruncation__SWIG_1` = function(precision)
{
  precision = as.integer(precision); 
  
  if(length(precision) > 1) {
    warning("using only the first element of precision");
  };
  
  ;ans = .Call('R_swig_new_FloorTruncation__SWIG_1', precision, PACKAGE='QuantLib');
  class(ans) <- "_p_FloorTruncation";
  
  reg.finalizer(ans, delete_FloorTruncation)
  ans
  
}

attr(`FloorTruncation__SWIG_1`, 'returnType') = '_p_FloorTruncation'
attr(`FloorTruncation__SWIG_1`, "inputTypes") = c('integer')
class(`FloorTruncation__SWIG_1`) = c("SWIGFunction", class('FloorTruncation__SWIG_1'))

`FloorTruncation` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]]))) {
      f <- FloorTruncation__SWIG_1; 
    }
  } else if (argc == 2) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && (is.integer(argv[[2]]) || is.numeric(argv[[2]]))) {
      f <- FloorTruncation__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for FloorTruncation with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_FloorTruncation

`delete_FloorTruncation` = function(self)
{
  ;.Call('R_swig_delete_FloorTruncation', self, PACKAGE='QuantLib');
  
}

attr(`delete_FloorTruncation`, 'returnType') = 'void'
attr(`delete_FloorTruncation`, "inputTypes") = c('_p_FloorTruncation')
class(`delete_FloorTruncation`) = c("SWIGFunction", class('delete_FloorTruncation'))

setMethod('delete', '_p_FloorTruncation', function(obj) {delete_FloorTruncation(obj)})
# Start of Currency_name

`Currency_name` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Currency_name', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Currency_name`, 'returnType') = 'character'
attr(`Currency_name`, "inputTypes") = c('_p_Currency')
class(`Currency_name`) = c("SWIGFunction", class('Currency_name'))

# Start of Currency_code

`Currency_code` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Currency_code', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Currency_code`, 'returnType') = 'character'
attr(`Currency_code`, "inputTypes") = c('_p_Currency')
class(`Currency_code`) = c("SWIGFunction", class('Currency_code'))

# Start of Currency_numericCode

`Currency_numericCode` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Currency_numericCode', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Currency_numericCode`, 'returnType') = 'integer'
attr(`Currency_numericCode`, "inputTypes") = c('_p_Currency')
class(`Currency_numericCode`) = c("SWIGFunction", class('Currency_numericCode'))

# Start of Currency_symbol

`Currency_symbol` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Currency_symbol', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Currency_symbol`, 'returnType') = 'character'
attr(`Currency_symbol`, "inputTypes") = c('_p_Currency')
class(`Currency_symbol`) = c("SWIGFunction", class('Currency_symbol'))

# Start of Currency_fractionSymbol

`Currency_fractionSymbol` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Currency_fractionSymbol', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Currency_fractionSymbol`, 'returnType') = 'character'
attr(`Currency_fractionSymbol`, "inputTypes") = c('_p_Currency')
class(`Currency_fractionSymbol`) = c("SWIGFunction", class('Currency_fractionSymbol'))

# Start of Currency_fractionsPerUnit

`Currency_fractionsPerUnit` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Currency_fractionsPerUnit', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Currency_fractionsPerUnit`, 'returnType') = 'integer'
attr(`Currency_fractionsPerUnit`, "inputTypes") = c('_p_Currency')
class(`Currency_fractionsPerUnit`) = c("SWIGFunction", class('Currency_fractionsPerUnit'))

# Start of Currency_rounding

`Currency_rounding` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_Currency_rounding', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Rounding";
  
  ans
  
}

attr(`Currency_rounding`, 'returnType') = '_p_Rounding'
attr(`Currency_rounding`, "inputTypes") = c('_p_Currency')
class(`Currency_rounding`) = c("SWIGFunction", class('Currency_rounding'))

# Start of Currency_format

`Currency_format` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Currency_format', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Currency_format`, 'returnType') = 'character'
attr(`Currency_format`, "inputTypes") = c('_p_Currency')
class(`Currency_format`) = c("SWIGFunction", class('Currency_format'))

# Start of Currency_empty

`Currency_empty` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Currency_empty', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Currency_empty`, 'returnType') = 'logical'
attr(`Currency_empty`, "inputTypes") = c('_p_Currency')
class(`Currency_empty`) = c("SWIGFunction", class('Currency_empty'))

# Start of Currency_triangulationCurrency

`Currency_triangulationCurrency` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_Currency_triangulationCurrency', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Currency";
  
  ans
  
}

attr(`Currency_triangulationCurrency`, 'returnType') = '_p_Currency'
attr(`Currency_triangulationCurrency`, "inputTypes") = c('_p_Currency')
class(`Currency_triangulationCurrency`) = c("SWIGFunction", class('Currency_triangulationCurrency'))

# Start of Currency___str__

`Currency___str__` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Currency___str__', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Currency___str__`, 'returnType') = 'character'
attr(`Currency___str__`, "inputTypes") = c('_p_Currency')
class(`Currency___str__`) = c("SWIGFunction", class('Currency___str__'))

# Start of new_Currency

`Currency` = function()
{
  ;ans = .Call('R_swig_new_Currency', PACKAGE='QuantLib');
  class(ans) <- "_p_Currency";
  
  reg.finalizer(ans, delete_Currency)
  ans
  
}

attr(`Currency`, 'returnType') = '_p_Currency'
class(`Currency`) = c("SWIGFunction", class('Currency'))

# Start of delete_Currency

`delete_Currency` = function(self)
{
  ;.Call('R_swig_delete_Currency', self, PACKAGE='QuantLib');
  
}

attr(`delete_Currency`, 'returnType') = 'void'
attr(`delete_Currency`, "inputTypes") = c('_p_Currency')
class(`delete_Currency`) = c("SWIGFunction", class('delete_Currency'))

# Start of accessor method for Currency
setMethod('$', '_p_Currency', function(x, name)

{
  accessorFuns = list('name' = Currency_name, 'code' = Currency_code, 'numericCode' = Currency_numericCode, 'symbol' = Currency_symbol, 'fractionSymbol' = Currency_fractionSymbol, 'fractionsPerUnit' = Currency_fractionsPerUnit, 'rounding' = Currency_rounding, 'format' = Currency_format, 'empty' = Currency_empty, 'triangulationCurrency' = Currency_triangulationCurrency, '__str__' = Currency___str__);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for Currency
setMethod('delete', '_p_Currency', function(obj) {delete_Currency(obj)})
# Start of new_ARSCurrency

`ARSCurrency` = function()
{
  ;ans = .Call('R_swig_new_ARSCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__ARSCurrency";
  
  reg.finalizer(ans, delete_ARSCurrency)
  ans
  
}

attr(`ARSCurrency`, 'returnType') = '_p_QuantLib__ARSCurrency'
class(`ARSCurrency`) = c("SWIGFunction", class('ARSCurrency'))

# Start of delete_ARSCurrency

`delete_ARSCurrency` = function(self)
{
  ;.Call('R_swig_delete_ARSCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_ARSCurrency`, 'returnType') = 'void'
attr(`delete_ARSCurrency`, "inputTypes") = c('_p_QuantLib__ARSCurrency')
class(`delete_ARSCurrency`) = c("SWIGFunction", class('delete_ARSCurrency'))

setMethod('delete', '_p_QuantLib__ARSCurrency', function(obj) {delete_QuantLib__ARSCurrency(obj)})
# Start of new_ATSCurrency

`ATSCurrency` = function()
{
  ;ans = .Call('R_swig_new_ATSCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__ATSCurrency";
  
  reg.finalizer(ans, delete_ATSCurrency)
  ans
  
}

attr(`ATSCurrency`, 'returnType') = '_p_QuantLib__ATSCurrency'
class(`ATSCurrency`) = c("SWIGFunction", class('ATSCurrency'))

# Start of delete_ATSCurrency

`delete_ATSCurrency` = function(self)
{
  ;.Call('R_swig_delete_ATSCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_ATSCurrency`, 'returnType') = 'void'
attr(`delete_ATSCurrency`, "inputTypes") = c('_p_QuantLib__ATSCurrency')
class(`delete_ATSCurrency`) = c("SWIGFunction", class('delete_ATSCurrency'))

setMethod('delete', '_p_QuantLib__ATSCurrency', function(obj) {delete_QuantLib__ATSCurrency(obj)})
# Start of new_AUDCurrency

`AUDCurrency` = function()
{
  ;ans = .Call('R_swig_new_AUDCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__AUDCurrency";
  
  reg.finalizer(ans, delete_AUDCurrency)
  ans
  
}

attr(`AUDCurrency`, 'returnType') = '_p_QuantLib__AUDCurrency'
class(`AUDCurrency`) = c("SWIGFunction", class('AUDCurrency'))

# Start of delete_AUDCurrency

`delete_AUDCurrency` = function(self)
{
  ;.Call('R_swig_delete_AUDCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_AUDCurrency`, 'returnType') = 'void'
attr(`delete_AUDCurrency`, "inputTypes") = c('_p_QuantLib__AUDCurrency')
class(`delete_AUDCurrency`) = c("SWIGFunction", class('delete_AUDCurrency'))

setMethod('delete', '_p_QuantLib__AUDCurrency', function(obj) {delete_QuantLib__AUDCurrency(obj)})
# Start of new_BDTCurrency

`BDTCurrency` = function()
{
  ;ans = .Call('R_swig_new_BDTCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__BDTCurrency";
  
  reg.finalizer(ans, delete_BDTCurrency)
  ans
  
}

attr(`BDTCurrency`, 'returnType') = '_p_QuantLib__BDTCurrency'
class(`BDTCurrency`) = c("SWIGFunction", class('BDTCurrency'))

# Start of delete_BDTCurrency

`delete_BDTCurrency` = function(self)
{
  ;.Call('R_swig_delete_BDTCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_BDTCurrency`, 'returnType') = 'void'
attr(`delete_BDTCurrency`, "inputTypes") = c('_p_QuantLib__BDTCurrency')
class(`delete_BDTCurrency`) = c("SWIGFunction", class('delete_BDTCurrency'))

setMethod('delete', '_p_QuantLib__BDTCurrency', function(obj) {delete_QuantLib__BDTCurrency(obj)})
# Start of new_BEFCurrency

`BEFCurrency` = function()
{
  ;ans = .Call('R_swig_new_BEFCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__BEFCurrency";
  
  reg.finalizer(ans, delete_BEFCurrency)
  ans
  
}

attr(`BEFCurrency`, 'returnType') = '_p_QuantLib__BEFCurrency'
class(`BEFCurrency`) = c("SWIGFunction", class('BEFCurrency'))

# Start of delete_BEFCurrency

`delete_BEFCurrency` = function(self)
{
  ;.Call('R_swig_delete_BEFCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_BEFCurrency`, 'returnType') = 'void'
attr(`delete_BEFCurrency`, "inputTypes") = c('_p_QuantLib__BEFCurrency')
class(`delete_BEFCurrency`) = c("SWIGFunction", class('delete_BEFCurrency'))

setMethod('delete', '_p_QuantLib__BEFCurrency', function(obj) {delete_QuantLib__BEFCurrency(obj)})
# Start of new_BGLCurrency

`BGLCurrency` = function()
{
  ;ans = .Call('R_swig_new_BGLCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__BGLCurrency";
  
  reg.finalizer(ans, delete_BGLCurrency)
  ans
  
}

attr(`BGLCurrency`, 'returnType') = '_p_QuantLib__BGLCurrency'
class(`BGLCurrency`) = c("SWIGFunction", class('BGLCurrency'))

# Start of delete_BGLCurrency

`delete_BGLCurrency` = function(self)
{
  ;.Call('R_swig_delete_BGLCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_BGLCurrency`, 'returnType') = 'void'
attr(`delete_BGLCurrency`, "inputTypes") = c('_p_QuantLib__BGLCurrency')
class(`delete_BGLCurrency`) = c("SWIGFunction", class('delete_BGLCurrency'))

setMethod('delete', '_p_QuantLib__BGLCurrency', function(obj) {delete_QuantLib__BGLCurrency(obj)})
# Start of new_BRLCurrency

`BRLCurrency` = function()
{
  ;ans = .Call('R_swig_new_BRLCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__BRLCurrency";
  
  reg.finalizer(ans, delete_BRLCurrency)
  ans
  
}

attr(`BRLCurrency`, 'returnType') = '_p_QuantLib__BRLCurrency'
class(`BRLCurrency`) = c("SWIGFunction", class('BRLCurrency'))

# Start of delete_BRLCurrency

`delete_BRLCurrency` = function(self)
{
  ;.Call('R_swig_delete_BRLCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_BRLCurrency`, 'returnType') = 'void'
attr(`delete_BRLCurrency`, "inputTypes") = c('_p_QuantLib__BRLCurrency')
class(`delete_BRLCurrency`) = c("SWIGFunction", class('delete_BRLCurrency'))

setMethod('delete', '_p_QuantLib__BRLCurrency', function(obj) {delete_QuantLib__BRLCurrency(obj)})
# Start of new_BYRCurrency

`BYRCurrency` = function()
{
  ;ans = .Call('R_swig_new_BYRCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__BYRCurrency";
  
  reg.finalizer(ans, delete_BYRCurrency)
  ans
  
}

attr(`BYRCurrency`, 'returnType') = '_p_QuantLib__BYRCurrency'
class(`BYRCurrency`) = c("SWIGFunction", class('BYRCurrency'))

# Start of delete_BYRCurrency

`delete_BYRCurrency` = function(self)
{
  ;.Call('R_swig_delete_BYRCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_BYRCurrency`, 'returnType') = 'void'
attr(`delete_BYRCurrency`, "inputTypes") = c('_p_QuantLib__BYRCurrency')
class(`delete_BYRCurrency`) = c("SWIGFunction", class('delete_BYRCurrency'))

setMethod('delete', '_p_QuantLib__BYRCurrency', function(obj) {delete_QuantLib__BYRCurrency(obj)})
# Start of new_CADCurrency

`CADCurrency` = function()
{
  ;ans = .Call('R_swig_new_CADCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__CADCurrency";
  
  reg.finalizer(ans, delete_CADCurrency)
  ans
  
}

attr(`CADCurrency`, 'returnType') = '_p_QuantLib__CADCurrency'
class(`CADCurrency`) = c("SWIGFunction", class('CADCurrency'))

# Start of delete_CADCurrency

`delete_CADCurrency` = function(self)
{
  ;.Call('R_swig_delete_CADCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_CADCurrency`, 'returnType') = 'void'
attr(`delete_CADCurrency`, "inputTypes") = c('_p_QuantLib__CADCurrency')
class(`delete_CADCurrency`) = c("SWIGFunction", class('delete_CADCurrency'))

setMethod('delete', '_p_QuantLib__CADCurrency', function(obj) {delete_QuantLib__CADCurrency(obj)})
# Start of new_CHFCurrency

`CHFCurrency` = function()
{
  ;ans = .Call('R_swig_new_CHFCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__CHFCurrency";
  
  reg.finalizer(ans, delete_CHFCurrency)
  ans
  
}

attr(`CHFCurrency`, 'returnType') = '_p_QuantLib__CHFCurrency'
class(`CHFCurrency`) = c("SWIGFunction", class('CHFCurrency'))

# Start of delete_CHFCurrency

`delete_CHFCurrency` = function(self)
{
  ;.Call('R_swig_delete_CHFCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_CHFCurrency`, 'returnType') = 'void'
attr(`delete_CHFCurrency`, "inputTypes") = c('_p_QuantLib__CHFCurrency')
class(`delete_CHFCurrency`) = c("SWIGFunction", class('delete_CHFCurrency'))

setMethod('delete', '_p_QuantLib__CHFCurrency', function(obj) {delete_QuantLib__CHFCurrency(obj)})
# Start of new_CLPCurrency

`CLPCurrency` = function()
{
  ;ans = .Call('R_swig_new_CLPCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__CLPCurrency";
  
  reg.finalizer(ans, delete_CLPCurrency)
  ans
  
}

attr(`CLPCurrency`, 'returnType') = '_p_QuantLib__CLPCurrency'
class(`CLPCurrency`) = c("SWIGFunction", class('CLPCurrency'))

# Start of delete_CLPCurrency

`delete_CLPCurrency` = function(self)
{
  ;.Call('R_swig_delete_CLPCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_CLPCurrency`, 'returnType') = 'void'
attr(`delete_CLPCurrency`, "inputTypes") = c('_p_QuantLib__CLPCurrency')
class(`delete_CLPCurrency`) = c("SWIGFunction", class('delete_CLPCurrency'))

setMethod('delete', '_p_QuantLib__CLPCurrency', function(obj) {delete_QuantLib__CLPCurrency(obj)})
# Start of new_CNYCurrency

`CNYCurrency` = function()
{
  ;ans = .Call('R_swig_new_CNYCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__CNYCurrency";
  
  reg.finalizer(ans, delete_CNYCurrency)
  ans
  
}

attr(`CNYCurrency`, 'returnType') = '_p_QuantLib__CNYCurrency'
class(`CNYCurrency`) = c("SWIGFunction", class('CNYCurrency'))

# Start of delete_CNYCurrency

`delete_CNYCurrency` = function(self)
{
  ;.Call('R_swig_delete_CNYCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_CNYCurrency`, 'returnType') = 'void'
attr(`delete_CNYCurrency`, "inputTypes") = c('_p_QuantLib__CNYCurrency')
class(`delete_CNYCurrency`) = c("SWIGFunction", class('delete_CNYCurrency'))

setMethod('delete', '_p_QuantLib__CNYCurrency', function(obj) {delete_QuantLib__CNYCurrency(obj)})
# Start of new_COPCurrency

`COPCurrency` = function()
{
  ;ans = .Call('R_swig_new_COPCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__COPCurrency";
  
  reg.finalizer(ans, delete_COPCurrency)
  ans
  
}

attr(`COPCurrency`, 'returnType') = '_p_QuantLib__COPCurrency'
class(`COPCurrency`) = c("SWIGFunction", class('COPCurrency'))

# Start of delete_COPCurrency

`delete_COPCurrency` = function(self)
{
  ;.Call('R_swig_delete_COPCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_COPCurrency`, 'returnType') = 'void'
attr(`delete_COPCurrency`, "inputTypes") = c('_p_QuantLib__COPCurrency')
class(`delete_COPCurrency`) = c("SWIGFunction", class('delete_COPCurrency'))

setMethod('delete', '_p_QuantLib__COPCurrency', function(obj) {delete_QuantLib__COPCurrency(obj)})
# Start of new_CYPCurrency

`CYPCurrency` = function()
{
  ;ans = .Call('R_swig_new_CYPCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__CYPCurrency";
  
  reg.finalizer(ans, delete_CYPCurrency)
  ans
  
}

attr(`CYPCurrency`, 'returnType') = '_p_QuantLib__CYPCurrency'
class(`CYPCurrency`) = c("SWIGFunction", class('CYPCurrency'))

# Start of delete_CYPCurrency

`delete_CYPCurrency` = function(self)
{
  ;.Call('R_swig_delete_CYPCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_CYPCurrency`, 'returnType') = 'void'
attr(`delete_CYPCurrency`, "inputTypes") = c('_p_QuantLib__CYPCurrency')
class(`delete_CYPCurrency`) = c("SWIGFunction", class('delete_CYPCurrency'))

setMethod('delete', '_p_QuantLib__CYPCurrency', function(obj) {delete_QuantLib__CYPCurrency(obj)})
# Start of new_CZKCurrency

`CZKCurrency` = function()
{
  ;ans = .Call('R_swig_new_CZKCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__CZKCurrency";
  
  reg.finalizer(ans, delete_CZKCurrency)
  ans
  
}

attr(`CZKCurrency`, 'returnType') = '_p_QuantLib__CZKCurrency'
class(`CZKCurrency`) = c("SWIGFunction", class('CZKCurrency'))

# Start of delete_CZKCurrency

`delete_CZKCurrency` = function(self)
{
  ;.Call('R_swig_delete_CZKCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_CZKCurrency`, 'returnType') = 'void'
attr(`delete_CZKCurrency`, "inputTypes") = c('_p_QuantLib__CZKCurrency')
class(`delete_CZKCurrency`) = c("SWIGFunction", class('delete_CZKCurrency'))

setMethod('delete', '_p_QuantLib__CZKCurrency', function(obj) {delete_QuantLib__CZKCurrency(obj)})
# Start of new_DEMCurrency

`DEMCurrency` = function()
{
  ;ans = .Call('R_swig_new_DEMCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__DEMCurrency";
  
  reg.finalizer(ans, delete_DEMCurrency)
  ans
  
}

attr(`DEMCurrency`, 'returnType') = '_p_QuantLib__DEMCurrency'
class(`DEMCurrency`) = c("SWIGFunction", class('DEMCurrency'))

# Start of delete_DEMCurrency

`delete_DEMCurrency` = function(self)
{
  ;.Call('R_swig_delete_DEMCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_DEMCurrency`, 'returnType') = 'void'
attr(`delete_DEMCurrency`, "inputTypes") = c('_p_QuantLib__DEMCurrency')
class(`delete_DEMCurrency`) = c("SWIGFunction", class('delete_DEMCurrency'))

setMethod('delete', '_p_QuantLib__DEMCurrency', function(obj) {delete_QuantLib__DEMCurrency(obj)})
# Start of new_DKKCurrency

`DKKCurrency` = function()
{
  ;ans = .Call('R_swig_new_DKKCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__DKKCurrency";
  
  reg.finalizer(ans, delete_DKKCurrency)
  ans
  
}

attr(`DKKCurrency`, 'returnType') = '_p_QuantLib__DKKCurrency'
class(`DKKCurrency`) = c("SWIGFunction", class('DKKCurrency'))

# Start of delete_DKKCurrency

`delete_DKKCurrency` = function(self)
{
  ;.Call('R_swig_delete_DKKCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_DKKCurrency`, 'returnType') = 'void'
attr(`delete_DKKCurrency`, "inputTypes") = c('_p_QuantLib__DKKCurrency')
class(`delete_DKKCurrency`) = c("SWIGFunction", class('delete_DKKCurrency'))

setMethod('delete', '_p_QuantLib__DKKCurrency', function(obj) {delete_QuantLib__DKKCurrency(obj)})
# Start of new_EEKCurrency

`EEKCurrency` = function()
{
  ;ans = .Call('R_swig_new_EEKCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__EEKCurrency";
  
  reg.finalizer(ans, delete_EEKCurrency)
  ans
  
}

attr(`EEKCurrency`, 'returnType') = '_p_QuantLib__EEKCurrency'
class(`EEKCurrency`) = c("SWIGFunction", class('EEKCurrency'))

# Start of delete_EEKCurrency

`delete_EEKCurrency` = function(self)
{
  ;.Call('R_swig_delete_EEKCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_EEKCurrency`, 'returnType') = 'void'
attr(`delete_EEKCurrency`, "inputTypes") = c('_p_QuantLib__EEKCurrency')
class(`delete_EEKCurrency`) = c("SWIGFunction", class('delete_EEKCurrency'))

setMethod('delete', '_p_QuantLib__EEKCurrency', function(obj) {delete_QuantLib__EEKCurrency(obj)})
# Start of new_ESPCurrency

`ESPCurrency` = function()
{
  ;ans = .Call('R_swig_new_ESPCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__ESPCurrency";
  
  reg.finalizer(ans, delete_ESPCurrency)
  ans
  
}

attr(`ESPCurrency`, 'returnType') = '_p_QuantLib__ESPCurrency'
class(`ESPCurrency`) = c("SWIGFunction", class('ESPCurrency'))

# Start of delete_ESPCurrency

`delete_ESPCurrency` = function(self)
{
  ;.Call('R_swig_delete_ESPCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_ESPCurrency`, 'returnType') = 'void'
attr(`delete_ESPCurrency`, "inputTypes") = c('_p_QuantLib__ESPCurrency')
class(`delete_ESPCurrency`) = c("SWIGFunction", class('delete_ESPCurrency'))

setMethod('delete', '_p_QuantLib__ESPCurrency', function(obj) {delete_QuantLib__ESPCurrency(obj)})
# Start of new_EURCurrency

`EURCurrency` = function()
{
  ;ans = .Call('R_swig_new_EURCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__EURCurrency";
  
  reg.finalizer(ans, delete_EURCurrency)
  ans
  
}

attr(`EURCurrency`, 'returnType') = '_p_QuantLib__EURCurrency'
class(`EURCurrency`) = c("SWIGFunction", class('EURCurrency'))

# Start of delete_EURCurrency

`delete_EURCurrency` = function(self)
{
  ;.Call('R_swig_delete_EURCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_EURCurrency`, 'returnType') = 'void'
attr(`delete_EURCurrency`, "inputTypes") = c('_p_QuantLib__EURCurrency')
class(`delete_EURCurrency`) = c("SWIGFunction", class('delete_EURCurrency'))

setMethod('delete', '_p_QuantLib__EURCurrency', function(obj) {delete_QuantLib__EURCurrency(obj)})
# Start of new_FIMCurrency

`FIMCurrency` = function()
{
  ;ans = .Call('R_swig_new_FIMCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__FIMCurrency";
  
  reg.finalizer(ans, delete_FIMCurrency)
  ans
  
}

attr(`FIMCurrency`, 'returnType') = '_p_QuantLib__FIMCurrency'
class(`FIMCurrency`) = c("SWIGFunction", class('FIMCurrency'))

# Start of delete_FIMCurrency

`delete_FIMCurrency` = function(self)
{
  ;.Call('R_swig_delete_FIMCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_FIMCurrency`, 'returnType') = 'void'
attr(`delete_FIMCurrency`, "inputTypes") = c('_p_QuantLib__FIMCurrency')
class(`delete_FIMCurrency`) = c("SWIGFunction", class('delete_FIMCurrency'))

setMethod('delete', '_p_QuantLib__FIMCurrency', function(obj) {delete_QuantLib__FIMCurrency(obj)})
# Start of new_FRFCurrency

`FRFCurrency` = function()
{
  ;ans = .Call('R_swig_new_FRFCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__FRFCurrency";
  
  reg.finalizer(ans, delete_FRFCurrency)
  ans
  
}

attr(`FRFCurrency`, 'returnType') = '_p_QuantLib__FRFCurrency'
class(`FRFCurrency`) = c("SWIGFunction", class('FRFCurrency'))

# Start of delete_FRFCurrency

`delete_FRFCurrency` = function(self)
{
  ;.Call('R_swig_delete_FRFCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_FRFCurrency`, 'returnType') = 'void'
attr(`delete_FRFCurrency`, "inputTypes") = c('_p_QuantLib__FRFCurrency')
class(`delete_FRFCurrency`) = c("SWIGFunction", class('delete_FRFCurrency'))

setMethod('delete', '_p_QuantLib__FRFCurrency', function(obj) {delete_QuantLib__FRFCurrency(obj)})
# Start of new_GBPCurrency

`GBPCurrency` = function()
{
  ;ans = .Call('R_swig_new_GBPCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__GBPCurrency";
  
  reg.finalizer(ans, delete_GBPCurrency)
  ans
  
}

attr(`GBPCurrency`, 'returnType') = '_p_QuantLib__GBPCurrency'
class(`GBPCurrency`) = c("SWIGFunction", class('GBPCurrency'))

# Start of delete_GBPCurrency

`delete_GBPCurrency` = function(self)
{
  ;.Call('R_swig_delete_GBPCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_GBPCurrency`, 'returnType') = 'void'
attr(`delete_GBPCurrency`, "inputTypes") = c('_p_QuantLib__GBPCurrency')
class(`delete_GBPCurrency`) = c("SWIGFunction", class('delete_GBPCurrency'))

setMethod('delete', '_p_QuantLib__GBPCurrency', function(obj) {delete_QuantLib__GBPCurrency(obj)})
# Start of new_GRDCurrency

`GRDCurrency` = function()
{
  ;ans = .Call('R_swig_new_GRDCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__GRDCurrency";
  
  reg.finalizer(ans, delete_GRDCurrency)
  ans
  
}

attr(`GRDCurrency`, 'returnType') = '_p_QuantLib__GRDCurrency'
class(`GRDCurrency`) = c("SWIGFunction", class('GRDCurrency'))

# Start of delete_GRDCurrency

`delete_GRDCurrency` = function(self)
{
  ;.Call('R_swig_delete_GRDCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_GRDCurrency`, 'returnType') = 'void'
attr(`delete_GRDCurrency`, "inputTypes") = c('_p_QuantLib__GRDCurrency')
class(`delete_GRDCurrency`) = c("SWIGFunction", class('delete_GRDCurrency'))

setMethod('delete', '_p_QuantLib__GRDCurrency', function(obj) {delete_QuantLib__GRDCurrency(obj)})
# Start of new_HKDCurrency

`HKDCurrency` = function()
{
  ;ans = .Call('R_swig_new_HKDCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__HKDCurrency";
  
  reg.finalizer(ans, delete_HKDCurrency)
  ans
  
}

attr(`HKDCurrency`, 'returnType') = '_p_QuantLib__HKDCurrency'
class(`HKDCurrency`) = c("SWIGFunction", class('HKDCurrency'))

# Start of delete_HKDCurrency

`delete_HKDCurrency` = function(self)
{
  ;.Call('R_swig_delete_HKDCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_HKDCurrency`, 'returnType') = 'void'
attr(`delete_HKDCurrency`, "inputTypes") = c('_p_QuantLib__HKDCurrency')
class(`delete_HKDCurrency`) = c("SWIGFunction", class('delete_HKDCurrency'))

setMethod('delete', '_p_QuantLib__HKDCurrency', function(obj) {delete_QuantLib__HKDCurrency(obj)})
# Start of new_HUFCurrency

`HUFCurrency` = function()
{
  ;ans = .Call('R_swig_new_HUFCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__HUFCurrency";
  
  reg.finalizer(ans, delete_HUFCurrency)
  ans
  
}

attr(`HUFCurrency`, 'returnType') = '_p_QuantLib__HUFCurrency'
class(`HUFCurrency`) = c("SWIGFunction", class('HUFCurrency'))

# Start of delete_HUFCurrency

`delete_HUFCurrency` = function(self)
{
  ;.Call('R_swig_delete_HUFCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_HUFCurrency`, 'returnType') = 'void'
attr(`delete_HUFCurrency`, "inputTypes") = c('_p_QuantLib__HUFCurrency')
class(`delete_HUFCurrency`) = c("SWIGFunction", class('delete_HUFCurrency'))

setMethod('delete', '_p_QuantLib__HUFCurrency', function(obj) {delete_QuantLib__HUFCurrency(obj)})
# Start of new_IEPCurrency

`IEPCurrency` = function()
{
  ;ans = .Call('R_swig_new_IEPCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__IEPCurrency";
  
  reg.finalizer(ans, delete_IEPCurrency)
  ans
  
}

attr(`IEPCurrency`, 'returnType') = '_p_QuantLib__IEPCurrency'
class(`IEPCurrency`) = c("SWIGFunction", class('IEPCurrency'))

# Start of delete_IEPCurrency

`delete_IEPCurrency` = function(self)
{
  ;.Call('R_swig_delete_IEPCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_IEPCurrency`, 'returnType') = 'void'
attr(`delete_IEPCurrency`, "inputTypes") = c('_p_QuantLib__IEPCurrency')
class(`delete_IEPCurrency`) = c("SWIGFunction", class('delete_IEPCurrency'))

setMethod('delete', '_p_QuantLib__IEPCurrency', function(obj) {delete_QuantLib__IEPCurrency(obj)})
# Start of new_ILSCurrency

`ILSCurrency` = function()
{
  ;ans = .Call('R_swig_new_ILSCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__ILSCurrency";
  
  reg.finalizer(ans, delete_ILSCurrency)
  ans
  
}

attr(`ILSCurrency`, 'returnType') = '_p_QuantLib__ILSCurrency'
class(`ILSCurrency`) = c("SWIGFunction", class('ILSCurrency'))

# Start of delete_ILSCurrency

`delete_ILSCurrency` = function(self)
{
  ;.Call('R_swig_delete_ILSCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_ILSCurrency`, 'returnType') = 'void'
attr(`delete_ILSCurrency`, "inputTypes") = c('_p_QuantLib__ILSCurrency')
class(`delete_ILSCurrency`) = c("SWIGFunction", class('delete_ILSCurrency'))

setMethod('delete', '_p_QuantLib__ILSCurrency', function(obj) {delete_QuantLib__ILSCurrency(obj)})
# Start of new_INRCurrency

`INRCurrency` = function()
{
  ;ans = .Call('R_swig_new_INRCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__INRCurrency";
  
  reg.finalizer(ans, delete_INRCurrency)
  ans
  
}

attr(`INRCurrency`, 'returnType') = '_p_QuantLib__INRCurrency'
class(`INRCurrency`) = c("SWIGFunction", class('INRCurrency'))

# Start of delete_INRCurrency

`delete_INRCurrency` = function(self)
{
  ;.Call('R_swig_delete_INRCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_INRCurrency`, 'returnType') = 'void'
attr(`delete_INRCurrency`, "inputTypes") = c('_p_QuantLib__INRCurrency')
class(`delete_INRCurrency`) = c("SWIGFunction", class('delete_INRCurrency'))

setMethod('delete', '_p_QuantLib__INRCurrency', function(obj) {delete_QuantLib__INRCurrency(obj)})
# Start of new_IQDCurrency

`IQDCurrency` = function()
{
  ;ans = .Call('R_swig_new_IQDCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__IQDCurrency";
  
  reg.finalizer(ans, delete_IQDCurrency)
  ans
  
}

attr(`IQDCurrency`, 'returnType') = '_p_QuantLib__IQDCurrency'
class(`IQDCurrency`) = c("SWIGFunction", class('IQDCurrency'))

# Start of delete_IQDCurrency

`delete_IQDCurrency` = function(self)
{
  ;.Call('R_swig_delete_IQDCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_IQDCurrency`, 'returnType') = 'void'
attr(`delete_IQDCurrency`, "inputTypes") = c('_p_QuantLib__IQDCurrency')
class(`delete_IQDCurrency`) = c("SWIGFunction", class('delete_IQDCurrency'))

setMethod('delete', '_p_QuantLib__IQDCurrency', function(obj) {delete_QuantLib__IQDCurrency(obj)})
# Start of new_IRRCurrency

`IRRCurrency` = function()
{
  ;ans = .Call('R_swig_new_IRRCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__IRRCurrency";
  
  reg.finalizer(ans, delete_IRRCurrency)
  ans
  
}

attr(`IRRCurrency`, 'returnType') = '_p_QuantLib__IRRCurrency'
class(`IRRCurrency`) = c("SWIGFunction", class('IRRCurrency'))

# Start of delete_IRRCurrency

`delete_IRRCurrency` = function(self)
{
  ;.Call('R_swig_delete_IRRCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_IRRCurrency`, 'returnType') = 'void'
attr(`delete_IRRCurrency`, "inputTypes") = c('_p_QuantLib__IRRCurrency')
class(`delete_IRRCurrency`) = c("SWIGFunction", class('delete_IRRCurrency'))

setMethod('delete', '_p_QuantLib__IRRCurrency', function(obj) {delete_QuantLib__IRRCurrency(obj)})
# Start of new_ISKCurrency

`ISKCurrency` = function()
{
  ;ans = .Call('R_swig_new_ISKCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__ISKCurrency";
  
  reg.finalizer(ans, delete_ISKCurrency)
  ans
  
}

attr(`ISKCurrency`, 'returnType') = '_p_QuantLib__ISKCurrency'
class(`ISKCurrency`) = c("SWIGFunction", class('ISKCurrency'))

# Start of delete_ISKCurrency

`delete_ISKCurrency` = function(self)
{
  ;.Call('R_swig_delete_ISKCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_ISKCurrency`, 'returnType') = 'void'
attr(`delete_ISKCurrency`, "inputTypes") = c('_p_QuantLib__ISKCurrency')
class(`delete_ISKCurrency`) = c("SWIGFunction", class('delete_ISKCurrency'))

setMethod('delete', '_p_QuantLib__ISKCurrency', function(obj) {delete_QuantLib__ISKCurrency(obj)})
# Start of new_ITLCurrency

`ITLCurrency` = function()
{
  ;ans = .Call('R_swig_new_ITLCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__ITLCurrency";
  
  reg.finalizer(ans, delete_ITLCurrency)
  ans
  
}

attr(`ITLCurrency`, 'returnType') = '_p_QuantLib__ITLCurrency'
class(`ITLCurrency`) = c("SWIGFunction", class('ITLCurrency'))

# Start of delete_ITLCurrency

`delete_ITLCurrency` = function(self)
{
  ;.Call('R_swig_delete_ITLCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_ITLCurrency`, 'returnType') = 'void'
attr(`delete_ITLCurrency`, "inputTypes") = c('_p_QuantLib__ITLCurrency')
class(`delete_ITLCurrency`) = c("SWIGFunction", class('delete_ITLCurrency'))

setMethod('delete', '_p_QuantLib__ITLCurrency', function(obj) {delete_QuantLib__ITLCurrency(obj)})
# Start of new_JPYCurrency

`JPYCurrency` = function()
{
  ;ans = .Call('R_swig_new_JPYCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__JPYCurrency";
  
  reg.finalizer(ans, delete_JPYCurrency)
  ans
  
}

attr(`JPYCurrency`, 'returnType') = '_p_QuantLib__JPYCurrency'
class(`JPYCurrency`) = c("SWIGFunction", class('JPYCurrency'))

# Start of delete_JPYCurrency

`delete_JPYCurrency` = function(self)
{
  ;.Call('R_swig_delete_JPYCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_JPYCurrency`, 'returnType') = 'void'
attr(`delete_JPYCurrency`, "inputTypes") = c('_p_QuantLib__JPYCurrency')
class(`delete_JPYCurrency`) = c("SWIGFunction", class('delete_JPYCurrency'))

setMethod('delete', '_p_QuantLib__JPYCurrency', function(obj) {delete_QuantLib__JPYCurrency(obj)})
# Start of new_KRWCurrency

`KRWCurrency` = function()
{
  ;ans = .Call('R_swig_new_KRWCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__KRWCurrency";
  
  reg.finalizer(ans, delete_KRWCurrency)
  ans
  
}

attr(`KRWCurrency`, 'returnType') = '_p_QuantLib__KRWCurrency'
class(`KRWCurrency`) = c("SWIGFunction", class('KRWCurrency'))

# Start of delete_KRWCurrency

`delete_KRWCurrency` = function(self)
{
  ;.Call('R_swig_delete_KRWCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_KRWCurrency`, 'returnType') = 'void'
attr(`delete_KRWCurrency`, "inputTypes") = c('_p_QuantLib__KRWCurrency')
class(`delete_KRWCurrency`) = c("SWIGFunction", class('delete_KRWCurrency'))

setMethod('delete', '_p_QuantLib__KRWCurrency', function(obj) {delete_QuantLib__KRWCurrency(obj)})
# Start of new_KWDCurrency

`KWDCurrency` = function()
{
  ;ans = .Call('R_swig_new_KWDCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__KWDCurrency";
  
  reg.finalizer(ans, delete_KWDCurrency)
  ans
  
}

attr(`KWDCurrency`, 'returnType') = '_p_QuantLib__KWDCurrency'
class(`KWDCurrency`) = c("SWIGFunction", class('KWDCurrency'))

# Start of delete_KWDCurrency

`delete_KWDCurrency` = function(self)
{
  ;.Call('R_swig_delete_KWDCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_KWDCurrency`, 'returnType') = 'void'
attr(`delete_KWDCurrency`, "inputTypes") = c('_p_QuantLib__KWDCurrency')
class(`delete_KWDCurrency`) = c("SWIGFunction", class('delete_KWDCurrency'))

setMethod('delete', '_p_QuantLib__KWDCurrency', function(obj) {delete_QuantLib__KWDCurrency(obj)})
# Start of new_LTLCurrency

`LTLCurrency` = function()
{
  ;ans = .Call('R_swig_new_LTLCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__LTLCurrency";
  
  reg.finalizer(ans, delete_LTLCurrency)
  ans
  
}

attr(`LTLCurrency`, 'returnType') = '_p_QuantLib__LTLCurrency'
class(`LTLCurrency`) = c("SWIGFunction", class('LTLCurrency'))

# Start of delete_LTLCurrency

`delete_LTLCurrency` = function(self)
{
  ;.Call('R_swig_delete_LTLCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_LTLCurrency`, 'returnType') = 'void'
attr(`delete_LTLCurrency`, "inputTypes") = c('_p_QuantLib__LTLCurrency')
class(`delete_LTLCurrency`) = c("SWIGFunction", class('delete_LTLCurrency'))

setMethod('delete', '_p_QuantLib__LTLCurrency', function(obj) {delete_QuantLib__LTLCurrency(obj)})
# Start of new_LUFCurrency

`LUFCurrency` = function()
{
  ;ans = .Call('R_swig_new_LUFCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__LUFCurrency";
  
  reg.finalizer(ans, delete_LUFCurrency)
  ans
  
}

attr(`LUFCurrency`, 'returnType') = '_p_QuantLib__LUFCurrency'
class(`LUFCurrency`) = c("SWIGFunction", class('LUFCurrency'))

# Start of delete_LUFCurrency

`delete_LUFCurrency` = function(self)
{
  ;.Call('R_swig_delete_LUFCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_LUFCurrency`, 'returnType') = 'void'
attr(`delete_LUFCurrency`, "inputTypes") = c('_p_QuantLib__LUFCurrency')
class(`delete_LUFCurrency`) = c("SWIGFunction", class('delete_LUFCurrency'))

setMethod('delete', '_p_QuantLib__LUFCurrency', function(obj) {delete_QuantLib__LUFCurrency(obj)})
# Start of new_LVLCurrency

`LVLCurrency` = function()
{
  ;ans = .Call('R_swig_new_LVLCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__LVLCurrency";
  
  reg.finalizer(ans, delete_LVLCurrency)
  ans
  
}

attr(`LVLCurrency`, 'returnType') = '_p_QuantLib__LVLCurrency'
class(`LVLCurrency`) = c("SWIGFunction", class('LVLCurrency'))

# Start of delete_LVLCurrency

`delete_LVLCurrency` = function(self)
{
  ;.Call('R_swig_delete_LVLCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_LVLCurrency`, 'returnType') = 'void'
attr(`delete_LVLCurrency`, "inputTypes") = c('_p_QuantLib__LVLCurrency')
class(`delete_LVLCurrency`) = c("SWIGFunction", class('delete_LVLCurrency'))

setMethod('delete', '_p_QuantLib__LVLCurrency', function(obj) {delete_QuantLib__LVLCurrency(obj)})
# Start of new_MTLCurrency

`MTLCurrency` = function()
{
  ;ans = .Call('R_swig_new_MTLCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__MTLCurrency";
  
  reg.finalizer(ans, delete_MTLCurrency)
  ans
  
}

attr(`MTLCurrency`, 'returnType') = '_p_QuantLib__MTLCurrency'
class(`MTLCurrency`) = c("SWIGFunction", class('MTLCurrency'))

# Start of delete_MTLCurrency

`delete_MTLCurrency` = function(self)
{
  ;.Call('R_swig_delete_MTLCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_MTLCurrency`, 'returnType') = 'void'
attr(`delete_MTLCurrency`, "inputTypes") = c('_p_QuantLib__MTLCurrency')
class(`delete_MTLCurrency`) = c("SWIGFunction", class('delete_MTLCurrency'))

setMethod('delete', '_p_QuantLib__MTLCurrency', function(obj) {delete_QuantLib__MTLCurrency(obj)})
# Start of new_MXNCurrency

`MXNCurrency` = function()
{
  ;ans = .Call('R_swig_new_MXNCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__MXNCurrency";
  
  reg.finalizer(ans, delete_MXNCurrency)
  ans
  
}

attr(`MXNCurrency`, 'returnType') = '_p_QuantLib__MXNCurrency'
class(`MXNCurrency`) = c("SWIGFunction", class('MXNCurrency'))

# Start of delete_MXNCurrency

`delete_MXNCurrency` = function(self)
{
  ;.Call('R_swig_delete_MXNCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_MXNCurrency`, 'returnType') = 'void'
attr(`delete_MXNCurrency`, "inputTypes") = c('_p_QuantLib__MXNCurrency')
class(`delete_MXNCurrency`) = c("SWIGFunction", class('delete_MXNCurrency'))

setMethod('delete', '_p_QuantLib__MXNCurrency', function(obj) {delete_QuantLib__MXNCurrency(obj)})
# Start of new_NLGCurrency

`NLGCurrency` = function()
{
  ;ans = .Call('R_swig_new_NLGCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__NLGCurrency";
  
  reg.finalizer(ans, delete_NLGCurrency)
  ans
  
}

attr(`NLGCurrency`, 'returnType') = '_p_QuantLib__NLGCurrency'
class(`NLGCurrency`) = c("SWIGFunction", class('NLGCurrency'))

# Start of delete_NLGCurrency

`delete_NLGCurrency` = function(self)
{
  ;.Call('R_swig_delete_NLGCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_NLGCurrency`, 'returnType') = 'void'
attr(`delete_NLGCurrency`, "inputTypes") = c('_p_QuantLib__NLGCurrency')
class(`delete_NLGCurrency`) = c("SWIGFunction", class('delete_NLGCurrency'))

setMethod('delete', '_p_QuantLib__NLGCurrency', function(obj) {delete_QuantLib__NLGCurrency(obj)})
# Start of new_NOKCurrency

`NOKCurrency` = function()
{
  ;ans = .Call('R_swig_new_NOKCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__NOKCurrency";
  
  reg.finalizer(ans, delete_NOKCurrency)
  ans
  
}

attr(`NOKCurrency`, 'returnType') = '_p_QuantLib__NOKCurrency'
class(`NOKCurrency`) = c("SWIGFunction", class('NOKCurrency'))

# Start of delete_NOKCurrency

`delete_NOKCurrency` = function(self)
{
  ;.Call('R_swig_delete_NOKCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_NOKCurrency`, 'returnType') = 'void'
attr(`delete_NOKCurrency`, "inputTypes") = c('_p_QuantLib__NOKCurrency')
class(`delete_NOKCurrency`) = c("SWIGFunction", class('delete_NOKCurrency'))

setMethod('delete', '_p_QuantLib__NOKCurrency', function(obj) {delete_QuantLib__NOKCurrency(obj)})
# Start of new_NPRCurrency

`NPRCurrency` = function()
{
  ;ans = .Call('R_swig_new_NPRCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__NPRCurrency";
  
  reg.finalizer(ans, delete_NPRCurrency)
  ans
  
}

attr(`NPRCurrency`, 'returnType') = '_p_QuantLib__NPRCurrency'
class(`NPRCurrency`) = c("SWIGFunction", class('NPRCurrency'))

# Start of delete_NPRCurrency

`delete_NPRCurrency` = function(self)
{
  ;.Call('R_swig_delete_NPRCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_NPRCurrency`, 'returnType') = 'void'
attr(`delete_NPRCurrency`, "inputTypes") = c('_p_QuantLib__NPRCurrency')
class(`delete_NPRCurrency`) = c("SWIGFunction", class('delete_NPRCurrency'))

setMethod('delete', '_p_QuantLib__NPRCurrency', function(obj) {delete_QuantLib__NPRCurrency(obj)})
# Start of new_NZDCurrency

`NZDCurrency` = function()
{
  ;ans = .Call('R_swig_new_NZDCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__NZDCurrency";
  
  reg.finalizer(ans, delete_NZDCurrency)
  ans
  
}

attr(`NZDCurrency`, 'returnType') = '_p_QuantLib__NZDCurrency'
class(`NZDCurrency`) = c("SWIGFunction", class('NZDCurrency'))

# Start of delete_NZDCurrency

`delete_NZDCurrency` = function(self)
{
  ;.Call('R_swig_delete_NZDCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_NZDCurrency`, 'returnType') = 'void'
attr(`delete_NZDCurrency`, "inputTypes") = c('_p_QuantLib__NZDCurrency')
class(`delete_NZDCurrency`) = c("SWIGFunction", class('delete_NZDCurrency'))

setMethod('delete', '_p_QuantLib__NZDCurrency', function(obj) {delete_QuantLib__NZDCurrency(obj)})
# Start of new_PEHCurrency

`PEHCurrency` = function()
{
  ;ans = .Call('R_swig_new_PEHCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__PEHCurrency";
  
  reg.finalizer(ans, delete_PEHCurrency)
  ans
  
}

attr(`PEHCurrency`, 'returnType') = '_p_QuantLib__PEHCurrency'
class(`PEHCurrency`) = c("SWIGFunction", class('PEHCurrency'))

# Start of delete_PEHCurrency

`delete_PEHCurrency` = function(self)
{
  ;.Call('R_swig_delete_PEHCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_PEHCurrency`, 'returnType') = 'void'
attr(`delete_PEHCurrency`, "inputTypes") = c('_p_QuantLib__PEHCurrency')
class(`delete_PEHCurrency`) = c("SWIGFunction", class('delete_PEHCurrency'))

setMethod('delete', '_p_QuantLib__PEHCurrency', function(obj) {delete_QuantLib__PEHCurrency(obj)})
# Start of new_PEICurrency

`PEICurrency` = function()
{
  ;ans = .Call('R_swig_new_PEICurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__PEICurrency";
  
  reg.finalizer(ans, delete_PEICurrency)
  ans
  
}

attr(`PEICurrency`, 'returnType') = '_p_QuantLib__PEICurrency'
class(`PEICurrency`) = c("SWIGFunction", class('PEICurrency'))

# Start of delete_PEICurrency

`delete_PEICurrency` = function(self)
{
  ;.Call('R_swig_delete_PEICurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_PEICurrency`, 'returnType') = 'void'
attr(`delete_PEICurrency`, "inputTypes") = c('_p_QuantLib__PEICurrency')
class(`delete_PEICurrency`) = c("SWIGFunction", class('delete_PEICurrency'))

setMethod('delete', '_p_QuantLib__PEICurrency', function(obj) {delete_QuantLib__PEICurrency(obj)})
# Start of new_PENCurrency

`PENCurrency` = function()
{
  ;ans = .Call('R_swig_new_PENCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__PENCurrency";
  
  reg.finalizer(ans, delete_PENCurrency)
  ans
  
}

attr(`PENCurrency`, 'returnType') = '_p_QuantLib__PENCurrency'
class(`PENCurrency`) = c("SWIGFunction", class('PENCurrency'))

# Start of delete_PENCurrency

`delete_PENCurrency` = function(self)
{
  ;.Call('R_swig_delete_PENCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_PENCurrency`, 'returnType') = 'void'
attr(`delete_PENCurrency`, "inputTypes") = c('_p_QuantLib__PENCurrency')
class(`delete_PENCurrency`) = c("SWIGFunction", class('delete_PENCurrency'))

setMethod('delete', '_p_QuantLib__PENCurrency', function(obj) {delete_QuantLib__PENCurrency(obj)})
# Start of new_PKRCurrency

`PKRCurrency` = function()
{
  ;ans = .Call('R_swig_new_PKRCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__PKRCurrency";
  
  reg.finalizer(ans, delete_PKRCurrency)
  ans
  
}

attr(`PKRCurrency`, 'returnType') = '_p_QuantLib__PKRCurrency'
class(`PKRCurrency`) = c("SWIGFunction", class('PKRCurrency'))

# Start of delete_PKRCurrency

`delete_PKRCurrency` = function(self)
{
  ;.Call('R_swig_delete_PKRCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_PKRCurrency`, 'returnType') = 'void'
attr(`delete_PKRCurrency`, "inputTypes") = c('_p_QuantLib__PKRCurrency')
class(`delete_PKRCurrency`) = c("SWIGFunction", class('delete_PKRCurrency'))

setMethod('delete', '_p_QuantLib__PKRCurrency', function(obj) {delete_QuantLib__PKRCurrency(obj)})
# Start of new_PLNCurrency

`PLNCurrency` = function()
{
  ;ans = .Call('R_swig_new_PLNCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__PLNCurrency";
  
  reg.finalizer(ans, delete_PLNCurrency)
  ans
  
}

attr(`PLNCurrency`, 'returnType') = '_p_QuantLib__PLNCurrency'
class(`PLNCurrency`) = c("SWIGFunction", class('PLNCurrency'))

# Start of delete_PLNCurrency

`delete_PLNCurrency` = function(self)
{
  ;.Call('R_swig_delete_PLNCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_PLNCurrency`, 'returnType') = 'void'
attr(`delete_PLNCurrency`, "inputTypes") = c('_p_QuantLib__PLNCurrency')
class(`delete_PLNCurrency`) = c("SWIGFunction", class('delete_PLNCurrency'))

setMethod('delete', '_p_QuantLib__PLNCurrency', function(obj) {delete_QuantLib__PLNCurrency(obj)})
# Start of new_PTECurrency

`PTECurrency` = function()
{
  ;ans = .Call('R_swig_new_PTECurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__PTECurrency";
  
  reg.finalizer(ans, delete_PTECurrency)
  ans
  
}

attr(`PTECurrency`, 'returnType') = '_p_QuantLib__PTECurrency'
class(`PTECurrency`) = c("SWIGFunction", class('PTECurrency'))

# Start of delete_PTECurrency

`delete_PTECurrency` = function(self)
{
  ;.Call('R_swig_delete_PTECurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_PTECurrency`, 'returnType') = 'void'
attr(`delete_PTECurrency`, "inputTypes") = c('_p_QuantLib__PTECurrency')
class(`delete_PTECurrency`) = c("SWIGFunction", class('delete_PTECurrency'))

setMethod('delete', '_p_QuantLib__PTECurrency', function(obj) {delete_QuantLib__PTECurrency(obj)})
# Start of new_ROLCurrency

`ROLCurrency` = function()
{
  ;ans = .Call('R_swig_new_ROLCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__ROLCurrency";
  
  reg.finalizer(ans, delete_ROLCurrency)
  ans
  
}

attr(`ROLCurrency`, 'returnType') = '_p_QuantLib__ROLCurrency'
class(`ROLCurrency`) = c("SWIGFunction", class('ROLCurrency'))

# Start of delete_ROLCurrency

`delete_ROLCurrency` = function(self)
{
  ;.Call('R_swig_delete_ROLCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_ROLCurrency`, 'returnType') = 'void'
attr(`delete_ROLCurrency`, "inputTypes") = c('_p_QuantLib__ROLCurrency')
class(`delete_ROLCurrency`) = c("SWIGFunction", class('delete_ROLCurrency'))

setMethod('delete', '_p_QuantLib__ROLCurrency', function(obj) {delete_QuantLib__ROLCurrency(obj)})
# Start of new_RONCurrency

`RONCurrency` = function()
{
  ;ans = .Call('R_swig_new_RONCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__RONCurrency";
  
  reg.finalizer(ans, delete_RONCurrency)
  ans
  
}

attr(`RONCurrency`, 'returnType') = '_p_QuantLib__RONCurrency'
class(`RONCurrency`) = c("SWIGFunction", class('RONCurrency'))

# Start of delete_RONCurrency

`delete_RONCurrency` = function(self)
{
  ;.Call('R_swig_delete_RONCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_RONCurrency`, 'returnType') = 'void'
attr(`delete_RONCurrency`, "inputTypes") = c('_p_QuantLib__RONCurrency')
class(`delete_RONCurrency`) = c("SWIGFunction", class('delete_RONCurrency'))

setMethod('delete', '_p_QuantLib__RONCurrency', function(obj) {delete_QuantLib__RONCurrency(obj)})
# Start of new_SARCurrency

`SARCurrency` = function()
{
  ;ans = .Call('R_swig_new_SARCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__SARCurrency";
  
  reg.finalizer(ans, delete_SARCurrency)
  ans
  
}

attr(`SARCurrency`, 'returnType') = '_p_QuantLib__SARCurrency'
class(`SARCurrency`) = c("SWIGFunction", class('SARCurrency'))

# Start of delete_SARCurrency

`delete_SARCurrency` = function(self)
{
  ;.Call('R_swig_delete_SARCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_SARCurrency`, 'returnType') = 'void'
attr(`delete_SARCurrency`, "inputTypes") = c('_p_QuantLib__SARCurrency')
class(`delete_SARCurrency`) = c("SWIGFunction", class('delete_SARCurrency'))

setMethod('delete', '_p_QuantLib__SARCurrency', function(obj) {delete_QuantLib__SARCurrency(obj)})
# Start of new_SEKCurrency

`SEKCurrency` = function()
{
  ;ans = .Call('R_swig_new_SEKCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__SEKCurrency";
  
  reg.finalizer(ans, delete_SEKCurrency)
  ans
  
}

attr(`SEKCurrency`, 'returnType') = '_p_QuantLib__SEKCurrency'
class(`SEKCurrency`) = c("SWIGFunction", class('SEKCurrency'))

# Start of delete_SEKCurrency

`delete_SEKCurrency` = function(self)
{
  ;.Call('R_swig_delete_SEKCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_SEKCurrency`, 'returnType') = 'void'
attr(`delete_SEKCurrency`, "inputTypes") = c('_p_QuantLib__SEKCurrency')
class(`delete_SEKCurrency`) = c("SWIGFunction", class('delete_SEKCurrency'))

setMethod('delete', '_p_QuantLib__SEKCurrency', function(obj) {delete_QuantLib__SEKCurrency(obj)})
# Start of new_SGDCurrency

`SGDCurrency` = function()
{
  ;ans = .Call('R_swig_new_SGDCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__SGDCurrency";
  
  reg.finalizer(ans, delete_SGDCurrency)
  ans
  
}

attr(`SGDCurrency`, 'returnType') = '_p_QuantLib__SGDCurrency'
class(`SGDCurrency`) = c("SWIGFunction", class('SGDCurrency'))

# Start of delete_SGDCurrency

`delete_SGDCurrency` = function(self)
{
  ;.Call('R_swig_delete_SGDCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_SGDCurrency`, 'returnType') = 'void'
attr(`delete_SGDCurrency`, "inputTypes") = c('_p_QuantLib__SGDCurrency')
class(`delete_SGDCurrency`) = c("SWIGFunction", class('delete_SGDCurrency'))

setMethod('delete', '_p_QuantLib__SGDCurrency', function(obj) {delete_QuantLib__SGDCurrency(obj)})
# Start of new_SITCurrency

`SITCurrency` = function()
{
  ;ans = .Call('R_swig_new_SITCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__SITCurrency";
  
  reg.finalizer(ans, delete_SITCurrency)
  ans
  
}

attr(`SITCurrency`, 'returnType') = '_p_QuantLib__SITCurrency'
class(`SITCurrency`) = c("SWIGFunction", class('SITCurrency'))

# Start of delete_SITCurrency

`delete_SITCurrency` = function(self)
{
  ;.Call('R_swig_delete_SITCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_SITCurrency`, 'returnType') = 'void'
attr(`delete_SITCurrency`, "inputTypes") = c('_p_QuantLib__SITCurrency')
class(`delete_SITCurrency`) = c("SWIGFunction", class('delete_SITCurrency'))

setMethod('delete', '_p_QuantLib__SITCurrency', function(obj) {delete_QuantLib__SITCurrency(obj)})
# Start of new_SKKCurrency

`SKKCurrency` = function()
{
  ;ans = .Call('R_swig_new_SKKCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__SKKCurrency";
  
  reg.finalizer(ans, delete_SKKCurrency)
  ans
  
}

attr(`SKKCurrency`, 'returnType') = '_p_QuantLib__SKKCurrency'
class(`SKKCurrency`) = c("SWIGFunction", class('SKKCurrency'))

# Start of delete_SKKCurrency

`delete_SKKCurrency` = function(self)
{
  ;.Call('R_swig_delete_SKKCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_SKKCurrency`, 'returnType') = 'void'
attr(`delete_SKKCurrency`, "inputTypes") = c('_p_QuantLib__SKKCurrency')
class(`delete_SKKCurrency`) = c("SWIGFunction", class('delete_SKKCurrency'))

setMethod('delete', '_p_QuantLib__SKKCurrency', function(obj) {delete_QuantLib__SKKCurrency(obj)})
# Start of new_THBCurrency

`THBCurrency` = function()
{
  ;ans = .Call('R_swig_new_THBCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__THBCurrency";
  
  reg.finalizer(ans, delete_THBCurrency)
  ans
  
}

attr(`THBCurrency`, 'returnType') = '_p_QuantLib__THBCurrency'
class(`THBCurrency`) = c("SWIGFunction", class('THBCurrency'))

# Start of delete_THBCurrency

`delete_THBCurrency` = function(self)
{
  ;.Call('R_swig_delete_THBCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_THBCurrency`, 'returnType') = 'void'
attr(`delete_THBCurrency`, "inputTypes") = c('_p_QuantLib__THBCurrency')
class(`delete_THBCurrency`) = c("SWIGFunction", class('delete_THBCurrency'))

setMethod('delete', '_p_QuantLib__THBCurrency', function(obj) {delete_QuantLib__THBCurrency(obj)})
# Start of new_TRLCurrency

`TRLCurrency` = function()
{
  ;ans = .Call('R_swig_new_TRLCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__TRLCurrency";
  
  reg.finalizer(ans, delete_TRLCurrency)
  ans
  
}

attr(`TRLCurrency`, 'returnType') = '_p_QuantLib__TRLCurrency'
class(`TRLCurrency`) = c("SWIGFunction", class('TRLCurrency'))

# Start of delete_TRLCurrency

`delete_TRLCurrency` = function(self)
{
  ;.Call('R_swig_delete_TRLCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_TRLCurrency`, 'returnType') = 'void'
attr(`delete_TRLCurrency`, "inputTypes") = c('_p_QuantLib__TRLCurrency')
class(`delete_TRLCurrency`) = c("SWIGFunction", class('delete_TRLCurrency'))

setMethod('delete', '_p_QuantLib__TRLCurrency', function(obj) {delete_QuantLib__TRLCurrency(obj)})
# Start of new_TRYCurrency

`TRYCurrency` = function()
{
  ;ans = .Call('R_swig_new_TRYCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__TRYCurrency";
  
  reg.finalizer(ans, delete_TRYCurrency)
  ans
  
}

attr(`TRYCurrency`, 'returnType') = '_p_QuantLib__TRYCurrency'
class(`TRYCurrency`) = c("SWIGFunction", class('TRYCurrency'))

# Start of delete_TRYCurrency

`delete_TRYCurrency` = function(self)
{
  ;.Call('R_swig_delete_TRYCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_TRYCurrency`, 'returnType') = 'void'
attr(`delete_TRYCurrency`, "inputTypes") = c('_p_QuantLib__TRYCurrency')
class(`delete_TRYCurrency`) = c("SWIGFunction", class('delete_TRYCurrency'))

setMethod('delete', '_p_QuantLib__TRYCurrency', function(obj) {delete_QuantLib__TRYCurrency(obj)})
# Start of new_TTDCurrency

`TTDCurrency` = function()
{
  ;ans = .Call('R_swig_new_TTDCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__TTDCurrency";
  
  reg.finalizer(ans, delete_TTDCurrency)
  ans
  
}

attr(`TTDCurrency`, 'returnType') = '_p_QuantLib__TTDCurrency'
class(`TTDCurrency`) = c("SWIGFunction", class('TTDCurrency'))

# Start of delete_TTDCurrency

`delete_TTDCurrency` = function(self)
{
  ;.Call('R_swig_delete_TTDCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_TTDCurrency`, 'returnType') = 'void'
attr(`delete_TTDCurrency`, "inputTypes") = c('_p_QuantLib__TTDCurrency')
class(`delete_TTDCurrency`) = c("SWIGFunction", class('delete_TTDCurrency'))

setMethod('delete', '_p_QuantLib__TTDCurrency', function(obj) {delete_QuantLib__TTDCurrency(obj)})
# Start of new_TWDCurrency

`TWDCurrency` = function()
{
  ;ans = .Call('R_swig_new_TWDCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__TWDCurrency";
  
  reg.finalizer(ans, delete_TWDCurrency)
  ans
  
}

attr(`TWDCurrency`, 'returnType') = '_p_QuantLib__TWDCurrency'
class(`TWDCurrency`) = c("SWIGFunction", class('TWDCurrency'))

# Start of delete_TWDCurrency

`delete_TWDCurrency` = function(self)
{
  ;.Call('R_swig_delete_TWDCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_TWDCurrency`, 'returnType') = 'void'
attr(`delete_TWDCurrency`, "inputTypes") = c('_p_QuantLib__TWDCurrency')
class(`delete_TWDCurrency`) = c("SWIGFunction", class('delete_TWDCurrency'))

setMethod('delete', '_p_QuantLib__TWDCurrency', function(obj) {delete_QuantLib__TWDCurrency(obj)})
# Start of new_USDCurrency

`USDCurrency` = function()
{
  ;ans = .Call('R_swig_new_USDCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__USDCurrency";
  
  reg.finalizer(ans, delete_USDCurrency)
  ans
  
}

attr(`USDCurrency`, 'returnType') = '_p_QuantLib__USDCurrency'
class(`USDCurrency`) = c("SWIGFunction", class('USDCurrency'))

# Start of delete_USDCurrency

`delete_USDCurrency` = function(self)
{
  ;.Call('R_swig_delete_USDCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_USDCurrency`, 'returnType') = 'void'
attr(`delete_USDCurrency`, "inputTypes") = c('_p_QuantLib__USDCurrency')
class(`delete_USDCurrency`) = c("SWIGFunction", class('delete_USDCurrency'))

setMethod('delete', '_p_QuantLib__USDCurrency', function(obj) {delete_QuantLib__USDCurrency(obj)})
# Start of new_VEBCurrency

`VEBCurrency` = function()
{
  ;ans = .Call('R_swig_new_VEBCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__VEBCurrency";
  
  reg.finalizer(ans, delete_VEBCurrency)
  ans
  
}

attr(`VEBCurrency`, 'returnType') = '_p_QuantLib__VEBCurrency'
class(`VEBCurrency`) = c("SWIGFunction", class('VEBCurrency'))

# Start of delete_VEBCurrency

`delete_VEBCurrency` = function(self)
{
  ;.Call('R_swig_delete_VEBCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_VEBCurrency`, 'returnType') = 'void'
attr(`delete_VEBCurrency`, "inputTypes") = c('_p_QuantLib__VEBCurrency')
class(`delete_VEBCurrency`) = c("SWIGFunction", class('delete_VEBCurrency'))

setMethod('delete', '_p_QuantLib__VEBCurrency', function(obj) {delete_QuantLib__VEBCurrency(obj)})
# Start of new_ZARCurrency

`ZARCurrency` = function()
{
  ;ans = .Call('R_swig_new_ZARCurrency', PACKAGE='QuantLib');
  class(ans) <- "_p_QuantLib__ZARCurrency";
  
  reg.finalizer(ans, delete_ZARCurrency)
  ans
  
}

attr(`ZARCurrency`, 'returnType') = '_p_QuantLib__ZARCurrency'
class(`ZARCurrency`) = c("SWIGFunction", class('ZARCurrency'))

# Start of delete_ZARCurrency

`delete_ZARCurrency` = function(self)
{
  ;.Call('R_swig_delete_ZARCurrency', self, PACKAGE='QuantLib');
  
}

attr(`delete_ZARCurrency`, 'returnType') = 'void'
attr(`delete_ZARCurrency`, "inputTypes") = c('_p_QuantLib__ZARCurrency')
class(`delete_ZARCurrency`) = c("SWIGFunction", class('delete_ZARCurrency'))

setMethod('delete', '_p_QuantLib__ZARCurrency', function(obj) {delete_QuantLib__ZARCurrency(obj)})
# Start of new_LinearInterpolation

`LinearInterpolation` = function(x, y)
{
  ;ans = .Call('R_swig_new_LinearInterpolation', x, y, PACKAGE='QuantLib');
  class(ans) <- "_p_SafeLinearInterpolation";
  
  reg.finalizer(ans, delete_LinearInterpolation)
  ans
  
}

attr(`LinearInterpolation`, 'returnType') = '_p_SafeLinearInterpolation'
attr(`LinearInterpolation`, "inputTypes") = c('_p_Array', '_p_Array')
class(`LinearInterpolation`) = c("SWIGFunction", class('LinearInterpolation'))

# Start of LinearInterpolation___call__

`LinearInterpolation___call____SWIG_0` = function(self, x, allowExtrapolation, .copy = FALSE)
{
  allowExtrapolation = as.logical(allowExtrapolation);
  ;.Call('R_swig_LinearInterpolation___call____SWIG_0', self, x, allowExtrapolation, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`LinearInterpolation___call____SWIG_0`, 'returnType') = 'numeric'
attr(`LinearInterpolation___call____SWIG_0`, "inputTypes") = c('_p_SafeLinearInterpolation', 'numeric', 'logical')
class(`LinearInterpolation___call____SWIG_0`) = c("SWIGFunction", class('LinearInterpolation___call____SWIG_0'))

# Start of LinearInterpolation___call__

`LinearInterpolation___call____SWIG_1` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_LinearInterpolation___call____SWIG_1', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`LinearInterpolation___call____SWIG_1`, 'returnType') = 'numeric'
attr(`LinearInterpolation___call____SWIG_1`, "inputTypes") = c('_p_SafeLinearInterpolation', 'numeric')
class(`LinearInterpolation___call____SWIG_1`) = c("SWIGFunction", class('LinearInterpolation___call____SWIG_1'))

`LinearInterpolation___call__` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_SafeLinearInterpolation') && is.numeric(argv[[2]])) {
      f <- LinearInterpolation___call____SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_SafeLinearInterpolation') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- LinearInterpolation___call____SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for LinearInterpolation___call__ with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_LinearInterpolation

`delete_LinearInterpolation` = function(self)
{
  ;.Call('R_swig_delete_LinearInterpolation', self, PACKAGE='QuantLib');
  
}

attr(`delete_LinearInterpolation`, 'returnType') = 'void'
attr(`delete_LinearInterpolation`, "inputTypes") = c('_p_SafeLinearInterpolation')
class(`delete_LinearInterpolation`) = c("SWIGFunction", class('delete_LinearInterpolation'))

# Start of accessor method for SafeLinearInterpolation
setMethod('$', '_p_SafeLinearInterpolation', function(x, name)

{
  accessorFuns = list('__call__' = LinearInterpolation___call__);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for SafeLinearInterpolation
setMethod('delete', '_p_SafeLinearInterpolation', function(obj) {delete_SafeLinearInterpolation(obj)})
# Start of new_LogLinearInterpolation

`LogLinearInterpolation` = function(x, y)
{
  ;ans = .Call('R_swig_new_LogLinearInterpolation', x, y, PACKAGE='QuantLib');
  class(ans) <- "_p_SafeLogLinearInterpolation";
  
  reg.finalizer(ans, delete_LogLinearInterpolation)
  ans
  
}

attr(`LogLinearInterpolation`, 'returnType') = '_p_SafeLogLinearInterpolation'
attr(`LogLinearInterpolation`, "inputTypes") = c('_p_Array', '_p_Array')
class(`LogLinearInterpolation`) = c("SWIGFunction", class('LogLinearInterpolation'))

# Start of LogLinearInterpolation___call__

`LogLinearInterpolation___call____SWIG_0` = function(self, x, allowExtrapolation, .copy = FALSE)
{
  allowExtrapolation = as.logical(allowExtrapolation);
  ;.Call('R_swig_LogLinearInterpolation___call____SWIG_0', self, x, allowExtrapolation, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`LogLinearInterpolation___call____SWIG_0`, 'returnType') = 'numeric'
attr(`LogLinearInterpolation___call____SWIG_0`, "inputTypes") = c('_p_SafeLogLinearInterpolation', 'numeric', 'logical')
class(`LogLinearInterpolation___call____SWIG_0`) = c("SWIGFunction", class('LogLinearInterpolation___call____SWIG_0'))

# Start of LogLinearInterpolation___call__

`LogLinearInterpolation___call____SWIG_1` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_LogLinearInterpolation___call____SWIG_1', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`LogLinearInterpolation___call____SWIG_1`, 'returnType') = 'numeric'
attr(`LogLinearInterpolation___call____SWIG_1`, "inputTypes") = c('_p_SafeLogLinearInterpolation', 'numeric')
class(`LogLinearInterpolation___call____SWIG_1`) = c("SWIGFunction", class('LogLinearInterpolation___call____SWIG_1'))

`LogLinearInterpolation___call__` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_SafeLogLinearInterpolation') && is.numeric(argv[[2]])) {
      f <- LogLinearInterpolation___call____SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_SafeLogLinearInterpolation') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- LogLinearInterpolation___call____SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for LogLinearInterpolation___call__ with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_LogLinearInterpolation

`delete_LogLinearInterpolation` = function(self)
{
  ;.Call('R_swig_delete_LogLinearInterpolation', self, PACKAGE='QuantLib');
  
}

attr(`delete_LogLinearInterpolation`, 'returnType') = 'void'
attr(`delete_LogLinearInterpolation`, "inputTypes") = c('_p_SafeLogLinearInterpolation')
class(`delete_LogLinearInterpolation`) = c("SWIGFunction", class('delete_LogLinearInterpolation'))

# Start of accessor method for SafeLogLinearInterpolation
setMethod('$', '_p_SafeLogLinearInterpolation', function(x, name)

{
  accessorFuns = list('__call__' = LogLinearInterpolation___call__);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for SafeLogLinearInterpolation
setMethod('delete', '_p_SafeLogLinearInterpolation', function(obj) {delete_SafeLogLinearInterpolation(obj)})
# Start of new_BackwardFlatInterpolation

`BackwardFlatInterpolation` = function(x, y)
{
  ;ans = .Call('R_swig_new_BackwardFlatInterpolation', x, y, PACKAGE='QuantLib');
  class(ans) <- "_p_SafeBackwardFlatInterpolation";
  
  reg.finalizer(ans, delete_BackwardFlatInterpolation)
  ans
  
}

attr(`BackwardFlatInterpolation`, 'returnType') = '_p_SafeBackwardFlatInterpolation'
attr(`BackwardFlatInterpolation`, "inputTypes") = c('_p_Array', '_p_Array')
class(`BackwardFlatInterpolation`) = c("SWIGFunction", class('BackwardFlatInterpolation'))

# Start of BackwardFlatInterpolation___call__

`BackwardFlatInterpolation___call____SWIG_0` = function(self, x, allowExtrapolation, .copy = FALSE)
{
  allowExtrapolation = as.logical(allowExtrapolation);
  ;.Call('R_swig_BackwardFlatInterpolation___call____SWIG_0', self, x, allowExtrapolation, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BackwardFlatInterpolation___call____SWIG_0`, 'returnType') = 'numeric'
attr(`BackwardFlatInterpolation___call____SWIG_0`, "inputTypes") = c('_p_SafeBackwardFlatInterpolation', 'numeric', 'logical')
class(`BackwardFlatInterpolation___call____SWIG_0`) = c("SWIGFunction", class('BackwardFlatInterpolation___call____SWIG_0'))

# Start of BackwardFlatInterpolation___call__

`BackwardFlatInterpolation___call____SWIG_1` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_BackwardFlatInterpolation___call____SWIG_1', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BackwardFlatInterpolation___call____SWIG_1`, 'returnType') = 'numeric'
attr(`BackwardFlatInterpolation___call____SWIG_1`, "inputTypes") = c('_p_SafeBackwardFlatInterpolation', 'numeric')
class(`BackwardFlatInterpolation___call____SWIG_1`) = c("SWIGFunction", class('BackwardFlatInterpolation___call____SWIG_1'))

`BackwardFlatInterpolation___call__` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_SafeBackwardFlatInterpolation') && is.numeric(argv[[2]])) {
      f <- BackwardFlatInterpolation___call____SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_SafeBackwardFlatInterpolation') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- BackwardFlatInterpolation___call____SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for BackwardFlatInterpolation___call__ with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_BackwardFlatInterpolation

`delete_BackwardFlatInterpolation` = function(self)
{
  ;.Call('R_swig_delete_BackwardFlatInterpolation', self, PACKAGE='QuantLib');
  
}

attr(`delete_BackwardFlatInterpolation`, 'returnType') = 'void'
attr(`delete_BackwardFlatInterpolation`, "inputTypes") = c('_p_SafeBackwardFlatInterpolation')
class(`delete_BackwardFlatInterpolation`) = c("SWIGFunction", class('delete_BackwardFlatInterpolation'))

# Start of accessor method for SafeBackwardFlatInterpolation
setMethod('$', '_p_SafeBackwardFlatInterpolation', function(x, name)

{
  accessorFuns = list('__call__' = BackwardFlatInterpolation___call__);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for SafeBackwardFlatInterpolation
setMethod('delete', '_p_SafeBackwardFlatInterpolation', function(obj) {delete_SafeBackwardFlatInterpolation(obj)})
# Start of new_ForwardFlatInterpolation

`ForwardFlatInterpolation` = function(x, y)
{
  ;ans = .Call('R_swig_new_ForwardFlatInterpolation', x, y, PACKAGE='QuantLib');
  class(ans) <- "_p_SafeForwardFlatInterpolation";
  
  reg.finalizer(ans, delete_ForwardFlatInterpolation)
  ans
  
}

attr(`ForwardFlatInterpolation`, 'returnType') = '_p_SafeForwardFlatInterpolation'
attr(`ForwardFlatInterpolation`, "inputTypes") = c('_p_Array', '_p_Array')
class(`ForwardFlatInterpolation`) = c("SWIGFunction", class('ForwardFlatInterpolation'))

# Start of ForwardFlatInterpolation___call__

`ForwardFlatInterpolation___call____SWIG_0` = function(self, x, allowExtrapolation, .copy = FALSE)
{
  allowExtrapolation = as.logical(allowExtrapolation);
  ;.Call('R_swig_ForwardFlatInterpolation___call____SWIG_0', self, x, allowExtrapolation, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`ForwardFlatInterpolation___call____SWIG_0`, 'returnType') = 'numeric'
attr(`ForwardFlatInterpolation___call____SWIG_0`, "inputTypes") = c('_p_SafeForwardFlatInterpolation', 'numeric', 'logical')
class(`ForwardFlatInterpolation___call____SWIG_0`) = c("SWIGFunction", class('ForwardFlatInterpolation___call____SWIG_0'))

# Start of ForwardFlatInterpolation___call__

`ForwardFlatInterpolation___call____SWIG_1` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_ForwardFlatInterpolation___call____SWIG_1', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`ForwardFlatInterpolation___call____SWIG_1`, 'returnType') = 'numeric'
attr(`ForwardFlatInterpolation___call____SWIG_1`, "inputTypes") = c('_p_SafeForwardFlatInterpolation', 'numeric')
class(`ForwardFlatInterpolation___call____SWIG_1`) = c("SWIGFunction", class('ForwardFlatInterpolation___call____SWIG_1'))

`ForwardFlatInterpolation___call__` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_SafeForwardFlatInterpolation') && is.numeric(argv[[2]])) {
      f <- ForwardFlatInterpolation___call____SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_SafeForwardFlatInterpolation') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- ForwardFlatInterpolation___call____SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for ForwardFlatInterpolation___call__ with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_ForwardFlatInterpolation

`delete_ForwardFlatInterpolation` = function(self)
{
  ;.Call('R_swig_delete_ForwardFlatInterpolation', self, PACKAGE='QuantLib');
  
}

attr(`delete_ForwardFlatInterpolation`, 'returnType') = 'void'
attr(`delete_ForwardFlatInterpolation`, "inputTypes") = c('_p_SafeForwardFlatInterpolation')
class(`delete_ForwardFlatInterpolation`) = c("SWIGFunction", class('delete_ForwardFlatInterpolation'))

# Start of accessor method for SafeForwardFlatInterpolation
setMethod('$', '_p_SafeForwardFlatInterpolation', function(x, name)

{
  accessorFuns = list('__call__' = ForwardFlatInterpolation___call__);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for SafeForwardFlatInterpolation
setMethod('delete', '_p_SafeForwardFlatInterpolation', function(obj) {delete_SafeForwardFlatInterpolation(obj)})
# Start of new_CubicNaturalSpline

`CubicNaturalSpline` = function(x, y)
{
  ;ans = .Call('R_swig_new_CubicNaturalSpline', x, y, PACKAGE='QuantLib');
  class(ans) <- "_p_SafeCubicNaturalSpline";
  
  reg.finalizer(ans, delete_CubicNaturalSpline)
  ans
  
}

attr(`CubicNaturalSpline`, 'returnType') = '_p_SafeCubicNaturalSpline'
attr(`CubicNaturalSpline`, "inputTypes") = c('_p_Array', '_p_Array')
class(`CubicNaturalSpline`) = c("SWIGFunction", class('CubicNaturalSpline'))

# Start of CubicNaturalSpline___call__

`CubicNaturalSpline___call____SWIG_0` = function(self, x, allowExtrapolation, .copy = FALSE)
{
  allowExtrapolation = as.logical(allowExtrapolation);
  ;.Call('R_swig_CubicNaturalSpline___call____SWIG_0', self, x, allowExtrapolation, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CubicNaturalSpline___call____SWIG_0`, 'returnType') = 'numeric'
attr(`CubicNaturalSpline___call____SWIG_0`, "inputTypes") = c('_p_SafeCubicNaturalSpline', 'numeric', 'logical')
class(`CubicNaturalSpline___call____SWIG_0`) = c("SWIGFunction", class('CubicNaturalSpline___call____SWIG_0'))

# Start of CubicNaturalSpline___call__

`CubicNaturalSpline___call____SWIG_1` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_CubicNaturalSpline___call____SWIG_1', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CubicNaturalSpline___call____SWIG_1`, 'returnType') = 'numeric'
attr(`CubicNaturalSpline___call____SWIG_1`, "inputTypes") = c('_p_SafeCubicNaturalSpline', 'numeric')
class(`CubicNaturalSpline___call____SWIG_1`) = c("SWIGFunction", class('CubicNaturalSpline___call____SWIG_1'))

`CubicNaturalSpline___call__` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_SafeCubicNaturalSpline') && is.numeric(argv[[2]])) {
      f <- CubicNaturalSpline___call____SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_SafeCubicNaturalSpline') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- CubicNaturalSpline___call____SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for CubicNaturalSpline___call__ with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of CubicNaturalSpline_derivative

`CubicNaturalSpline_derivative__SWIG_0` = function(self, x, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_CubicNaturalSpline_derivative__SWIG_0', self, x, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CubicNaturalSpline_derivative__SWIG_0`, 'returnType') = 'numeric'
attr(`CubicNaturalSpline_derivative__SWIG_0`, "inputTypes") = c('_p_SafeCubicNaturalSpline', 'numeric', 'logical')
class(`CubicNaturalSpline_derivative__SWIG_0`) = c("SWIGFunction", class('CubicNaturalSpline_derivative__SWIG_0'))

# Start of CubicNaturalSpline_derivative

`CubicNaturalSpline_derivative__SWIG_1` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_CubicNaturalSpline_derivative__SWIG_1', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CubicNaturalSpline_derivative__SWIG_1`, 'returnType') = 'numeric'
attr(`CubicNaturalSpline_derivative__SWIG_1`, "inputTypes") = c('_p_SafeCubicNaturalSpline', 'numeric')
class(`CubicNaturalSpline_derivative__SWIG_1`) = c("SWIGFunction", class('CubicNaturalSpline_derivative__SWIG_1'))

`CubicNaturalSpline_derivative` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_SafeCubicNaturalSpline') && is.numeric(argv[[2]])) {
      f <- CubicNaturalSpline_derivative__SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_SafeCubicNaturalSpline') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- CubicNaturalSpline_derivative__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for CubicNaturalSpline_derivative with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of CubicNaturalSpline_secondDerivative

`CubicNaturalSpline_secondDerivative__SWIG_0` = function(self, x, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_CubicNaturalSpline_secondDerivative__SWIG_0', self, x, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CubicNaturalSpline_secondDerivative__SWIG_0`, 'returnType') = 'numeric'
attr(`CubicNaturalSpline_secondDerivative__SWIG_0`, "inputTypes") = c('_p_SafeCubicNaturalSpline', 'numeric', 'logical')
class(`CubicNaturalSpline_secondDerivative__SWIG_0`) = c("SWIGFunction", class('CubicNaturalSpline_secondDerivative__SWIG_0'))

# Start of CubicNaturalSpline_secondDerivative

`CubicNaturalSpline_secondDerivative__SWIG_1` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_CubicNaturalSpline_secondDerivative__SWIG_1', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CubicNaturalSpline_secondDerivative__SWIG_1`, 'returnType') = 'numeric'
attr(`CubicNaturalSpline_secondDerivative__SWIG_1`, "inputTypes") = c('_p_SafeCubicNaturalSpline', 'numeric')
class(`CubicNaturalSpline_secondDerivative__SWIG_1`) = c("SWIGFunction", class('CubicNaturalSpline_secondDerivative__SWIG_1'))

`CubicNaturalSpline_secondDerivative` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_SafeCubicNaturalSpline') && is.numeric(argv[[2]])) {
      f <- CubicNaturalSpline_secondDerivative__SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_SafeCubicNaturalSpline') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- CubicNaturalSpline_secondDerivative__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for CubicNaturalSpline_secondDerivative with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of CubicNaturalSpline_primitive

`CubicNaturalSpline_primitive__SWIG_0` = function(self, x, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_CubicNaturalSpline_primitive__SWIG_0', self, x, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CubicNaturalSpline_primitive__SWIG_0`, 'returnType') = 'numeric'
attr(`CubicNaturalSpline_primitive__SWIG_0`, "inputTypes") = c('_p_SafeCubicNaturalSpline', 'numeric', 'logical')
class(`CubicNaturalSpline_primitive__SWIG_0`) = c("SWIGFunction", class('CubicNaturalSpline_primitive__SWIG_0'))

# Start of CubicNaturalSpline_primitive

`CubicNaturalSpline_primitive__SWIG_1` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_CubicNaturalSpline_primitive__SWIG_1', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CubicNaturalSpline_primitive__SWIG_1`, 'returnType') = 'numeric'
attr(`CubicNaturalSpline_primitive__SWIG_1`, "inputTypes") = c('_p_SafeCubicNaturalSpline', 'numeric')
class(`CubicNaturalSpline_primitive__SWIG_1`) = c("SWIGFunction", class('CubicNaturalSpline_primitive__SWIG_1'))

`CubicNaturalSpline_primitive` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_SafeCubicNaturalSpline') && is.numeric(argv[[2]])) {
      f <- CubicNaturalSpline_primitive__SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_SafeCubicNaturalSpline') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- CubicNaturalSpline_primitive__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for CubicNaturalSpline_primitive with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_CubicNaturalSpline

`delete_CubicNaturalSpline` = function(self)
{
  ;.Call('R_swig_delete_CubicNaturalSpline', self, PACKAGE='QuantLib');
  
}

attr(`delete_CubicNaturalSpline`, 'returnType') = 'void'
attr(`delete_CubicNaturalSpline`, "inputTypes") = c('_p_SafeCubicNaturalSpline')
class(`delete_CubicNaturalSpline`) = c("SWIGFunction", class('delete_CubicNaturalSpline'))

# Start of accessor method for SafeCubicNaturalSpline
setMethod('$', '_p_SafeCubicNaturalSpline', function(x, name)

{
  accessorFuns = list('__call__' = CubicNaturalSpline___call__, 'derivative' = CubicNaturalSpline_derivative, 'secondDerivative' = CubicNaturalSpline_secondDerivative, 'primitive' = CubicNaturalSpline_primitive);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for SafeCubicNaturalSpline
setMethod('delete', '_p_SafeCubicNaturalSpline', function(obj) {delete_SafeCubicNaturalSpline(obj)})
# Start of new_LogCubicNaturalSpline

`LogCubicNaturalSpline` = function(x, y)
{
  ;ans = .Call('R_swig_new_LogCubicNaturalSpline', x, y, PACKAGE='QuantLib');
  class(ans) <- "_p_SafeLogCubicNaturalSpline";
  
  reg.finalizer(ans, delete_LogCubicNaturalSpline)
  ans
  
}

attr(`LogCubicNaturalSpline`, 'returnType') = '_p_SafeLogCubicNaturalSpline'
attr(`LogCubicNaturalSpline`, "inputTypes") = c('_p_Array', '_p_Array')
class(`LogCubicNaturalSpline`) = c("SWIGFunction", class('LogCubicNaturalSpline'))

# Start of LogCubicNaturalSpline___call__

`LogCubicNaturalSpline___call____SWIG_0` = function(self, x, allowExtrapolation, .copy = FALSE)
{
  allowExtrapolation = as.logical(allowExtrapolation);
  ;.Call('R_swig_LogCubicNaturalSpline___call____SWIG_0', self, x, allowExtrapolation, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`LogCubicNaturalSpline___call____SWIG_0`, 'returnType') = 'numeric'
attr(`LogCubicNaturalSpline___call____SWIG_0`, "inputTypes") = c('_p_SafeLogCubicNaturalSpline', 'numeric', 'logical')
class(`LogCubicNaturalSpline___call____SWIG_0`) = c("SWIGFunction", class('LogCubicNaturalSpline___call____SWIG_0'))

# Start of LogCubicNaturalSpline___call__

`LogCubicNaturalSpline___call____SWIG_1` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_LogCubicNaturalSpline___call____SWIG_1', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`LogCubicNaturalSpline___call____SWIG_1`, 'returnType') = 'numeric'
attr(`LogCubicNaturalSpline___call____SWIG_1`, "inputTypes") = c('_p_SafeLogCubicNaturalSpline', 'numeric')
class(`LogCubicNaturalSpline___call____SWIG_1`) = c("SWIGFunction", class('LogCubicNaturalSpline___call____SWIG_1'))

`LogCubicNaturalSpline___call__` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_SafeLogCubicNaturalSpline') && is.numeric(argv[[2]])) {
      f <- LogCubicNaturalSpline___call____SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_SafeLogCubicNaturalSpline') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- LogCubicNaturalSpline___call____SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for LogCubicNaturalSpline___call__ with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of LogCubicNaturalSpline_derivative

`LogCubicNaturalSpline_derivative__SWIG_0` = function(self, x, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_LogCubicNaturalSpline_derivative__SWIG_0', self, x, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`LogCubicNaturalSpline_derivative__SWIG_0`, 'returnType') = 'numeric'
attr(`LogCubicNaturalSpline_derivative__SWIG_0`, "inputTypes") = c('_p_SafeLogCubicNaturalSpline', 'numeric', 'logical')
class(`LogCubicNaturalSpline_derivative__SWIG_0`) = c("SWIGFunction", class('LogCubicNaturalSpline_derivative__SWIG_0'))

# Start of LogCubicNaturalSpline_derivative

`LogCubicNaturalSpline_derivative__SWIG_1` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_LogCubicNaturalSpline_derivative__SWIG_1', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`LogCubicNaturalSpline_derivative__SWIG_1`, 'returnType') = 'numeric'
attr(`LogCubicNaturalSpline_derivative__SWIG_1`, "inputTypes") = c('_p_SafeLogCubicNaturalSpline', 'numeric')
class(`LogCubicNaturalSpline_derivative__SWIG_1`) = c("SWIGFunction", class('LogCubicNaturalSpline_derivative__SWIG_1'))

`LogCubicNaturalSpline_derivative` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_SafeLogCubicNaturalSpline') && is.numeric(argv[[2]])) {
      f <- LogCubicNaturalSpline_derivative__SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_SafeLogCubicNaturalSpline') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- LogCubicNaturalSpline_derivative__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for LogCubicNaturalSpline_derivative with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of LogCubicNaturalSpline_secondDerivative

`LogCubicNaturalSpline_secondDerivative__SWIG_0` = function(self, x, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_LogCubicNaturalSpline_secondDerivative__SWIG_0', self, x, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`LogCubicNaturalSpline_secondDerivative__SWIG_0`, 'returnType') = 'numeric'
attr(`LogCubicNaturalSpline_secondDerivative__SWIG_0`, "inputTypes") = c('_p_SafeLogCubicNaturalSpline', 'numeric', 'logical')
class(`LogCubicNaturalSpline_secondDerivative__SWIG_0`) = c("SWIGFunction", class('LogCubicNaturalSpline_secondDerivative__SWIG_0'))

# Start of LogCubicNaturalSpline_secondDerivative

`LogCubicNaturalSpline_secondDerivative__SWIG_1` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_LogCubicNaturalSpline_secondDerivative__SWIG_1', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`LogCubicNaturalSpline_secondDerivative__SWIG_1`, 'returnType') = 'numeric'
attr(`LogCubicNaturalSpline_secondDerivative__SWIG_1`, "inputTypes") = c('_p_SafeLogCubicNaturalSpline', 'numeric')
class(`LogCubicNaturalSpline_secondDerivative__SWIG_1`) = c("SWIGFunction", class('LogCubicNaturalSpline_secondDerivative__SWIG_1'))

`LogCubicNaturalSpline_secondDerivative` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_SafeLogCubicNaturalSpline') && is.numeric(argv[[2]])) {
      f <- LogCubicNaturalSpline_secondDerivative__SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_SafeLogCubicNaturalSpline') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- LogCubicNaturalSpline_secondDerivative__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for LogCubicNaturalSpline_secondDerivative with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of LogCubicNaturalSpline_primitive

`LogCubicNaturalSpline_primitive__SWIG_0` = function(self, x, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_LogCubicNaturalSpline_primitive__SWIG_0', self, x, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`LogCubicNaturalSpline_primitive__SWIG_0`, 'returnType') = 'numeric'
attr(`LogCubicNaturalSpline_primitive__SWIG_0`, "inputTypes") = c('_p_SafeLogCubicNaturalSpline', 'numeric', 'logical')
class(`LogCubicNaturalSpline_primitive__SWIG_0`) = c("SWIGFunction", class('LogCubicNaturalSpline_primitive__SWIG_0'))

# Start of LogCubicNaturalSpline_primitive

`LogCubicNaturalSpline_primitive__SWIG_1` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_LogCubicNaturalSpline_primitive__SWIG_1', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`LogCubicNaturalSpline_primitive__SWIG_1`, 'returnType') = 'numeric'
attr(`LogCubicNaturalSpline_primitive__SWIG_1`, "inputTypes") = c('_p_SafeLogCubicNaturalSpline', 'numeric')
class(`LogCubicNaturalSpline_primitive__SWIG_1`) = c("SWIGFunction", class('LogCubicNaturalSpline_primitive__SWIG_1'))

`LogCubicNaturalSpline_primitive` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_SafeLogCubicNaturalSpline') && is.numeric(argv[[2]])) {
      f <- LogCubicNaturalSpline_primitive__SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_SafeLogCubicNaturalSpline') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- LogCubicNaturalSpline_primitive__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for LogCubicNaturalSpline_primitive with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_LogCubicNaturalSpline

`delete_LogCubicNaturalSpline` = function(self)
{
  ;.Call('R_swig_delete_LogCubicNaturalSpline', self, PACKAGE='QuantLib');
  
}

attr(`delete_LogCubicNaturalSpline`, 'returnType') = 'void'
attr(`delete_LogCubicNaturalSpline`, "inputTypes") = c('_p_SafeLogCubicNaturalSpline')
class(`delete_LogCubicNaturalSpline`) = c("SWIGFunction", class('delete_LogCubicNaturalSpline'))

# Start of accessor method for SafeLogCubicNaturalSpline
setMethod('$', '_p_SafeLogCubicNaturalSpline', function(x, name)

{
  accessorFuns = list('__call__' = LogCubicNaturalSpline___call__, 'derivative' = LogCubicNaturalSpline_derivative, 'secondDerivative' = LogCubicNaturalSpline_secondDerivative, 'primitive' = LogCubicNaturalSpline_primitive);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for SafeLogCubicNaturalSpline
setMethod('delete', '_p_SafeLogCubicNaturalSpline', function(obj) {delete_SafeLogCubicNaturalSpline(obj)})
# Start of new_MonotonicCubicNaturalSpline

`MonotonicCubicNaturalSpline` = function(x, y)
{
  ;ans = .Call('R_swig_new_MonotonicCubicNaturalSpline', x, y, PACKAGE='QuantLib');
  class(ans) <- "_p_SafeMonotonicCubicNaturalSpline";
  
  reg.finalizer(ans, delete_MonotonicCubicNaturalSpline)
  ans
  
}

attr(`MonotonicCubicNaturalSpline`, 'returnType') = '_p_SafeMonotonicCubicNaturalSpline'
attr(`MonotonicCubicNaturalSpline`, "inputTypes") = c('_p_Array', '_p_Array')
class(`MonotonicCubicNaturalSpline`) = c("SWIGFunction", class('MonotonicCubicNaturalSpline'))

# Start of MonotonicCubicNaturalSpline___call__

`MonotonicCubicNaturalSpline___call____SWIG_0` = function(self, x, allowExtrapolation, .copy = FALSE)
{
  allowExtrapolation = as.logical(allowExtrapolation);
  ;.Call('R_swig_MonotonicCubicNaturalSpline___call____SWIG_0', self, x, allowExtrapolation, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`MonotonicCubicNaturalSpline___call____SWIG_0`, 'returnType') = 'numeric'
attr(`MonotonicCubicNaturalSpline___call____SWIG_0`, "inputTypes") = c('_p_SafeMonotonicCubicNaturalSpline', 'numeric', 'logical')
class(`MonotonicCubicNaturalSpline___call____SWIG_0`) = c("SWIGFunction", class('MonotonicCubicNaturalSpline___call____SWIG_0'))

# Start of MonotonicCubicNaturalSpline___call__

`MonotonicCubicNaturalSpline___call____SWIG_1` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_MonotonicCubicNaturalSpline___call____SWIG_1', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`MonotonicCubicNaturalSpline___call____SWIG_1`, 'returnType') = 'numeric'
attr(`MonotonicCubicNaturalSpline___call____SWIG_1`, "inputTypes") = c('_p_SafeMonotonicCubicNaturalSpline', 'numeric')
class(`MonotonicCubicNaturalSpline___call____SWIG_1`) = c("SWIGFunction", class('MonotonicCubicNaturalSpline___call____SWIG_1'))

`MonotonicCubicNaturalSpline___call__` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_SafeMonotonicCubicNaturalSpline') && is.numeric(argv[[2]])) {
      f <- MonotonicCubicNaturalSpline___call____SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_SafeMonotonicCubicNaturalSpline') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- MonotonicCubicNaturalSpline___call____SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for MonotonicCubicNaturalSpline___call__ with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of MonotonicCubicNaturalSpline_derivative

`MonotonicCubicNaturalSpline_derivative__SWIG_0` = function(self, x, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_MonotonicCubicNaturalSpline_derivative__SWIG_0', self, x, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`MonotonicCubicNaturalSpline_derivative__SWIG_0`, 'returnType') = 'numeric'
attr(`MonotonicCubicNaturalSpline_derivative__SWIG_0`, "inputTypes") = c('_p_SafeMonotonicCubicNaturalSpline', 'numeric', 'logical')
class(`MonotonicCubicNaturalSpline_derivative__SWIG_0`) = c("SWIGFunction", class('MonotonicCubicNaturalSpline_derivative__SWIG_0'))

# Start of MonotonicCubicNaturalSpline_derivative

`MonotonicCubicNaturalSpline_derivative__SWIG_1` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_MonotonicCubicNaturalSpline_derivative__SWIG_1', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`MonotonicCubicNaturalSpline_derivative__SWIG_1`, 'returnType') = 'numeric'
attr(`MonotonicCubicNaturalSpline_derivative__SWIG_1`, "inputTypes") = c('_p_SafeMonotonicCubicNaturalSpline', 'numeric')
class(`MonotonicCubicNaturalSpline_derivative__SWIG_1`) = c("SWIGFunction", class('MonotonicCubicNaturalSpline_derivative__SWIG_1'))

`MonotonicCubicNaturalSpline_derivative` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_SafeMonotonicCubicNaturalSpline') && is.numeric(argv[[2]])) {
      f <- MonotonicCubicNaturalSpline_derivative__SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_SafeMonotonicCubicNaturalSpline') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- MonotonicCubicNaturalSpline_derivative__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for MonotonicCubicNaturalSpline_derivative with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of MonotonicCubicNaturalSpline_secondDerivative

`MonotonicCubicNaturalSpline_secondDerivative__SWIG_0` = function(self, x, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_MonotonicCubicNaturalSpline_secondDerivative__SWIG_0', self, x, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`MonotonicCubicNaturalSpline_secondDerivative__SWIG_0`, 'returnType') = 'numeric'
attr(`MonotonicCubicNaturalSpline_secondDerivative__SWIG_0`, "inputTypes") = c('_p_SafeMonotonicCubicNaturalSpline', 'numeric', 'logical')
class(`MonotonicCubicNaturalSpline_secondDerivative__SWIG_0`) = c("SWIGFunction", class('MonotonicCubicNaturalSpline_secondDerivative__SWIG_0'))

# Start of MonotonicCubicNaturalSpline_secondDerivative

`MonotonicCubicNaturalSpline_secondDerivative__SWIG_1` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_MonotonicCubicNaturalSpline_secondDerivative__SWIG_1', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`MonotonicCubicNaturalSpline_secondDerivative__SWIG_1`, 'returnType') = 'numeric'
attr(`MonotonicCubicNaturalSpline_secondDerivative__SWIG_1`, "inputTypes") = c('_p_SafeMonotonicCubicNaturalSpline', 'numeric')
class(`MonotonicCubicNaturalSpline_secondDerivative__SWIG_1`) = c("SWIGFunction", class('MonotonicCubicNaturalSpline_secondDerivative__SWIG_1'))

`MonotonicCubicNaturalSpline_secondDerivative` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_SafeMonotonicCubicNaturalSpline') && is.numeric(argv[[2]])) {
      f <- MonotonicCubicNaturalSpline_secondDerivative__SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_SafeMonotonicCubicNaturalSpline') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- MonotonicCubicNaturalSpline_secondDerivative__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for MonotonicCubicNaturalSpline_secondDerivative with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of MonotonicCubicNaturalSpline_primitive

`MonotonicCubicNaturalSpline_primitive__SWIG_0` = function(self, x, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_MonotonicCubicNaturalSpline_primitive__SWIG_0', self, x, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`MonotonicCubicNaturalSpline_primitive__SWIG_0`, 'returnType') = 'numeric'
attr(`MonotonicCubicNaturalSpline_primitive__SWIG_0`, "inputTypes") = c('_p_SafeMonotonicCubicNaturalSpline', 'numeric', 'logical')
class(`MonotonicCubicNaturalSpline_primitive__SWIG_0`) = c("SWIGFunction", class('MonotonicCubicNaturalSpline_primitive__SWIG_0'))

# Start of MonotonicCubicNaturalSpline_primitive

`MonotonicCubicNaturalSpline_primitive__SWIG_1` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_MonotonicCubicNaturalSpline_primitive__SWIG_1', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`MonotonicCubicNaturalSpline_primitive__SWIG_1`, 'returnType') = 'numeric'
attr(`MonotonicCubicNaturalSpline_primitive__SWIG_1`, "inputTypes") = c('_p_SafeMonotonicCubicNaturalSpline', 'numeric')
class(`MonotonicCubicNaturalSpline_primitive__SWIG_1`) = c("SWIGFunction", class('MonotonicCubicNaturalSpline_primitive__SWIG_1'))

`MonotonicCubicNaturalSpline_primitive` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_SafeMonotonicCubicNaturalSpline') && is.numeric(argv[[2]])) {
      f <- MonotonicCubicNaturalSpline_primitive__SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_SafeMonotonicCubicNaturalSpline') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- MonotonicCubicNaturalSpline_primitive__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for MonotonicCubicNaturalSpline_primitive with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_MonotonicCubicNaturalSpline

`delete_MonotonicCubicNaturalSpline` = function(self)
{
  ;.Call('R_swig_delete_MonotonicCubicNaturalSpline', self, PACKAGE='QuantLib');
  
}

attr(`delete_MonotonicCubicNaturalSpline`, 'returnType') = 'void'
attr(`delete_MonotonicCubicNaturalSpline`, "inputTypes") = c('_p_SafeMonotonicCubicNaturalSpline')
class(`delete_MonotonicCubicNaturalSpline`) = c("SWIGFunction", class('delete_MonotonicCubicNaturalSpline'))

# Start of accessor method for SafeMonotonicCubicNaturalSpline
setMethod('$', '_p_SafeMonotonicCubicNaturalSpline', function(x, name)

{
  accessorFuns = list('__call__' = MonotonicCubicNaturalSpline___call__, 'derivative' = MonotonicCubicNaturalSpline_derivative, 'secondDerivative' = MonotonicCubicNaturalSpline_secondDerivative, 'primitive' = MonotonicCubicNaturalSpline_primitive);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for SafeMonotonicCubicNaturalSpline
setMethod('delete', '_p_SafeMonotonicCubicNaturalSpline', function(obj) {delete_SafeMonotonicCubicNaturalSpline(obj)})
# Start of new_MonotonicLogCubicNaturalSpline

`MonotonicLogCubicNaturalSpline` = function(x, y)
{
  ;ans = .Call('R_swig_new_MonotonicLogCubicNaturalSpline', x, y, PACKAGE='QuantLib');
  class(ans) <- "_p_SafeMonotonicLogCubicNaturalSpline";
  
  reg.finalizer(ans, delete_MonotonicLogCubicNaturalSpline)
  ans
  
}

attr(`MonotonicLogCubicNaturalSpline`, 'returnType') = '_p_SafeMonotonicLogCubicNaturalSpline'
attr(`MonotonicLogCubicNaturalSpline`, "inputTypes") = c('_p_Array', '_p_Array')
class(`MonotonicLogCubicNaturalSpline`) = c("SWIGFunction", class('MonotonicLogCubicNaturalSpline'))

# Start of MonotonicLogCubicNaturalSpline___call__

`MonotonicLogCubicNaturalSpline___call____SWIG_0` = function(self, x, allowExtrapolation, .copy = FALSE)
{
  allowExtrapolation = as.logical(allowExtrapolation);
  ;.Call('R_swig_MonotonicLogCubicNaturalSpline___call____SWIG_0', self, x, allowExtrapolation, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`MonotonicLogCubicNaturalSpline___call____SWIG_0`, 'returnType') = 'numeric'
attr(`MonotonicLogCubicNaturalSpline___call____SWIG_0`, "inputTypes") = c('_p_SafeMonotonicLogCubicNaturalSpline', 'numeric', 'logical')
class(`MonotonicLogCubicNaturalSpline___call____SWIG_0`) = c("SWIGFunction", class('MonotonicLogCubicNaturalSpline___call____SWIG_0'))

# Start of MonotonicLogCubicNaturalSpline___call__

`MonotonicLogCubicNaturalSpline___call____SWIG_1` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_MonotonicLogCubicNaturalSpline___call____SWIG_1', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`MonotonicLogCubicNaturalSpline___call____SWIG_1`, 'returnType') = 'numeric'
attr(`MonotonicLogCubicNaturalSpline___call____SWIG_1`, "inputTypes") = c('_p_SafeMonotonicLogCubicNaturalSpline', 'numeric')
class(`MonotonicLogCubicNaturalSpline___call____SWIG_1`) = c("SWIGFunction", class('MonotonicLogCubicNaturalSpline___call____SWIG_1'))

`MonotonicLogCubicNaturalSpline___call__` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_SafeMonotonicLogCubicNaturalSpline') && is.numeric(argv[[2]])) {
      f <- MonotonicLogCubicNaturalSpline___call____SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_SafeMonotonicLogCubicNaturalSpline') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- MonotonicLogCubicNaturalSpline___call____SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for MonotonicLogCubicNaturalSpline___call__ with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of MonotonicLogCubicNaturalSpline_derivative

`MonotonicLogCubicNaturalSpline_derivative__SWIG_0` = function(self, x, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_MonotonicLogCubicNaturalSpline_derivative__SWIG_0', self, x, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`MonotonicLogCubicNaturalSpline_derivative__SWIG_0`, 'returnType') = 'numeric'
attr(`MonotonicLogCubicNaturalSpline_derivative__SWIG_0`, "inputTypes") = c('_p_SafeMonotonicLogCubicNaturalSpline', 'numeric', 'logical')
class(`MonotonicLogCubicNaturalSpline_derivative__SWIG_0`) = c("SWIGFunction", class('MonotonicLogCubicNaturalSpline_derivative__SWIG_0'))

# Start of MonotonicLogCubicNaturalSpline_derivative

`MonotonicLogCubicNaturalSpline_derivative__SWIG_1` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_MonotonicLogCubicNaturalSpline_derivative__SWIG_1', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`MonotonicLogCubicNaturalSpline_derivative__SWIG_1`, 'returnType') = 'numeric'
attr(`MonotonicLogCubicNaturalSpline_derivative__SWIG_1`, "inputTypes") = c('_p_SafeMonotonicLogCubicNaturalSpline', 'numeric')
class(`MonotonicLogCubicNaturalSpline_derivative__SWIG_1`) = c("SWIGFunction", class('MonotonicLogCubicNaturalSpline_derivative__SWIG_1'))

`MonotonicLogCubicNaturalSpline_derivative` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_SafeMonotonicLogCubicNaturalSpline') && is.numeric(argv[[2]])) {
      f <- MonotonicLogCubicNaturalSpline_derivative__SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_SafeMonotonicLogCubicNaturalSpline') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- MonotonicLogCubicNaturalSpline_derivative__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for MonotonicLogCubicNaturalSpline_derivative with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of MonotonicLogCubicNaturalSpline_secondDerivative

`MonotonicLogCubicNaturalSpline_secondDerivative__SWIG_0` = function(self, x, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_MonotonicLogCubicNaturalSpline_secondDerivative__SWIG_0', self, x, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`MonotonicLogCubicNaturalSpline_secondDerivative__SWIG_0`, 'returnType') = 'numeric'
attr(`MonotonicLogCubicNaturalSpline_secondDerivative__SWIG_0`, "inputTypes") = c('_p_SafeMonotonicLogCubicNaturalSpline', 'numeric', 'logical')
class(`MonotonicLogCubicNaturalSpline_secondDerivative__SWIG_0`) = c("SWIGFunction", class('MonotonicLogCubicNaturalSpline_secondDerivative__SWIG_0'))

# Start of MonotonicLogCubicNaturalSpline_secondDerivative

`MonotonicLogCubicNaturalSpline_secondDerivative__SWIG_1` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_MonotonicLogCubicNaturalSpline_secondDerivative__SWIG_1', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`MonotonicLogCubicNaturalSpline_secondDerivative__SWIG_1`, 'returnType') = 'numeric'
attr(`MonotonicLogCubicNaturalSpline_secondDerivative__SWIG_1`, "inputTypes") = c('_p_SafeMonotonicLogCubicNaturalSpline', 'numeric')
class(`MonotonicLogCubicNaturalSpline_secondDerivative__SWIG_1`) = c("SWIGFunction", class('MonotonicLogCubicNaturalSpline_secondDerivative__SWIG_1'))

`MonotonicLogCubicNaturalSpline_secondDerivative` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_SafeMonotonicLogCubicNaturalSpline') && is.numeric(argv[[2]])) {
      f <- MonotonicLogCubicNaturalSpline_secondDerivative__SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_SafeMonotonicLogCubicNaturalSpline') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- MonotonicLogCubicNaturalSpline_secondDerivative__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for MonotonicLogCubicNaturalSpline_secondDerivative with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of MonotonicLogCubicNaturalSpline_primitive

`MonotonicLogCubicNaturalSpline_primitive__SWIG_0` = function(self, x, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_MonotonicLogCubicNaturalSpline_primitive__SWIG_0', self, x, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`MonotonicLogCubicNaturalSpline_primitive__SWIG_0`, 'returnType') = 'numeric'
attr(`MonotonicLogCubicNaturalSpline_primitive__SWIG_0`, "inputTypes") = c('_p_SafeMonotonicLogCubicNaturalSpline', 'numeric', 'logical')
class(`MonotonicLogCubicNaturalSpline_primitive__SWIG_0`) = c("SWIGFunction", class('MonotonicLogCubicNaturalSpline_primitive__SWIG_0'))

# Start of MonotonicLogCubicNaturalSpline_primitive

`MonotonicLogCubicNaturalSpline_primitive__SWIG_1` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_MonotonicLogCubicNaturalSpline_primitive__SWIG_1', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`MonotonicLogCubicNaturalSpline_primitive__SWIG_1`, 'returnType') = 'numeric'
attr(`MonotonicLogCubicNaturalSpline_primitive__SWIG_1`, "inputTypes") = c('_p_SafeMonotonicLogCubicNaturalSpline', 'numeric')
class(`MonotonicLogCubicNaturalSpline_primitive__SWIG_1`) = c("SWIGFunction", class('MonotonicLogCubicNaturalSpline_primitive__SWIG_1'))

`MonotonicLogCubicNaturalSpline_primitive` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_SafeMonotonicLogCubicNaturalSpline') && is.numeric(argv[[2]])) {
      f <- MonotonicLogCubicNaturalSpline_primitive__SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_SafeMonotonicLogCubicNaturalSpline') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- MonotonicLogCubicNaturalSpline_primitive__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for MonotonicLogCubicNaturalSpline_primitive with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_MonotonicLogCubicNaturalSpline

`delete_MonotonicLogCubicNaturalSpline` = function(self)
{
  ;.Call('R_swig_delete_MonotonicLogCubicNaturalSpline', self, PACKAGE='QuantLib');
  
}

attr(`delete_MonotonicLogCubicNaturalSpline`, 'returnType') = 'void'
attr(`delete_MonotonicLogCubicNaturalSpline`, "inputTypes") = c('_p_SafeMonotonicLogCubicNaturalSpline')
class(`delete_MonotonicLogCubicNaturalSpline`) = c("SWIGFunction", class('delete_MonotonicLogCubicNaturalSpline'))

# Start of accessor method for SafeMonotonicLogCubicNaturalSpline
setMethod('$', '_p_SafeMonotonicLogCubicNaturalSpline', function(x, name)

{
  accessorFuns = list('__call__' = MonotonicLogCubicNaturalSpline___call__, 'derivative' = MonotonicLogCubicNaturalSpline_derivative, 'secondDerivative' = MonotonicLogCubicNaturalSpline_secondDerivative, 'primitive' = MonotonicLogCubicNaturalSpline_primitive);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for SafeMonotonicLogCubicNaturalSpline
setMethod('delete', '_p_SafeMonotonicLogCubicNaturalSpline', function(obj) {delete_SafeMonotonicLogCubicNaturalSpline(obj)})
# Start of new_KrugerCubic

`KrugerCubic` = function(x, y)
{
  ;ans = .Call('R_swig_new_KrugerCubic', x, y, PACKAGE='QuantLib');
  class(ans) <- "_p_SafeKrugerCubic";
  
  reg.finalizer(ans, delete_KrugerCubic)
  ans
  
}

attr(`KrugerCubic`, 'returnType') = '_p_SafeKrugerCubic'
attr(`KrugerCubic`, "inputTypes") = c('_p_Array', '_p_Array')
class(`KrugerCubic`) = c("SWIGFunction", class('KrugerCubic'))

# Start of KrugerCubic___call__

`KrugerCubic___call____SWIG_0` = function(self, x, allowExtrapolation, .copy = FALSE)
{
  allowExtrapolation = as.logical(allowExtrapolation);
  ;.Call('R_swig_KrugerCubic___call____SWIG_0', self, x, allowExtrapolation, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`KrugerCubic___call____SWIG_0`, 'returnType') = 'numeric'
attr(`KrugerCubic___call____SWIG_0`, "inputTypes") = c('_p_SafeKrugerCubic', 'numeric', 'logical')
class(`KrugerCubic___call____SWIG_0`) = c("SWIGFunction", class('KrugerCubic___call____SWIG_0'))

# Start of KrugerCubic___call__

`KrugerCubic___call____SWIG_1` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_KrugerCubic___call____SWIG_1', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`KrugerCubic___call____SWIG_1`, 'returnType') = 'numeric'
attr(`KrugerCubic___call____SWIG_1`, "inputTypes") = c('_p_SafeKrugerCubic', 'numeric')
class(`KrugerCubic___call____SWIG_1`) = c("SWIGFunction", class('KrugerCubic___call____SWIG_1'))

`KrugerCubic___call__` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_SafeKrugerCubic') && is.numeric(argv[[2]])) {
      f <- KrugerCubic___call____SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_SafeKrugerCubic') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- KrugerCubic___call____SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for KrugerCubic___call__ with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of KrugerCubic_derivative

`KrugerCubic_derivative__SWIG_0` = function(self, x, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_KrugerCubic_derivative__SWIG_0', self, x, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`KrugerCubic_derivative__SWIG_0`, 'returnType') = 'numeric'
attr(`KrugerCubic_derivative__SWIG_0`, "inputTypes") = c('_p_SafeKrugerCubic', 'numeric', 'logical')
class(`KrugerCubic_derivative__SWIG_0`) = c("SWIGFunction", class('KrugerCubic_derivative__SWIG_0'))

# Start of KrugerCubic_derivative

`KrugerCubic_derivative__SWIG_1` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_KrugerCubic_derivative__SWIG_1', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`KrugerCubic_derivative__SWIG_1`, 'returnType') = 'numeric'
attr(`KrugerCubic_derivative__SWIG_1`, "inputTypes") = c('_p_SafeKrugerCubic', 'numeric')
class(`KrugerCubic_derivative__SWIG_1`) = c("SWIGFunction", class('KrugerCubic_derivative__SWIG_1'))

`KrugerCubic_derivative` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_SafeKrugerCubic') && is.numeric(argv[[2]])) {
      f <- KrugerCubic_derivative__SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_SafeKrugerCubic') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- KrugerCubic_derivative__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for KrugerCubic_derivative with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of KrugerCubic_secondDerivative

`KrugerCubic_secondDerivative__SWIG_0` = function(self, x, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_KrugerCubic_secondDerivative__SWIG_0', self, x, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`KrugerCubic_secondDerivative__SWIG_0`, 'returnType') = 'numeric'
attr(`KrugerCubic_secondDerivative__SWIG_0`, "inputTypes") = c('_p_SafeKrugerCubic', 'numeric', 'logical')
class(`KrugerCubic_secondDerivative__SWIG_0`) = c("SWIGFunction", class('KrugerCubic_secondDerivative__SWIG_0'))

# Start of KrugerCubic_secondDerivative

`KrugerCubic_secondDerivative__SWIG_1` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_KrugerCubic_secondDerivative__SWIG_1', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`KrugerCubic_secondDerivative__SWIG_1`, 'returnType') = 'numeric'
attr(`KrugerCubic_secondDerivative__SWIG_1`, "inputTypes") = c('_p_SafeKrugerCubic', 'numeric')
class(`KrugerCubic_secondDerivative__SWIG_1`) = c("SWIGFunction", class('KrugerCubic_secondDerivative__SWIG_1'))

`KrugerCubic_secondDerivative` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_SafeKrugerCubic') && is.numeric(argv[[2]])) {
      f <- KrugerCubic_secondDerivative__SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_SafeKrugerCubic') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- KrugerCubic_secondDerivative__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for KrugerCubic_secondDerivative with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of KrugerCubic_primitive

`KrugerCubic_primitive__SWIG_0` = function(self, x, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_KrugerCubic_primitive__SWIG_0', self, x, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`KrugerCubic_primitive__SWIG_0`, 'returnType') = 'numeric'
attr(`KrugerCubic_primitive__SWIG_0`, "inputTypes") = c('_p_SafeKrugerCubic', 'numeric', 'logical')
class(`KrugerCubic_primitive__SWIG_0`) = c("SWIGFunction", class('KrugerCubic_primitive__SWIG_0'))

# Start of KrugerCubic_primitive

`KrugerCubic_primitive__SWIG_1` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_KrugerCubic_primitive__SWIG_1', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`KrugerCubic_primitive__SWIG_1`, 'returnType') = 'numeric'
attr(`KrugerCubic_primitive__SWIG_1`, "inputTypes") = c('_p_SafeKrugerCubic', 'numeric')
class(`KrugerCubic_primitive__SWIG_1`) = c("SWIGFunction", class('KrugerCubic_primitive__SWIG_1'))

`KrugerCubic_primitive` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_SafeKrugerCubic') && is.numeric(argv[[2]])) {
      f <- KrugerCubic_primitive__SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_SafeKrugerCubic') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- KrugerCubic_primitive__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for KrugerCubic_primitive with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_KrugerCubic

`delete_KrugerCubic` = function(self)
{
  ;.Call('R_swig_delete_KrugerCubic', self, PACKAGE='QuantLib');
  
}

attr(`delete_KrugerCubic`, 'returnType') = 'void'
attr(`delete_KrugerCubic`, "inputTypes") = c('_p_SafeKrugerCubic')
class(`delete_KrugerCubic`) = c("SWIGFunction", class('delete_KrugerCubic'))

# Start of accessor method for SafeKrugerCubic
setMethod('$', '_p_SafeKrugerCubic', function(x, name)

{
  accessorFuns = list('__call__' = KrugerCubic___call__, 'derivative' = KrugerCubic_derivative, 'secondDerivative' = KrugerCubic_secondDerivative, 'primitive' = KrugerCubic_primitive);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for SafeKrugerCubic
setMethod('delete', '_p_SafeKrugerCubic', function(obj) {delete_SafeKrugerCubic(obj)})
# Start of new_KrugerLogCubic

`KrugerLogCubic` = function(x, y)
{
  ;ans = .Call('R_swig_new_KrugerLogCubic', x, y, PACKAGE='QuantLib');
  class(ans) <- "_p_SafeKrugerLogCubic";
  
  reg.finalizer(ans, delete_KrugerLogCubic)
  ans
  
}

attr(`KrugerLogCubic`, 'returnType') = '_p_SafeKrugerLogCubic'
attr(`KrugerLogCubic`, "inputTypes") = c('_p_Array', '_p_Array')
class(`KrugerLogCubic`) = c("SWIGFunction", class('KrugerLogCubic'))

# Start of KrugerLogCubic___call__

`KrugerLogCubic___call____SWIG_0` = function(self, x, allowExtrapolation, .copy = FALSE)
{
  allowExtrapolation = as.logical(allowExtrapolation);
  ;.Call('R_swig_KrugerLogCubic___call____SWIG_0', self, x, allowExtrapolation, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`KrugerLogCubic___call____SWIG_0`, 'returnType') = 'numeric'
attr(`KrugerLogCubic___call____SWIG_0`, "inputTypes") = c('_p_SafeKrugerLogCubic', 'numeric', 'logical')
class(`KrugerLogCubic___call____SWIG_0`) = c("SWIGFunction", class('KrugerLogCubic___call____SWIG_0'))

# Start of KrugerLogCubic___call__

`KrugerLogCubic___call____SWIG_1` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_KrugerLogCubic___call____SWIG_1', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`KrugerLogCubic___call____SWIG_1`, 'returnType') = 'numeric'
attr(`KrugerLogCubic___call____SWIG_1`, "inputTypes") = c('_p_SafeKrugerLogCubic', 'numeric')
class(`KrugerLogCubic___call____SWIG_1`) = c("SWIGFunction", class('KrugerLogCubic___call____SWIG_1'))

`KrugerLogCubic___call__` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_SafeKrugerLogCubic') && is.numeric(argv[[2]])) {
      f <- KrugerLogCubic___call____SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_SafeKrugerLogCubic') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- KrugerLogCubic___call____SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for KrugerLogCubic___call__ with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of KrugerLogCubic_derivative

`KrugerLogCubic_derivative__SWIG_0` = function(self, x, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_KrugerLogCubic_derivative__SWIG_0', self, x, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`KrugerLogCubic_derivative__SWIG_0`, 'returnType') = 'numeric'
attr(`KrugerLogCubic_derivative__SWIG_0`, "inputTypes") = c('_p_SafeKrugerLogCubic', 'numeric', 'logical')
class(`KrugerLogCubic_derivative__SWIG_0`) = c("SWIGFunction", class('KrugerLogCubic_derivative__SWIG_0'))

# Start of KrugerLogCubic_derivative

`KrugerLogCubic_derivative__SWIG_1` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_KrugerLogCubic_derivative__SWIG_1', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`KrugerLogCubic_derivative__SWIG_1`, 'returnType') = 'numeric'
attr(`KrugerLogCubic_derivative__SWIG_1`, "inputTypes") = c('_p_SafeKrugerLogCubic', 'numeric')
class(`KrugerLogCubic_derivative__SWIG_1`) = c("SWIGFunction", class('KrugerLogCubic_derivative__SWIG_1'))

`KrugerLogCubic_derivative` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_SafeKrugerLogCubic') && is.numeric(argv[[2]])) {
      f <- KrugerLogCubic_derivative__SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_SafeKrugerLogCubic') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- KrugerLogCubic_derivative__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for KrugerLogCubic_derivative with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of KrugerLogCubic_secondDerivative

`KrugerLogCubic_secondDerivative__SWIG_0` = function(self, x, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_KrugerLogCubic_secondDerivative__SWIG_0', self, x, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`KrugerLogCubic_secondDerivative__SWIG_0`, 'returnType') = 'numeric'
attr(`KrugerLogCubic_secondDerivative__SWIG_0`, "inputTypes") = c('_p_SafeKrugerLogCubic', 'numeric', 'logical')
class(`KrugerLogCubic_secondDerivative__SWIG_0`) = c("SWIGFunction", class('KrugerLogCubic_secondDerivative__SWIG_0'))

# Start of KrugerLogCubic_secondDerivative

`KrugerLogCubic_secondDerivative__SWIG_1` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_KrugerLogCubic_secondDerivative__SWIG_1', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`KrugerLogCubic_secondDerivative__SWIG_1`, 'returnType') = 'numeric'
attr(`KrugerLogCubic_secondDerivative__SWIG_1`, "inputTypes") = c('_p_SafeKrugerLogCubic', 'numeric')
class(`KrugerLogCubic_secondDerivative__SWIG_1`) = c("SWIGFunction", class('KrugerLogCubic_secondDerivative__SWIG_1'))

`KrugerLogCubic_secondDerivative` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_SafeKrugerLogCubic') && is.numeric(argv[[2]])) {
      f <- KrugerLogCubic_secondDerivative__SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_SafeKrugerLogCubic') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- KrugerLogCubic_secondDerivative__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for KrugerLogCubic_secondDerivative with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of KrugerLogCubic_primitive

`KrugerLogCubic_primitive__SWIG_0` = function(self, x, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_KrugerLogCubic_primitive__SWIG_0', self, x, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`KrugerLogCubic_primitive__SWIG_0`, 'returnType') = 'numeric'
attr(`KrugerLogCubic_primitive__SWIG_0`, "inputTypes") = c('_p_SafeKrugerLogCubic', 'numeric', 'logical')
class(`KrugerLogCubic_primitive__SWIG_0`) = c("SWIGFunction", class('KrugerLogCubic_primitive__SWIG_0'))

# Start of KrugerLogCubic_primitive

`KrugerLogCubic_primitive__SWIG_1` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_KrugerLogCubic_primitive__SWIG_1', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`KrugerLogCubic_primitive__SWIG_1`, 'returnType') = 'numeric'
attr(`KrugerLogCubic_primitive__SWIG_1`, "inputTypes") = c('_p_SafeKrugerLogCubic', 'numeric')
class(`KrugerLogCubic_primitive__SWIG_1`) = c("SWIGFunction", class('KrugerLogCubic_primitive__SWIG_1'))

`KrugerLogCubic_primitive` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_SafeKrugerLogCubic') && is.numeric(argv[[2]])) {
      f <- KrugerLogCubic_primitive__SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_SafeKrugerLogCubic') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- KrugerLogCubic_primitive__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for KrugerLogCubic_primitive with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_KrugerLogCubic

`delete_KrugerLogCubic` = function(self)
{
  ;.Call('R_swig_delete_KrugerLogCubic', self, PACKAGE='QuantLib');
  
}

attr(`delete_KrugerLogCubic`, 'returnType') = 'void'
attr(`delete_KrugerLogCubic`, "inputTypes") = c('_p_SafeKrugerLogCubic')
class(`delete_KrugerLogCubic`) = c("SWIGFunction", class('delete_KrugerLogCubic'))

# Start of accessor method for SafeKrugerLogCubic
setMethod('$', '_p_SafeKrugerLogCubic', function(x, name)

{
  accessorFuns = list('__call__' = KrugerLogCubic___call__, 'derivative' = KrugerLogCubic_derivative, 'secondDerivative' = KrugerLogCubic_secondDerivative, 'primitive' = KrugerLogCubic_primitive);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for SafeKrugerLogCubic
setMethod('delete', '_p_SafeKrugerLogCubic', function(obj) {delete_SafeKrugerLogCubic(obj)})
# Start of new_FritschButlandCubic

`FritschButlandCubic` = function(x, y)
{
  ;ans = .Call('R_swig_new_FritschButlandCubic', x, y, PACKAGE='QuantLib');
  class(ans) <- "_p_SafeFritschButlandCubic";
  
  reg.finalizer(ans, delete_FritschButlandCubic)
  ans
  
}

attr(`FritschButlandCubic`, 'returnType') = '_p_SafeFritschButlandCubic'
attr(`FritschButlandCubic`, "inputTypes") = c('_p_Array', '_p_Array')
class(`FritschButlandCubic`) = c("SWIGFunction", class('FritschButlandCubic'))

# Start of FritschButlandCubic___call__

`FritschButlandCubic___call____SWIG_0` = function(self, x, allowExtrapolation, .copy = FALSE)
{
  allowExtrapolation = as.logical(allowExtrapolation);
  ;.Call('R_swig_FritschButlandCubic___call____SWIG_0', self, x, allowExtrapolation, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`FritschButlandCubic___call____SWIG_0`, 'returnType') = 'numeric'
attr(`FritschButlandCubic___call____SWIG_0`, "inputTypes") = c('_p_SafeFritschButlandCubic', 'numeric', 'logical')
class(`FritschButlandCubic___call____SWIG_0`) = c("SWIGFunction", class('FritschButlandCubic___call____SWIG_0'))

# Start of FritschButlandCubic___call__

`FritschButlandCubic___call____SWIG_1` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_FritschButlandCubic___call____SWIG_1', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`FritschButlandCubic___call____SWIG_1`, 'returnType') = 'numeric'
attr(`FritschButlandCubic___call____SWIG_1`, "inputTypes") = c('_p_SafeFritschButlandCubic', 'numeric')
class(`FritschButlandCubic___call____SWIG_1`) = c("SWIGFunction", class('FritschButlandCubic___call____SWIG_1'))

`FritschButlandCubic___call__` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_SafeFritschButlandCubic') && is.numeric(argv[[2]])) {
      f <- FritschButlandCubic___call____SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_SafeFritschButlandCubic') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- FritschButlandCubic___call____SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for FritschButlandCubic___call__ with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of FritschButlandCubic_derivative

`FritschButlandCubic_derivative__SWIG_0` = function(self, x, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_FritschButlandCubic_derivative__SWIG_0', self, x, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`FritschButlandCubic_derivative__SWIG_0`, 'returnType') = 'numeric'
attr(`FritschButlandCubic_derivative__SWIG_0`, "inputTypes") = c('_p_SafeFritschButlandCubic', 'numeric', 'logical')
class(`FritschButlandCubic_derivative__SWIG_0`) = c("SWIGFunction", class('FritschButlandCubic_derivative__SWIG_0'))

# Start of FritschButlandCubic_derivative

`FritschButlandCubic_derivative__SWIG_1` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_FritschButlandCubic_derivative__SWIG_1', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`FritschButlandCubic_derivative__SWIG_1`, 'returnType') = 'numeric'
attr(`FritschButlandCubic_derivative__SWIG_1`, "inputTypes") = c('_p_SafeFritschButlandCubic', 'numeric')
class(`FritschButlandCubic_derivative__SWIG_1`) = c("SWIGFunction", class('FritschButlandCubic_derivative__SWIG_1'))

`FritschButlandCubic_derivative` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_SafeFritschButlandCubic') && is.numeric(argv[[2]])) {
      f <- FritschButlandCubic_derivative__SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_SafeFritschButlandCubic') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- FritschButlandCubic_derivative__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for FritschButlandCubic_derivative with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of FritschButlandCubic_secondDerivative

`FritschButlandCubic_secondDerivative__SWIG_0` = function(self, x, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_FritschButlandCubic_secondDerivative__SWIG_0', self, x, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`FritschButlandCubic_secondDerivative__SWIG_0`, 'returnType') = 'numeric'
attr(`FritschButlandCubic_secondDerivative__SWIG_0`, "inputTypes") = c('_p_SafeFritschButlandCubic', 'numeric', 'logical')
class(`FritschButlandCubic_secondDerivative__SWIG_0`) = c("SWIGFunction", class('FritschButlandCubic_secondDerivative__SWIG_0'))

# Start of FritschButlandCubic_secondDerivative

`FritschButlandCubic_secondDerivative__SWIG_1` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_FritschButlandCubic_secondDerivative__SWIG_1', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`FritschButlandCubic_secondDerivative__SWIG_1`, 'returnType') = 'numeric'
attr(`FritschButlandCubic_secondDerivative__SWIG_1`, "inputTypes") = c('_p_SafeFritschButlandCubic', 'numeric')
class(`FritschButlandCubic_secondDerivative__SWIG_1`) = c("SWIGFunction", class('FritschButlandCubic_secondDerivative__SWIG_1'))

`FritschButlandCubic_secondDerivative` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_SafeFritschButlandCubic') && is.numeric(argv[[2]])) {
      f <- FritschButlandCubic_secondDerivative__SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_SafeFritschButlandCubic') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- FritschButlandCubic_secondDerivative__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for FritschButlandCubic_secondDerivative with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of FritschButlandCubic_primitive

`FritschButlandCubic_primitive__SWIG_0` = function(self, x, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_FritschButlandCubic_primitive__SWIG_0', self, x, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`FritschButlandCubic_primitive__SWIG_0`, 'returnType') = 'numeric'
attr(`FritschButlandCubic_primitive__SWIG_0`, "inputTypes") = c('_p_SafeFritschButlandCubic', 'numeric', 'logical')
class(`FritschButlandCubic_primitive__SWIG_0`) = c("SWIGFunction", class('FritschButlandCubic_primitive__SWIG_0'))

# Start of FritschButlandCubic_primitive

`FritschButlandCubic_primitive__SWIG_1` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_FritschButlandCubic_primitive__SWIG_1', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`FritschButlandCubic_primitive__SWIG_1`, 'returnType') = 'numeric'
attr(`FritschButlandCubic_primitive__SWIG_1`, "inputTypes") = c('_p_SafeFritschButlandCubic', 'numeric')
class(`FritschButlandCubic_primitive__SWIG_1`) = c("SWIGFunction", class('FritschButlandCubic_primitive__SWIG_1'))

`FritschButlandCubic_primitive` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_SafeFritschButlandCubic') && is.numeric(argv[[2]])) {
      f <- FritschButlandCubic_primitive__SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_SafeFritschButlandCubic') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- FritschButlandCubic_primitive__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for FritschButlandCubic_primitive with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_FritschButlandCubic

`delete_FritschButlandCubic` = function(self)
{
  ;.Call('R_swig_delete_FritschButlandCubic', self, PACKAGE='QuantLib');
  
}

attr(`delete_FritschButlandCubic`, 'returnType') = 'void'
attr(`delete_FritschButlandCubic`, "inputTypes") = c('_p_SafeFritschButlandCubic')
class(`delete_FritschButlandCubic`) = c("SWIGFunction", class('delete_FritschButlandCubic'))

# Start of accessor method for SafeFritschButlandCubic
setMethod('$', '_p_SafeFritschButlandCubic', function(x, name)

{
  accessorFuns = list('__call__' = FritschButlandCubic___call__, 'derivative' = FritschButlandCubic_derivative, 'secondDerivative' = FritschButlandCubic_secondDerivative, 'primitive' = FritschButlandCubic_primitive);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for SafeFritschButlandCubic
setMethod('delete', '_p_SafeFritschButlandCubic', function(obj) {delete_SafeFritschButlandCubic(obj)})
# Start of new_FritschButlandLogCubic

`FritschButlandLogCubic` = function(x, y)
{
  ;ans = .Call('R_swig_new_FritschButlandLogCubic', x, y, PACKAGE='QuantLib');
  class(ans) <- "_p_SafeFritschButlandLogCubic";
  
  reg.finalizer(ans, delete_FritschButlandLogCubic)
  ans
  
}

attr(`FritschButlandLogCubic`, 'returnType') = '_p_SafeFritschButlandLogCubic'
attr(`FritschButlandLogCubic`, "inputTypes") = c('_p_Array', '_p_Array')
class(`FritschButlandLogCubic`) = c("SWIGFunction", class('FritschButlandLogCubic'))

# Start of FritschButlandLogCubic___call__

`FritschButlandLogCubic___call____SWIG_0` = function(self, x, allowExtrapolation, .copy = FALSE)
{
  allowExtrapolation = as.logical(allowExtrapolation);
  ;.Call('R_swig_FritschButlandLogCubic___call____SWIG_0', self, x, allowExtrapolation, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`FritschButlandLogCubic___call____SWIG_0`, 'returnType') = 'numeric'
attr(`FritschButlandLogCubic___call____SWIG_0`, "inputTypes") = c('_p_SafeFritschButlandLogCubic', 'numeric', 'logical')
class(`FritschButlandLogCubic___call____SWIG_0`) = c("SWIGFunction", class('FritschButlandLogCubic___call____SWIG_0'))

# Start of FritschButlandLogCubic___call__

`FritschButlandLogCubic___call____SWIG_1` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_FritschButlandLogCubic___call____SWIG_1', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`FritschButlandLogCubic___call____SWIG_1`, 'returnType') = 'numeric'
attr(`FritschButlandLogCubic___call____SWIG_1`, "inputTypes") = c('_p_SafeFritschButlandLogCubic', 'numeric')
class(`FritschButlandLogCubic___call____SWIG_1`) = c("SWIGFunction", class('FritschButlandLogCubic___call____SWIG_1'))

`FritschButlandLogCubic___call__` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_SafeFritschButlandLogCubic') && is.numeric(argv[[2]])) {
      f <- FritschButlandLogCubic___call____SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_SafeFritschButlandLogCubic') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- FritschButlandLogCubic___call____SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for FritschButlandLogCubic___call__ with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of FritschButlandLogCubic_derivative

`FritschButlandLogCubic_derivative__SWIG_0` = function(self, x, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_FritschButlandLogCubic_derivative__SWIG_0', self, x, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`FritschButlandLogCubic_derivative__SWIG_0`, 'returnType') = 'numeric'
attr(`FritschButlandLogCubic_derivative__SWIG_0`, "inputTypes") = c('_p_SafeFritschButlandLogCubic', 'numeric', 'logical')
class(`FritschButlandLogCubic_derivative__SWIG_0`) = c("SWIGFunction", class('FritschButlandLogCubic_derivative__SWIG_0'))

# Start of FritschButlandLogCubic_derivative

`FritschButlandLogCubic_derivative__SWIG_1` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_FritschButlandLogCubic_derivative__SWIG_1', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`FritschButlandLogCubic_derivative__SWIG_1`, 'returnType') = 'numeric'
attr(`FritschButlandLogCubic_derivative__SWIG_1`, "inputTypes") = c('_p_SafeFritschButlandLogCubic', 'numeric')
class(`FritschButlandLogCubic_derivative__SWIG_1`) = c("SWIGFunction", class('FritschButlandLogCubic_derivative__SWIG_1'))

`FritschButlandLogCubic_derivative` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_SafeFritschButlandLogCubic') && is.numeric(argv[[2]])) {
      f <- FritschButlandLogCubic_derivative__SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_SafeFritschButlandLogCubic') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- FritschButlandLogCubic_derivative__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for FritschButlandLogCubic_derivative with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of FritschButlandLogCubic_secondDerivative

`FritschButlandLogCubic_secondDerivative__SWIG_0` = function(self, x, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_FritschButlandLogCubic_secondDerivative__SWIG_0', self, x, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`FritschButlandLogCubic_secondDerivative__SWIG_0`, 'returnType') = 'numeric'
attr(`FritschButlandLogCubic_secondDerivative__SWIG_0`, "inputTypes") = c('_p_SafeFritschButlandLogCubic', 'numeric', 'logical')
class(`FritschButlandLogCubic_secondDerivative__SWIG_0`) = c("SWIGFunction", class('FritschButlandLogCubic_secondDerivative__SWIG_0'))

# Start of FritschButlandLogCubic_secondDerivative

`FritschButlandLogCubic_secondDerivative__SWIG_1` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_FritschButlandLogCubic_secondDerivative__SWIG_1', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`FritschButlandLogCubic_secondDerivative__SWIG_1`, 'returnType') = 'numeric'
attr(`FritschButlandLogCubic_secondDerivative__SWIG_1`, "inputTypes") = c('_p_SafeFritschButlandLogCubic', 'numeric')
class(`FritschButlandLogCubic_secondDerivative__SWIG_1`) = c("SWIGFunction", class('FritschButlandLogCubic_secondDerivative__SWIG_1'))

`FritschButlandLogCubic_secondDerivative` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_SafeFritschButlandLogCubic') && is.numeric(argv[[2]])) {
      f <- FritschButlandLogCubic_secondDerivative__SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_SafeFritschButlandLogCubic') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- FritschButlandLogCubic_secondDerivative__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for FritschButlandLogCubic_secondDerivative with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of FritschButlandLogCubic_primitive

`FritschButlandLogCubic_primitive__SWIG_0` = function(self, x, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_FritschButlandLogCubic_primitive__SWIG_0', self, x, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`FritschButlandLogCubic_primitive__SWIG_0`, 'returnType') = 'numeric'
attr(`FritschButlandLogCubic_primitive__SWIG_0`, "inputTypes") = c('_p_SafeFritschButlandLogCubic', 'numeric', 'logical')
class(`FritschButlandLogCubic_primitive__SWIG_0`) = c("SWIGFunction", class('FritschButlandLogCubic_primitive__SWIG_0'))

# Start of FritschButlandLogCubic_primitive

`FritschButlandLogCubic_primitive__SWIG_1` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_FritschButlandLogCubic_primitive__SWIG_1', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`FritschButlandLogCubic_primitive__SWIG_1`, 'returnType') = 'numeric'
attr(`FritschButlandLogCubic_primitive__SWIG_1`, "inputTypes") = c('_p_SafeFritschButlandLogCubic', 'numeric')
class(`FritschButlandLogCubic_primitive__SWIG_1`) = c("SWIGFunction", class('FritschButlandLogCubic_primitive__SWIG_1'))

`FritschButlandLogCubic_primitive` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_SafeFritschButlandLogCubic') && is.numeric(argv[[2]])) {
      f <- FritschButlandLogCubic_primitive__SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_SafeFritschButlandLogCubic') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- FritschButlandLogCubic_primitive__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for FritschButlandLogCubic_primitive with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_FritschButlandLogCubic

`delete_FritschButlandLogCubic` = function(self)
{
  ;.Call('R_swig_delete_FritschButlandLogCubic', self, PACKAGE='QuantLib');
  
}

attr(`delete_FritschButlandLogCubic`, 'returnType') = 'void'
attr(`delete_FritschButlandLogCubic`, "inputTypes") = c('_p_SafeFritschButlandLogCubic')
class(`delete_FritschButlandLogCubic`) = c("SWIGFunction", class('delete_FritschButlandLogCubic'))

# Start of accessor method for SafeFritschButlandLogCubic
setMethod('$', '_p_SafeFritschButlandLogCubic', function(x, name)

{
  accessorFuns = list('__call__' = FritschButlandLogCubic___call__, 'derivative' = FritschButlandLogCubic_derivative, 'secondDerivative' = FritschButlandLogCubic_secondDerivative, 'primitive' = FritschButlandLogCubic_primitive);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for SafeFritschButlandLogCubic
setMethod('delete', '_p_SafeFritschButlandLogCubic', function(obj) {delete_SafeFritschButlandLogCubic(obj)})
# Start of new_Parabolic

`Parabolic` = function(x, y)
{
  ;ans = .Call('R_swig_new_Parabolic', x, y, PACKAGE='QuantLib');
  class(ans) <- "_p_SafeParabolic";
  
  reg.finalizer(ans, delete_Parabolic)
  ans
  
}

attr(`Parabolic`, 'returnType') = '_p_SafeParabolic'
attr(`Parabolic`, "inputTypes") = c('_p_Array', '_p_Array')
class(`Parabolic`) = c("SWIGFunction", class('Parabolic'))

# Start of Parabolic___call__

`Parabolic___call____SWIG_0` = function(self, x, allowExtrapolation, .copy = FALSE)
{
  allowExtrapolation = as.logical(allowExtrapolation);
  ;.Call('R_swig_Parabolic___call____SWIG_0', self, x, allowExtrapolation, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Parabolic___call____SWIG_0`, 'returnType') = 'numeric'
attr(`Parabolic___call____SWIG_0`, "inputTypes") = c('_p_SafeParabolic', 'numeric', 'logical')
class(`Parabolic___call____SWIG_0`) = c("SWIGFunction", class('Parabolic___call____SWIG_0'))

# Start of Parabolic___call__

`Parabolic___call____SWIG_1` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_Parabolic___call____SWIG_1', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Parabolic___call____SWIG_1`, 'returnType') = 'numeric'
attr(`Parabolic___call____SWIG_1`, "inputTypes") = c('_p_SafeParabolic', 'numeric')
class(`Parabolic___call____SWIG_1`) = c("SWIGFunction", class('Parabolic___call____SWIG_1'))

`Parabolic___call__` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_SafeParabolic') && is.numeric(argv[[2]])) {
      f <- Parabolic___call____SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_SafeParabolic') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- Parabolic___call____SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Parabolic___call__ with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of Parabolic_derivative

`Parabolic_derivative__SWIG_0` = function(self, x, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_Parabolic_derivative__SWIG_0', self, x, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Parabolic_derivative__SWIG_0`, 'returnType') = 'numeric'
attr(`Parabolic_derivative__SWIG_0`, "inputTypes") = c('_p_SafeParabolic', 'numeric', 'logical')
class(`Parabolic_derivative__SWIG_0`) = c("SWIGFunction", class('Parabolic_derivative__SWIG_0'))

# Start of Parabolic_derivative

`Parabolic_derivative__SWIG_1` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_Parabolic_derivative__SWIG_1', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Parabolic_derivative__SWIG_1`, 'returnType') = 'numeric'
attr(`Parabolic_derivative__SWIG_1`, "inputTypes") = c('_p_SafeParabolic', 'numeric')
class(`Parabolic_derivative__SWIG_1`) = c("SWIGFunction", class('Parabolic_derivative__SWIG_1'))

`Parabolic_derivative` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_SafeParabolic') && is.numeric(argv[[2]])) {
      f <- Parabolic_derivative__SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_SafeParabolic') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- Parabolic_derivative__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Parabolic_derivative with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of Parabolic_secondDerivative

`Parabolic_secondDerivative__SWIG_0` = function(self, x, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_Parabolic_secondDerivative__SWIG_0', self, x, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Parabolic_secondDerivative__SWIG_0`, 'returnType') = 'numeric'
attr(`Parabolic_secondDerivative__SWIG_0`, "inputTypes") = c('_p_SafeParabolic', 'numeric', 'logical')
class(`Parabolic_secondDerivative__SWIG_0`) = c("SWIGFunction", class('Parabolic_secondDerivative__SWIG_0'))

# Start of Parabolic_secondDerivative

`Parabolic_secondDerivative__SWIG_1` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_Parabolic_secondDerivative__SWIG_1', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Parabolic_secondDerivative__SWIG_1`, 'returnType') = 'numeric'
attr(`Parabolic_secondDerivative__SWIG_1`, "inputTypes") = c('_p_SafeParabolic', 'numeric')
class(`Parabolic_secondDerivative__SWIG_1`) = c("SWIGFunction", class('Parabolic_secondDerivative__SWIG_1'))

`Parabolic_secondDerivative` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_SafeParabolic') && is.numeric(argv[[2]])) {
      f <- Parabolic_secondDerivative__SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_SafeParabolic') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- Parabolic_secondDerivative__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Parabolic_secondDerivative with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of Parabolic_primitive

`Parabolic_primitive__SWIG_0` = function(self, x, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_Parabolic_primitive__SWIG_0', self, x, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Parabolic_primitive__SWIG_0`, 'returnType') = 'numeric'
attr(`Parabolic_primitive__SWIG_0`, "inputTypes") = c('_p_SafeParabolic', 'numeric', 'logical')
class(`Parabolic_primitive__SWIG_0`) = c("SWIGFunction", class('Parabolic_primitive__SWIG_0'))

# Start of Parabolic_primitive

`Parabolic_primitive__SWIG_1` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_Parabolic_primitive__SWIG_1', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Parabolic_primitive__SWIG_1`, 'returnType') = 'numeric'
attr(`Parabolic_primitive__SWIG_1`, "inputTypes") = c('_p_SafeParabolic', 'numeric')
class(`Parabolic_primitive__SWIG_1`) = c("SWIGFunction", class('Parabolic_primitive__SWIG_1'))

`Parabolic_primitive` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_SafeParabolic') && is.numeric(argv[[2]])) {
      f <- Parabolic_primitive__SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_SafeParabolic') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- Parabolic_primitive__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Parabolic_primitive with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_Parabolic

`delete_Parabolic` = function(self)
{
  ;.Call('R_swig_delete_Parabolic', self, PACKAGE='QuantLib');
  
}

attr(`delete_Parabolic`, 'returnType') = 'void'
attr(`delete_Parabolic`, "inputTypes") = c('_p_SafeParabolic')
class(`delete_Parabolic`) = c("SWIGFunction", class('delete_Parabolic'))

# Start of accessor method for SafeParabolic
setMethod('$', '_p_SafeParabolic', function(x, name)

{
  accessorFuns = list('__call__' = Parabolic___call__, 'derivative' = Parabolic_derivative, 'secondDerivative' = Parabolic_secondDerivative, 'primitive' = Parabolic_primitive);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for SafeParabolic
setMethod('delete', '_p_SafeParabolic', function(obj) {delete_SafeParabolic(obj)})
# Start of new_LogParabolic

`LogParabolic` = function(x, y)
{
  ;ans = .Call('R_swig_new_LogParabolic', x, y, PACKAGE='QuantLib');
  class(ans) <- "_p_SafeLogParabolic";
  
  reg.finalizer(ans, delete_LogParabolic)
  ans
  
}

attr(`LogParabolic`, 'returnType') = '_p_SafeLogParabolic'
attr(`LogParabolic`, "inputTypes") = c('_p_Array', '_p_Array')
class(`LogParabolic`) = c("SWIGFunction", class('LogParabolic'))

# Start of LogParabolic___call__

`LogParabolic___call____SWIG_0` = function(self, x, allowExtrapolation, .copy = FALSE)
{
  allowExtrapolation = as.logical(allowExtrapolation);
  ;.Call('R_swig_LogParabolic___call____SWIG_0', self, x, allowExtrapolation, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`LogParabolic___call____SWIG_0`, 'returnType') = 'numeric'
attr(`LogParabolic___call____SWIG_0`, "inputTypes") = c('_p_SafeLogParabolic', 'numeric', 'logical')
class(`LogParabolic___call____SWIG_0`) = c("SWIGFunction", class('LogParabolic___call____SWIG_0'))

# Start of LogParabolic___call__

`LogParabolic___call____SWIG_1` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_LogParabolic___call____SWIG_1', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`LogParabolic___call____SWIG_1`, 'returnType') = 'numeric'
attr(`LogParabolic___call____SWIG_1`, "inputTypes") = c('_p_SafeLogParabolic', 'numeric')
class(`LogParabolic___call____SWIG_1`) = c("SWIGFunction", class('LogParabolic___call____SWIG_1'))

`LogParabolic___call__` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_SafeLogParabolic') && is.numeric(argv[[2]])) {
      f <- LogParabolic___call____SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_SafeLogParabolic') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- LogParabolic___call____SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for LogParabolic___call__ with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of LogParabolic_derivative

`LogParabolic_derivative__SWIG_0` = function(self, x, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_LogParabolic_derivative__SWIG_0', self, x, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`LogParabolic_derivative__SWIG_0`, 'returnType') = 'numeric'
attr(`LogParabolic_derivative__SWIG_0`, "inputTypes") = c('_p_SafeLogParabolic', 'numeric', 'logical')
class(`LogParabolic_derivative__SWIG_0`) = c("SWIGFunction", class('LogParabolic_derivative__SWIG_0'))

# Start of LogParabolic_derivative

`LogParabolic_derivative__SWIG_1` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_LogParabolic_derivative__SWIG_1', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`LogParabolic_derivative__SWIG_1`, 'returnType') = 'numeric'
attr(`LogParabolic_derivative__SWIG_1`, "inputTypes") = c('_p_SafeLogParabolic', 'numeric')
class(`LogParabolic_derivative__SWIG_1`) = c("SWIGFunction", class('LogParabolic_derivative__SWIG_1'))

`LogParabolic_derivative` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_SafeLogParabolic') && is.numeric(argv[[2]])) {
      f <- LogParabolic_derivative__SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_SafeLogParabolic') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- LogParabolic_derivative__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for LogParabolic_derivative with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of LogParabolic_secondDerivative

`LogParabolic_secondDerivative__SWIG_0` = function(self, x, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_LogParabolic_secondDerivative__SWIG_0', self, x, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`LogParabolic_secondDerivative__SWIG_0`, 'returnType') = 'numeric'
attr(`LogParabolic_secondDerivative__SWIG_0`, "inputTypes") = c('_p_SafeLogParabolic', 'numeric', 'logical')
class(`LogParabolic_secondDerivative__SWIG_0`) = c("SWIGFunction", class('LogParabolic_secondDerivative__SWIG_0'))

# Start of LogParabolic_secondDerivative

`LogParabolic_secondDerivative__SWIG_1` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_LogParabolic_secondDerivative__SWIG_1', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`LogParabolic_secondDerivative__SWIG_1`, 'returnType') = 'numeric'
attr(`LogParabolic_secondDerivative__SWIG_1`, "inputTypes") = c('_p_SafeLogParabolic', 'numeric')
class(`LogParabolic_secondDerivative__SWIG_1`) = c("SWIGFunction", class('LogParabolic_secondDerivative__SWIG_1'))

`LogParabolic_secondDerivative` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_SafeLogParabolic') && is.numeric(argv[[2]])) {
      f <- LogParabolic_secondDerivative__SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_SafeLogParabolic') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- LogParabolic_secondDerivative__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for LogParabolic_secondDerivative with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of LogParabolic_primitive

`LogParabolic_primitive__SWIG_0` = function(self, x, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_LogParabolic_primitive__SWIG_0', self, x, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`LogParabolic_primitive__SWIG_0`, 'returnType') = 'numeric'
attr(`LogParabolic_primitive__SWIG_0`, "inputTypes") = c('_p_SafeLogParabolic', 'numeric', 'logical')
class(`LogParabolic_primitive__SWIG_0`) = c("SWIGFunction", class('LogParabolic_primitive__SWIG_0'))

# Start of LogParabolic_primitive

`LogParabolic_primitive__SWIG_1` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_LogParabolic_primitive__SWIG_1', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`LogParabolic_primitive__SWIG_1`, 'returnType') = 'numeric'
attr(`LogParabolic_primitive__SWIG_1`, "inputTypes") = c('_p_SafeLogParabolic', 'numeric')
class(`LogParabolic_primitive__SWIG_1`) = c("SWIGFunction", class('LogParabolic_primitive__SWIG_1'))

`LogParabolic_primitive` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_SafeLogParabolic') && is.numeric(argv[[2]])) {
      f <- LogParabolic_primitive__SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_SafeLogParabolic') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- LogParabolic_primitive__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for LogParabolic_primitive with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_LogParabolic

`delete_LogParabolic` = function(self)
{
  ;.Call('R_swig_delete_LogParabolic', self, PACKAGE='QuantLib');
  
}

attr(`delete_LogParabolic`, 'returnType') = 'void'
attr(`delete_LogParabolic`, "inputTypes") = c('_p_SafeLogParabolic')
class(`delete_LogParabolic`) = c("SWIGFunction", class('delete_LogParabolic'))

# Start of accessor method for SafeLogParabolic
setMethod('$', '_p_SafeLogParabolic', function(x, name)

{
  accessorFuns = list('__call__' = LogParabolic___call__, 'derivative' = LogParabolic_derivative, 'secondDerivative' = LogParabolic_secondDerivative, 'primitive' = LogParabolic_primitive);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for SafeLogParabolic
setMethod('delete', '_p_SafeLogParabolic', function(obj) {delete_SafeLogParabolic(obj)})
# Start of new_MonotonicParabolic

`MonotonicParabolic` = function(x, y)
{
  ;ans = .Call('R_swig_new_MonotonicParabolic', x, y, PACKAGE='QuantLib');
  class(ans) <- "_p_SafeMonotonicParabolic";
  
  reg.finalizer(ans, delete_MonotonicParabolic)
  ans
  
}

attr(`MonotonicParabolic`, 'returnType') = '_p_SafeMonotonicParabolic'
attr(`MonotonicParabolic`, "inputTypes") = c('_p_Array', '_p_Array')
class(`MonotonicParabolic`) = c("SWIGFunction", class('MonotonicParabolic'))

# Start of MonotonicParabolic___call__

`MonotonicParabolic___call____SWIG_0` = function(self, x, allowExtrapolation, .copy = FALSE)
{
  allowExtrapolation = as.logical(allowExtrapolation);
  ;.Call('R_swig_MonotonicParabolic___call____SWIG_0', self, x, allowExtrapolation, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`MonotonicParabolic___call____SWIG_0`, 'returnType') = 'numeric'
attr(`MonotonicParabolic___call____SWIG_0`, "inputTypes") = c('_p_SafeMonotonicParabolic', 'numeric', 'logical')
class(`MonotonicParabolic___call____SWIG_0`) = c("SWIGFunction", class('MonotonicParabolic___call____SWIG_0'))

# Start of MonotonicParabolic___call__

`MonotonicParabolic___call____SWIG_1` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_MonotonicParabolic___call____SWIG_1', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`MonotonicParabolic___call____SWIG_1`, 'returnType') = 'numeric'
attr(`MonotonicParabolic___call____SWIG_1`, "inputTypes") = c('_p_SafeMonotonicParabolic', 'numeric')
class(`MonotonicParabolic___call____SWIG_1`) = c("SWIGFunction", class('MonotonicParabolic___call____SWIG_1'))

`MonotonicParabolic___call__` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_SafeMonotonicParabolic') && is.numeric(argv[[2]])) {
      f <- MonotonicParabolic___call____SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_SafeMonotonicParabolic') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- MonotonicParabolic___call____SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for MonotonicParabolic___call__ with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of MonotonicParabolic_derivative

`MonotonicParabolic_derivative__SWIG_0` = function(self, x, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_MonotonicParabolic_derivative__SWIG_0', self, x, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`MonotonicParabolic_derivative__SWIG_0`, 'returnType') = 'numeric'
attr(`MonotonicParabolic_derivative__SWIG_0`, "inputTypes") = c('_p_SafeMonotonicParabolic', 'numeric', 'logical')
class(`MonotonicParabolic_derivative__SWIG_0`) = c("SWIGFunction", class('MonotonicParabolic_derivative__SWIG_0'))

# Start of MonotonicParabolic_derivative

`MonotonicParabolic_derivative__SWIG_1` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_MonotonicParabolic_derivative__SWIG_1', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`MonotonicParabolic_derivative__SWIG_1`, 'returnType') = 'numeric'
attr(`MonotonicParabolic_derivative__SWIG_1`, "inputTypes") = c('_p_SafeMonotonicParabolic', 'numeric')
class(`MonotonicParabolic_derivative__SWIG_1`) = c("SWIGFunction", class('MonotonicParabolic_derivative__SWIG_1'))

`MonotonicParabolic_derivative` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_SafeMonotonicParabolic') && is.numeric(argv[[2]])) {
      f <- MonotonicParabolic_derivative__SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_SafeMonotonicParabolic') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- MonotonicParabolic_derivative__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for MonotonicParabolic_derivative with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of MonotonicParabolic_secondDerivative

`MonotonicParabolic_secondDerivative__SWIG_0` = function(self, x, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_MonotonicParabolic_secondDerivative__SWIG_0', self, x, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`MonotonicParabolic_secondDerivative__SWIG_0`, 'returnType') = 'numeric'
attr(`MonotonicParabolic_secondDerivative__SWIG_0`, "inputTypes") = c('_p_SafeMonotonicParabolic', 'numeric', 'logical')
class(`MonotonicParabolic_secondDerivative__SWIG_0`) = c("SWIGFunction", class('MonotonicParabolic_secondDerivative__SWIG_0'))

# Start of MonotonicParabolic_secondDerivative

`MonotonicParabolic_secondDerivative__SWIG_1` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_MonotonicParabolic_secondDerivative__SWIG_1', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`MonotonicParabolic_secondDerivative__SWIG_1`, 'returnType') = 'numeric'
attr(`MonotonicParabolic_secondDerivative__SWIG_1`, "inputTypes") = c('_p_SafeMonotonicParabolic', 'numeric')
class(`MonotonicParabolic_secondDerivative__SWIG_1`) = c("SWIGFunction", class('MonotonicParabolic_secondDerivative__SWIG_1'))

`MonotonicParabolic_secondDerivative` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_SafeMonotonicParabolic') && is.numeric(argv[[2]])) {
      f <- MonotonicParabolic_secondDerivative__SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_SafeMonotonicParabolic') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- MonotonicParabolic_secondDerivative__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for MonotonicParabolic_secondDerivative with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of MonotonicParabolic_primitive

`MonotonicParabolic_primitive__SWIG_0` = function(self, x, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_MonotonicParabolic_primitive__SWIG_0', self, x, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`MonotonicParabolic_primitive__SWIG_0`, 'returnType') = 'numeric'
attr(`MonotonicParabolic_primitive__SWIG_0`, "inputTypes") = c('_p_SafeMonotonicParabolic', 'numeric', 'logical')
class(`MonotonicParabolic_primitive__SWIG_0`) = c("SWIGFunction", class('MonotonicParabolic_primitive__SWIG_0'))

# Start of MonotonicParabolic_primitive

`MonotonicParabolic_primitive__SWIG_1` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_MonotonicParabolic_primitive__SWIG_1', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`MonotonicParabolic_primitive__SWIG_1`, 'returnType') = 'numeric'
attr(`MonotonicParabolic_primitive__SWIG_1`, "inputTypes") = c('_p_SafeMonotonicParabolic', 'numeric')
class(`MonotonicParabolic_primitive__SWIG_1`) = c("SWIGFunction", class('MonotonicParabolic_primitive__SWIG_1'))

`MonotonicParabolic_primitive` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_SafeMonotonicParabolic') && is.numeric(argv[[2]])) {
      f <- MonotonicParabolic_primitive__SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_SafeMonotonicParabolic') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- MonotonicParabolic_primitive__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for MonotonicParabolic_primitive with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_MonotonicParabolic

`delete_MonotonicParabolic` = function(self)
{
  ;.Call('R_swig_delete_MonotonicParabolic', self, PACKAGE='QuantLib');
  
}

attr(`delete_MonotonicParabolic`, 'returnType') = 'void'
attr(`delete_MonotonicParabolic`, "inputTypes") = c('_p_SafeMonotonicParabolic')
class(`delete_MonotonicParabolic`) = c("SWIGFunction", class('delete_MonotonicParabolic'))

# Start of accessor method for SafeMonotonicParabolic
setMethod('$', '_p_SafeMonotonicParabolic', function(x, name)

{
  accessorFuns = list('__call__' = MonotonicParabolic___call__, 'derivative' = MonotonicParabolic_derivative, 'secondDerivative' = MonotonicParabolic_secondDerivative, 'primitive' = MonotonicParabolic_primitive);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for SafeMonotonicParabolic
setMethod('delete', '_p_SafeMonotonicParabolic', function(obj) {delete_SafeMonotonicParabolic(obj)})
# Start of new_MonotonicLogParabolic

`MonotonicLogParabolic` = function(x, y)
{
  ;ans = .Call('R_swig_new_MonotonicLogParabolic', x, y, PACKAGE='QuantLib');
  class(ans) <- "_p_SafeMonotonicLogParabolic";
  
  reg.finalizer(ans, delete_MonotonicLogParabolic)
  ans
  
}

attr(`MonotonicLogParabolic`, 'returnType') = '_p_SafeMonotonicLogParabolic'
attr(`MonotonicLogParabolic`, "inputTypes") = c('_p_Array', '_p_Array')
class(`MonotonicLogParabolic`) = c("SWIGFunction", class('MonotonicLogParabolic'))

# Start of MonotonicLogParabolic___call__

`MonotonicLogParabolic___call____SWIG_0` = function(self, x, allowExtrapolation, .copy = FALSE)
{
  allowExtrapolation = as.logical(allowExtrapolation);
  ;.Call('R_swig_MonotonicLogParabolic___call____SWIG_0', self, x, allowExtrapolation, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`MonotonicLogParabolic___call____SWIG_0`, 'returnType') = 'numeric'
attr(`MonotonicLogParabolic___call____SWIG_0`, "inputTypes") = c('_p_SafeMonotonicLogParabolic', 'numeric', 'logical')
class(`MonotonicLogParabolic___call____SWIG_0`) = c("SWIGFunction", class('MonotonicLogParabolic___call____SWIG_0'))

# Start of MonotonicLogParabolic___call__

`MonotonicLogParabolic___call____SWIG_1` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_MonotonicLogParabolic___call____SWIG_1', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`MonotonicLogParabolic___call____SWIG_1`, 'returnType') = 'numeric'
attr(`MonotonicLogParabolic___call____SWIG_1`, "inputTypes") = c('_p_SafeMonotonicLogParabolic', 'numeric')
class(`MonotonicLogParabolic___call____SWIG_1`) = c("SWIGFunction", class('MonotonicLogParabolic___call____SWIG_1'))

`MonotonicLogParabolic___call__` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_SafeMonotonicLogParabolic') && is.numeric(argv[[2]])) {
      f <- MonotonicLogParabolic___call____SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_SafeMonotonicLogParabolic') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- MonotonicLogParabolic___call____SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for MonotonicLogParabolic___call__ with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of MonotonicLogParabolic_derivative

`MonotonicLogParabolic_derivative__SWIG_0` = function(self, x, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_MonotonicLogParabolic_derivative__SWIG_0', self, x, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`MonotonicLogParabolic_derivative__SWIG_0`, 'returnType') = 'numeric'
attr(`MonotonicLogParabolic_derivative__SWIG_0`, "inputTypes") = c('_p_SafeMonotonicLogParabolic', 'numeric', 'logical')
class(`MonotonicLogParabolic_derivative__SWIG_0`) = c("SWIGFunction", class('MonotonicLogParabolic_derivative__SWIG_0'))

# Start of MonotonicLogParabolic_derivative

`MonotonicLogParabolic_derivative__SWIG_1` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_MonotonicLogParabolic_derivative__SWIG_1', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`MonotonicLogParabolic_derivative__SWIG_1`, 'returnType') = 'numeric'
attr(`MonotonicLogParabolic_derivative__SWIG_1`, "inputTypes") = c('_p_SafeMonotonicLogParabolic', 'numeric')
class(`MonotonicLogParabolic_derivative__SWIG_1`) = c("SWIGFunction", class('MonotonicLogParabolic_derivative__SWIG_1'))

`MonotonicLogParabolic_derivative` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_SafeMonotonicLogParabolic') && is.numeric(argv[[2]])) {
      f <- MonotonicLogParabolic_derivative__SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_SafeMonotonicLogParabolic') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- MonotonicLogParabolic_derivative__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for MonotonicLogParabolic_derivative with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of MonotonicLogParabolic_secondDerivative

`MonotonicLogParabolic_secondDerivative__SWIG_0` = function(self, x, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_MonotonicLogParabolic_secondDerivative__SWIG_0', self, x, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`MonotonicLogParabolic_secondDerivative__SWIG_0`, 'returnType') = 'numeric'
attr(`MonotonicLogParabolic_secondDerivative__SWIG_0`, "inputTypes") = c('_p_SafeMonotonicLogParabolic', 'numeric', 'logical')
class(`MonotonicLogParabolic_secondDerivative__SWIG_0`) = c("SWIGFunction", class('MonotonicLogParabolic_secondDerivative__SWIG_0'))

# Start of MonotonicLogParabolic_secondDerivative

`MonotonicLogParabolic_secondDerivative__SWIG_1` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_MonotonicLogParabolic_secondDerivative__SWIG_1', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`MonotonicLogParabolic_secondDerivative__SWIG_1`, 'returnType') = 'numeric'
attr(`MonotonicLogParabolic_secondDerivative__SWIG_1`, "inputTypes") = c('_p_SafeMonotonicLogParabolic', 'numeric')
class(`MonotonicLogParabolic_secondDerivative__SWIG_1`) = c("SWIGFunction", class('MonotonicLogParabolic_secondDerivative__SWIG_1'))

`MonotonicLogParabolic_secondDerivative` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_SafeMonotonicLogParabolic') && is.numeric(argv[[2]])) {
      f <- MonotonicLogParabolic_secondDerivative__SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_SafeMonotonicLogParabolic') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- MonotonicLogParabolic_secondDerivative__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for MonotonicLogParabolic_secondDerivative with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of MonotonicLogParabolic_primitive

`MonotonicLogParabolic_primitive__SWIG_0` = function(self, x, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_MonotonicLogParabolic_primitive__SWIG_0', self, x, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`MonotonicLogParabolic_primitive__SWIG_0`, 'returnType') = 'numeric'
attr(`MonotonicLogParabolic_primitive__SWIG_0`, "inputTypes") = c('_p_SafeMonotonicLogParabolic', 'numeric', 'logical')
class(`MonotonicLogParabolic_primitive__SWIG_0`) = c("SWIGFunction", class('MonotonicLogParabolic_primitive__SWIG_0'))

# Start of MonotonicLogParabolic_primitive

`MonotonicLogParabolic_primitive__SWIG_1` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_MonotonicLogParabolic_primitive__SWIG_1', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`MonotonicLogParabolic_primitive__SWIG_1`, 'returnType') = 'numeric'
attr(`MonotonicLogParabolic_primitive__SWIG_1`, "inputTypes") = c('_p_SafeMonotonicLogParabolic', 'numeric')
class(`MonotonicLogParabolic_primitive__SWIG_1`) = c("SWIGFunction", class('MonotonicLogParabolic_primitive__SWIG_1'))

`MonotonicLogParabolic_primitive` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_SafeMonotonicLogParabolic') && is.numeric(argv[[2]])) {
      f <- MonotonicLogParabolic_primitive__SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_SafeMonotonicLogParabolic') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- MonotonicLogParabolic_primitive__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for MonotonicLogParabolic_primitive with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_MonotonicLogParabolic

`delete_MonotonicLogParabolic` = function(self)
{
  ;.Call('R_swig_delete_MonotonicLogParabolic', self, PACKAGE='QuantLib');
  
}

attr(`delete_MonotonicLogParabolic`, 'returnType') = 'void'
attr(`delete_MonotonicLogParabolic`, "inputTypes") = c('_p_SafeMonotonicLogParabolic')
class(`delete_MonotonicLogParabolic`) = c("SWIGFunction", class('delete_MonotonicLogParabolic'))

# Start of accessor method for SafeMonotonicLogParabolic
setMethod('$', '_p_SafeMonotonicLogParabolic', function(x, name)

{
  accessorFuns = list('__call__' = MonotonicLogParabolic___call__, 'derivative' = MonotonicLogParabolic_derivative, 'secondDerivative' = MonotonicLogParabolic_secondDerivative, 'primitive' = MonotonicLogParabolic_primitive);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for SafeMonotonicLogParabolic
setMethod('delete', '_p_SafeMonotonicLogParabolic', function(obj) {delete_SafeMonotonicLogParabolic(obj)})
# Start of new_BilinearInterpolation

`BilinearInterpolation` = function(x, y, m)
{
  ;ans = .Call('R_swig_new_BilinearInterpolation', x, y, m, PACKAGE='QuantLib');
  class(ans) <- "_p_SafeBilinearInterpolation";
  
  reg.finalizer(ans, delete_BilinearInterpolation)
  ans
  
}

attr(`BilinearInterpolation`, 'returnType') = '_p_SafeBilinearInterpolation'
attr(`BilinearInterpolation`, "inputTypes") = c('_p_Array', '_p_Array', '_p_Matrix')
class(`BilinearInterpolation`) = c("SWIGFunction", class('BilinearInterpolation'))

# Start of BilinearInterpolation___call__

`BilinearInterpolation___call____SWIG_0` = function(self, x, y, allowExtrapolation, .copy = FALSE)
{
  allowExtrapolation = as.logical(allowExtrapolation);
  ;.Call('R_swig_BilinearInterpolation___call____SWIG_0', self, x, y, allowExtrapolation, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BilinearInterpolation___call____SWIG_0`, 'returnType') = 'numeric'
attr(`BilinearInterpolation___call____SWIG_0`, "inputTypes") = c('_p_SafeBilinearInterpolation', 'numeric', 'numeric', 'logical')
class(`BilinearInterpolation___call____SWIG_0`) = c("SWIGFunction", class('BilinearInterpolation___call____SWIG_0'))

# Start of BilinearInterpolation___call__

`BilinearInterpolation___call____SWIG_1` = function(self, x, y, .copy = FALSE)
{
  ;.Call('R_swig_BilinearInterpolation___call____SWIG_1', self, x, y, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BilinearInterpolation___call____SWIG_1`, 'returnType') = 'numeric'
attr(`BilinearInterpolation___call____SWIG_1`, "inputTypes") = c('_p_SafeBilinearInterpolation', 'numeric', 'numeric')
class(`BilinearInterpolation___call____SWIG_1`) = c("SWIGFunction", class('BilinearInterpolation___call____SWIG_1'))

`BilinearInterpolation___call__` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 3) {
    if (extends(argtypes[1], '_p_SafeBilinearInterpolation') && is.numeric(argv[[2]]) && is.numeric(argv[[3]])) {
      f <- BilinearInterpolation___call____SWIG_1; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_SafeBilinearInterpolation') && is.numeric(argv[[2]]) && is.numeric(argv[[3]]) && extends(argtypes[4], 'logical')) {
      f <- BilinearInterpolation___call____SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for BilinearInterpolation___call__ with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_BilinearInterpolation

`delete_BilinearInterpolation` = function(self)
{
  ;.Call('R_swig_delete_BilinearInterpolation', self, PACKAGE='QuantLib');
  
}

attr(`delete_BilinearInterpolation`, 'returnType') = 'void'
attr(`delete_BilinearInterpolation`, "inputTypes") = c('_p_SafeBilinearInterpolation')
class(`delete_BilinearInterpolation`) = c("SWIGFunction", class('delete_BilinearInterpolation'))

# Start of accessor method for SafeBilinearInterpolation
setMethod('$', '_p_SafeBilinearInterpolation', function(x, name)

{
  accessorFuns = list('__call__' = BilinearInterpolation___call__);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for SafeBilinearInterpolation
setMethod('delete', '_p_SafeBilinearInterpolation', function(obj) {delete_SafeBilinearInterpolation(obj)})
# Start of new_BicubicSpline

`BicubicSpline` = function(x, y, m)
{
  ;ans = .Call('R_swig_new_BicubicSpline', x, y, m, PACKAGE='QuantLib');
  class(ans) <- "_p_SafeBicubicSpline";
  
  reg.finalizer(ans, delete_BicubicSpline)
  ans
  
}

attr(`BicubicSpline`, 'returnType') = '_p_SafeBicubicSpline'
attr(`BicubicSpline`, "inputTypes") = c('_p_Array', '_p_Array', '_p_Matrix')
class(`BicubicSpline`) = c("SWIGFunction", class('BicubicSpline'))

# Start of BicubicSpline___call__

`BicubicSpline___call____SWIG_0` = function(self, x, y, allowExtrapolation, .copy = FALSE)
{
  allowExtrapolation = as.logical(allowExtrapolation);
  ;.Call('R_swig_BicubicSpline___call____SWIG_0', self, x, y, allowExtrapolation, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BicubicSpline___call____SWIG_0`, 'returnType') = 'numeric'
attr(`BicubicSpline___call____SWIG_0`, "inputTypes") = c('_p_SafeBicubicSpline', 'numeric', 'numeric', 'logical')
class(`BicubicSpline___call____SWIG_0`) = c("SWIGFunction", class('BicubicSpline___call____SWIG_0'))

# Start of BicubicSpline___call__

`BicubicSpline___call____SWIG_1` = function(self, x, y, .copy = FALSE)
{
  ;.Call('R_swig_BicubicSpline___call____SWIG_1', self, x, y, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BicubicSpline___call____SWIG_1`, 'returnType') = 'numeric'
attr(`BicubicSpline___call____SWIG_1`, "inputTypes") = c('_p_SafeBicubicSpline', 'numeric', 'numeric')
class(`BicubicSpline___call____SWIG_1`) = c("SWIGFunction", class('BicubicSpline___call____SWIG_1'))

`BicubicSpline___call__` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 3) {
    if (extends(argtypes[1], '_p_SafeBicubicSpline') && is.numeric(argv[[2]]) && is.numeric(argv[[3]])) {
      f <- BicubicSpline___call____SWIG_1; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_SafeBicubicSpline') && is.numeric(argv[[2]]) && is.numeric(argv[[3]]) && extends(argtypes[4], 'logical')) {
      f <- BicubicSpline___call____SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for BicubicSpline___call__ with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_BicubicSpline

`delete_BicubicSpline` = function(self)
{
  ;.Call('R_swig_delete_BicubicSpline', self, PACKAGE='QuantLib');
  
}

attr(`delete_BicubicSpline`, 'returnType') = 'void'
attr(`delete_BicubicSpline`, "inputTypes") = c('_p_SafeBicubicSpline')
class(`delete_BicubicSpline`) = c("SWIGFunction", class('delete_BicubicSpline'))

# Start of accessor method for SafeBicubicSpline
setMethod('$', '_p_SafeBicubicSpline', function(x, name)

{
  accessorFuns = list('__call__' = BicubicSpline___call__);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for SafeBicubicSpline
setMethod('delete', '_p_SafeBicubicSpline', function(obj) {delete_SafeBicubicSpline(obj)})
# Start of new_BackwardFlat

`BackwardFlat` = function()
{
  ;ans = .Call('R_swig_new_BackwardFlat', PACKAGE='QuantLib');
  class(ans) <- "_p_BackwardFlat";
  
  reg.finalizer(ans, delete_BackwardFlat)
  ans
  
}

attr(`BackwardFlat`, 'returnType') = '_p_BackwardFlat'
class(`BackwardFlat`) = c("SWIGFunction", class('BackwardFlat'))

# Start of delete_BackwardFlat

`delete_BackwardFlat` = function(self)
{
  ;.Call('R_swig_delete_BackwardFlat', self, PACKAGE='QuantLib');
  
}

attr(`delete_BackwardFlat`, 'returnType') = 'void'
attr(`delete_BackwardFlat`, "inputTypes") = c('_p_BackwardFlat')
class(`delete_BackwardFlat`) = c("SWIGFunction", class('delete_BackwardFlat'))

setMethod('delete', '_p_BackwardFlat', function(obj) {delete_BackwardFlat(obj)})
# Start definition of copy functions & methods for BackwardFlat
CopyToR_BackwardFlat = function(value, obj = new("BackwardFlat"))
{
  obj;
}



CopyToC_BackwardFlat = function(value, obj)
{
  obj
}



# Start definition of copy methods for BackwardFlat
setMethod('copyToR', '_p_BackwardFlat', CopyToR_BackwardFlat);
setMethod('copyToC', 'BackwardFlat', CopyToC_BackwardFlat);

# End definition of copy methods for BackwardFlat
# End definition of copy functions & methods for BackwardFlat
# Start of new_ForwardFlat

`ForwardFlat` = function()
{
  ;ans = .Call('R_swig_new_ForwardFlat', PACKAGE='QuantLib');
  class(ans) <- "_p_ForwardFlat";
  
  reg.finalizer(ans, delete_ForwardFlat)
  ans
  
}

attr(`ForwardFlat`, 'returnType') = '_p_ForwardFlat'
class(`ForwardFlat`) = c("SWIGFunction", class('ForwardFlat'))

# Start of delete_ForwardFlat

`delete_ForwardFlat` = function(self)
{
  ;.Call('R_swig_delete_ForwardFlat', self, PACKAGE='QuantLib');
  
}

attr(`delete_ForwardFlat`, 'returnType') = 'void'
attr(`delete_ForwardFlat`, "inputTypes") = c('_p_ForwardFlat')
class(`delete_ForwardFlat`) = c("SWIGFunction", class('delete_ForwardFlat'))

setMethod('delete', '_p_ForwardFlat', function(obj) {delete_ForwardFlat(obj)})
# Start definition of copy functions & methods for ForwardFlat
CopyToR_ForwardFlat = function(value, obj = new("ForwardFlat"))
{
  obj;
}



CopyToC_ForwardFlat = function(value, obj)
{
  obj
}



# Start definition of copy methods for ForwardFlat
setMethod('copyToR', '_p_ForwardFlat', CopyToR_ForwardFlat);
setMethod('copyToC', 'ForwardFlat', CopyToC_ForwardFlat);

# End definition of copy methods for ForwardFlat
# End definition of copy functions & methods for ForwardFlat
# Start of new_Linear

`Linear` = function()
{
  ;ans = .Call('R_swig_new_Linear', PACKAGE='QuantLib');
  class(ans) <- "_p_Linear";
  
  reg.finalizer(ans, delete_Linear)
  ans
  
}

attr(`Linear`, 'returnType') = '_p_Linear'
class(`Linear`) = c("SWIGFunction", class('Linear'))

# Start of delete_Linear

`delete_Linear` = function(self)
{
  ;.Call('R_swig_delete_Linear', self, PACKAGE='QuantLib');
  
}

attr(`delete_Linear`, 'returnType') = 'void'
attr(`delete_Linear`, "inputTypes") = c('_p_Linear')
class(`delete_Linear`) = c("SWIGFunction", class('delete_Linear'))

setMethod('delete', '_p_Linear', function(obj) {delete_Linear(obj)})
# Start definition of copy functions & methods for Linear
CopyToR_Linear = function(value, obj = new("Linear"))
{
  obj;
}



CopyToC_Linear = function(value, obj)
{
  obj
}



# Start definition of copy methods for Linear
setMethod('copyToR', '_p_Linear', CopyToR_Linear);
setMethod('copyToC', 'Linear', CopyToC_Linear);

# End definition of copy methods for Linear
# End definition of copy functions & methods for Linear
# Start of new_LogLinear

`LogLinear` = function()
{
  ;ans = .Call('R_swig_new_LogLinear', PACKAGE='QuantLib');
  class(ans) <- "_p_LogLinear";
  
  reg.finalizer(ans, delete_LogLinear)
  ans
  
}

attr(`LogLinear`, 'returnType') = '_p_LogLinear'
class(`LogLinear`) = c("SWIGFunction", class('LogLinear'))

# Start of delete_LogLinear

`delete_LogLinear` = function(self)
{
  ;.Call('R_swig_delete_LogLinear', self, PACKAGE='QuantLib');
  
}

attr(`delete_LogLinear`, 'returnType') = 'void'
attr(`delete_LogLinear`, "inputTypes") = c('_p_LogLinear')
class(`delete_LogLinear`) = c("SWIGFunction", class('delete_LogLinear'))

setMethod('delete', '_p_LogLinear', function(obj) {delete_LogLinear(obj)})
# Start definition of copy functions & methods for LogLinear
CopyToR_LogLinear = function(value, obj = new("LogLinear"))
{
  obj;
}



CopyToC_LogLinear = function(value, obj)
{
  obj
}



# Start definition of copy methods for LogLinear
setMethod('copyToR', '_p_LogLinear', CopyToR_LogLinear);
setMethod('copyToC', 'LogLinear', CopyToC_LogLinear);

# End definition of copy methods for LogLinear
# End definition of copy functions & methods for LogLinear
# Start of new_Cubic

`Cubic` = function()
{
  ;ans = .Call('R_swig_new_Cubic', PACKAGE='QuantLib');
  class(ans) <- "_p_Cubic";
  
  reg.finalizer(ans, delete_Cubic)
  ans
  
}

attr(`Cubic`, 'returnType') = '_p_Cubic'
class(`Cubic`) = c("SWIGFunction", class('Cubic'))

# Start of delete_Cubic

`delete_Cubic` = function(self)
{
  ;.Call('R_swig_delete_Cubic', self, PACKAGE='QuantLib');
  
}

attr(`delete_Cubic`, 'returnType') = 'void'
attr(`delete_Cubic`, "inputTypes") = c('_p_Cubic')
class(`delete_Cubic`) = c("SWIGFunction", class('delete_Cubic'))

setMethod('delete', '_p_Cubic', function(obj) {delete_Cubic(obj)})
# Start definition of copy functions & methods for Cubic
CopyToR_Cubic = function(value, obj = new("Cubic"))
{
  obj;
}



CopyToC_Cubic = function(value, obj)
{
  obj
}



# Start definition of copy methods for Cubic
setMethod('copyToR', '_p_Cubic', CopyToR_Cubic);
setMethod('copyToC', 'Cubic', CopyToC_Cubic);

# End definition of copy methods for Cubic
# End definition of copy functions & methods for Cubic
# Start of YieldTermStructure___deref__

`YieldTermStructure___deref__` = function(self)
{
  ;ans = .Call('R_swig_YieldTermStructure___deref__', self, PACKAGE='QuantLib');
  class(ans) <- "_p_YieldTermStructure";
  
  ans
  
}

attr(`YieldTermStructure___deref__`, 'returnType') = '_p_YieldTermStructure'
attr(`YieldTermStructure___deref__`, "inputTypes") = c('_p_boost__shared_ptrT_YieldTermStructure_t')
class(`YieldTermStructure___deref__`) = c("SWIGFunction", class('YieldTermStructure___deref__'))

# Start of YieldTermStructure_isNull

`YieldTermStructure_isNull` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_YieldTermStructure_isNull', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`YieldTermStructure_isNull`, 'returnType') = 'logical'
attr(`YieldTermStructure_isNull`, "inputTypes") = c('_p_boost__shared_ptrT_YieldTermStructure_t')
class(`YieldTermStructure_isNull`) = c("SWIGFunction", class('YieldTermStructure_isNull'))

# Start of YieldTermStructure_asObservable

`YieldTermStructure_asObservable` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_YieldTermStructure_asObservable', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_Observable_t";
  
  ans
  
}

attr(`YieldTermStructure_asObservable`, 'returnType') = '_p_boost__shared_ptrT_Observable_t'
attr(`YieldTermStructure_asObservable`, "inputTypes") = c('_p_boost__shared_ptrT_YieldTermStructure_t')
class(`YieldTermStructure_asObservable`) = c("SWIGFunction", class('YieldTermStructure_asObservable'))

# Start of new_YieldTermStructure

`YieldTermStructure` = function()
{
  ;ans = .Call('R_swig_new_YieldTermStructure', PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_YieldTermStructure_t";
  
  reg.finalizer(ans, delete_YieldTermStructure)
  ans
  
}

attr(`YieldTermStructure`, 'returnType') = '_p_boost__shared_ptrT_YieldTermStructure_t'
class(`YieldTermStructure`) = c("SWIGFunction", class('YieldTermStructure'))

# Start of delete_YieldTermStructure

`delete_YieldTermStructure` = function(self)
{
  ;.Call('R_swig_delete_YieldTermStructure', self, PACKAGE='QuantLib');
  
}

attr(`delete_YieldTermStructure`, 'returnType') = 'void'
attr(`delete_YieldTermStructure`, "inputTypes") = c('_p_boost__shared_ptrT_YieldTermStructure_t')
class(`delete_YieldTermStructure`) = c("SWIGFunction", class('delete_YieldTermStructure'))

# Start of YieldTermStructure_dayCounter

`YieldTermStructure_dayCounter` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_YieldTermStructure_dayCounter', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_DayCounter";
  
  ans
  
}

attr(`YieldTermStructure_dayCounter`, 'returnType') = '_p_DayCounter'
attr(`YieldTermStructure_dayCounter`, "inputTypes") = c('_p_boost__shared_ptrT_YieldTermStructure_t')
class(`YieldTermStructure_dayCounter`) = c("SWIGFunction", class('YieldTermStructure_dayCounter'))

# Start of YieldTermStructure_calendar

`YieldTermStructure_calendar` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_YieldTermStructure_calendar', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Calendar";
  
  ans
  
}

attr(`YieldTermStructure_calendar`, 'returnType') = '_p_Calendar'
attr(`YieldTermStructure_calendar`, "inputTypes") = c('_p_boost__shared_ptrT_YieldTermStructure_t')
class(`YieldTermStructure_calendar`) = c("SWIGFunction", class('YieldTermStructure_calendar'))

# Start of YieldTermStructure_referenceDate

`YieldTermStructure_referenceDate` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_YieldTermStructure_referenceDate', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`YieldTermStructure_referenceDate`, 'returnType') = '_p_Date'
attr(`YieldTermStructure_referenceDate`, "inputTypes") = c('_p_boost__shared_ptrT_YieldTermStructure_t')
class(`YieldTermStructure_referenceDate`) = c("SWIGFunction", class('YieldTermStructure_referenceDate'))

# Start of YieldTermStructure_maxDate

`YieldTermStructure_maxDate` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_YieldTermStructure_maxDate', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`YieldTermStructure_maxDate`, 'returnType') = '_p_Date'
attr(`YieldTermStructure_maxDate`, "inputTypes") = c('_p_boost__shared_ptrT_YieldTermStructure_t')
class(`YieldTermStructure_maxDate`) = c("SWIGFunction", class('YieldTermStructure_maxDate'))

# Start of YieldTermStructure_maxTime

`YieldTermStructure_maxTime` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_YieldTermStructure_maxTime', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`YieldTermStructure_maxTime`, 'returnType') = 'numeric'
attr(`YieldTermStructure_maxTime`, "inputTypes") = c('_p_boost__shared_ptrT_YieldTermStructure_t')
class(`YieldTermStructure_maxTime`) = c("SWIGFunction", class('YieldTermStructure_maxTime'))

# Start of YieldTermStructure_discount

`YieldTermStructure_discount__SWIG_0` = function(self, s_arg2, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_YieldTermStructure_discount__SWIG_0', self, s_arg2, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`YieldTermStructure_discount__SWIG_0`, 'returnType') = 'numeric'
attr(`YieldTermStructure_discount__SWIG_0`, "inputTypes") = c('_p_boost__shared_ptrT_YieldTermStructure_t', '_p_Date', 'logical')
class(`YieldTermStructure_discount__SWIG_0`) = c("SWIGFunction", class('YieldTermStructure_discount__SWIG_0'))

# Start of YieldTermStructure_discount

`YieldTermStructure_discount__SWIG_1` = function(self, s_arg2, .copy = FALSE)
{
  ;.Call('R_swig_YieldTermStructure_discount__SWIG_1', self, s_arg2, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`YieldTermStructure_discount__SWIG_1`, 'returnType') = 'numeric'
attr(`YieldTermStructure_discount__SWIG_1`, "inputTypes") = c('_p_boost__shared_ptrT_YieldTermStructure_t', '_p_Date')
class(`YieldTermStructure_discount__SWIG_1`) = c("SWIGFunction", class('YieldTermStructure_discount__SWIG_1'))

# Start of YieldTermStructure_discount

`YieldTermStructure_discount__SWIG_2` = function(self, s_arg2, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_YieldTermStructure_discount__SWIG_2', self, s_arg2, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`YieldTermStructure_discount__SWIG_2`, 'returnType') = 'numeric'
attr(`YieldTermStructure_discount__SWIG_2`, "inputTypes") = c('_p_boost__shared_ptrT_YieldTermStructure_t', 'numeric', 'logical')
class(`YieldTermStructure_discount__SWIG_2`) = c("SWIGFunction", class('YieldTermStructure_discount__SWIG_2'))

# Start of YieldTermStructure_discount

`YieldTermStructure_discount__SWIG_3` = function(self, s_arg2, .copy = FALSE)
{
  ;.Call('R_swig_YieldTermStructure_discount__SWIG_3', self, s_arg2, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`YieldTermStructure_discount__SWIG_3`, 'returnType') = 'numeric'
attr(`YieldTermStructure_discount__SWIG_3`, "inputTypes") = c('_p_boost__shared_ptrT_YieldTermStructure_t', 'numeric')
class(`YieldTermStructure_discount__SWIG_3`) = c("SWIGFunction", class('YieldTermStructure_discount__SWIG_3'))

`YieldTermStructure_discount` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 2) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_YieldTermStructure_t') && extends(argtypes[2], '_p_Date')) {
      f <- YieldTermStructure_discount__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_boost__shared_ptrT_YieldTermStructure_t') && is.numeric(argv[[2]])) {
      f <- YieldTermStructure_discount__SWIG_3; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_YieldTermStructure_t') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], 'logical')) {
      f <- YieldTermStructure_discount__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_boost__shared_ptrT_YieldTermStructure_t') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- YieldTermStructure_discount__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for YieldTermStructure_discount with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of YieldTermStructure_zeroRate

`YieldTermStructure_zeroRate__SWIG_0` = function(self, d, s_arg3, s_arg4, f, extrapolate, .copy = FALSE)
{
  s_arg4 = enumToInteger(s_arg4, "_Compounding"); 
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  f = enumToInteger(f, "_Frequency"); 
  
  if(length(f) > 1) {
    warning("using only the first element of f");
  };
  
  extrapolate = as.logical(extrapolate);
  ;ans = .Call('R_swig_YieldTermStructure_zeroRate__SWIG_0', self, d, s_arg3, s_arg4, f, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_InterestRate";
  
  ans
  
}

attr(`YieldTermStructure_zeroRate__SWIG_0`, 'returnType') = '_p_InterestRate'
attr(`YieldTermStructure_zeroRate__SWIG_0`, "inputTypes") = c('_p_boost__shared_ptrT_YieldTermStructure_t', '_p_Date', '_p_DayCounter', 'character', 'character', 'logical')
class(`YieldTermStructure_zeroRate__SWIG_0`) = c("SWIGFunction", class('YieldTermStructure_zeroRate__SWIG_0'))

# Start of YieldTermStructure_zeroRate

`YieldTermStructure_zeroRate__SWIG_1` = function(self, d, s_arg3, s_arg4, f, .copy = FALSE)
{
  s_arg4 = enumToInteger(s_arg4, "_Compounding"); 
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  f = enumToInteger(f, "_Frequency"); 
  
  if(length(f) > 1) {
    warning("using only the first element of f");
  };
  
  ;ans = .Call('R_swig_YieldTermStructure_zeroRate__SWIG_1', self, d, s_arg3, s_arg4, f, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_InterestRate";
  
  ans
  
}

attr(`YieldTermStructure_zeroRate__SWIG_1`, 'returnType') = '_p_InterestRate'
attr(`YieldTermStructure_zeroRate__SWIG_1`, "inputTypes") = c('_p_boost__shared_ptrT_YieldTermStructure_t', '_p_Date', '_p_DayCounter', 'character', 'character')
class(`YieldTermStructure_zeroRate__SWIG_1`) = c("SWIGFunction", class('YieldTermStructure_zeroRate__SWIG_1'))

# Start of YieldTermStructure_zeroRate

`YieldTermStructure_zeroRate__SWIG_2` = function(self, d, s_arg3, s_arg4, .copy = FALSE)
{
  s_arg4 = enumToInteger(s_arg4, "_Compounding"); 
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  ;ans = .Call('R_swig_YieldTermStructure_zeroRate__SWIG_2', self, d, s_arg3, s_arg4, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_InterestRate";
  
  ans
  
}

attr(`YieldTermStructure_zeroRate__SWIG_2`, 'returnType') = '_p_InterestRate'
attr(`YieldTermStructure_zeroRate__SWIG_2`, "inputTypes") = c('_p_boost__shared_ptrT_YieldTermStructure_t', '_p_Date', '_p_DayCounter', 'character')
class(`YieldTermStructure_zeroRate__SWIG_2`) = c("SWIGFunction", class('YieldTermStructure_zeroRate__SWIG_2'))

# Start of YieldTermStructure_zeroRate

`YieldTermStructure_zeroRate__SWIG_3` = function(self, t, s_arg3, f, extrapolate, .copy = FALSE)
{
  s_arg3 = enumToInteger(s_arg3, "_Compounding"); 
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  f = enumToInteger(f, "_Frequency"); 
  
  if(length(f) > 1) {
    warning("using only the first element of f");
  };
  
  extrapolate = as.logical(extrapolate);
  ;ans = .Call('R_swig_YieldTermStructure_zeroRate__SWIG_3', self, t, s_arg3, f, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_InterestRate";
  
  ans
  
}

attr(`YieldTermStructure_zeroRate__SWIG_3`, 'returnType') = '_p_InterestRate'
attr(`YieldTermStructure_zeroRate__SWIG_3`, "inputTypes") = c('_p_boost__shared_ptrT_YieldTermStructure_t', 'numeric', 'character', 'character', 'logical')
class(`YieldTermStructure_zeroRate__SWIG_3`) = c("SWIGFunction", class('YieldTermStructure_zeroRate__SWIG_3'))

# Start of YieldTermStructure_zeroRate

`YieldTermStructure_zeroRate__SWIG_4` = function(self, t, s_arg3, f, .copy = FALSE)
{
  s_arg3 = enumToInteger(s_arg3, "_Compounding"); 
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  f = enumToInteger(f, "_Frequency"); 
  
  if(length(f) > 1) {
    warning("using only the first element of f");
  };
  
  ;ans = .Call('R_swig_YieldTermStructure_zeroRate__SWIG_4', self, t, s_arg3, f, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_InterestRate";
  
  ans
  
}

attr(`YieldTermStructure_zeroRate__SWIG_4`, 'returnType') = '_p_InterestRate'
attr(`YieldTermStructure_zeroRate__SWIG_4`, "inputTypes") = c('_p_boost__shared_ptrT_YieldTermStructure_t', 'numeric', 'character', 'character')
class(`YieldTermStructure_zeroRate__SWIG_4`) = c("SWIGFunction", class('YieldTermStructure_zeroRate__SWIG_4'))

# Start of YieldTermStructure_zeroRate

`YieldTermStructure_zeroRate__SWIG_5` = function(self, t, s_arg3, .copy = FALSE)
{
  s_arg3 = enumToInteger(s_arg3, "_Compounding"); 
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  ;ans = .Call('R_swig_YieldTermStructure_zeroRate__SWIG_5', self, t, s_arg3, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_InterestRate";
  
  ans
  
}

attr(`YieldTermStructure_zeroRate__SWIG_5`, 'returnType') = '_p_InterestRate'
attr(`YieldTermStructure_zeroRate__SWIG_5`, "inputTypes") = c('_p_boost__shared_ptrT_YieldTermStructure_t', 'numeric', 'character')
class(`YieldTermStructure_zeroRate__SWIG_5`) = c("SWIGFunction", class('YieldTermStructure_zeroRate__SWIG_5'))

`YieldTermStructure_zeroRate` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 6
  if (argc == 3) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_YieldTermStructure_t') && is.numeric(argv[[2]]) && is.character(argv[[3]])) {
      f <- YieldTermStructure_zeroRate__SWIG_5; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_YieldTermStructure_t') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_DayCounter') && is.character(argv[[4]])) {
      f <- YieldTermStructure_zeroRate__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_boost__shared_ptrT_YieldTermStructure_t') && is.numeric(argv[[2]]) && is.character(argv[[3]]) && is.character(argv[[4]])) {
      f <- YieldTermStructure_zeroRate__SWIG_4; 
    }
  } else if (argc == 5) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_YieldTermStructure_t') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_DayCounter') && is.character(argv[[4]]) && is.character(argv[[5]])) {
      f <- YieldTermStructure_zeroRate__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_boost__shared_ptrT_YieldTermStructure_t') && is.numeric(argv[[2]]) && is.character(argv[[3]]) && is.character(argv[[4]]) && extends(argtypes[5], 'logical')) {
      f <- YieldTermStructure_zeroRate__SWIG_3; 
    }
  } else if (argc == 6) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_YieldTermStructure_t') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_DayCounter') && is.character(argv[[4]]) && is.character(argv[[5]]) && extends(argtypes[6], 'logical')) {
      f <- YieldTermStructure_zeroRate__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for YieldTermStructure_zeroRate with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of YieldTermStructure_forwardRate

`YieldTermStructure_forwardRate__SWIG_0` = function(self, d1, d2, s_arg4, s_arg5, f, extrapolate, .copy = FALSE)
{
  s_arg5 = enumToInteger(s_arg5, "_Compounding"); 
  
  if(length(s_arg5) > 1) {
    warning("using only the first element of s_arg5");
  };
  
  f = enumToInteger(f, "_Frequency"); 
  
  if(length(f) > 1) {
    warning("using only the first element of f");
  };
  
  extrapolate = as.logical(extrapolate);
  ;ans = .Call('R_swig_YieldTermStructure_forwardRate__SWIG_0', self, d1, d2, s_arg4, s_arg5, f, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_InterestRate";
  
  ans
  
}

attr(`YieldTermStructure_forwardRate__SWIG_0`, 'returnType') = '_p_InterestRate'
attr(`YieldTermStructure_forwardRate__SWIG_0`, "inputTypes") = c('_p_boost__shared_ptrT_YieldTermStructure_t', '_p_Date', '_p_Date', '_p_DayCounter', 'character', 'character', 'logical')
class(`YieldTermStructure_forwardRate__SWIG_0`) = c("SWIGFunction", class('YieldTermStructure_forwardRate__SWIG_0'))

# Start of YieldTermStructure_forwardRate

`YieldTermStructure_forwardRate__SWIG_1` = function(self, d1, d2, s_arg4, s_arg5, f, .copy = FALSE)
{
  s_arg5 = enumToInteger(s_arg5, "_Compounding"); 
  
  if(length(s_arg5) > 1) {
    warning("using only the first element of s_arg5");
  };
  
  f = enumToInteger(f, "_Frequency"); 
  
  if(length(f) > 1) {
    warning("using only the first element of f");
  };
  
  ;ans = .Call('R_swig_YieldTermStructure_forwardRate__SWIG_1', self, d1, d2, s_arg4, s_arg5, f, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_InterestRate";
  
  ans
  
}

attr(`YieldTermStructure_forwardRate__SWIG_1`, 'returnType') = '_p_InterestRate'
attr(`YieldTermStructure_forwardRate__SWIG_1`, "inputTypes") = c('_p_boost__shared_ptrT_YieldTermStructure_t', '_p_Date', '_p_Date', '_p_DayCounter', 'character', 'character')
class(`YieldTermStructure_forwardRate__SWIG_1`) = c("SWIGFunction", class('YieldTermStructure_forwardRate__SWIG_1'))

# Start of YieldTermStructure_forwardRate

`YieldTermStructure_forwardRate__SWIG_2` = function(self, d1, d2, s_arg4, s_arg5, .copy = FALSE)
{
  s_arg5 = enumToInteger(s_arg5, "_Compounding"); 
  
  if(length(s_arg5) > 1) {
    warning("using only the first element of s_arg5");
  };
  
  ;ans = .Call('R_swig_YieldTermStructure_forwardRate__SWIG_2', self, d1, d2, s_arg4, s_arg5, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_InterestRate";
  
  ans
  
}

attr(`YieldTermStructure_forwardRate__SWIG_2`, 'returnType') = '_p_InterestRate'
attr(`YieldTermStructure_forwardRate__SWIG_2`, "inputTypes") = c('_p_boost__shared_ptrT_YieldTermStructure_t', '_p_Date', '_p_Date', '_p_DayCounter', 'character')
class(`YieldTermStructure_forwardRate__SWIG_2`) = c("SWIGFunction", class('YieldTermStructure_forwardRate__SWIG_2'))

# Start of YieldTermStructure_forwardRate

`YieldTermStructure_forwardRate__SWIG_3` = function(self, t1, t2, s_arg4, f, extrapolate, .copy = FALSE)
{
  s_arg4 = enumToInteger(s_arg4, "_Compounding"); 
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  f = enumToInteger(f, "_Frequency"); 
  
  if(length(f) > 1) {
    warning("using only the first element of f");
  };
  
  extrapolate = as.logical(extrapolate);
  ;ans = .Call('R_swig_YieldTermStructure_forwardRate__SWIG_3', self, t1, t2, s_arg4, f, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_InterestRate";
  
  ans
  
}

attr(`YieldTermStructure_forwardRate__SWIG_3`, 'returnType') = '_p_InterestRate'
attr(`YieldTermStructure_forwardRate__SWIG_3`, "inputTypes") = c('_p_boost__shared_ptrT_YieldTermStructure_t', 'numeric', 'numeric', 'character', 'character', 'logical')
class(`YieldTermStructure_forwardRate__SWIG_3`) = c("SWIGFunction", class('YieldTermStructure_forwardRate__SWIG_3'))

# Start of YieldTermStructure_forwardRate

`YieldTermStructure_forwardRate__SWIG_4` = function(self, t1, t2, s_arg4, f, .copy = FALSE)
{
  s_arg4 = enumToInteger(s_arg4, "_Compounding"); 
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  f = enumToInteger(f, "_Frequency"); 
  
  if(length(f) > 1) {
    warning("using only the first element of f");
  };
  
  ;ans = .Call('R_swig_YieldTermStructure_forwardRate__SWIG_4', self, t1, t2, s_arg4, f, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_InterestRate";
  
  ans
  
}

attr(`YieldTermStructure_forwardRate__SWIG_4`, 'returnType') = '_p_InterestRate'
attr(`YieldTermStructure_forwardRate__SWIG_4`, "inputTypes") = c('_p_boost__shared_ptrT_YieldTermStructure_t', 'numeric', 'numeric', 'character', 'character')
class(`YieldTermStructure_forwardRate__SWIG_4`) = c("SWIGFunction", class('YieldTermStructure_forwardRate__SWIG_4'))

# Start of YieldTermStructure_forwardRate

`YieldTermStructure_forwardRate__SWIG_5` = function(self, t1, t2, s_arg4, .copy = FALSE)
{
  s_arg4 = enumToInteger(s_arg4, "_Compounding"); 
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  ;ans = .Call('R_swig_YieldTermStructure_forwardRate__SWIG_5', self, t1, t2, s_arg4, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_InterestRate";
  
  ans
  
}

attr(`YieldTermStructure_forwardRate__SWIG_5`, 'returnType') = '_p_InterestRate'
attr(`YieldTermStructure_forwardRate__SWIG_5`, "inputTypes") = c('_p_boost__shared_ptrT_YieldTermStructure_t', 'numeric', 'numeric', 'character')
class(`YieldTermStructure_forwardRate__SWIG_5`) = c("SWIGFunction", class('YieldTermStructure_forwardRate__SWIG_5'))

`YieldTermStructure_forwardRate` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 6
  if (argc == 4) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_YieldTermStructure_t') && is.numeric(argv[[2]]) && is.numeric(argv[[3]]) && is.character(argv[[4]])) {
      f <- YieldTermStructure_forwardRate__SWIG_5; 
    }
  } else if (argc == 5) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_YieldTermStructure_t') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_Date') && extends(argtypes[4], '_p_DayCounter') && is.character(argv[[5]])) {
      f <- YieldTermStructure_forwardRate__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_boost__shared_ptrT_YieldTermStructure_t') && is.numeric(argv[[2]]) && is.numeric(argv[[3]]) && is.character(argv[[4]]) && is.character(argv[[5]])) {
      f <- YieldTermStructure_forwardRate__SWIG_4; 
    }
  } else if (argc == 6) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_YieldTermStructure_t') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_Date') && extends(argtypes[4], '_p_DayCounter') && is.character(argv[[5]]) && is.character(argv[[6]])) {
      f <- YieldTermStructure_forwardRate__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_boost__shared_ptrT_YieldTermStructure_t') && is.numeric(argv[[2]]) && is.numeric(argv[[3]]) && is.character(argv[[4]]) && is.character(argv[[5]]) && extends(argtypes[6], 'logical')) {
      f <- YieldTermStructure_forwardRate__SWIG_3; 
    }
  } else if (argc == 7) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_YieldTermStructure_t') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_Date') && extends(argtypes[4], '_p_DayCounter') && is.character(argv[[5]]) && is.character(argv[[6]]) && extends(argtypes[7], 'logical')) {
      f <- YieldTermStructure_forwardRate__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for YieldTermStructure_forwardRate with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of YieldTermStructure_enableExtrapolation

`YieldTermStructure_enableExtrapolation` = function(self)
{
  ;.Call('R_swig_YieldTermStructure_enableExtrapolation', self, PACKAGE='QuantLib');
  
}

attr(`YieldTermStructure_enableExtrapolation`, 'returnType') = 'void'
attr(`YieldTermStructure_enableExtrapolation`, "inputTypes") = c('_p_boost__shared_ptrT_YieldTermStructure_t')
class(`YieldTermStructure_enableExtrapolation`) = c("SWIGFunction", class('YieldTermStructure_enableExtrapolation'))

# Start of YieldTermStructure_disableExtrapolation

`YieldTermStructure_disableExtrapolation` = function(self)
{
  ;.Call('R_swig_YieldTermStructure_disableExtrapolation', self, PACKAGE='QuantLib');
  
}

attr(`YieldTermStructure_disableExtrapolation`, 'returnType') = 'void'
attr(`YieldTermStructure_disableExtrapolation`, "inputTypes") = c('_p_boost__shared_ptrT_YieldTermStructure_t')
class(`YieldTermStructure_disableExtrapolation`) = c("SWIGFunction", class('YieldTermStructure_disableExtrapolation'))

# Start of YieldTermStructure_allowsExtrapolation

`YieldTermStructure_allowsExtrapolation` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_YieldTermStructure_allowsExtrapolation', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`YieldTermStructure_allowsExtrapolation`, 'returnType') = 'logical'
attr(`YieldTermStructure_allowsExtrapolation`, "inputTypes") = c('_p_boost__shared_ptrT_YieldTermStructure_t')
class(`YieldTermStructure_allowsExtrapolation`) = c("SWIGFunction", class('YieldTermStructure_allowsExtrapolation'))

# Start of accessor method for boost::shared_ptr<(YieldTermStructure)>
setMethod('$', '_p_boost__shared_ptrT_YieldTermStructure_t', function(x, name)

{
  accessorFuns = list('__deref__' = YieldTermStructure___deref__, 'isNull' = YieldTermStructure_isNull, 'asObservable' = YieldTermStructure_asObservable, 'dayCounter' = YieldTermStructure_dayCounter, 'calendar' = YieldTermStructure_calendar, 'referenceDate' = YieldTermStructure_referenceDate, 'maxDate' = YieldTermStructure_maxDate, 'maxTime' = YieldTermStructure_maxTime, 'discount' = YieldTermStructure_discount, 'zeroRate' = YieldTermStructure_zeroRate, 'forwardRate' = YieldTermStructure_forwardRate, 'enableExtrapolation' = YieldTermStructure_enableExtrapolation, 'disableExtrapolation' = YieldTermStructure_disableExtrapolation, 'allowsExtrapolation' = YieldTermStructure_allowsExtrapolation);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for boost::shared_ptr<(YieldTermStructure)>
setMethod('delete', '_p_boost__shared_ptrT_YieldTermStructure_t', function(obj) {delete_boost__shared_ptrT_YieldTermStructure_t(obj)})
# Start of new_YieldTermStructureHandle

`YieldTermStructureHandle__SWIG_0` = function(s_arg1)
{
  ;ans = .Call('R_swig_new_YieldTermStructureHandle__SWIG_0', s_arg1, PACKAGE='QuantLib');
  class(ans) <- "_p_HandleT_YieldTermStructure_t";
  
  reg.finalizer(ans, delete_YieldTermStructureHandle)
  ans
  
}

attr(`YieldTermStructureHandle__SWIG_0`, 'returnType') = '_p_HandleT_YieldTermStructure_t'
attr(`YieldTermStructureHandle__SWIG_0`, "inputTypes") = c('_p_boost__shared_ptrT_YieldTermStructure_t')
class(`YieldTermStructureHandle__SWIG_0`) = c("SWIGFunction", class('YieldTermStructureHandle__SWIG_0'))

# Start of new_YieldTermStructureHandle

`YieldTermStructureHandle__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_YieldTermStructureHandle__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_HandleT_YieldTermStructure_t";
  
  reg.finalizer(ans, delete_YieldTermStructureHandle)
  ans
  
}

attr(`YieldTermStructureHandle__SWIG_1`, 'returnType') = '_p_HandleT_YieldTermStructure_t'
class(`YieldTermStructureHandle__SWIG_1`) = c("SWIGFunction", class('YieldTermStructureHandle__SWIG_1'))

`YieldTermStructureHandle` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- YieldTermStructureHandle__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_YieldTermStructure_t')) {
      f <- YieldTermStructureHandle__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for YieldTermStructureHandle with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of YieldTermStructureHandle___deref__

`YieldTermStructureHandle___deref__` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_YieldTermStructureHandle___deref__', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_YieldTermStructure_t";
  
  ans
  
}

attr(`YieldTermStructureHandle___deref__`, 'returnType') = '_p_boost__shared_ptrT_YieldTermStructure_t'
attr(`YieldTermStructureHandle___deref__`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`YieldTermStructureHandle___deref__`) = c("SWIGFunction", class('YieldTermStructureHandle___deref__'))

# Start of YieldTermStructureHandle_empty

`YieldTermStructureHandle_empty` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_YieldTermStructureHandle_empty', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`YieldTermStructureHandle_empty`, 'returnType') = 'logical'
attr(`YieldTermStructureHandle_empty`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`YieldTermStructureHandle_empty`) = c("SWIGFunction", class('YieldTermStructureHandle_empty'))

# Start of YieldTermStructureHandle_asObservable

`YieldTermStructureHandle_asObservable` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_YieldTermStructureHandle_asObservable', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_Observable_t";
  
  ans
  
}

attr(`YieldTermStructureHandle_asObservable`, 'returnType') = '_p_boost__shared_ptrT_Observable_t'
attr(`YieldTermStructureHandle_asObservable`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`YieldTermStructureHandle_asObservable`) = c("SWIGFunction", class('YieldTermStructureHandle_asObservable'))

# Start of delete_YieldTermStructureHandle

`delete_YieldTermStructureHandle` = function(self)
{
  ;.Call('R_swig_delete_YieldTermStructureHandle', self, PACKAGE='QuantLib');
  
}

attr(`delete_YieldTermStructureHandle`, 'returnType') = 'void'
attr(`delete_YieldTermStructureHandle`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`delete_YieldTermStructureHandle`) = c("SWIGFunction", class('delete_YieldTermStructureHandle'))

# Start of YieldTermStructureHandle_dayCounter

`YieldTermStructureHandle_dayCounter` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_YieldTermStructureHandle_dayCounter', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_DayCounter";
  
  ans
  
}

attr(`YieldTermStructureHandle_dayCounter`, 'returnType') = '_p_DayCounter'
attr(`YieldTermStructureHandle_dayCounter`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`YieldTermStructureHandle_dayCounter`) = c("SWIGFunction", class('YieldTermStructureHandle_dayCounter'))

# Start of YieldTermStructureHandle_calendar

`YieldTermStructureHandle_calendar` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_YieldTermStructureHandle_calendar', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Calendar";
  
  ans
  
}

attr(`YieldTermStructureHandle_calendar`, 'returnType') = '_p_Calendar'
attr(`YieldTermStructureHandle_calendar`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`YieldTermStructureHandle_calendar`) = c("SWIGFunction", class('YieldTermStructureHandle_calendar'))

# Start of YieldTermStructureHandle_referenceDate

`YieldTermStructureHandle_referenceDate` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_YieldTermStructureHandle_referenceDate', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`YieldTermStructureHandle_referenceDate`, 'returnType') = '_p_Date'
attr(`YieldTermStructureHandle_referenceDate`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`YieldTermStructureHandle_referenceDate`) = c("SWIGFunction", class('YieldTermStructureHandle_referenceDate'))

# Start of YieldTermStructureHandle_maxDate

`YieldTermStructureHandle_maxDate` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_YieldTermStructureHandle_maxDate', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`YieldTermStructureHandle_maxDate`, 'returnType') = '_p_Date'
attr(`YieldTermStructureHandle_maxDate`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`YieldTermStructureHandle_maxDate`) = c("SWIGFunction", class('YieldTermStructureHandle_maxDate'))

# Start of YieldTermStructureHandle_maxTime

`YieldTermStructureHandle_maxTime` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_YieldTermStructureHandle_maxTime', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`YieldTermStructureHandle_maxTime`, 'returnType') = 'numeric'
attr(`YieldTermStructureHandle_maxTime`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`YieldTermStructureHandle_maxTime`) = c("SWIGFunction", class('YieldTermStructureHandle_maxTime'))

# Start of YieldTermStructureHandle_discount

`YieldTermStructureHandle_discount__SWIG_0` = function(self, s_arg2, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_YieldTermStructureHandle_discount__SWIG_0', self, s_arg2, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`YieldTermStructureHandle_discount__SWIG_0`, 'returnType') = 'numeric'
attr(`YieldTermStructureHandle_discount__SWIG_0`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t', '_p_Date', 'logical')
class(`YieldTermStructureHandle_discount__SWIG_0`) = c("SWIGFunction", class('YieldTermStructureHandle_discount__SWIG_0'))

# Start of YieldTermStructureHandle_discount

`YieldTermStructureHandle_discount__SWIG_1` = function(self, s_arg2, .copy = FALSE)
{
  ;.Call('R_swig_YieldTermStructureHandle_discount__SWIG_1', self, s_arg2, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`YieldTermStructureHandle_discount__SWIG_1`, 'returnType') = 'numeric'
attr(`YieldTermStructureHandle_discount__SWIG_1`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t', '_p_Date')
class(`YieldTermStructureHandle_discount__SWIG_1`) = c("SWIGFunction", class('YieldTermStructureHandle_discount__SWIG_1'))

# Start of YieldTermStructureHandle_discount

`YieldTermStructureHandle_discount__SWIG_2` = function(self, s_arg2, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_YieldTermStructureHandle_discount__SWIG_2', self, s_arg2, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`YieldTermStructureHandle_discount__SWIG_2`, 'returnType') = 'numeric'
attr(`YieldTermStructureHandle_discount__SWIG_2`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t', 'numeric', 'logical')
class(`YieldTermStructureHandle_discount__SWIG_2`) = c("SWIGFunction", class('YieldTermStructureHandle_discount__SWIG_2'))

# Start of YieldTermStructureHandle_discount

`YieldTermStructureHandle_discount__SWIG_3` = function(self, s_arg2, .copy = FALSE)
{
  ;.Call('R_swig_YieldTermStructureHandle_discount__SWIG_3', self, s_arg2, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`YieldTermStructureHandle_discount__SWIG_3`, 'returnType') = 'numeric'
attr(`YieldTermStructureHandle_discount__SWIG_3`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t', 'numeric')
class(`YieldTermStructureHandle_discount__SWIG_3`) = c("SWIGFunction", class('YieldTermStructureHandle_discount__SWIG_3'))

`YieldTermStructureHandle_discount` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 2) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t') && extends(argtypes[2], '_p_Date')) {
      f <- YieldTermStructureHandle_discount__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t') && is.numeric(argv[[2]])) {
      f <- YieldTermStructureHandle_discount__SWIG_3; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], 'logical')) {
      f <- YieldTermStructureHandle_discount__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- YieldTermStructureHandle_discount__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for YieldTermStructureHandle_discount with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of YieldTermStructureHandle_zeroRate

`YieldTermStructureHandle_zeroRate__SWIG_0` = function(self, d, s_arg3, s_arg4, f, extrapolate, .copy = FALSE)
{
  s_arg4 = enumToInteger(s_arg4, "_Compounding"); 
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  f = enumToInteger(f, "_Frequency"); 
  
  if(length(f) > 1) {
    warning("using only the first element of f");
  };
  
  extrapolate = as.logical(extrapolate);
  ;ans = .Call('R_swig_YieldTermStructureHandle_zeroRate__SWIG_0', self, d, s_arg3, s_arg4, f, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_InterestRate";
  
  ans
  
}

attr(`YieldTermStructureHandle_zeroRate__SWIG_0`, 'returnType') = '_p_InterestRate'
attr(`YieldTermStructureHandle_zeroRate__SWIG_0`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t', '_p_Date', '_p_DayCounter', 'character', 'character', 'logical')
class(`YieldTermStructureHandle_zeroRate__SWIG_0`) = c("SWIGFunction", class('YieldTermStructureHandle_zeroRate__SWIG_0'))

# Start of YieldTermStructureHandle_zeroRate

`YieldTermStructureHandle_zeroRate__SWIG_1` = function(self, d, s_arg3, s_arg4, f, .copy = FALSE)
{
  s_arg4 = enumToInteger(s_arg4, "_Compounding"); 
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  f = enumToInteger(f, "_Frequency"); 
  
  if(length(f) > 1) {
    warning("using only the first element of f");
  };
  
  ;ans = .Call('R_swig_YieldTermStructureHandle_zeroRate__SWIG_1', self, d, s_arg3, s_arg4, f, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_InterestRate";
  
  ans
  
}

attr(`YieldTermStructureHandle_zeroRate__SWIG_1`, 'returnType') = '_p_InterestRate'
attr(`YieldTermStructureHandle_zeroRate__SWIG_1`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t', '_p_Date', '_p_DayCounter', 'character', 'character')
class(`YieldTermStructureHandle_zeroRate__SWIG_1`) = c("SWIGFunction", class('YieldTermStructureHandle_zeroRate__SWIG_1'))

# Start of YieldTermStructureHandle_zeroRate

`YieldTermStructureHandle_zeroRate__SWIG_2` = function(self, d, s_arg3, s_arg4, .copy = FALSE)
{
  s_arg4 = enumToInteger(s_arg4, "_Compounding"); 
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  ;ans = .Call('R_swig_YieldTermStructureHandle_zeroRate__SWIG_2', self, d, s_arg3, s_arg4, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_InterestRate";
  
  ans
  
}

attr(`YieldTermStructureHandle_zeroRate__SWIG_2`, 'returnType') = '_p_InterestRate'
attr(`YieldTermStructureHandle_zeroRate__SWIG_2`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t', '_p_Date', '_p_DayCounter', 'character')
class(`YieldTermStructureHandle_zeroRate__SWIG_2`) = c("SWIGFunction", class('YieldTermStructureHandle_zeroRate__SWIG_2'))

# Start of YieldTermStructureHandle_zeroRate

`YieldTermStructureHandle_zeroRate__SWIG_3` = function(self, t, s_arg3, f, extrapolate, .copy = FALSE)
{
  s_arg3 = enumToInteger(s_arg3, "_Compounding"); 
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  f = enumToInteger(f, "_Frequency"); 
  
  if(length(f) > 1) {
    warning("using only the first element of f");
  };
  
  extrapolate = as.logical(extrapolate);
  ;ans = .Call('R_swig_YieldTermStructureHandle_zeroRate__SWIG_3', self, t, s_arg3, f, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_InterestRate";
  
  ans
  
}

attr(`YieldTermStructureHandle_zeroRate__SWIG_3`, 'returnType') = '_p_InterestRate'
attr(`YieldTermStructureHandle_zeroRate__SWIG_3`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t', 'numeric', 'character', 'character', 'logical')
class(`YieldTermStructureHandle_zeroRate__SWIG_3`) = c("SWIGFunction", class('YieldTermStructureHandle_zeroRate__SWIG_3'))

# Start of YieldTermStructureHandle_zeroRate

`YieldTermStructureHandle_zeroRate__SWIG_4` = function(self, t, s_arg3, f, .copy = FALSE)
{
  s_arg3 = enumToInteger(s_arg3, "_Compounding"); 
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  f = enumToInteger(f, "_Frequency"); 
  
  if(length(f) > 1) {
    warning("using only the first element of f");
  };
  
  ;ans = .Call('R_swig_YieldTermStructureHandle_zeroRate__SWIG_4', self, t, s_arg3, f, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_InterestRate";
  
  ans
  
}

attr(`YieldTermStructureHandle_zeroRate__SWIG_4`, 'returnType') = '_p_InterestRate'
attr(`YieldTermStructureHandle_zeroRate__SWIG_4`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t', 'numeric', 'character', 'character')
class(`YieldTermStructureHandle_zeroRate__SWIG_4`) = c("SWIGFunction", class('YieldTermStructureHandle_zeroRate__SWIG_4'))

# Start of YieldTermStructureHandle_zeroRate

`YieldTermStructureHandle_zeroRate__SWIG_5` = function(self, t, s_arg3, .copy = FALSE)
{
  s_arg3 = enumToInteger(s_arg3, "_Compounding"); 
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  ;ans = .Call('R_swig_YieldTermStructureHandle_zeroRate__SWIG_5', self, t, s_arg3, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_InterestRate";
  
  ans
  
}

attr(`YieldTermStructureHandle_zeroRate__SWIG_5`, 'returnType') = '_p_InterestRate'
attr(`YieldTermStructureHandle_zeroRate__SWIG_5`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t', 'numeric', 'character')
class(`YieldTermStructureHandle_zeroRate__SWIG_5`) = c("SWIGFunction", class('YieldTermStructureHandle_zeroRate__SWIG_5'))

`YieldTermStructureHandle_zeroRate` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 6
  if (argc == 3) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t') && is.numeric(argv[[2]]) && is.character(argv[[3]])) {
      f <- YieldTermStructureHandle_zeroRate__SWIG_5; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_DayCounter') && is.character(argv[[4]])) {
      f <- YieldTermStructureHandle_zeroRate__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t') && is.numeric(argv[[2]]) && is.character(argv[[3]]) && is.character(argv[[4]])) {
      f <- YieldTermStructureHandle_zeroRate__SWIG_4; 
    }
  } else if (argc == 5) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_DayCounter') && is.character(argv[[4]]) && is.character(argv[[5]])) {
      f <- YieldTermStructureHandle_zeroRate__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t') && is.numeric(argv[[2]]) && is.character(argv[[3]]) && is.character(argv[[4]]) && extends(argtypes[5], 'logical')) {
      f <- YieldTermStructureHandle_zeroRate__SWIG_3; 
    }
  } else if (argc == 6) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_DayCounter') && is.character(argv[[4]]) && is.character(argv[[5]]) && extends(argtypes[6], 'logical')) {
      f <- YieldTermStructureHandle_zeroRate__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for YieldTermStructureHandle_zeroRate with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of YieldTermStructureHandle_forwardRate

`YieldTermStructureHandle_forwardRate__SWIG_0` = function(self, d1, d2, s_arg4, s_arg5, f, extrapolate, .copy = FALSE)
{
  s_arg5 = enumToInteger(s_arg5, "_Compounding"); 
  
  if(length(s_arg5) > 1) {
    warning("using only the first element of s_arg5");
  };
  
  f = enumToInteger(f, "_Frequency"); 
  
  if(length(f) > 1) {
    warning("using only the first element of f");
  };
  
  extrapolate = as.logical(extrapolate);
  ;ans = .Call('R_swig_YieldTermStructureHandle_forwardRate__SWIG_0', self, d1, d2, s_arg4, s_arg5, f, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_InterestRate";
  
  ans
  
}

attr(`YieldTermStructureHandle_forwardRate__SWIG_0`, 'returnType') = '_p_InterestRate'
attr(`YieldTermStructureHandle_forwardRate__SWIG_0`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t', '_p_Date', '_p_Date', '_p_DayCounter', 'character', 'character', 'logical')
class(`YieldTermStructureHandle_forwardRate__SWIG_0`) = c("SWIGFunction", class('YieldTermStructureHandle_forwardRate__SWIG_0'))

# Start of YieldTermStructureHandle_forwardRate

`YieldTermStructureHandle_forwardRate__SWIG_1` = function(self, d1, d2, s_arg4, s_arg5, f, .copy = FALSE)
{
  s_arg5 = enumToInteger(s_arg5, "_Compounding"); 
  
  if(length(s_arg5) > 1) {
    warning("using only the first element of s_arg5");
  };
  
  f = enumToInteger(f, "_Frequency"); 
  
  if(length(f) > 1) {
    warning("using only the first element of f");
  };
  
  ;ans = .Call('R_swig_YieldTermStructureHandle_forwardRate__SWIG_1', self, d1, d2, s_arg4, s_arg5, f, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_InterestRate";
  
  ans
  
}

attr(`YieldTermStructureHandle_forwardRate__SWIG_1`, 'returnType') = '_p_InterestRate'
attr(`YieldTermStructureHandle_forwardRate__SWIG_1`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t', '_p_Date', '_p_Date', '_p_DayCounter', 'character', 'character')
class(`YieldTermStructureHandle_forwardRate__SWIG_1`) = c("SWIGFunction", class('YieldTermStructureHandle_forwardRate__SWIG_1'))

# Start of YieldTermStructureHandle_forwardRate

`YieldTermStructureHandle_forwardRate__SWIG_2` = function(self, d1, d2, s_arg4, s_arg5, .copy = FALSE)
{
  s_arg5 = enumToInteger(s_arg5, "_Compounding"); 
  
  if(length(s_arg5) > 1) {
    warning("using only the first element of s_arg5");
  };
  
  ;ans = .Call('R_swig_YieldTermStructureHandle_forwardRate__SWIG_2', self, d1, d2, s_arg4, s_arg5, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_InterestRate";
  
  ans
  
}

attr(`YieldTermStructureHandle_forwardRate__SWIG_2`, 'returnType') = '_p_InterestRate'
attr(`YieldTermStructureHandle_forwardRate__SWIG_2`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t', '_p_Date', '_p_Date', '_p_DayCounter', 'character')
class(`YieldTermStructureHandle_forwardRate__SWIG_2`) = c("SWIGFunction", class('YieldTermStructureHandle_forwardRate__SWIG_2'))

# Start of YieldTermStructureHandle_forwardRate

`YieldTermStructureHandle_forwardRate__SWIG_3` = function(self, t1, t2, s_arg4, f, extrapolate, .copy = FALSE)
{
  s_arg4 = enumToInteger(s_arg4, "_Compounding"); 
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  f = enumToInteger(f, "_Frequency"); 
  
  if(length(f) > 1) {
    warning("using only the first element of f");
  };
  
  extrapolate = as.logical(extrapolate);
  ;ans = .Call('R_swig_YieldTermStructureHandle_forwardRate__SWIG_3', self, t1, t2, s_arg4, f, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_InterestRate";
  
  ans
  
}

attr(`YieldTermStructureHandle_forwardRate__SWIG_3`, 'returnType') = '_p_InterestRate'
attr(`YieldTermStructureHandle_forwardRate__SWIG_3`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t', 'numeric', 'numeric', 'character', 'character', 'logical')
class(`YieldTermStructureHandle_forwardRate__SWIG_3`) = c("SWIGFunction", class('YieldTermStructureHandle_forwardRate__SWIG_3'))

# Start of YieldTermStructureHandle_forwardRate

`YieldTermStructureHandle_forwardRate__SWIG_4` = function(self, t1, t2, s_arg4, f, .copy = FALSE)
{
  s_arg4 = enumToInteger(s_arg4, "_Compounding"); 
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  f = enumToInteger(f, "_Frequency"); 
  
  if(length(f) > 1) {
    warning("using only the first element of f");
  };
  
  ;ans = .Call('R_swig_YieldTermStructureHandle_forwardRate__SWIG_4', self, t1, t2, s_arg4, f, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_InterestRate";
  
  ans
  
}

attr(`YieldTermStructureHandle_forwardRate__SWIG_4`, 'returnType') = '_p_InterestRate'
attr(`YieldTermStructureHandle_forwardRate__SWIG_4`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t', 'numeric', 'numeric', 'character', 'character')
class(`YieldTermStructureHandle_forwardRate__SWIG_4`) = c("SWIGFunction", class('YieldTermStructureHandle_forwardRate__SWIG_4'))

# Start of YieldTermStructureHandle_forwardRate

`YieldTermStructureHandle_forwardRate__SWIG_5` = function(self, t1, t2, s_arg4, .copy = FALSE)
{
  s_arg4 = enumToInteger(s_arg4, "_Compounding"); 
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  ;ans = .Call('R_swig_YieldTermStructureHandle_forwardRate__SWIG_5', self, t1, t2, s_arg4, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_InterestRate";
  
  ans
  
}

attr(`YieldTermStructureHandle_forwardRate__SWIG_5`, 'returnType') = '_p_InterestRate'
attr(`YieldTermStructureHandle_forwardRate__SWIG_5`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t', 'numeric', 'numeric', 'character')
class(`YieldTermStructureHandle_forwardRate__SWIG_5`) = c("SWIGFunction", class('YieldTermStructureHandle_forwardRate__SWIG_5'))

`YieldTermStructureHandle_forwardRate` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 6
  if (argc == 4) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t') && is.numeric(argv[[2]]) && is.numeric(argv[[3]]) && is.character(argv[[4]])) {
      f <- YieldTermStructureHandle_forwardRate__SWIG_5; 
    }
  } else if (argc == 5) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_Date') && extends(argtypes[4], '_p_DayCounter') && is.character(argv[[5]])) {
      f <- YieldTermStructureHandle_forwardRate__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t') && is.numeric(argv[[2]]) && is.numeric(argv[[3]]) && is.character(argv[[4]]) && is.character(argv[[5]])) {
      f <- YieldTermStructureHandle_forwardRate__SWIG_4; 
    }
  } else if (argc == 6) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_Date') && extends(argtypes[4], '_p_DayCounter') && is.character(argv[[5]]) && is.character(argv[[6]])) {
      f <- YieldTermStructureHandle_forwardRate__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t') && is.numeric(argv[[2]]) && is.numeric(argv[[3]]) && is.character(argv[[4]]) && is.character(argv[[5]]) && extends(argtypes[6], 'logical')) {
      f <- YieldTermStructureHandle_forwardRate__SWIG_3; 
    }
  } else if (argc == 7) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_Date') && extends(argtypes[4], '_p_DayCounter') && is.character(argv[[5]]) && is.character(argv[[6]]) && extends(argtypes[7], 'logical')) {
      f <- YieldTermStructureHandle_forwardRate__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for YieldTermStructureHandle_forwardRate with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of YieldTermStructureHandle_enableExtrapolation

`YieldTermStructureHandle_enableExtrapolation` = function(self)
{
  ;.Call('R_swig_YieldTermStructureHandle_enableExtrapolation', self, PACKAGE='QuantLib');
  
}

attr(`YieldTermStructureHandle_enableExtrapolation`, 'returnType') = 'void'
attr(`YieldTermStructureHandle_enableExtrapolation`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`YieldTermStructureHandle_enableExtrapolation`) = c("SWIGFunction", class('YieldTermStructureHandle_enableExtrapolation'))

# Start of YieldTermStructureHandle_disableExtrapolation

`YieldTermStructureHandle_disableExtrapolation` = function(self)
{
  ;.Call('R_swig_YieldTermStructureHandle_disableExtrapolation', self, PACKAGE='QuantLib');
  
}

attr(`YieldTermStructureHandle_disableExtrapolation`, 'returnType') = 'void'
attr(`YieldTermStructureHandle_disableExtrapolation`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`YieldTermStructureHandle_disableExtrapolation`) = c("SWIGFunction", class('YieldTermStructureHandle_disableExtrapolation'))

# Start of YieldTermStructureHandle_allowsExtrapolation

`YieldTermStructureHandle_allowsExtrapolation` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_YieldTermStructureHandle_allowsExtrapolation', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`YieldTermStructureHandle_allowsExtrapolation`, 'returnType') = 'logical'
attr(`YieldTermStructureHandle_allowsExtrapolation`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`YieldTermStructureHandle_allowsExtrapolation`) = c("SWIGFunction", class('YieldTermStructureHandle_allowsExtrapolation'))

# Start of accessor method for Handle<(YieldTermStructure)>
setMethod('$', '_p_HandleT_YieldTermStructure_t', function(x, name)

{
  accessorFuns = list('__deref__' = YieldTermStructureHandle___deref__, 'empty' = YieldTermStructureHandle_empty, 'asObservable' = YieldTermStructureHandle_asObservable, 'dayCounter' = YieldTermStructureHandle_dayCounter, 'calendar' = YieldTermStructureHandle_calendar, 'referenceDate' = YieldTermStructureHandle_referenceDate, 'maxDate' = YieldTermStructureHandle_maxDate, 'maxTime' = YieldTermStructureHandle_maxTime, 'discount' = YieldTermStructureHandle_discount, 'zeroRate' = YieldTermStructureHandle_zeroRate, 'forwardRate' = YieldTermStructureHandle_forwardRate, 'enableExtrapolation' = YieldTermStructureHandle_enableExtrapolation, 'disableExtrapolation' = YieldTermStructureHandle_disableExtrapolation, 'allowsExtrapolation' = YieldTermStructureHandle_allowsExtrapolation);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for Handle<(YieldTermStructure)>
setMethod('delete', '_p_HandleT_YieldTermStructure_t', function(obj) {delete_HandleT_YieldTermStructure_t(obj)})
# Start of new_RelinkableYieldTermStructureHandle

`RelinkableYieldTermStructureHandle__SWIG_0` = function(s_arg1)
{
  ;ans = .Call('R_swig_new_RelinkableYieldTermStructureHandle__SWIG_0', s_arg1, PACKAGE='QuantLib');
  class(ans) <- "_p_RelinkableHandleT_YieldTermStructure_t";
  
  reg.finalizer(ans, delete_RelinkableYieldTermStructureHandle)
  ans
  
}

attr(`RelinkableYieldTermStructureHandle__SWIG_0`, 'returnType') = '_p_RelinkableHandleT_YieldTermStructure_t'
attr(`RelinkableYieldTermStructureHandle__SWIG_0`, "inputTypes") = c('_p_boost__shared_ptrT_YieldTermStructure_t')
class(`RelinkableYieldTermStructureHandle__SWIG_0`) = c("SWIGFunction", class('RelinkableYieldTermStructureHandle__SWIG_0'))

# Start of new_RelinkableYieldTermStructureHandle

`RelinkableYieldTermStructureHandle__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_RelinkableYieldTermStructureHandle__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_RelinkableHandleT_YieldTermStructure_t";
  
  reg.finalizer(ans, delete_RelinkableYieldTermStructureHandle)
  ans
  
}

attr(`RelinkableYieldTermStructureHandle__SWIG_1`, 'returnType') = '_p_RelinkableHandleT_YieldTermStructure_t'
class(`RelinkableYieldTermStructureHandle__SWIG_1`) = c("SWIGFunction", class('RelinkableYieldTermStructureHandle__SWIG_1'))

`RelinkableYieldTermStructureHandle` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- RelinkableYieldTermStructureHandle__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_YieldTermStructure_t')) {
      f <- RelinkableYieldTermStructureHandle__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for RelinkableYieldTermStructureHandle with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of RelinkableYieldTermStructureHandle_linkTo

`RelinkableYieldTermStructureHandle_linkTo` = function(self, s_arg2)
{
  ;.Call('R_swig_RelinkableYieldTermStructureHandle_linkTo', self, s_arg2, PACKAGE='QuantLib');
  
}

attr(`RelinkableYieldTermStructureHandle_linkTo`, 'returnType') = 'void'
attr(`RelinkableYieldTermStructureHandle_linkTo`, "inputTypes") = c('_p_RelinkableHandleT_YieldTermStructure_t', '_p_boost__shared_ptrT_YieldTermStructure_t')
class(`RelinkableYieldTermStructureHandle_linkTo`) = c("SWIGFunction", class('RelinkableYieldTermStructureHandle_linkTo'))

# Start of delete_RelinkableYieldTermStructureHandle

`delete_RelinkableYieldTermStructureHandle` = function(self)
{
  ;.Call('R_swig_delete_RelinkableYieldTermStructureHandle', self, PACKAGE='QuantLib');
  
}

attr(`delete_RelinkableYieldTermStructureHandle`, 'returnType') = 'void'
attr(`delete_RelinkableYieldTermStructureHandle`, "inputTypes") = c('_p_RelinkableHandleT_YieldTermStructure_t')
class(`delete_RelinkableYieldTermStructureHandle`) = c("SWIGFunction", class('delete_RelinkableYieldTermStructureHandle'))

# Start of accessor method for RelinkableHandle<(YieldTermStructure)>
setMethod('$', '_p_RelinkableHandleT_YieldTermStructure_t', function(x, name)

{
  accessorFuns = list('linkTo' = RelinkableYieldTermStructureHandle_linkTo);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for RelinkableHandle<(YieldTermStructure)>
setMethod('delete', '_p_RelinkableHandleT_YieldTermStructure_t', function(obj) {delete_RelinkableHandleT_YieldTermStructure_t(obj)})
# Start of new_ImpliedTermStructure

`ImpliedTermStructure` = function(curveHandle, referenceDate)
{
  ;ans = .Call('R_swig_new_ImpliedTermStructure', curveHandle, referenceDate, PACKAGE='QuantLib');
  class(ans) <- "_p_ImpliedTermStructurePtr";
  
  reg.finalizer(ans, delete_ImpliedTermStructure)
  ans
  
}

attr(`ImpliedTermStructure`, 'returnType') = '_p_ImpliedTermStructurePtr'
attr(`ImpliedTermStructure`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t', '_p_Date')
class(`ImpliedTermStructure`) = c("SWIGFunction", class('ImpliedTermStructure'))

# Start of delete_ImpliedTermStructure

`delete_ImpliedTermStructure` = function(self)
{
  ;.Call('R_swig_delete_ImpliedTermStructure', self, PACKAGE='QuantLib');
  
}

attr(`delete_ImpliedTermStructure`, 'returnType') = 'void'
attr(`delete_ImpliedTermStructure`, "inputTypes") = c('_p_ImpliedTermStructurePtr')
class(`delete_ImpliedTermStructure`) = c("SWIGFunction", class('delete_ImpliedTermStructure'))

setMethod('delete', '_p_ImpliedTermStructurePtr', function(obj) {delete_ImpliedTermStructurePtr(obj)})
# Start of new_ZeroSpreadedTermStructure

`ZeroSpreadedTermStructure` = function(curveHandle, spreadHandle)
{
  ;ans = .Call('R_swig_new_ZeroSpreadedTermStructure', curveHandle, spreadHandle, PACKAGE='QuantLib');
  class(ans) <- "_p_ZeroSpreadedTermStructurePtr";
  
  reg.finalizer(ans, delete_ZeroSpreadedTermStructure)
  ans
  
}

attr(`ZeroSpreadedTermStructure`, 'returnType') = '_p_ZeroSpreadedTermStructurePtr'
attr(`ZeroSpreadedTermStructure`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t', '_p_HandleT_Quote_t')
class(`ZeroSpreadedTermStructure`) = c("SWIGFunction", class('ZeroSpreadedTermStructure'))

# Start of delete_ZeroSpreadedTermStructure

`delete_ZeroSpreadedTermStructure` = function(self)
{
  ;.Call('R_swig_delete_ZeroSpreadedTermStructure', self, PACKAGE='QuantLib');
  
}

attr(`delete_ZeroSpreadedTermStructure`, 'returnType') = 'void'
attr(`delete_ZeroSpreadedTermStructure`, "inputTypes") = c('_p_ZeroSpreadedTermStructurePtr')
class(`delete_ZeroSpreadedTermStructure`) = c("SWIGFunction", class('delete_ZeroSpreadedTermStructure'))

setMethod('delete', '_p_ZeroSpreadedTermStructurePtr', function(obj) {delete_ZeroSpreadedTermStructurePtr(obj)})
# Start of new_ForwardSpreadedTermStructure

`ForwardSpreadedTermStructure` = function(curveHandle, spreadHandle)
{
  ;ans = .Call('R_swig_new_ForwardSpreadedTermStructure', curveHandle, spreadHandle, PACKAGE='QuantLib');
  class(ans) <- "_p_ForwardSpreadedTermStructurePtr";
  
  reg.finalizer(ans, delete_ForwardSpreadedTermStructure)
  ans
  
}

attr(`ForwardSpreadedTermStructure`, 'returnType') = '_p_ForwardSpreadedTermStructurePtr'
attr(`ForwardSpreadedTermStructure`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t', '_p_HandleT_Quote_t')
class(`ForwardSpreadedTermStructure`) = c("SWIGFunction", class('ForwardSpreadedTermStructure'))

# Start of delete_ForwardSpreadedTermStructure

`delete_ForwardSpreadedTermStructure` = function(self)
{
  ;.Call('R_swig_delete_ForwardSpreadedTermStructure', self, PACKAGE='QuantLib');
  
}

attr(`delete_ForwardSpreadedTermStructure`, 'returnType') = 'void'
attr(`delete_ForwardSpreadedTermStructure`, "inputTypes") = c('_p_ForwardSpreadedTermStructurePtr')
class(`delete_ForwardSpreadedTermStructure`) = c("SWIGFunction", class('delete_ForwardSpreadedTermStructure'))

setMethod('delete', '_p_ForwardSpreadedTermStructurePtr', function(obj) {delete_ForwardSpreadedTermStructurePtr(obj)})
# Start of new_FlatForward

`FlatForward__SWIG_0` = function(referenceDate, forward, dayCounter, compounding, frequency)
{
  compounding = enumToInteger(compounding, "_Compounding"); 
  
  if(length(compounding) > 1) {
    warning("using only the first element of compounding");
  };
  
  frequency = enumToInteger(frequency, "_Frequency"); 
  
  if(length(frequency) > 1) {
    warning("using only the first element of frequency");
  };
  
  ;ans = .Call('R_swig_new_FlatForward__SWIG_0', referenceDate, forward, dayCounter, compounding, frequency, PACKAGE='QuantLib');
  class(ans) <- "_p_FlatForwardPtr";
  
  reg.finalizer(ans, delete_FlatForward)
  ans
  
}

attr(`FlatForward__SWIG_0`, 'returnType') = '_p_FlatForwardPtr'
attr(`FlatForward__SWIG_0`, "inputTypes") = c('_p_Date', '_p_HandleT_Quote_t', '_p_DayCounter', 'character', 'character')
class(`FlatForward__SWIG_0`) = c("SWIGFunction", class('FlatForward__SWIG_0'))

# Start of new_FlatForward

`FlatForward__SWIG_1` = function(referenceDate, forward, dayCounter, compounding)
{
  compounding = enumToInteger(compounding, "_Compounding"); 
  
  if(length(compounding) > 1) {
    warning("using only the first element of compounding");
  };
  
  ;ans = .Call('R_swig_new_FlatForward__SWIG_1', referenceDate, forward, dayCounter, compounding, PACKAGE='QuantLib');
  class(ans) <- "_p_FlatForwardPtr";
  
  reg.finalizer(ans, delete_FlatForward)
  ans
  
}

attr(`FlatForward__SWIG_1`, 'returnType') = '_p_FlatForwardPtr'
attr(`FlatForward__SWIG_1`, "inputTypes") = c('_p_Date', '_p_HandleT_Quote_t', '_p_DayCounter', 'character')
class(`FlatForward__SWIG_1`) = c("SWIGFunction", class('FlatForward__SWIG_1'))

# Start of new_FlatForward

`FlatForward__SWIG_2` = function(referenceDate, forward, dayCounter)
{
  ;ans = .Call('R_swig_new_FlatForward__SWIG_2', referenceDate, forward, dayCounter, PACKAGE='QuantLib');
  class(ans) <- "_p_FlatForwardPtr";
  
  reg.finalizer(ans, delete_FlatForward)
  ans
  
}

attr(`FlatForward__SWIG_2`, 'returnType') = '_p_FlatForwardPtr'
attr(`FlatForward__SWIG_2`, "inputTypes") = c('_p_Date', '_p_HandleT_Quote_t', '_p_DayCounter')
class(`FlatForward__SWIG_2`) = c("SWIGFunction", class('FlatForward__SWIG_2'))

# Start of new_FlatForward

`FlatForward__SWIG_3` = function(referenceDate, forward, dayCounter, compounding, frequency)
{
  compounding = enumToInteger(compounding, "_Compounding"); 
  
  if(length(compounding) > 1) {
    warning("using only the first element of compounding");
  };
  
  frequency = enumToInteger(frequency, "_Frequency"); 
  
  if(length(frequency) > 1) {
    warning("using only the first element of frequency");
  };
  
  ;ans = .Call('R_swig_new_FlatForward__SWIG_3', referenceDate, forward, dayCounter, compounding, frequency, PACKAGE='QuantLib');
  class(ans) <- "_p_FlatForwardPtr";
  
  reg.finalizer(ans, delete_FlatForward)
  ans
  
}

attr(`FlatForward__SWIG_3`, 'returnType') = '_p_FlatForwardPtr'
attr(`FlatForward__SWIG_3`, "inputTypes") = c('_p_Date', 'numeric', '_p_DayCounter', 'character', 'character')
class(`FlatForward__SWIG_3`) = c("SWIGFunction", class('FlatForward__SWIG_3'))

# Start of new_FlatForward

`FlatForward__SWIG_4` = function(referenceDate, forward, dayCounter, compounding)
{
  compounding = enumToInteger(compounding, "_Compounding"); 
  
  if(length(compounding) > 1) {
    warning("using only the first element of compounding");
  };
  
  ;ans = .Call('R_swig_new_FlatForward__SWIG_4', referenceDate, forward, dayCounter, compounding, PACKAGE='QuantLib');
  class(ans) <- "_p_FlatForwardPtr";
  
  reg.finalizer(ans, delete_FlatForward)
  ans
  
}

attr(`FlatForward__SWIG_4`, 'returnType') = '_p_FlatForwardPtr'
attr(`FlatForward__SWIG_4`, "inputTypes") = c('_p_Date', 'numeric', '_p_DayCounter', 'character')
class(`FlatForward__SWIG_4`) = c("SWIGFunction", class('FlatForward__SWIG_4'))

# Start of new_FlatForward

`FlatForward__SWIG_5` = function(referenceDate, forward, dayCounter)
{
  ;ans = .Call('R_swig_new_FlatForward__SWIG_5', referenceDate, forward, dayCounter, PACKAGE='QuantLib');
  class(ans) <- "_p_FlatForwardPtr";
  
  reg.finalizer(ans, delete_FlatForward)
  ans
  
}

attr(`FlatForward__SWIG_5`, 'returnType') = '_p_FlatForwardPtr'
attr(`FlatForward__SWIG_5`, "inputTypes") = c('_p_Date', 'numeric', '_p_DayCounter')
class(`FlatForward__SWIG_5`) = c("SWIGFunction", class('FlatForward__SWIG_5'))

# Start of new_FlatForward

`FlatForward__SWIG_6` = function(settlementDays, calendar, forward, dayCounter, compounding, frequency)
{
  settlementDays = as.integer(settlementDays); 
  
  if(length(settlementDays) > 1) {
    warning("using only the first element of settlementDays");
  };
  
  
  
  
  compounding = enumToInteger(compounding, "_Compounding"); 
  
  if(length(compounding) > 1) {
    warning("using only the first element of compounding");
  };
  
  frequency = enumToInteger(frequency, "_Frequency"); 
  
  if(length(frequency) > 1) {
    warning("using only the first element of frequency");
  };
  
  ;ans = .Call('R_swig_new_FlatForward__SWIG_6', settlementDays, calendar, forward, dayCounter, compounding, frequency, PACKAGE='QuantLib');
  class(ans) <- "_p_FlatForwardPtr";
  
  reg.finalizer(ans, delete_FlatForward)
  ans
  
}

attr(`FlatForward__SWIG_6`, 'returnType') = '_p_FlatForwardPtr'
attr(`FlatForward__SWIG_6`, "inputTypes") = c('integer', '_p_Calendar', '_p_HandleT_Quote_t', '_p_DayCounter', 'character', 'character')
class(`FlatForward__SWIG_6`) = c("SWIGFunction", class('FlatForward__SWIG_6'))

# Start of new_FlatForward

`FlatForward__SWIG_7` = function(settlementDays, calendar, forward, dayCounter, compounding)
{
  settlementDays = as.integer(settlementDays); 
  
  if(length(settlementDays) > 1) {
    warning("using only the first element of settlementDays");
  };
  
  
  
  
  compounding = enumToInteger(compounding, "_Compounding"); 
  
  if(length(compounding) > 1) {
    warning("using only the first element of compounding");
  };
  
  ;ans = .Call('R_swig_new_FlatForward__SWIG_7', settlementDays, calendar, forward, dayCounter, compounding, PACKAGE='QuantLib');
  class(ans) <- "_p_FlatForwardPtr";
  
  reg.finalizer(ans, delete_FlatForward)
  ans
  
}

attr(`FlatForward__SWIG_7`, 'returnType') = '_p_FlatForwardPtr'
attr(`FlatForward__SWIG_7`, "inputTypes") = c('integer', '_p_Calendar', '_p_HandleT_Quote_t', '_p_DayCounter', 'character')
class(`FlatForward__SWIG_7`) = c("SWIGFunction", class('FlatForward__SWIG_7'))

# Start of new_FlatForward

`FlatForward__SWIG_8` = function(settlementDays, calendar, forward, dayCounter)
{
  settlementDays = as.integer(settlementDays); 
  
  if(length(settlementDays) > 1) {
    warning("using only the first element of settlementDays");
  };
  
  
  
  
  ;ans = .Call('R_swig_new_FlatForward__SWIG_8', settlementDays, calendar, forward, dayCounter, PACKAGE='QuantLib');
  class(ans) <- "_p_FlatForwardPtr";
  
  reg.finalizer(ans, delete_FlatForward)
  ans
  
}

attr(`FlatForward__SWIG_8`, 'returnType') = '_p_FlatForwardPtr'
attr(`FlatForward__SWIG_8`, "inputTypes") = c('integer', '_p_Calendar', '_p_HandleT_Quote_t', '_p_DayCounter')
class(`FlatForward__SWIG_8`) = c("SWIGFunction", class('FlatForward__SWIG_8'))

# Start of new_FlatForward

`FlatForward__SWIG_9` = function(settlementDays, calendar, forward, dayCounter, compounding, frequency)
{
  settlementDays = as.integer(settlementDays); 
  
  if(length(settlementDays) > 1) {
    warning("using only the first element of settlementDays");
  };
  
  
  
  
  compounding = enumToInteger(compounding, "_Compounding"); 
  
  if(length(compounding) > 1) {
    warning("using only the first element of compounding");
  };
  
  frequency = enumToInteger(frequency, "_Frequency"); 
  
  if(length(frequency) > 1) {
    warning("using only the first element of frequency");
  };
  
  ;ans = .Call('R_swig_new_FlatForward__SWIG_9', settlementDays, calendar, forward, dayCounter, compounding, frequency, PACKAGE='QuantLib');
  class(ans) <- "_p_FlatForwardPtr";
  
  reg.finalizer(ans, delete_FlatForward)
  ans
  
}

attr(`FlatForward__SWIG_9`, 'returnType') = '_p_FlatForwardPtr'
attr(`FlatForward__SWIG_9`, "inputTypes") = c('integer', '_p_Calendar', 'numeric', '_p_DayCounter', 'character', 'character')
class(`FlatForward__SWIG_9`) = c("SWIGFunction", class('FlatForward__SWIG_9'))

# Start of new_FlatForward

`FlatForward__SWIG_10` = function(settlementDays, calendar, forward, dayCounter, compounding)
{
  settlementDays = as.integer(settlementDays); 
  
  if(length(settlementDays) > 1) {
    warning("using only the first element of settlementDays");
  };
  
  
  
  
  compounding = enumToInteger(compounding, "_Compounding"); 
  
  if(length(compounding) > 1) {
    warning("using only the first element of compounding");
  };
  
  ;ans = .Call('R_swig_new_FlatForward__SWIG_10', settlementDays, calendar, forward, dayCounter, compounding, PACKAGE='QuantLib');
  class(ans) <- "_p_FlatForwardPtr";
  
  reg.finalizer(ans, delete_FlatForward)
  ans
  
}

attr(`FlatForward__SWIG_10`, 'returnType') = '_p_FlatForwardPtr'
attr(`FlatForward__SWIG_10`, "inputTypes") = c('integer', '_p_Calendar', 'numeric', '_p_DayCounter', 'character')
class(`FlatForward__SWIG_10`) = c("SWIGFunction", class('FlatForward__SWIG_10'))

# Start of new_FlatForward

`FlatForward__SWIG_11` = function(settlementDays, calendar, forward, dayCounter)
{
  settlementDays = as.integer(settlementDays); 
  
  if(length(settlementDays) > 1) {
    warning("using only the first element of settlementDays");
  };
  
  
  
  
  ;ans = .Call('R_swig_new_FlatForward__SWIG_11', settlementDays, calendar, forward, dayCounter, PACKAGE='QuantLib');
  class(ans) <- "_p_FlatForwardPtr";
  
  reg.finalizer(ans, delete_FlatForward)
  ans
  
}

attr(`FlatForward__SWIG_11`, 'returnType') = '_p_FlatForwardPtr'
attr(`FlatForward__SWIG_11`, "inputTypes") = c('integer', '_p_Calendar', 'numeric', '_p_DayCounter')
class(`FlatForward__SWIG_11`) = c("SWIGFunction", class('FlatForward__SWIG_11'))

`FlatForward` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 12
  if (argc == 3) {
    if (extends(argtypes[1], '_p_Date') && extends(argtypes[2], '_p_HandleT_Quote_t') && extends(argtypes[3], '_p_DayCounter')) {
      f <- FlatForward__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_Date') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_DayCounter')) {
      f <- FlatForward__SWIG_5; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_Date') && extends(argtypes[2], '_p_HandleT_Quote_t') && extends(argtypes[3], '_p_DayCounter') && is.character(argv[[4]])) {
      f <- FlatForward__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_Date') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_DayCounter') && is.character(argv[[4]])) {
      f <- FlatForward__SWIG_4; 
    }
    else if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && extends(argtypes[2], '_p_Calendar') && extends(argtypes[3], '_p_HandleT_Quote_t') && extends(argtypes[4], '_p_DayCounter')) {
      f <- FlatForward__SWIG_8; 
    }
    else if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && extends(argtypes[2], '_p_Calendar') && is.numeric(argv[[3]]) && extends(argtypes[4], '_p_DayCounter')) {
      f <- FlatForward__SWIG_11; 
    }
  } else if (argc == 5) {
    if (extends(argtypes[1], '_p_Date') && extends(argtypes[2], '_p_HandleT_Quote_t') && extends(argtypes[3], '_p_DayCounter') && is.character(argv[[4]]) && is.character(argv[[5]])) {
      f <- FlatForward__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_Date') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_DayCounter') && is.character(argv[[4]]) && is.character(argv[[5]])) {
      f <- FlatForward__SWIG_3; 
    }
    else if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && extends(argtypes[2], '_p_Calendar') && extends(argtypes[3], '_p_HandleT_Quote_t') && extends(argtypes[4], '_p_DayCounter') && is.character(argv[[5]])) {
      f <- FlatForward__SWIG_7; 
    }
    else if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && extends(argtypes[2], '_p_Calendar') && is.numeric(argv[[3]]) && extends(argtypes[4], '_p_DayCounter') && is.character(argv[[5]])) {
      f <- FlatForward__SWIG_10; 
    }
  } else if (argc == 6) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && extends(argtypes[2], '_p_Calendar') && extends(argtypes[3], '_p_HandleT_Quote_t') && extends(argtypes[4], '_p_DayCounter') && is.character(argv[[5]]) && is.character(argv[[6]])) {
      f <- FlatForward__SWIG_6; 
    }
    else if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && extends(argtypes[2], '_p_Calendar') && is.numeric(argv[[3]]) && extends(argtypes[4], '_p_DayCounter') && is.character(argv[[5]]) && is.character(argv[[6]])) {
      f <- FlatForward__SWIG_9; 
    }
  } else {
    stop("cannot find overloaded function for FlatForward with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_FlatForward

`delete_FlatForward` = function(self)
{
  ;.Call('R_swig_delete_FlatForward', self, PACKAGE='QuantLib');
  
}

attr(`delete_FlatForward`, 'returnType') = 'void'
attr(`delete_FlatForward`, "inputTypes") = c('_p_FlatForwardPtr')
class(`delete_FlatForward`) = c("SWIGFunction", class('delete_FlatForward'))

setMethod('delete', '_p_FlatForwardPtr', function(obj) {delete_FlatForwardPtr(obj)})
# Start of new_RealTimeSeries

`RealTimeSeries__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_RealTimeSeries__SWIG_0', PACKAGE='QuantLib');
  class(ans) <- "_p_TimeSeriesT_double_std__mapT_Date_double_t_t";
  
  reg.finalizer(ans, delete_RealTimeSeries)
  ans
  
}

attr(`RealTimeSeries__SWIG_0`, 'returnType') = '_p_TimeSeriesT_double_std__mapT_Date_double_t_t'
class(`RealTimeSeries__SWIG_0`) = c("SWIGFunction", class('RealTimeSeries__SWIG_0'))

# Start of new_RealTimeSeries

`RealTimeSeries__SWIG_1` = function(d, v)
{
  ;ans = .Call('R_swig_new_RealTimeSeries__SWIG_1', d, v, PACKAGE='QuantLib');
  class(ans) <- "_p_TimeSeriesT_double_std__mapT_Date_double_t_t";
  
  reg.finalizer(ans, delete_RealTimeSeries)
  ans
  
}

attr(`RealTimeSeries__SWIG_1`, 'returnType') = '_p_TimeSeriesT_double_std__mapT_Date_double_t_t'
attr(`RealTimeSeries__SWIG_1`, "inputTypes") = c('_p_std__vectorT_Date_std__allocatorT_Date_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`RealTimeSeries__SWIG_1`) = c("SWIGFunction", class('RealTimeSeries__SWIG_1'))

`RealTimeSeries` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- RealTimeSeries__SWIG_0; 
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_std__vectorT_Date_std__allocatorT_Date_t_t') && extends(argtypes[2], '_p_std__vectorT_double_std__allocatorT_double_t_t')) {
      f <- RealTimeSeries__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for RealTimeSeries with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of RealTimeSeries_dates

`RealTimeSeries_dates` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_RealTimeSeries_dates', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_Date_std__allocatorT_Date_t_t";
  
  ans
  
}

attr(`RealTimeSeries_dates`, 'returnType') = '_p_std__vectorT_Date_std__allocatorT_Date_t_t'
attr(`RealTimeSeries_dates`, "inputTypes") = c('_p_TimeSeriesT_double_std__mapT_Date_double_t_t')
class(`RealTimeSeries_dates`) = c("SWIGFunction", class('RealTimeSeries_dates'))

# Start of RealTimeSeries_values

`RealTimeSeries_values` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_RealTimeSeries_values', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_double_std__allocatorT_double_t_t";
  
  ans
  
}

attr(`RealTimeSeries_values`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`RealTimeSeries_values`, "inputTypes") = c('_p_TimeSeriesT_double_std__mapT_Date_double_t_t')
class(`RealTimeSeries_values`) = c("SWIGFunction", class('RealTimeSeries_values'))

# Start of RealTimeSeries_size

`RealTimeSeries_size` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_RealTimeSeries_size', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__size_t";
  
  ans
  
}

attr(`RealTimeSeries_size`, 'returnType') = 'integer'
attr(`RealTimeSeries_size`, "inputTypes") = c('_p_TimeSeriesT_double_std__mapT_Date_double_t_t')
class(`RealTimeSeries_size`) = c("SWIGFunction", class('RealTimeSeries_size'))

# Start of RealTimeSeries___getitem__

`RealTimeSeries___getitem__` = function(self, d, .copy = FALSE)
{
  ;.Call('R_swig_RealTimeSeries___getitem__', self, d, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`RealTimeSeries___getitem__`, 'returnType') = 'numeric'
attr(`RealTimeSeries___getitem__`, "inputTypes") = c('_p_TimeSeriesT_double_std__mapT_Date_double_t_t', '_p_Date')
class(`RealTimeSeries___getitem__`) = c("SWIGFunction", class('RealTimeSeries___getitem__'))

# Start of RealTimeSeries___setitem__

`RealTimeSeries___setitem__` = function(self, d, value)
{
  ;.Call('R_swig_RealTimeSeries___setitem__', self, d, value, PACKAGE='QuantLib');
  
}

attr(`RealTimeSeries___setitem__`, 'returnType') = 'void'
attr(`RealTimeSeries___setitem__`, "inputTypes") = c('_p_TimeSeriesT_double_std__mapT_Date_double_t_t', '_p_Date', 'numeric')
class(`RealTimeSeries___setitem__`) = c("SWIGFunction", class('RealTimeSeries___setitem__'))

# Start of delete_RealTimeSeries

`delete_RealTimeSeries` = function(self)
{
  ;.Call('R_swig_delete_RealTimeSeries', self, PACKAGE='QuantLib');
  
}

attr(`delete_RealTimeSeries`, 'returnType') = 'void'
attr(`delete_RealTimeSeries`, "inputTypes") = c('_p_TimeSeriesT_double_std__mapT_Date_double_t_t')
class(`delete_RealTimeSeries`) = c("SWIGFunction", class('delete_RealTimeSeries'))

# Start of accessor method for TimeSeries<(Real)>
setMethod('$', '_p_TimeSeriesT_double_std__mapT_Date_double_t_t', function(x, name)

{
  accessorFuns = list('dates' = RealTimeSeries_dates, 'values' = RealTimeSeries_values, 'size' = RealTimeSeries_size, '__getitem__' = RealTimeSeries___getitem__, '__setitem__' = RealTimeSeries___setitem__);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for TimeSeries<(Real)>
setMethod('delete', '_p_TimeSeriesT_double_std__mapT_Date_double_t_t', function(obj) {delete_TimeSeriesT_double_std__mapT_Date_double_t_t(obj)})
# Start of new_IntervalPriceTimeSeries

`IntervalPriceTimeSeries__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_IntervalPriceTimeSeries__SWIG_0', PACKAGE='QuantLib');
  class(ans) <- "_p_TimeSeriesT_IntervalPrice_std__mapT_Date_IntervalPrice_t_t";
  
  reg.finalizer(ans, delete_IntervalPriceTimeSeries)
  ans
  
}

attr(`IntervalPriceTimeSeries__SWIG_0`, 'returnType') = '_p_TimeSeriesT_IntervalPrice_std__mapT_Date_IntervalPrice_t_t'
class(`IntervalPriceTimeSeries__SWIG_0`) = c("SWIGFunction", class('IntervalPriceTimeSeries__SWIG_0'))

# Start of new_IntervalPriceTimeSeries

`IntervalPriceTimeSeries__SWIG_1` = function(d, v)
{
  ;ans = .Call('R_swig_new_IntervalPriceTimeSeries__SWIG_1', d, v, PACKAGE='QuantLib');
  class(ans) <- "_p_TimeSeriesT_IntervalPrice_std__mapT_Date_IntervalPrice_t_t";
  
  reg.finalizer(ans, delete_IntervalPriceTimeSeries)
  ans
  
}

attr(`IntervalPriceTimeSeries__SWIG_1`, 'returnType') = '_p_TimeSeriesT_IntervalPrice_std__mapT_Date_IntervalPrice_t_t'
attr(`IntervalPriceTimeSeries__SWIG_1`, "inputTypes") = c('_p_std__vectorT_Date_std__allocatorT_Date_t_t', '_p_std__vectorT_IntervalPrice_std__allocatorT_IntervalPrice_t_t')
class(`IntervalPriceTimeSeries__SWIG_1`) = c("SWIGFunction", class('IntervalPriceTimeSeries__SWIG_1'))

`IntervalPriceTimeSeries` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- IntervalPriceTimeSeries__SWIG_0; 
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_std__vectorT_Date_std__allocatorT_Date_t_t') && extends(argtypes[2], '_p_std__vectorT_IntervalPrice_std__allocatorT_IntervalPrice_t_t')) {
      f <- IntervalPriceTimeSeries__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for IntervalPriceTimeSeries with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of IntervalPriceTimeSeries_dates

`IntervalPriceTimeSeries_dates` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_IntervalPriceTimeSeries_dates', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_Date_std__allocatorT_Date_t_t";
  
  ans
  
}

attr(`IntervalPriceTimeSeries_dates`, 'returnType') = '_p_std__vectorT_Date_std__allocatorT_Date_t_t'
attr(`IntervalPriceTimeSeries_dates`, "inputTypes") = c('_p_TimeSeriesT_IntervalPrice_std__mapT_Date_IntervalPrice_t_t')
class(`IntervalPriceTimeSeries_dates`) = c("SWIGFunction", class('IntervalPriceTimeSeries_dates'))

# Start of IntervalPriceTimeSeries_values

`IntervalPriceTimeSeries_values` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_IntervalPriceTimeSeries_values', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_IntervalPrice_std__allocatorT_IntervalPrice_t_t";
  
  ans
  
}

attr(`IntervalPriceTimeSeries_values`, 'returnType') = '_p_std__vectorT_IntervalPrice_std__allocatorT_IntervalPrice_t_t'
attr(`IntervalPriceTimeSeries_values`, "inputTypes") = c('_p_TimeSeriesT_IntervalPrice_std__mapT_Date_IntervalPrice_t_t')
class(`IntervalPriceTimeSeries_values`) = c("SWIGFunction", class('IntervalPriceTimeSeries_values'))

# Start of IntervalPriceTimeSeries_size

`IntervalPriceTimeSeries_size` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_IntervalPriceTimeSeries_size', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__size_t";
  
  ans
  
}

attr(`IntervalPriceTimeSeries_size`, 'returnType') = 'integer'
attr(`IntervalPriceTimeSeries_size`, "inputTypes") = c('_p_TimeSeriesT_IntervalPrice_std__mapT_Date_IntervalPrice_t_t')
class(`IntervalPriceTimeSeries_size`) = c("SWIGFunction", class('IntervalPriceTimeSeries_size'))

# Start of IntervalPriceTimeSeries___getitem__

`IntervalPriceTimeSeries___getitem__` = function(self, d, .copy = FALSE)
{
  ;ans = .Call('R_swig_IntervalPriceTimeSeries___getitem__', self, d, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_IntervalPrice";
  
  ans
  
}

attr(`IntervalPriceTimeSeries___getitem__`, 'returnType') = '_p_IntervalPrice'
attr(`IntervalPriceTimeSeries___getitem__`, "inputTypes") = c('_p_TimeSeriesT_IntervalPrice_std__mapT_Date_IntervalPrice_t_t', '_p_Date')
class(`IntervalPriceTimeSeries___getitem__`) = c("SWIGFunction", class('IntervalPriceTimeSeries___getitem__'))

# Start of IntervalPriceTimeSeries___setitem__

`IntervalPriceTimeSeries___setitem__` = function(self, d, value)
{
  ;.Call('R_swig_IntervalPriceTimeSeries___setitem__', self, d, value, PACKAGE='QuantLib');
  
}

attr(`IntervalPriceTimeSeries___setitem__`, 'returnType') = 'void'
attr(`IntervalPriceTimeSeries___setitem__`, "inputTypes") = c('_p_TimeSeriesT_IntervalPrice_std__mapT_Date_IntervalPrice_t_t', '_p_Date', '_p_IntervalPrice')
class(`IntervalPriceTimeSeries___setitem__`) = c("SWIGFunction", class('IntervalPriceTimeSeries___setitem__'))

# Start of delete_IntervalPriceTimeSeries

`delete_IntervalPriceTimeSeries` = function(self)
{
  ;.Call('R_swig_delete_IntervalPriceTimeSeries', self, PACKAGE='QuantLib');
  
}

attr(`delete_IntervalPriceTimeSeries`, 'returnType') = 'void'
attr(`delete_IntervalPriceTimeSeries`, "inputTypes") = c('_p_TimeSeriesT_IntervalPrice_std__mapT_Date_IntervalPrice_t_t')
class(`delete_IntervalPriceTimeSeries`) = c("SWIGFunction", class('delete_IntervalPriceTimeSeries'))

# Start of accessor method for TimeSeries<(IntervalPrice)>
setMethod('$', '_p_TimeSeriesT_IntervalPrice_std__mapT_Date_IntervalPrice_t_t', function(x, name)

{
  accessorFuns = list('dates' = IntervalPriceTimeSeries_dates, 'values' = IntervalPriceTimeSeries_values, 'size' = IntervalPriceTimeSeries_size, '__getitem__' = IntervalPriceTimeSeries___getitem__, '__setitem__' = IntervalPriceTimeSeries___setitem__);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for TimeSeries<(IntervalPrice)>
setMethod('delete', '_p_TimeSeriesT_IntervalPrice_std__mapT_Date_IntervalPrice_t_t', function(obj) {delete_TimeSeriesT_IntervalPrice_std__mapT_Date_IntervalPrice_t_t(obj)})
# Start of IntervalPriceVector___nonzero__

`IntervalPriceVector___nonzero__` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_IntervalPriceVector___nonzero__', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`IntervalPriceVector___nonzero__`, 'returnType') = 'logical'
attr(`IntervalPriceVector___nonzero__`, "inputTypes") = c('_p_std__vectorT_IntervalPrice_std__allocatorT_IntervalPrice_t_t')
class(`IntervalPriceVector___nonzero__`) = c("SWIGFunction", class('IntervalPriceVector___nonzero__'))

# Start of IntervalPriceVector___len__

`IntervalPriceVector___len__` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_IntervalPriceVector___len__', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`IntervalPriceVector___len__`, 'returnType') = 'integer'
attr(`IntervalPriceVector___len__`, "inputTypes") = c('_p_std__vectorT_IntervalPrice_std__allocatorT_IntervalPrice_t_t')
class(`IntervalPriceVector___len__`) = c("SWIGFunction", class('IntervalPriceVector___len__'))

# Start of IntervalPriceVector_pop

`IntervalPriceVector_pop` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_IntervalPriceVector_pop', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_IntervalPrice";
  
  ans
  
}

attr(`IntervalPriceVector_pop`, 'returnType') = '_p_IntervalPrice'
attr(`IntervalPriceVector_pop`, "inputTypes") = c('_p_std__vectorT_IntervalPrice_std__allocatorT_IntervalPrice_t_t')
class(`IntervalPriceVector_pop`) = c("SWIGFunction", class('IntervalPriceVector_pop'))

# Start of IntervalPriceVector___getslice__

`IntervalPriceVector___getslice__` = function(self, i, j)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;ans = .Call('R_swig_IntervalPriceVector___getslice__', self, i, j, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_IntervalPrice_std__allocatorT_IntervalPrice_t_t";
  
  ans
  
}

attr(`IntervalPriceVector___getslice__`, 'returnType') = '_p_std__vectorT_IntervalPrice_std__allocatorT_IntervalPrice_t_t'
attr(`IntervalPriceVector___getslice__`, "inputTypes") = c('_p_std__vectorT_IntervalPrice_std__allocatorT_IntervalPrice_t_t', 'integer', 'integer')
class(`IntervalPriceVector___getslice__`) = c("SWIGFunction", class('IntervalPriceVector___getslice__'))

# Start of IntervalPriceVector___setslice__

`IntervalPriceVector___setslice__` = function(self, i, j, v)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  
  ;.Call('R_swig_IntervalPriceVector___setslice__', self, i, j, v, PACKAGE='QuantLib');
  
}

attr(`IntervalPriceVector___setslice__`, 'returnType') = 'void'
attr(`IntervalPriceVector___setslice__`, "inputTypes") = c('_p_std__vectorT_IntervalPrice_std__allocatorT_IntervalPrice_t_t', 'integer', 'integer', '_p_std__vectorT_IntervalPrice_std__allocatorT_IntervalPrice_t_t')
class(`IntervalPriceVector___setslice__`) = c("SWIGFunction", class('IntervalPriceVector___setslice__'))

# Start of IntervalPriceVector___delslice__

`IntervalPriceVector___delslice__` = function(self, i, j)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_IntervalPriceVector___delslice__', self, i, j, PACKAGE='QuantLib');
  
}

attr(`IntervalPriceVector___delslice__`, 'returnType') = 'void'
attr(`IntervalPriceVector___delslice__`, "inputTypes") = c('_p_std__vectorT_IntervalPrice_std__allocatorT_IntervalPrice_t_t', 'integer', 'integer')
class(`IntervalPriceVector___delslice__`) = c("SWIGFunction", class('IntervalPriceVector___delslice__'))

# Start of IntervalPriceVector___delitem__

`IntervalPriceVector___delitem__` = function(self, i)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_IntervalPriceVector___delitem__', self, i, PACKAGE='QuantLib');
  
}

attr(`IntervalPriceVector___delitem__`, 'returnType') = 'void'
attr(`IntervalPriceVector___delitem__`, "inputTypes") = c('_p_std__vectorT_IntervalPrice_std__allocatorT_IntervalPrice_t_t', 'integer')
class(`IntervalPriceVector___delitem__`) = c("SWIGFunction", class('IntervalPriceVector___delitem__'))

# Start of IntervalPriceVector___getitem__

`IntervalPriceVector___getitem__` = function(self, i, .copy = FALSE)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;ans = .Call('R_swig_IntervalPriceVector___getitem__', self, i, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_IntervalPrice";
  
  ans
  
}

attr(`IntervalPriceVector___getitem__`, 'returnType') = '_p_IntervalPrice'
attr(`IntervalPriceVector___getitem__`, "inputTypes") = c('_p_std__vectorT_IntervalPrice_std__allocatorT_IntervalPrice_t_t', 'integer')
class(`IntervalPriceVector___getitem__`) = c("SWIGFunction", class('IntervalPriceVector___getitem__'))

# Start of IntervalPriceVector___setitem__

`IntervalPriceVector___setitem__` = function(self, i, x)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  ;.Call('R_swig_IntervalPriceVector___setitem__', self, i, x, PACKAGE='QuantLib');
  
}

attr(`IntervalPriceVector___setitem__`, 'returnType') = 'void'
attr(`IntervalPriceVector___setitem__`, "inputTypes") = c('_p_std__vectorT_IntervalPrice_std__allocatorT_IntervalPrice_t_t', 'integer', '_p_IntervalPrice')
class(`IntervalPriceVector___setitem__`) = c("SWIGFunction", class('IntervalPriceVector___setitem__'))

# Start of IntervalPriceVector_append

`IntervalPriceVector_append` = function(self, x)
{
  ;.Call('R_swig_IntervalPriceVector_append', self, x, PACKAGE='QuantLib');
  
}

attr(`IntervalPriceVector_append`, 'returnType') = 'void'
attr(`IntervalPriceVector_append`, "inputTypes") = c('_p_std__vectorT_IntervalPrice_std__allocatorT_IntervalPrice_t_t', '_p_IntervalPrice')
class(`IntervalPriceVector_append`) = c("SWIGFunction", class('IntervalPriceVector_append'))

# Start of new_IntervalPriceVector

`IntervalPriceVector__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_IntervalPriceVector__SWIG_0', PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_IntervalPrice_std__allocatorT_IntervalPrice_t_t";
  
  reg.finalizer(ans, delete_IntervalPriceVector)
  ans
  
}

attr(`IntervalPriceVector__SWIG_0`, 'returnType') = '_p_std__vectorT_IntervalPrice_std__allocatorT_IntervalPrice_t_t'
class(`IntervalPriceVector__SWIG_0`) = c("SWIGFunction", class('IntervalPriceVector__SWIG_0'))

# Start of new_IntervalPriceVector

`IntervalPriceVector__SWIG_1` = function(s_arg1)
{
  ;ans = .Call('R_swig_new_IntervalPriceVector__SWIG_1', s_arg1, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_IntervalPrice_std__allocatorT_IntervalPrice_t_t";
  
  reg.finalizer(ans, delete_IntervalPriceVector)
  ans
  
}

attr(`IntervalPriceVector__SWIG_1`, 'returnType') = '_p_std__vectorT_IntervalPrice_std__allocatorT_IntervalPrice_t_t'
attr(`IntervalPriceVector__SWIG_1`, "inputTypes") = c('_p_std__vectorT_IntervalPrice_std__allocatorT_IntervalPrice_t_t')
class(`IntervalPriceVector__SWIG_1`) = c("SWIGFunction", class('IntervalPriceVector__SWIG_1'))

# Start of IntervalPriceVector_empty

`IntervalPriceVector_empty` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_IntervalPriceVector_empty', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`IntervalPriceVector_empty`, 'returnType') = 'logical'
attr(`IntervalPriceVector_empty`, "inputTypes") = c('_p_std__vectorT_IntervalPrice_std__allocatorT_IntervalPrice_t_t')
class(`IntervalPriceVector_empty`) = c("SWIGFunction", class('IntervalPriceVector_empty'))

# Start of IntervalPriceVector_size

`IntervalPriceVector_size` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_IntervalPriceVector_size', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`IntervalPriceVector_size`, 'returnType') = 'integer'
attr(`IntervalPriceVector_size`, "inputTypes") = c('_p_std__vectorT_IntervalPrice_std__allocatorT_IntervalPrice_t_t')
class(`IntervalPriceVector_size`) = c("SWIGFunction", class('IntervalPriceVector_size'))

# Start of IntervalPriceVector_clear

`IntervalPriceVector_clear` = function(self)
{
  ;.Call('R_swig_IntervalPriceVector_clear', self, PACKAGE='QuantLib');
  
}

attr(`IntervalPriceVector_clear`, 'returnType') = 'void'
attr(`IntervalPriceVector_clear`, "inputTypes") = c('_p_std__vectorT_IntervalPrice_std__allocatorT_IntervalPrice_t_t')
class(`IntervalPriceVector_clear`) = c("SWIGFunction", class('IntervalPriceVector_clear'))

# Start of IntervalPriceVector_swap

`IntervalPriceVector_swap` = function(self, v)
{
  ;.Call('R_swig_IntervalPriceVector_swap', self, v, PACKAGE='QuantLib');
  
}

attr(`IntervalPriceVector_swap`, 'returnType') = 'void'
attr(`IntervalPriceVector_swap`, "inputTypes") = c('_p_std__vectorT_IntervalPrice_std__allocatorT_IntervalPrice_t_t', '_p_std__vectorT_IntervalPrice_std__allocatorT_IntervalPrice_t_t')
class(`IntervalPriceVector_swap`) = c("SWIGFunction", class('IntervalPriceVector_swap'))

# Start of IntervalPriceVector_get_allocator

`IntervalPriceVector_get_allocator` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_IntervalPriceVector_get_allocator', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__allocatorT_IntervalPrice_t";
  
  ans
  
}

attr(`IntervalPriceVector_get_allocator`, 'returnType') = '_p_std__allocatorT_IntervalPrice_t'
attr(`IntervalPriceVector_get_allocator`, "inputTypes") = c('_p_std__vectorT_IntervalPrice_std__allocatorT_IntervalPrice_t_t')
class(`IntervalPriceVector_get_allocator`) = c("SWIGFunction", class('IntervalPriceVector_get_allocator'))

# Start of new_IntervalPriceVector

`IntervalPriceVector__SWIG_2` = function(size)
{
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_new_IntervalPriceVector__SWIG_2', size, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_IntervalPrice_std__allocatorT_IntervalPrice_t_t";
  
  reg.finalizer(ans, delete_IntervalPriceVector)
  ans
  
}

attr(`IntervalPriceVector__SWIG_2`, 'returnType') = '_p_std__vectorT_IntervalPrice_std__allocatorT_IntervalPrice_t_t'
attr(`IntervalPriceVector__SWIG_2`, "inputTypes") = c('integer')
class(`IntervalPriceVector__SWIG_2`) = c("SWIGFunction", class('IntervalPriceVector__SWIG_2'))

# Start of IntervalPriceVector_pop_back

`IntervalPriceVector_pop_back` = function(self)
{
  ;.Call('R_swig_IntervalPriceVector_pop_back', self, PACKAGE='QuantLib');
  
}

attr(`IntervalPriceVector_pop_back`, 'returnType') = 'void'
attr(`IntervalPriceVector_pop_back`, "inputTypes") = c('_p_std__vectorT_IntervalPrice_std__allocatorT_IntervalPrice_t_t')
class(`IntervalPriceVector_pop_back`) = c("SWIGFunction", class('IntervalPriceVector_pop_back'))

# Start of IntervalPriceVector_resize

`IntervalPriceVector_resize__SWIG_0` = function(self, new_size)
{
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_IntervalPriceVector_resize__SWIG_0', self, new_size, PACKAGE='QuantLib');
  
}

attr(`IntervalPriceVector_resize__SWIG_0`, 'returnType') = 'void'
attr(`IntervalPriceVector_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_IntervalPrice_std__allocatorT_IntervalPrice_t_t', 'integer')
class(`IntervalPriceVector_resize__SWIG_0`) = c("SWIGFunction", class('IntervalPriceVector_resize__SWIG_0'))

# Start of new_IntervalPriceVector

`IntervalPriceVector__SWIG_3` = function(size, value)
{
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  
  ;ans = .Call('R_swig_new_IntervalPriceVector__SWIG_3', size, value, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_IntervalPrice_std__allocatorT_IntervalPrice_t_t";
  
  reg.finalizer(ans, delete_IntervalPriceVector)
  ans
  
}

attr(`IntervalPriceVector__SWIG_3`, 'returnType') = '_p_std__vectorT_IntervalPrice_std__allocatorT_IntervalPrice_t_t'
attr(`IntervalPriceVector__SWIG_3`, "inputTypes") = c('integer', '_p_IntervalPrice')
class(`IntervalPriceVector__SWIG_3`) = c("SWIGFunction", class('IntervalPriceVector__SWIG_3'))

`IntervalPriceVector` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- IntervalPriceVector__SWIG_0; 
  } else if (argc == 1) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]]))) {
      f <- IntervalPriceVector__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_IntervalPrice_std__allocatorT_IntervalPrice_t_t')) {
      f <- IntervalPriceVector__SWIG_1; 
    }
  } else if (argc == 2) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && extends(argtypes[2], '_p_IntervalPrice')) {
      f <- IntervalPriceVector__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for IntervalPriceVector with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of IntervalPriceVector_push_back

`IntervalPriceVector_push_back` = function(self, x)
{
  ;.Call('R_swig_IntervalPriceVector_push_back', self, x, PACKAGE='QuantLib');
  
}

attr(`IntervalPriceVector_push_back`, 'returnType') = 'void'
attr(`IntervalPriceVector_push_back`, "inputTypes") = c('_p_std__vectorT_IntervalPrice_std__allocatorT_IntervalPrice_t_t', '_p_IntervalPrice')
class(`IntervalPriceVector_push_back`) = c("SWIGFunction", class('IntervalPriceVector_push_back'))

# Start of IntervalPriceVector_front

`IntervalPriceVector_front` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_IntervalPriceVector_front', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_IntervalPrice";
  
  ans
  
}

attr(`IntervalPriceVector_front`, 'returnType') = '_p_IntervalPrice'
attr(`IntervalPriceVector_front`, "inputTypes") = c('_p_std__vectorT_IntervalPrice_std__allocatorT_IntervalPrice_t_t')
class(`IntervalPriceVector_front`) = c("SWIGFunction", class('IntervalPriceVector_front'))

# Start of IntervalPriceVector_back

`IntervalPriceVector_back` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_IntervalPriceVector_back', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_IntervalPrice";
  
  ans
  
}

attr(`IntervalPriceVector_back`, 'returnType') = '_p_IntervalPrice'
attr(`IntervalPriceVector_back`, "inputTypes") = c('_p_std__vectorT_IntervalPrice_std__allocatorT_IntervalPrice_t_t')
class(`IntervalPriceVector_back`) = c("SWIGFunction", class('IntervalPriceVector_back'))

# Start of IntervalPriceVector_assign

`IntervalPriceVector_assign` = function(self, n, x)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  
  ;.Call('R_swig_IntervalPriceVector_assign', self, n, x, PACKAGE='QuantLib');
  
}

attr(`IntervalPriceVector_assign`, 'returnType') = 'void'
attr(`IntervalPriceVector_assign`, "inputTypes") = c('_p_std__vectorT_IntervalPrice_std__allocatorT_IntervalPrice_t_t', 'integer', '_p_IntervalPrice')
class(`IntervalPriceVector_assign`) = c("SWIGFunction", class('IntervalPriceVector_assign'))

# Start of IntervalPriceVector_resize

`IntervalPriceVector_resize__SWIG_1` = function(self, new_size, x)
{
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  
  ;.Call('R_swig_IntervalPriceVector_resize__SWIG_1', self, new_size, x, PACKAGE='QuantLib');
  
}

attr(`IntervalPriceVector_resize__SWIG_1`, 'returnType') = 'void'
attr(`IntervalPriceVector_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_IntervalPrice_std__allocatorT_IntervalPrice_t_t', 'integer', '_p_IntervalPrice')
class(`IntervalPriceVector_resize__SWIG_1`) = c("SWIGFunction", class('IntervalPriceVector_resize__SWIG_1'))

`IntervalPriceVector_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_std__vectorT_IntervalPrice_std__allocatorT_IntervalPrice_t_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]]))) {
      f <- IntervalPriceVector_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_std__vectorT_IntervalPrice_std__allocatorT_IntervalPrice_t_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && extends(argtypes[3], '_p_IntervalPrice')) {
      f <- IntervalPriceVector_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for IntervalPriceVector_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of IntervalPriceVector_reserve

`IntervalPriceVector_reserve` = function(self, n)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_IntervalPriceVector_reserve', self, n, PACKAGE='QuantLib');
  
}

attr(`IntervalPriceVector_reserve`, 'returnType') = 'void'
attr(`IntervalPriceVector_reserve`, "inputTypes") = c('_p_std__vectorT_IntervalPrice_std__allocatorT_IntervalPrice_t_t', 'integer')
class(`IntervalPriceVector_reserve`) = c("SWIGFunction", class('IntervalPriceVector_reserve'))

# Start of IntervalPriceVector_capacity

`IntervalPriceVector_capacity` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_IntervalPriceVector_capacity', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`IntervalPriceVector_capacity`, 'returnType') = 'integer'
attr(`IntervalPriceVector_capacity`, "inputTypes") = c('_p_std__vectorT_IntervalPrice_std__allocatorT_IntervalPrice_t_t')
class(`IntervalPriceVector_capacity`) = c("SWIGFunction", class('IntervalPriceVector_capacity'))

# Start of delete_IntervalPriceVector

`delete_IntervalPriceVector` = function(self)
{
  ;.Call('R_swig_delete_IntervalPriceVector', self, PACKAGE='QuantLib');
  
}

attr(`delete_IntervalPriceVector`, 'returnType') = 'void'
attr(`delete_IntervalPriceVector`, "inputTypes") = c('_p_std__vectorT_IntervalPrice_std__allocatorT_IntervalPrice_t_t')
class(`delete_IntervalPriceVector`) = c("SWIGFunction", class('delete_IntervalPriceVector'))

# Start of accessor method for std::vector<(IntervalPrice)>
setMethod('$', '_p_std__vectorT_IntervalPrice_std__allocatorT_IntervalPrice_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = IntervalPriceVector___nonzero__, '__len__' = IntervalPriceVector___len__, 'pop' = IntervalPriceVector_pop, '__getslice__' = IntervalPriceVector___getslice__, '__setslice__' = IntervalPriceVector___setslice__, '__delslice__' = IntervalPriceVector___delslice__, '__delitem__' = IntervalPriceVector___delitem__, '__getitem__' = IntervalPriceVector___getitem__, '__setitem__' = IntervalPriceVector___setitem__, 'append' = IntervalPriceVector_append, 'empty' = IntervalPriceVector_empty, 'size' = IntervalPriceVector_size, 'clear' = IntervalPriceVector_clear, 'swap' = IntervalPriceVector_swap, 'get_allocator' = IntervalPriceVector_get_allocator, 'pop_back' = IntervalPriceVector_pop_back, 'resize' = IntervalPriceVector_resize, 'push_back' = IntervalPriceVector_push_back, 'front' = IntervalPriceVector_front, 'back' = IntervalPriceVector_back, 'assign' = IntervalPriceVector_assign, 'reserve' = IntervalPriceVector_reserve, 'capacity' = IntervalPriceVector_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for std::vector<(IntervalPrice)>
setMethod('delete', '_p_std__vectorT_IntervalPrice_std__allocatorT_IntervalPrice_t_t', function(obj) {delete_std__vectorT_IntervalPrice_std__allocatorT_IntervalPrice_t_t(obj)})
defineEnumeration('_IntervalPrice__Type',
                    .values = c(
                        'Open' = 0, 
                        'Close' = 1, 
                        'High' = 2, 
                        'Low' = 3
))
# Start of new_IntervalPrice

`IntervalPrice` = function(s_arg1, s_arg2, s_arg3, s_arg4)
{
  ;ans = .Call('R_swig_new_IntervalPrice', s_arg1, s_arg2, s_arg3, s_arg4, PACKAGE='QuantLib');
  class(ans) <- "_p_IntervalPrice";
  
  reg.finalizer(ans, delete_IntervalPrice)
  ans
  
}

attr(`IntervalPrice`, 'returnType') = '_p_IntervalPrice'
attr(`IntervalPrice`, "inputTypes") = c('numeric', 'numeric', 'numeric', 'numeric')
class(`IntervalPrice`) = c("SWIGFunction", class('IntervalPrice'))

# Start of IntervalPrice_setValue

`IntervalPrice_setValue` = function(self, s_arg2, s_arg3)
{
  s_arg3 = enumToInteger(s_arg3, "_IntervalPrice__Type"); 
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  ;.Call('R_swig_IntervalPrice_setValue', self, s_arg2, s_arg3, PACKAGE='QuantLib');
  
}

attr(`IntervalPrice_setValue`, 'returnType') = 'void'
attr(`IntervalPrice_setValue`, "inputTypes") = c('_p_IntervalPrice', 'numeric', 'character')
class(`IntervalPrice_setValue`) = c("SWIGFunction", class('IntervalPrice_setValue'))

# Start of IntervalPrice_setValues

`IntervalPrice_setValues` = function(self, s_arg2, s_arg3, s_arg4, s_arg5)
{
  ;.Call('R_swig_IntervalPrice_setValues', self, s_arg2, s_arg3, s_arg4, s_arg5, PACKAGE='QuantLib');
  
}

attr(`IntervalPrice_setValues`, 'returnType') = 'void'
attr(`IntervalPrice_setValues`, "inputTypes") = c('_p_IntervalPrice', 'numeric', 'numeric', 'numeric', 'numeric')
class(`IntervalPrice_setValues`) = c("SWIGFunction", class('IntervalPrice_setValues'))

# Start of IntervalPrice_value

`IntervalPrice_value` = function(self, t, .copy = FALSE)
{
  t = enumToInteger(t, "_IntervalPrice__Type"); 
  
  if(length(t) > 1) {
    warning("using only the first element of t");
  };
  
  ;.Call('R_swig_IntervalPrice_value', self, t, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`IntervalPrice_value`, 'returnType') = 'numeric'
attr(`IntervalPrice_value`, "inputTypes") = c('_p_IntervalPrice', 'character')
class(`IntervalPrice_value`) = c("SWIGFunction", class('IntervalPrice_value'))

# Start of IntervalPrice_open

`IntervalPrice_open` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_IntervalPrice_open', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`IntervalPrice_open`, 'returnType') = 'numeric'
attr(`IntervalPrice_open`, "inputTypes") = c('_p_IntervalPrice')
class(`IntervalPrice_open`) = c("SWIGFunction", class('IntervalPrice_open'))

# Start of IntervalPrice_close

`IntervalPrice_close` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_IntervalPrice_close', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`IntervalPrice_close`, 'returnType') = 'numeric'
attr(`IntervalPrice_close`, "inputTypes") = c('_p_IntervalPrice')
class(`IntervalPrice_close`) = c("SWIGFunction", class('IntervalPrice_close'))

# Start of IntervalPrice_high

`IntervalPrice_high` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_IntervalPrice_high', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`IntervalPrice_high`, 'returnType') = 'numeric'
attr(`IntervalPrice_high`, "inputTypes") = c('_p_IntervalPrice')
class(`IntervalPrice_high`) = c("SWIGFunction", class('IntervalPrice_high'))

# Start of IntervalPrice_low

`IntervalPrice_low` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_IntervalPrice_low', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`IntervalPrice_low`, 'returnType') = 'numeric'
attr(`IntervalPrice_low`, "inputTypes") = c('_p_IntervalPrice')
class(`IntervalPrice_low`) = c("SWIGFunction", class('IntervalPrice_low'))

# Start of IntervalPrice_makeSeries

`IntervalPrice_makeSeries` = function(d, open, close, high, low, .copy = FALSE)
{
  ;ans = .Call('R_swig_IntervalPrice_makeSeries', d, open, close, high, low, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_TimeSeriesT_IntervalPrice_std__mapT_Date_IntervalPrice_t_t";
  
  ans
  
}

attr(`IntervalPrice_makeSeries`, 'returnType') = '_p_TimeSeriesT_IntervalPrice_std__mapT_Date_IntervalPrice_t_t'
attr(`IntervalPrice_makeSeries`, "inputTypes") = c('_p_std__vectorT_Date_std__allocatorT_Date_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`IntervalPrice_makeSeries`) = c("SWIGFunction", class('IntervalPrice_makeSeries'))

# Start of IntervalPrice_extractValues

`IntervalPrice_extractValues` = function(s_arg1, t, .copy = FALSE)
{
  t = enumToInteger(t, "_IntervalPrice__Type"); 
  
  if(length(t) > 1) {
    warning("using only the first element of t");
  };
  
  ;ans = .Call('R_swig_IntervalPrice_extractValues', s_arg1, t, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_double_std__allocatorT_double_t_t";
  
  ans
  
}

attr(`IntervalPrice_extractValues`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`IntervalPrice_extractValues`, "inputTypes") = c('_p_TimeSeriesT_IntervalPrice_std__mapT_Date_IntervalPrice_t_t', 'character')
class(`IntervalPrice_extractValues`) = c("SWIGFunction", class('IntervalPrice_extractValues'))

# Start of IntervalPrice_extractComponent

`IntervalPrice_extractComponent` = function(s_arg1, t, .copy = FALSE)
{
  t = enumToInteger(t, "_IntervalPrice__Type"); 
  
  if(length(t) > 1) {
    warning("using only the first element of t");
  };
  
  ;ans = .Call('R_swig_IntervalPrice_extractComponent', s_arg1, t, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_TimeSeriesT_double_std__mapT_Date_double_t_t";
  
  ans
  
}

attr(`IntervalPrice_extractComponent`, 'returnType') = '_p_TimeSeriesT_double_std__mapT_Date_double_t_t'
attr(`IntervalPrice_extractComponent`, "inputTypes") = c('_p_TimeSeriesT_IntervalPrice_std__mapT_Date_IntervalPrice_t_t', 'character')
class(`IntervalPrice_extractComponent`) = c("SWIGFunction", class('IntervalPrice_extractComponent'))

# Start of delete_IntervalPrice

`delete_IntervalPrice` = function(self)
{
  ;.Call('R_swig_delete_IntervalPrice', self, PACKAGE='QuantLib');
  
}

attr(`delete_IntervalPrice`, 'returnType') = 'void'
attr(`delete_IntervalPrice`, "inputTypes") = c('_p_IntervalPrice')
class(`delete_IntervalPrice`) = c("SWIGFunction", class('delete_IntervalPrice'))

# Start of accessor method for IntervalPrice
setMethod('$', '_p_IntervalPrice', function(x, name)

{
  accessorFuns = list('setValue' = IntervalPrice_setValue, 'setValues' = IntervalPrice_setValues, 'value' = IntervalPrice_value, 'open' = IntervalPrice_open, 'close' = IntervalPrice_close, 'high' = IntervalPrice_high, 'low' = IntervalPrice_low);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for IntervalPrice
setMethod('delete', '_p_IntervalPrice', function(obj) {delete_IntervalPrice(obj)})

setMethod('as.data.frame', '_p_TimeSeriesTdouble_std__mapTDate_double_t_t',
function(x,row.names,optional)
data.frame("date"=as(x$dates(), "character"),
"values"=as(x$values(), "numeric")))

setMethod("print", '_p_TimeSeriesTdouble_std_mapTDate_double_t_t',
function(x) print(as.data.frame(x)))

setMethod('as.data.frame', '_p_TimeSeriesTIntervalPrice_std_mapTDate_IntervalPrice_t_t',
function(x,row.names,optional)
data.frame("date"=as(x$dates(), "character"),
"open"=as(IntervalPrice_extractValues(x, "Open"), "numeric"),
"close"=as(IntervalPrice_extractValues(x, "Close"), "numeric"),
"high"=as(IntervalPrice_extractValues(x, "High"), "numeric"),
"low"=as(IntervalPrice_extractValues(x, "Low"), "numeric")))

setMethod("print", '_p_TimeSeriesTIntervalPrice_std_mapTDate_IntervalPrice_t_t',
function(x) print(as.data.frame(x)))

# Start of IndexManager_instance

`IndexManager_instance` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_IndexManager_instance', as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_IndexManager";
  
  ans
  
}

attr(`IndexManager_instance`, 'returnType') = '_p_IndexManager'
class(`IndexManager_instance`) = c("SWIGFunction", class('IndexManager_instance'))

# Start of IndexManager_setHistory

`IndexManager_setHistory` = function(self, name, fixings)
{
  name = as(name, "character"); 
  
  ;.Call('R_swig_IndexManager_setHistory', self, name, fixings, PACKAGE='QuantLib');
  
}

attr(`IndexManager_setHistory`, 'returnType') = 'void'
attr(`IndexManager_setHistory`, "inputTypes") = c('_p_IndexManager', 'character', '_p_TimeSeriesT_double_std__mapT_Date_double_t_t')
class(`IndexManager_setHistory`) = c("SWIGFunction", class('IndexManager_setHistory'))

# Start of IndexManager_getHistory

`IndexManager_getHistory` = function(self, name, .copy = FALSE)
{
  name = as(name, "character"); 
  ;ans = .Call('R_swig_IndexManager_getHistory', self, name, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_TimeSeriesT_double_std__mapT_Date_double_t_t";
  
  ans
  
}

attr(`IndexManager_getHistory`, 'returnType') = '_p_TimeSeriesT_double_std__mapT_Date_double_t_t'
attr(`IndexManager_getHistory`, "inputTypes") = c('_p_IndexManager', 'character')
class(`IndexManager_getHistory`) = c("SWIGFunction", class('IndexManager_getHistory'))

# Start of IndexManager_hasHistory

`IndexManager_hasHistory` = function(self, name, .copy = FALSE)
{
  name = as(name, "character"); 
  ;.Call('R_swig_IndexManager_hasHistory', self, name, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`IndexManager_hasHistory`, 'returnType') = 'logical'
attr(`IndexManager_hasHistory`, "inputTypes") = c('_p_IndexManager', 'character')
class(`IndexManager_hasHistory`) = c("SWIGFunction", class('IndexManager_hasHistory'))

# Start of IndexManager_histories

`IndexManager_histories` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_IndexManager_histories', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_std__string_std__allocatorT_std__string_t_t";
  
  ans
  
}

attr(`IndexManager_histories`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
attr(`IndexManager_histories`, "inputTypes") = c('_p_IndexManager')
class(`IndexManager_histories`) = c("SWIGFunction", class('IndexManager_histories'))

# Start of IndexManager_clearHistory

`IndexManager_clearHistory` = function(self, name)
{
  name = as(name, "character"); 
  ;.Call('R_swig_IndexManager_clearHistory', self, name, PACKAGE='QuantLib');
  
}

attr(`IndexManager_clearHistory`, 'returnType') = 'void'
attr(`IndexManager_clearHistory`, "inputTypes") = c('_p_IndexManager', 'character')
class(`IndexManager_clearHistory`) = c("SWIGFunction", class('IndexManager_clearHistory'))

# Start of IndexManager_clearHistories

`IndexManager_clearHistories` = function(self)
{
  ;.Call('R_swig_IndexManager_clearHistories', self, PACKAGE='QuantLib');
  
}

attr(`IndexManager_clearHistories`, 'returnType') = 'void'
attr(`IndexManager_clearHistories`, "inputTypes") = c('_p_IndexManager')
class(`IndexManager_clearHistories`) = c("SWIGFunction", class('IndexManager_clearHistories'))

# Start of delete_IndexManager

`delete_IndexManager` = function(self)
{
  ;.Call('R_swig_delete_IndexManager', self, PACKAGE='QuantLib');
  
}

attr(`delete_IndexManager`, 'returnType') = 'void'
attr(`delete_IndexManager`, "inputTypes") = c('_p_IndexManager')
class(`delete_IndexManager`) = c("SWIGFunction", class('delete_IndexManager'))

# Start of accessor method for IndexManager
setMethod('$', '_p_IndexManager', function(x, name)

{
  accessorFuns = list('setHistory' = IndexManager_setHistory, 'getHistory' = IndexManager_getHistory, 'hasHistory' = IndexManager_hasHistory, 'histories' = IndexManager_histories, 'clearHistory' = IndexManager_clearHistory, 'clearHistories' = IndexManager_clearHistories);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for IndexManager
setMethod('delete', '_p_IndexManager', function(obj) {delete_IndexManager(obj)})
# Start of Index___deref__

`Index___deref__` = function(self)
{
  ;ans = .Call('R_swig_Index___deref__', self, PACKAGE='QuantLib');
  class(ans) <- "_p_Index";
  
  ans
  
}

attr(`Index___deref__`, 'returnType') = '_p_Index'
attr(`Index___deref__`, "inputTypes") = c('_p_boost__shared_ptrT_Index_t')
class(`Index___deref__`) = c("SWIGFunction", class('Index___deref__'))

# Start of Index_isNull

`Index_isNull` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Index_isNull', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Index_isNull`, 'returnType') = 'logical'
attr(`Index_isNull`, "inputTypes") = c('_p_boost__shared_ptrT_Index_t')
class(`Index_isNull`) = c("SWIGFunction", class('Index_isNull'))

# Start of Index_addFixings

`Index_addFixings` = function(self, fixingDates, fixings)
{
  ;.Call('R_swig_Index_addFixings', self, fixingDates, fixings, PACKAGE='QuantLib');
  
}

attr(`Index_addFixings`, 'returnType') = 'void'
attr(`Index_addFixings`, "inputTypes") = c('_p_boost__shared_ptrT_Index_t', '_p_std__vectorT_Date_std__allocatorT_Date_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`Index_addFixings`) = c("SWIGFunction", class('Index_addFixings'))

# Start of Index___str__

`Index___str__` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Index___str__', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Index___str__`, 'returnType') = 'character'
attr(`Index___str__`, "inputTypes") = c('_p_boost__shared_ptrT_Index_t')
class(`Index___str__`) = c("SWIGFunction", class('Index___str__'))

# Start of Index_asObservable

`Index_asObservable` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_Index_asObservable', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_Observable_t";
  
  ans
  
}

attr(`Index_asObservable`, 'returnType') = '_p_boost__shared_ptrT_Observable_t'
attr(`Index_asObservable`, "inputTypes") = c('_p_boost__shared_ptrT_Index_t')
class(`Index_asObservable`) = c("SWIGFunction", class('Index_asObservable'))

# Start of new_Index

`Index` = function()
{
  ;ans = .Call('R_swig_new_Index', PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_Index_t";
  
  reg.finalizer(ans, delete_Index)
  ans
  
}

attr(`Index`, 'returnType') = '_p_boost__shared_ptrT_Index_t'
class(`Index`) = c("SWIGFunction", class('Index'))

# Start of delete_Index

`delete_Index` = function(self)
{
  ;.Call('R_swig_delete_Index', self, PACKAGE='QuantLib');
  
}

attr(`delete_Index`, 'returnType') = 'void'
attr(`delete_Index`, "inputTypes") = c('_p_boost__shared_ptrT_Index_t')
class(`delete_Index`) = c("SWIGFunction", class('delete_Index'))

# Start of Index_name

`Index_name` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Index_name', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Index_name`, 'returnType') = 'character'
attr(`Index_name`, "inputTypes") = c('_p_boost__shared_ptrT_Index_t')
class(`Index_name`) = c("SWIGFunction", class('Index_name'))

# Start of Index_fixingCalendar

`Index_fixingCalendar` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_Index_fixingCalendar', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Calendar";
  
  ans
  
}

attr(`Index_fixingCalendar`, 'returnType') = '_p_Calendar'
attr(`Index_fixingCalendar`, "inputTypes") = c('_p_boost__shared_ptrT_Index_t')
class(`Index_fixingCalendar`) = c("SWIGFunction", class('Index_fixingCalendar'))

# Start of Index_isValidFixingDate

`Index_isValidFixingDate` = function(self, fixingDate, .copy = FALSE)
{
  ;.Call('R_swig_Index_isValidFixingDate', self, fixingDate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Index_isValidFixingDate`, 'returnType') = 'logical'
attr(`Index_isValidFixingDate`, "inputTypes") = c('_p_boost__shared_ptrT_Index_t', '_p_Date')
class(`Index_isValidFixingDate`) = c("SWIGFunction", class('Index_isValidFixingDate'))

# Start of Index_fixing

`Index_fixing__SWIG_0` = function(self, fixingDate, forecastTodaysFixing, .copy = FALSE)
{
  forecastTodaysFixing = as.logical(forecastTodaysFixing);
  ;.Call('R_swig_Index_fixing__SWIG_0', self, fixingDate, forecastTodaysFixing, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Index_fixing__SWIG_0`, 'returnType') = 'numeric'
attr(`Index_fixing__SWIG_0`, "inputTypes") = c('_p_boost__shared_ptrT_Index_t', '_p_Date', 'logical')
class(`Index_fixing__SWIG_0`) = c("SWIGFunction", class('Index_fixing__SWIG_0'))

# Start of Index_fixing

`Index_fixing__SWIG_1` = function(self, fixingDate, .copy = FALSE)
{
  ;.Call('R_swig_Index_fixing__SWIG_1', self, fixingDate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Index_fixing__SWIG_1`, 'returnType') = 'numeric'
attr(`Index_fixing__SWIG_1`, "inputTypes") = c('_p_boost__shared_ptrT_Index_t', '_p_Date')
class(`Index_fixing__SWIG_1`) = c("SWIGFunction", class('Index_fixing__SWIG_1'))

`Index_fixing` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_Index_t') && extends(argtypes[2], '_p_Date')) {
      f <- Index_fixing__SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_Index_t') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], 'logical')) {
      f <- Index_fixing__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Index_fixing with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of Index_addFixing

`Index_addFixing` = function(self, fixingDate, fixing)
{
  ;.Call('R_swig_Index_addFixing', self, fixingDate, fixing, PACKAGE='QuantLib');
  
}

attr(`Index_addFixing`, 'returnType') = 'void'
attr(`Index_addFixing`, "inputTypes") = c('_p_boost__shared_ptrT_Index_t', '_p_Date', 'numeric')
class(`Index_addFixing`) = c("SWIGFunction", class('Index_addFixing'))

# Start of accessor method for boost::shared_ptr<(Index)>
setMethod('$', '_p_boost__shared_ptrT_Index_t', function(x, name)

{
  accessorFuns = list('__deref__' = Index___deref__, 'isNull' = Index_isNull, 'addFixings' = Index_addFixings, '__str__' = Index___str__, 'asObservable' = Index_asObservable, 'name' = Index_name, 'fixingCalendar' = Index_fixingCalendar, 'isValidFixingDate' = Index_isValidFixingDate, 'fixing' = Index_fixing, 'addFixing' = Index_addFixing);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for boost::shared_ptr<(Index)>
setMethod('delete', '_p_boost__shared_ptrT_Index_t', function(obj) {delete_boost__shared_ptrT_Index_t(obj)})
# Start of InterestRateIndex_familyName

`InterestRateIndex_familyName` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_InterestRateIndex_familyName', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`InterestRateIndex_familyName`, 'returnType') = 'character'
attr(`InterestRateIndex_familyName`, "inputTypes") = c('_p_InterestRateIndexPtr')
class(`InterestRateIndex_familyName`) = c("SWIGFunction", class('InterestRateIndex_familyName'))

# Start of InterestRateIndex_tenor

`InterestRateIndex_tenor` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_InterestRateIndex_tenor', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Period";
  
  ans
  
}

attr(`InterestRateIndex_tenor`, 'returnType') = '_p_Period'
attr(`InterestRateIndex_tenor`, "inputTypes") = c('_p_InterestRateIndexPtr')
class(`InterestRateIndex_tenor`) = c("SWIGFunction", class('InterestRateIndex_tenor'))

# Start of InterestRateIndex_fixingDays

`InterestRateIndex_fixingDays` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_InterestRateIndex_fixingDays', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`InterestRateIndex_fixingDays`, 'returnType') = 'integer'
attr(`InterestRateIndex_fixingDays`, "inputTypes") = c('_p_InterestRateIndexPtr')
class(`InterestRateIndex_fixingDays`) = c("SWIGFunction", class('InterestRateIndex_fixingDays'))

# Start of InterestRateIndex_fixingDate

`InterestRateIndex_fixingDate` = function(self, valueDate, .copy = FALSE)
{
  ;ans = .Call('R_swig_InterestRateIndex_fixingDate', self, valueDate, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`InterestRateIndex_fixingDate`, 'returnType') = '_p_Date'
attr(`InterestRateIndex_fixingDate`, "inputTypes") = c('_p_InterestRateIndexPtr', '_p_Date')
class(`InterestRateIndex_fixingDate`) = c("SWIGFunction", class('InterestRateIndex_fixingDate'))

# Start of InterestRateIndex_currency

`InterestRateIndex_currency` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_InterestRateIndex_currency', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Currency";
  
  ans
  
}

attr(`InterestRateIndex_currency`, 'returnType') = '_p_Currency'
attr(`InterestRateIndex_currency`, "inputTypes") = c('_p_InterestRateIndexPtr')
class(`InterestRateIndex_currency`) = c("SWIGFunction", class('InterestRateIndex_currency'))

# Start of InterestRateIndex_dayCounter

`InterestRateIndex_dayCounter` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_InterestRateIndex_dayCounter', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_DayCounter";
  
  ans
  
}

attr(`InterestRateIndex_dayCounter`, 'returnType') = '_p_DayCounter'
attr(`InterestRateIndex_dayCounter`, "inputTypes") = c('_p_InterestRateIndexPtr')
class(`InterestRateIndex_dayCounter`) = c("SWIGFunction", class('InterestRateIndex_dayCounter'))

# Start of InterestRateIndex_maturityDate

`InterestRateIndex_maturityDate` = function(self, valueDate, .copy = FALSE)
{
  ;ans = .Call('R_swig_InterestRateIndex_maturityDate', self, valueDate, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`InterestRateIndex_maturityDate`, 'returnType') = '_p_Date'
attr(`InterestRateIndex_maturityDate`, "inputTypes") = c('_p_InterestRateIndexPtr', '_p_Date')
class(`InterestRateIndex_maturityDate`) = c("SWIGFunction", class('InterestRateIndex_maturityDate'))

# Start of InterestRateIndex_valueDate

`InterestRateIndex_valueDate` = function(self, fixingDate, .copy = FALSE)
{
  ;ans = .Call('R_swig_InterestRateIndex_valueDate', self, fixingDate, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`InterestRateIndex_valueDate`, 'returnType') = '_p_Date'
attr(`InterestRateIndex_valueDate`, "inputTypes") = c('_p_InterestRateIndexPtr', '_p_Date')
class(`InterestRateIndex_valueDate`) = c("SWIGFunction", class('InterestRateIndex_valueDate'))

# Start of delete_InterestRateIndex

`delete_InterestRateIndex` = function(self)
{
  ;.Call('R_swig_delete_InterestRateIndex', self, PACKAGE='QuantLib');
  
}

attr(`delete_InterestRateIndex`, 'returnType') = 'void'
attr(`delete_InterestRateIndex`, "inputTypes") = c('_p_InterestRateIndexPtr')
class(`delete_InterestRateIndex`) = c("SWIGFunction", class('delete_InterestRateIndex'))

# Start of accessor method for InterestRateIndexPtr
setMethod('$', '_p_InterestRateIndexPtr', function(x, name)

{
  accessorFuns = list('familyName' = InterestRateIndex_familyName, 'tenor' = InterestRateIndex_tenor, 'fixingDays' = InterestRateIndex_fixingDays, 'fixingDate' = InterestRateIndex_fixingDate, 'currency' = InterestRateIndex_currency, 'dayCounter' = InterestRateIndex_dayCounter, 'maturityDate' = InterestRateIndex_maturityDate, 'valueDate' = InterestRateIndex_valueDate);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for InterestRateIndexPtr
setMethod('delete', '_p_InterestRateIndexPtr', function(obj) {delete_InterestRateIndexPtr(obj)})
# Start of new_IborIndex

`IborIndex__SWIG_0` = function(familyName, tenor, settlementDays, currency, calendar, convention, endOfMonth, dayCounter, h)
{
  familyName = as(familyName, "character"); 
  
  settlementDays = as.integer(settlementDays); 
  
  if(length(settlementDays) > 1) {
    warning("using only the first element of settlementDays");
  };
  
  
  
  convention = enumToInteger(convention, "_BusinessDayConvention"); 
  
  if(length(convention) > 1) {
    warning("using only the first element of convention");
  };
  
  endOfMonth = as.logical(endOfMonth);
  
  
  ;ans = .Call('R_swig_new_IborIndex__SWIG_0', familyName, tenor, settlementDays, currency, calendar, convention, endOfMonth, dayCounter, h, PACKAGE='QuantLib');
  class(ans) <- "_p_IborIndexPtr";
  
  reg.finalizer(ans, delete_IborIndex)
  ans
  
}

attr(`IborIndex__SWIG_0`, 'returnType') = '_p_IborIndexPtr'
attr(`IborIndex__SWIG_0`, "inputTypes") = c('character', '_p_Period', 'integer', '_p_Currency', '_p_Calendar', 'character', 'logical', '_p_DayCounter', '_p_HandleT_YieldTermStructure_t')
class(`IborIndex__SWIG_0`) = c("SWIGFunction", class('IborIndex__SWIG_0'))

# Start of new_IborIndex

`IborIndex__SWIG_1` = function(familyName, tenor, settlementDays, currency, calendar, convention, endOfMonth, dayCounter)
{
  familyName = as(familyName, "character"); 
  
  settlementDays = as.integer(settlementDays); 
  
  if(length(settlementDays) > 1) {
    warning("using only the first element of settlementDays");
  };
  
  
  
  convention = enumToInteger(convention, "_BusinessDayConvention"); 
  
  if(length(convention) > 1) {
    warning("using only the first element of convention");
  };
  
  endOfMonth = as.logical(endOfMonth);
  
  ;ans = .Call('R_swig_new_IborIndex__SWIG_1', familyName, tenor, settlementDays, currency, calendar, convention, endOfMonth, dayCounter, PACKAGE='QuantLib');
  class(ans) <- "_p_IborIndexPtr";
  
  reg.finalizer(ans, delete_IborIndex)
  ans
  
}

attr(`IborIndex__SWIG_1`, 'returnType') = '_p_IborIndexPtr'
attr(`IborIndex__SWIG_1`, "inputTypes") = c('character', '_p_Period', 'integer', '_p_Currency', '_p_Calendar', 'character', 'logical', '_p_DayCounter')
class(`IborIndex__SWIG_1`) = c("SWIGFunction", class('IborIndex__SWIG_1'))

`IborIndex` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 8) {
    if (is.character(argv[[1]]) && extends(argtypes[2], '_p_Period') && (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && extends(argtypes[4], '_p_Currency') && extends(argtypes[5], '_p_Calendar') && is.character(argv[[6]]) && extends(argtypes[7], 'logical') && extends(argtypes[8], '_p_DayCounter')) {
      f <- IborIndex__SWIG_1; 
    }
  } else if (argc == 9) {
    if (is.character(argv[[1]]) && extends(argtypes[2], '_p_Period') && (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && extends(argtypes[4], '_p_Currency') && extends(argtypes[5], '_p_Calendar') && is.character(argv[[6]]) && extends(argtypes[7], 'logical') && extends(argtypes[8], '_p_DayCounter') && extends(argtypes[9], '_p_HandleT_YieldTermStructure_t')) {
      f <- IborIndex__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for IborIndex with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of IborIndex_businessDayConvention

`IborIndex_businessDayConvention` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_IborIndex_businessDayConvention', self, as.logical(.copy), PACKAGE='QuantLib');
  ans = enumFromInteger(ans, "_BusinessDayConvention");
  
  ans
  
}

attr(`IborIndex_businessDayConvention`, 'returnType') = 'character'
attr(`IborIndex_businessDayConvention`, "inputTypes") = c('_p_IborIndexPtr')
class(`IborIndex_businessDayConvention`) = c("SWIGFunction", class('IborIndex_businessDayConvention'))

# Start of IborIndex_endOfMonth

`IborIndex_endOfMonth` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_IborIndex_endOfMonth', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`IborIndex_endOfMonth`, 'returnType') = 'logical'
attr(`IborIndex_endOfMonth`, "inputTypes") = c('_p_IborIndexPtr')
class(`IborIndex_endOfMonth`) = c("SWIGFunction", class('IborIndex_endOfMonth'))

# Start of IborIndex_forwardingTermStructure

`IborIndex_forwardingTermStructure` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_IborIndex_forwardingTermStructure', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_HandleT_YieldTermStructure_t";
  
  ans
  
}

attr(`IborIndex_forwardingTermStructure`, 'returnType') = '_p_HandleT_YieldTermStructure_t'
attr(`IborIndex_forwardingTermStructure`, "inputTypes") = c('_p_IborIndexPtr')
class(`IborIndex_forwardingTermStructure`) = c("SWIGFunction", class('IborIndex_forwardingTermStructure'))

# Start of delete_IborIndex

`delete_IborIndex` = function(self)
{
  ;.Call('R_swig_delete_IborIndex', self, PACKAGE='QuantLib');
  
}

attr(`delete_IborIndex`, 'returnType') = 'void'
attr(`delete_IborIndex`, "inputTypes") = c('_p_IborIndexPtr')
class(`delete_IborIndex`) = c("SWIGFunction", class('delete_IborIndex'))

# Start of accessor method for IborIndexPtr
setMethod('$', '_p_IborIndexPtr', function(x, name)

{
  accessorFuns = list('businessDayConvention' = IborIndex_businessDayConvention, 'endOfMonth' = IborIndex_endOfMonth, 'forwardingTermStructure' = IborIndex_forwardingTermStructure);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for IborIndexPtr
setMethod('delete', '_p_IborIndexPtr', function(obj) {delete_IborIndexPtr(obj)})
# Start of new_SwapIndex

`SwapIndex__SWIG_0` = function(familyName, tenor, settlementDays, currency, calendar, fixedLegTenor, fixedLegConvention, fixedLegDayCounter, iborIndex)
{
  familyName = as(familyName, "character"); 
  
  settlementDays = as.integer(settlementDays); 
  
  if(length(settlementDays) > 1) {
    warning("using only the first element of settlementDays");
  };
  
  
  
  
  fixedLegConvention = enumToInteger(fixedLegConvention, "_BusinessDayConvention"); 
  
  if(length(fixedLegConvention) > 1) {
    warning("using only the first element of fixedLegConvention");
  };
  
  
  
  ;ans = .Call('R_swig_new_SwapIndex__SWIG_0', familyName, tenor, settlementDays, currency, calendar, fixedLegTenor, fixedLegConvention, fixedLegDayCounter, iborIndex, PACKAGE='QuantLib');
  class(ans) <- "_p_SwapIndexPtr";
  
  reg.finalizer(ans, delete_SwapIndex)
  ans
  
}

attr(`SwapIndex__SWIG_0`, 'returnType') = '_p_SwapIndexPtr'
attr(`SwapIndex__SWIG_0`, "inputTypes") = c('character', '_p_Period', 'integer', '_p_Currency', '_p_Calendar', '_p_Period', 'character', '_p_DayCounter', '_p_IborIndexPtr')
class(`SwapIndex__SWIG_0`) = c("SWIGFunction", class('SwapIndex__SWIG_0'))

# Start of new_SwapIndex

`SwapIndex__SWIG_1` = function(familyName, tenor, settlementDays, currency, calendar, fixedLegTenor, fixedLegConvention, fixedLegDayCounter, iborIndex, discountCurve)
{
  familyName = as(familyName, "character"); 
  
  settlementDays = as.integer(settlementDays); 
  
  if(length(settlementDays) > 1) {
    warning("using only the first element of settlementDays");
  };
  
  
  
  
  fixedLegConvention = enumToInteger(fixedLegConvention, "_BusinessDayConvention"); 
  
  if(length(fixedLegConvention) > 1) {
    warning("using only the first element of fixedLegConvention");
  };
  
  
  
  
  ;ans = .Call('R_swig_new_SwapIndex__SWIG_1', familyName, tenor, settlementDays, currency, calendar, fixedLegTenor, fixedLegConvention, fixedLegDayCounter, iborIndex, discountCurve, PACKAGE='QuantLib');
  class(ans) <- "_p_SwapIndexPtr";
  
  reg.finalizer(ans, delete_SwapIndex)
  ans
  
}

attr(`SwapIndex__SWIG_1`, 'returnType') = '_p_SwapIndexPtr'
attr(`SwapIndex__SWIG_1`, "inputTypes") = c('character', '_p_Period', 'integer', '_p_Currency', '_p_Calendar', '_p_Period', 'character', '_p_DayCounter', '_p_IborIndexPtr', '_p_HandleT_YieldTermStructure_t')
class(`SwapIndex__SWIG_1`) = c("SWIGFunction", class('SwapIndex__SWIG_1'))

`SwapIndex` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 9) {
    if (is.character(argv[[1]]) && extends(argtypes[2], '_p_Period') && (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && extends(argtypes[4], '_p_Currency') && extends(argtypes[5], '_p_Calendar') && extends(argtypes[6], '_p_Period') && is.character(argv[[7]]) && extends(argtypes[8], '_p_DayCounter') && extends(argtypes[9], '_p_IborIndexPtr')) {
      f <- SwapIndex__SWIG_0; 
    }
  } else if (argc == 10) {
    if (is.character(argv[[1]]) && extends(argtypes[2], '_p_Period') && (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && extends(argtypes[4], '_p_Currency') && extends(argtypes[5], '_p_Calendar') && extends(argtypes[6], '_p_Period') && is.character(argv[[7]]) && extends(argtypes[8], '_p_DayCounter') && extends(argtypes[9], '_p_IborIndexPtr') && extends(argtypes[10], '_p_HandleT_YieldTermStructure_t')) {
      f <- SwapIndex__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for SwapIndex with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of SwapIndex_fixedLegTenor

`SwapIndex_fixedLegTenor` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_SwapIndex_fixedLegTenor', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Period";
  
  ans
  
}

attr(`SwapIndex_fixedLegTenor`, 'returnType') = '_p_Period'
attr(`SwapIndex_fixedLegTenor`, "inputTypes") = c('_p_SwapIndexPtr')
class(`SwapIndex_fixedLegTenor`) = c("SWIGFunction", class('SwapIndex_fixedLegTenor'))

# Start of SwapIndex_fixedLegConvention

`SwapIndex_fixedLegConvention` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_SwapIndex_fixedLegConvention', self, as.logical(.copy), PACKAGE='QuantLib');
  ans = enumFromInteger(ans, "_BusinessDayConvention");
  
  ans
  
}

attr(`SwapIndex_fixedLegConvention`, 'returnType') = 'character'
attr(`SwapIndex_fixedLegConvention`, "inputTypes") = c('_p_SwapIndexPtr')
class(`SwapIndex_fixedLegConvention`) = c("SWIGFunction", class('SwapIndex_fixedLegConvention'))

# Start of SwapIndex_iborIndex

`SwapIndex_iborIndex` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_SwapIndex_iborIndex', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_IborIndexPtr";
  
  ans
  
}

attr(`SwapIndex_iborIndex`, 'returnType') = '_p_IborIndexPtr'
attr(`SwapIndex_iborIndex`, "inputTypes") = c('_p_SwapIndexPtr')
class(`SwapIndex_iborIndex`) = c("SWIGFunction", class('SwapIndex_iborIndex'))

# Start of SwapIndex_forwardingTermStructure

`SwapIndex_forwardingTermStructure` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_SwapIndex_forwardingTermStructure', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_HandleT_YieldTermStructure_t";
  
  ans
  
}

attr(`SwapIndex_forwardingTermStructure`, 'returnType') = '_p_HandleT_YieldTermStructure_t'
attr(`SwapIndex_forwardingTermStructure`, "inputTypes") = c('_p_SwapIndexPtr')
class(`SwapIndex_forwardingTermStructure`) = c("SWIGFunction", class('SwapIndex_forwardingTermStructure'))

# Start of delete_SwapIndex

`delete_SwapIndex` = function(self)
{
  ;.Call('R_swig_delete_SwapIndex', self, PACKAGE='QuantLib');
  
}

attr(`delete_SwapIndex`, 'returnType') = 'void'
attr(`delete_SwapIndex`, "inputTypes") = c('_p_SwapIndexPtr')
class(`delete_SwapIndex`) = c("SWIGFunction", class('delete_SwapIndex'))

# Start of accessor method for SwapIndexPtr
setMethod('$', '_p_SwapIndexPtr', function(x, name)

{
  accessorFuns = list('fixedLegTenor' = SwapIndex_fixedLegTenor, 'fixedLegConvention' = SwapIndex_fixedLegConvention, 'iborIndex' = SwapIndex_iborIndex, 'forwardingTermStructure' = SwapIndex_forwardingTermStructure);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for SwapIndexPtr
setMethod('delete', '_p_SwapIndexPtr', function(obj) {delete_SwapIndexPtr(obj)})
# Start of new_AUDLibor

`AUDLibor__SWIG_0` = function(tenor, h)
{
  ;ans = .Call('R_swig_new_AUDLibor__SWIG_0', tenor, h, PACKAGE='QuantLib');
  class(ans) <- "_p_AUDLiborPtr";
  
  reg.finalizer(ans, delete_AUDLibor)
  ans
  
}

attr(`AUDLibor__SWIG_0`, 'returnType') = '_p_AUDLiborPtr'
attr(`AUDLibor__SWIG_0`, "inputTypes") = c('_p_Period', '_p_HandleT_YieldTermStructure_t')
class(`AUDLibor__SWIG_0`) = c("SWIGFunction", class('AUDLibor__SWIG_0'))

# Start of new_AUDLibor

`AUDLibor__SWIG_1` = function(tenor)
{
  ;ans = .Call('R_swig_new_AUDLibor__SWIG_1', tenor, PACKAGE='QuantLib');
  class(ans) <- "_p_AUDLiborPtr";
  
  reg.finalizer(ans, delete_AUDLibor)
  ans
  
}

attr(`AUDLibor__SWIG_1`, 'returnType') = '_p_AUDLiborPtr'
attr(`AUDLibor__SWIG_1`, "inputTypes") = c('_p_Period')
class(`AUDLibor__SWIG_1`) = c("SWIGFunction", class('AUDLibor__SWIG_1'))

`AUDLibor` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_Period')) {
      f <- AUDLibor__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_Period') && extends(argtypes[2], '_p_HandleT_YieldTermStructure_t')) {
      f <- AUDLibor__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for AUDLibor with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_AUDLibor

`delete_AUDLibor` = function(self)
{
  ;.Call('R_swig_delete_AUDLibor', self, PACKAGE='QuantLib');
  
}

attr(`delete_AUDLibor`, 'returnType') = 'void'
attr(`delete_AUDLibor`, "inputTypes") = c('_p_AUDLiborPtr')
class(`delete_AUDLibor`) = c("SWIGFunction", class('delete_AUDLibor'))

setMethod('delete', '_p_AUDLiborPtr', function(obj) {delete_AUDLiborPtr(obj)})
# Start of new_CADLibor

`CADLibor__SWIG_0` = function(tenor, h)
{
  ;ans = .Call('R_swig_new_CADLibor__SWIG_0', tenor, h, PACKAGE='QuantLib');
  class(ans) <- "_p_CADLiborPtr";
  
  reg.finalizer(ans, delete_CADLibor)
  ans
  
}

attr(`CADLibor__SWIG_0`, 'returnType') = '_p_CADLiborPtr'
attr(`CADLibor__SWIG_0`, "inputTypes") = c('_p_Period', '_p_HandleT_YieldTermStructure_t')
class(`CADLibor__SWIG_0`) = c("SWIGFunction", class('CADLibor__SWIG_0'))

# Start of new_CADLibor

`CADLibor__SWIG_1` = function(tenor)
{
  ;ans = .Call('R_swig_new_CADLibor__SWIG_1', tenor, PACKAGE='QuantLib');
  class(ans) <- "_p_CADLiborPtr";
  
  reg.finalizer(ans, delete_CADLibor)
  ans
  
}

attr(`CADLibor__SWIG_1`, 'returnType') = '_p_CADLiborPtr'
attr(`CADLibor__SWIG_1`, "inputTypes") = c('_p_Period')
class(`CADLibor__SWIG_1`) = c("SWIGFunction", class('CADLibor__SWIG_1'))

`CADLibor` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_Period')) {
      f <- CADLibor__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_Period') && extends(argtypes[2], '_p_HandleT_YieldTermStructure_t')) {
      f <- CADLibor__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for CADLibor with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_CADLibor

`delete_CADLibor` = function(self)
{
  ;.Call('R_swig_delete_CADLibor', self, PACKAGE='QuantLib');
  
}

attr(`delete_CADLibor`, 'returnType') = 'void'
attr(`delete_CADLibor`, "inputTypes") = c('_p_CADLiborPtr')
class(`delete_CADLibor`) = c("SWIGFunction", class('delete_CADLibor'))

setMethod('delete', '_p_CADLiborPtr', function(obj) {delete_CADLiborPtr(obj)})
# Start of new_Cdor

`Cdor__SWIG_0` = function(tenor, h)
{
  ;ans = .Call('R_swig_new_Cdor__SWIG_0', tenor, h, PACKAGE='QuantLib');
  class(ans) <- "_p_CdorPtr";
  
  reg.finalizer(ans, delete_Cdor)
  ans
  
}

attr(`Cdor__SWIG_0`, 'returnType') = '_p_CdorPtr'
attr(`Cdor__SWIG_0`, "inputTypes") = c('_p_Period', '_p_HandleT_YieldTermStructure_t')
class(`Cdor__SWIG_0`) = c("SWIGFunction", class('Cdor__SWIG_0'))

# Start of new_Cdor

`Cdor__SWIG_1` = function(tenor)
{
  ;ans = .Call('R_swig_new_Cdor__SWIG_1', tenor, PACKAGE='QuantLib');
  class(ans) <- "_p_CdorPtr";
  
  reg.finalizer(ans, delete_Cdor)
  ans
  
}

attr(`Cdor__SWIG_1`, 'returnType') = '_p_CdorPtr'
attr(`Cdor__SWIG_1`, "inputTypes") = c('_p_Period')
class(`Cdor__SWIG_1`) = c("SWIGFunction", class('Cdor__SWIG_1'))

`Cdor` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_Period')) {
      f <- Cdor__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_Period') && extends(argtypes[2], '_p_HandleT_YieldTermStructure_t')) {
      f <- Cdor__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Cdor with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_Cdor

`delete_Cdor` = function(self)
{
  ;.Call('R_swig_delete_Cdor', self, PACKAGE='QuantLib');
  
}

attr(`delete_Cdor`, 'returnType') = 'void'
attr(`delete_Cdor`, "inputTypes") = c('_p_CdorPtr')
class(`delete_Cdor`) = c("SWIGFunction", class('delete_Cdor'))

setMethod('delete', '_p_CdorPtr', function(obj) {delete_CdorPtr(obj)})
# Start of new_CHFLibor

`CHFLibor__SWIG_0` = function(tenor, h)
{
  ;ans = .Call('R_swig_new_CHFLibor__SWIG_0', tenor, h, PACKAGE='QuantLib');
  class(ans) <- "_p_CHFLiborPtr";
  
  reg.finalizer(ans, delete_CHFLibor)
  ans
  
}

attr(`CHFLibor__SWIG_0`, 'returnType') = '_p_CHFLiborPtr'
attr(`CHFLibor__SWIG_0`, "inputTypes") = c('_p_Period', '_p_HandleT_YieldTermStructure_t')
class(`CHFLibor__SWIG_0`) = c("SWIGFunction", class('CHFLibor__SWIG_0'))

# Start of new_CHFLibor

`CHFLibor__SWIG_1` = function(tenor)
{
  ;ans = .Call('R_swig_new_CHFLibor__SWIG_1', tenor, PACKAGE='QuantLib');
  class(ans) <- "_p_CHFLiborPtr";
  
  reg.finalizer(ans, delete_CHFLibor)
  ans
  
}

attr(`CHFLibor__SWIG_1`, 'returnType') = '_p_CHFLiborPtr'
attr(`CHFLibor__SWIG_1`, "inputTypes") = c('_p_Period')
class(`CHFLibor__SWIG_1`) = c("SWIGFunction", class('CHFLibor__SWIG_1'))

`CHFLibor` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_Period')) {
      f <- CHFLibor__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_Period') && extends(argtypes[2], '_p_HandleT_YieldTermStructure_t')) {
      f <- CHFLibor__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for CHFLibor with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_CHFLibor

`delete_CHFLibor` = function(self)
{
  ;.Call('R_swig_delete_CHFLibor', self, PACKAGE='QuantLib');
  
}

attr(`delete_CHFLibor`, 'returnType') = 'void'
attr(`delete_CHFLibor`, "inputTypes") = c('_p_CHFLiborPtr')
class(`delete_CHFLibor`) = c("SWIGFunction", class('delete_CHFLibor'))

setMethod('delete', '_p_CHFLiborPtr', function(obj) {delete_CHFLiborPtr(obj)})
# Start of new_DKKLibor

`DKKLibor__SWIG_0` = function(tenor, h)
{
  ;ans = .Call('R_swig_new_DKKLibor__SWIG_0', tenor, h, PACKAGE='QuantLib');
  class(ans) <- "_p_DKKLiborPtr";
  
  reg.finalizer(ans, delete_DKKLibor)
  ans
  
}

attr(`DKKLibor__SWIG_0`, 'returnType') = '_p_DKKLiborPtr'
attr(`DKKLibor__SWIG_0`, "inputTypes") = c('_p_Period', '_p_HandleT_YieldTermStructure_t')
class(`DKKLibor__SWIG_0`) = c("SWIGFunction", class('DKKLibor__SWIG_0'))

# Start of new_DKKLibor

`DKKLibor__SWIG_1` = function(tenor)
{
  ;ans = .Call('R_swig_new_DKKLibor__SWIG_1', tenor, PACKAGE='QuantLib');
  class(ans) <- "_p_DKKLiborPtr";
  
  reg.finalizer(ans, delete_DKKLibor)
  ans
  
}

attr(`DKKLibor__SWIG_1`, 'returnType') = '_p_DKKLiborPtr'
attr(`DKKLibor__SWIG_1`, "inputTypes") = c('_p_Period')
class(`DKKLibor__SWIG_1`) = c("SWIGFunction", class('DKKLibor__SWIG_1'))

`DKKLibor` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_Period')) {
      f <- DKKLibor__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_Period') && extends(argtypes[2], '_p_HandleT_YieldTermStructure_t')) {
      f <- DKKLibor__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for DKKLibor with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_DKKLibor

`delete_DKKLibor` = function(self)
{
  ;.Call('R_swig_delete_DKKLibor', self, PACKAGE='QuantLib');
  
}

attr(`delete_DKKLibor`, 'returnType') = 'void'
attr(`delete_DKKLibor`, "inputTypes") = c('_p_DKKLiborPtr')
class(`delete_DKKLibor`) = c("SWIGFunction", class('delete_DKKLibor'))

setMethod('delete', '_p_DKKLiborPtr', function(obj) {delete_DKKLiborPtr(obj)})
# Start of new_Euribor

`Euribor__SWIG_0` = function(tenor, h)
{
  ;ans = .Call('R_swig_new_Euribor__SWIG_0', tenor, h, PACKAGE='QuantLib');
  class(ans) <- "_p_EuriborPtr";
  
  reg.finalizer(ans, delete_Euribor)
  ans
  
}

attr(`Euribor__SWIG_0`, 'returnType') = '_p_EuriborPtr'
attr(`Euribor__SWIG_0`, "inputTypes") = c('_p_Period', '_p_HandleT_YieldTermStructure_t')
class(`Euribor__SWIG_0`) = c("SWIGFunction", class('Euribor__SWIG_0'))

# Start of new_Euribor

`Euribor__SWIG_1` = function(tenor)
{
  ;ans = .Call('R_swig_new_Euribor__SWIG_1', tenor, PACKAGE='QuantLib');
  class(ans) <- "_p_EuriborPtr";
  
  reg.finalizer(ans, delete_Euribor)
  ans
  
}

attr(`Euribor__SWIG_1`, 'returnType') = '_p_EuriborPtr'
attr(`Euribor__SWIG_1`, "inputTypes") = c('_p_Period')
class(`Euribor__SWIG_1`) = c("SWIGFunction", class('Euribor__SWIG_1'))

`Euribor` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_Period')) {
      f <- Euribor__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_Period') && extends(argtypes[2], '_p_HandleT_YieldTermStructure_t')) {
      f <- Euribor__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Euribor with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_Euribor

`delete_Euribor` = function(self)
{
  ;.Call('R_swig_delete_Euribor', self, PACKAGE='QuantLib');
  
}

attr(`delete_Euribor`, 'returnType') = 'void'
attr(`delete_Euribor`, "inputTypes") = c('_p_EuriborPtr')
class(`delete_Euribor`) = c("SWIGFunction", class('delete_Euribor'))

setMethod('delete', '_p_EuriborPtr', function(obj) {delete_EuriborPtr(obj)})
# Start of new_EuriborSW

`EuriborSW__SWIG_0` = function(h)
{
  ;ans = .Call('R_swig_new_EuriborSW__SWIG_0', h, PACKAGE='QuantLib');
  class(ans) <- "_p_EuriborSWPtr";
  
  reg.finalizer(ans, delete_EuriborSW)
  ans
  
}

attr(`EuriborSW__SWIG_0`, 'returnType') = '_p_EuriborSWPtr'
attr(`EuriborSW__SWIG_0`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`EuriborSW__SWIG_0`) = c("SWIGFunction", class('EuriborSW__SWIG_0'))

# Start of new_EuriborSW

`EuriborSW__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_EuriborSW__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_EuriborSWPtr";
  
  reg.finalizer(ans, delete_EuriborSW)
  ans
  
}

attr(`EuriborSW__SWIG_1`, 'returnType') = '_p_EuriborSWPtr'
class(`EuriborSW__SWIG_1`) = c("SWIGFunction", class('EuriborSW__SWIG_1'))

`EuriborSW` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- EuriborSW__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t')) {
      f <- EuriborSW__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for EuriborSW with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_EuriborSW

`delete_EuriborSW` = function(self)
{
  ;.Call('R_swig_delete_EuriborSW', self, PACKAGE='QuantLib');
  
}

attr(`delete_EuriborSW`, 'returnType') = 'void'
attr(`delete_EuriborSW`, "inputTypes") = c('_p_EuriborSWPtr')
class(`delete_EuriborSW`) = c("SWIGFunction", class('delete_EuriborSW'))

setMethod('delete', '_p_EuriborSWPtr', function(obj) {delete_EuriborSWPtr(obj)})
# Start of new_Euribor2W

`Euribor2W__SWIG_0` = function(h)
{
  ;ans = .Call('R_swig_new_Euribor2W__SWIG_0', h, PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor2WPtr";
  
  reg.finalizer(ans, delete_Euribor2W)
  ans
  
}

attr(`Euribor2W__SWIG_0`, 'returnType') = '_p_Euribor2WPtr'
attr(`Euribor2W__SWIG_0`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`Euribor2W__SWIG_0`) = c("SWIGFunction", class('Euribor2W__SWIG_0'))

# Start of new_Euribor2W

`Euribor2W__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_Euribor2W__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor2WPtr";
  
  reg.finalizer(ans, delete_Euribor2W)
  ans
  
}

attr(`Euribor2W__SWIG_1`, 'returnType') = '_p_Euribor2WPtr'
class(`Euribor2W__SWIG_1`) = c("SWIGFunction", class('Euribor2W__SWIG_1'))

`Euribor2W` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- Euribor2W__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t')) {
      f <- Euribor2W__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Euribor2W with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_Euribor2W

`delete_Euribor2W` = function(self)
{
  ;.Call('R_swig_delete_Euribor2W', self, PACKAGE='QuantLib');
  
}

attr(`delete_Euribor2W`, 'returnType') = 'void'
attr(`delete_Euribor2W`, "inputTypes") = c('_p_Euribor2WPtr')
class(`delete_Euribor2W`) = c("SWIGFunction", class('delete_Euribor2W'))

setMethod('delete', '_p_Euribor2WPtr', function(obj) {delete_Euribor2WPtr(obj)})
# Start of new_Euribor3W

`Euribor3W__SWIG_0` = function(h)
{
  ;ans = .Call('R_swig_new_Euribor3W__SWIG_0', h, PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor3WPtr";
  
  reg.finalizer(ans, delete_Euribor3W)
  ans
  
}

attr(`Euribor3W__SWIG_0`, 'returnType') = '_p_Euribor3WPtr'
attr(`Euribor3W__SWIG_0`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`Euribor3W__SWIG_0`) = c("SWIGFunction", class('Euribor3W__SWIG_0'))

# Start of new_Euribor3W

`Euribor3W__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_Euribor3W__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor3WPtr";
  
  reg.finalizer(ans, delete_Euribor3W)
  ans
  
}

attr(`Euribor3W__SWIG_1`, 'returnType') = '_p_Euribor3WPtr'
class(`Euribor3W__SWIG_1`) = c("SWIGFunction", class('Euribor3W__SWIG_1'))

`Euribor3W` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- Euribor3W__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t')) {
      f <- Euribor3W__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Euribor3W with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_Euribor3W

`delete_Euribor3W` = function(self)
{
  ;.Call('R_swig_delete_Euribor3W', self, PACKAGE='QuantLib');
  
}

attr(`delete_Euribor3W`, 'returnType') = 'void'
attr(`delete_Euribor3W`, "inputTypes") = c('_p_Euribor3WPtr')
class(`delete_Euribor3W`) = c("SWIGFunction", class('delete_Euribor3W'))

setMethod('delete', '_p_Euribor3WPtr', function(obj) {delete_Euribor3WPtr(obj)})
# Start of new_Euribor1M

`Euribor1M__SWIG_0` = function(h)
{
  ;ans = .Call('R_swig_new_Euribor1M__SWIG_0', h, PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor1MPtr";
  
  reg.finalizer(ans, delete_Euribor1M)
  ans
  
}

attr(`Euribor1M__SWIG_0`, 'returnType') = '_p_Euribor1MPtr'
attr(`Euribor1M__SWIG_0`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`Euribor1M__SWIG_0`) = c("SWIGFunction", class('Euribor1M__SWIG_0'))

# Start of new_Euribor1M

`Euribor1M__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_Euribor1M__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor1MPtr";
  
  reg.finalizer(ans, delete_Euribor1M)
  ans
  
}

attr(`Euribor1M__SWIG_1`, 'returnType') = '_p_Euribor1MPtr'
class(`Euribor1M__SWIG_1`) = c("SWIGFunction", class('Euribor1M__SWIG_1'))

`Euribor1M` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- Euribor1M__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t')) {
      f <- Euribor1M__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Euribor1M with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_Euribor1M

`delete_Euribor1M` = function(self)
{
  ;.Call('R_swig_delete_Euribor1M', self, PACKAGE='QuantLib');
  
}

attr(`delete_Euribor1M`, 'returnType') = 'void'
attr(`delete_Euribor1M`, "inputTypes") = c('_p_Euribor1MPtr')
class(`delete_Euribor1M`) = c("SWIGFunction", class('delete_Euribor1M'))

setMethod('delete', '_p_Euribor1MPtr', function(obj) {delete_Euribor1MPtr(obj)})
# Start of new_Euribor2M

`Euribor2M__SWIG_0` = function(h)
{
  ;ans = .Call('R_swig_new_Euribor2M__SWIG_0', h, PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor2MPtr";
  
  reg.finalizer(ans, delete_Euribor2M)
  ans
  
}

attr(`Euribor2M__SWIG_0`, 'returnType') = '_p_Euribor2MPtr'
attr(`Euribor2M__SWIG_0`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`Euribor2M__SWIG_0`) = c("SWIGFunction", class('Euribor2M__SWIG_0'))

# Start of new_Euribor2M

`Euribor2M__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_Euribor2M__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor2MPtr";
  
  reg.finalizer(ans, delete_Euribor2M)
  ans
  
}

attr(`Euribor2M__SWIG_1`, 'returnType') = '_p_Euribor2MPtr'
class(`Euribor2M__SWIG_1`) = c("SWIGFunction", class('Euribor2M__SWIG_1'))

`Euribor2M` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- Euribor2M__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t')) {
      f <- Euribor2M__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Euribor2M with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_Euribor2M

`delete_Euribor2M` = function(self)
{
  ;.Call('R_swig_delete_Euribor2M', self, PACKAGE='QuantLib');
  
}

attr(`delete_Euribor2M`, 'returnType') = 'void'
attr(`delete_Euribor2M`, "inputTypes") = c('_p_Euribor2MPtr')
class(`delete_Euribor2M`) = c("SWIGFunction", class('delete_Euribor2M'))

setMethod('delete', '_p_Euribor2MPtr', function(obj) {delete_Euribor2MPtr(obj)})
# Start of new_Euribor3M

`Euribor3M__SWIG_0` = function(h)
{
  ;ans = .Call('R_swig_new_Euribor3M__SWIG_0', h, PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor3MPtr";
  
  reg.finalizer(ans, delete_Euribor3M)
  ans
  
}

attr(`Euribor3M__SWIG_0`, 'returnType') = '_p_Euribor3MPtr'
attr(`Euribor3M__SWIG_0`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`Euribor3M__SWIG_0`) = c("SWIGFunction", class('Euribor3M__SWIG_0'))

# Start of new_Euribor3M

`Euribor3M__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_Euribor3M__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor3MPtr";
  
  reg.finalizer(ans, delete_Euribor3M)
  ans
  
}

attr(`Euribor3M__SWIG_1`, 'returnType') = '_p_Euribor3MPtr'
class(`Euribor3M__SWIG_1`) = c("SWIGFunction", class('Euribor3M__SWIG_1'))

`Euribor3M` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- Euribor3M__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t')) {
      f <- Euribor3M__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Euribor3M with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_Euribor3M

`delete_Euribor3M` = function(self)
{
  ;.Call('R_swig_delete_Euribor3M', self, PACKAGE='QuantLib');
  
}

attr(`delete_Euribor3M`, 'returnType') = 'void'
attr(`delete_Euribor3M`, "inputTypes") = c('_p_Euribor3MPtr')
class(`delete_Euribor3M`) = c("SWIGFunction", class('delete_Euribor3M'))

setMethod('delete', '_p_Euribor3MPtr', function(obj) {delete_Euribor3MPtr(obj)})
# Start of new_Euribor4M

`Euribor4M__SWIG_0` = function(h)
{
  ;ans = .Call('R_swig_new_Euribor4M__SWIG_0', h, PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor4MPtr";
  
  reg.finalizer(ans, delete_Euribor4M)
  ans
  
}

attr(`Euribor4M__SWIG_0`, 'returnType') = '_p_Euribor4MPtr'
attr(`Euribor4M__SWIG_0`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`Euribor4M__SWIG_0`) = c("SWIGFunction", class('Euribor4M__SWIG_0'))

# Start of new_Euribor4M

`Euribor4M__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_Euribor4M__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor4MPtr";
  
  reg.finalizer(ans, delete_Euribor4M)
  ans
  
}

attr(`Euribor4M__SWIG_1`, 'returnType') = '_p_Euribor4MPtr'
class(`Euribor4M__SWIG_1`) = c("SWIGFunction", class('Euribor4M__SWIG_1'))

`Euribor4M` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- Euribor4M__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t')) {
      f <- Euribor4M__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Euribor4M with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_Euribor4M

`delete_Euribor4M` = function(self)
{
  ;.Call('R_swig_delete_Euribor4M', self, PACKAGE='QuantLib');
  
}

attr(`delete_Euribor4M`, 'returnType') = 'void'
attr(`delete_Euribor4M`, "inputTypes") = c('_p_Euribor4MPtr')
class(`delete_Euribor4M`) = c("SWIGFunction", class('delete_Euribor4M'))

setMethod('delete', '_p_Euribor4MPtr', function(obj) {delete_Euribor4MPtr(obj)})
# Start of new_Euribor5M

`Euribor5M__SWIG_0` = function(h)
{
  ;ans = .Call('R_swig_new_Euribor5M__SWIG_0', h, PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor5MPtr";
  
  reg.finalizer(ans, delete_Euribor5M)
  ans
  
}

attr(`Euribor5M__SWIG_0`, 'returnType') = '_p_Euribor5MPtr'
attr(`Euribor5M__SWIG_0`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`Euribor5M__SWIG_0`) = c("SWIGFunction", class('Euribor5M__SWIG_0'))

# Start of new_Euribor5M

`Euribor5M__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_Euribor5M__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor5MPtr";
  
  reg.finalizer(ans, delete_Euribor5M)
  ans
  
}

attr(`Euribor5M__SWIG_1`, 'returnType') = '_p_Euribor5MPtr'
class(`Euribor5M__SWIG_1`) = c("SWIGFunction", class('Euribor5M__SWIG_1'))

`Euribor5M` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- Euribor5M__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t')) {
      f <- Euribor5M__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Euribor5M with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_Euribor5M

`delete_Euribor5M` = function(self)
{
  ;.Call('R_swig_delete_Euribor5M', self, PACKAGE='QuantLib');
  
}

attr(`delete_Euribor5M`, 'returnType') = 'void'
attr(`delete_Euribor5M`, "inputTypes") = c('_p_Euribor5MPtr')
class(`delete_Euribor5M`) = c("SWIGFunction", class('delete_Euribor5M'))

setMethod('delete', '_p_Euribor5MPtr', function(obj) {delete_Euribor5MPtr(obj)})
# Start of new_Euribor6M

`Euribor6M__SWIG_0` = function(h)
{
  ;ans = .Call('R_swig_new_Euribor6M__SWIG_0', h, PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor6MPtr";
  
  reg.finalizer(ans, delete_Euribor6M)
  ans
  
}

attr(`Euribor6M__SWIG_0`, 'returnType') = '_p_Euribor6MPtr'
attr(`Euribor6M__SWIG_0`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`Euribor6M__SWIG_0`) = c("SWIGFunction", class('Euribor6M__SWIG_0'))

# Start of new_Euribor6M

`Euribor6M__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_Euribor6M__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor6MPtr";
  
  reg.finalizer(ans, delete_Euribor6M)
  ans
  
}

attr(`Euribor6M__SWIG_1`, 'returnType') = '_p_Euribor6MPtr'
class(`Euribor6M__SWIG_1`) = c("SWIGFunction", class('Euribor6M__SWIG_1'))

`Euribor6M` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- Euribor6M__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t')) {
      f <- Euribor6M__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Euribor6M with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_Euribor6M

`delete_Euribor6M` = function(self)
{
  ;.Call('R_swig_delete_Euribor6M', self, PACKAGE='QuantLib');
  
}

attr(`delete_Euribor6M`, 'returnType') = 'void'
attr(`delete_Euribor6M`, "inputTypes") = c('_p_Euribor6MPtr')
class(`delete_Euribor6M`) = c("SWIGFunction", class('delete_Euribor6M'))

setMethod('delete', '_p_Euribor6MPtr', function(obj) {delete_Euribor6MPtr(obj)})
# Start of new_Euribor7M

`Euribor7M__SWIG_0` = function(h)
{
  ;ans = .Call('R_swig_new_Euribor7M__SWIG_0', h, PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor7MPtr";
  
  reg.finalizer(ans, delete_Euribor7M)
  ans
  
}

attr(`Euribor7M__SWIG_0`, 'returnType') = '_p_Euribor7MPtr'
attr(`Euribor7M__SWIG_0`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`Euribor7M__SWIG_0`) = c("SWIGFunction", class('Euribor7M__SWIG_0'))

# Start of new_Euribor7M

`Euribor7M__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_Euribor7M__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor7MPtr";
  
  reg.finalizer(ans, delete_Euribor7M)
  ans
  
}

attr(`Euribor7M__SWIG_1`, 'returnType') = '_p_Euribor7MPtr'
class(`Euribor7M__SWIG_1`) = c("SWIGFunction", class('Euribor7M__SWIG_1'))

`Euribor7M` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- Euribor7M__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t')) {
      f <- Euribor7M__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Euribor7M with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_Euribor7M

`delete_Euribor7M` = function(self)
{
  ;.Call('R_swig_delete_Euribor7M', self, PACKAGE='QuantLib');
  
}

attr(`delete_Euribor7M`, 'returnType') = 'void'
attr(`delete_Euribor7M`, "inputTypes") = c('_p_Euribor7MPtr')
class(`delete_Euribor7M`) = c("SWIGFunction", class('delete_Euribor7M'))

setMethod('delete', '_p_Euribor7MPtr', function(obj) {delete_Euribor7MPtr(obj)})
# Start of new_Euribor8M

`Euribor8M__SWIG_0` = function(h)
{
  ;ans = .Call('R_swig_new_Euribor8M__SWIG_0', h, PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor8MPtr";
  
  reg.finalizer(ans, delete_Euribor8M)
  ans
  
}

attr(`Euribor8M__SWIG_0`, 'returnType') = '_p_Euribor8MPtr'
attr(`Euribor8M__SWIG_0`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`Euribor8M__SWIG_0`) = c("SWIGFunction", class('Euribor8M__SWIG_0'))

# Start of new_Euribor8M

`Euribor8M__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_Euribor8M__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor8MPtr";
  
  reg.finalizer(ans, delete_Euribor8M)
  ans
  
}

attr(`Euribor8M__SWIG_1`, 'returnType') = '_p_Euribor8MPtr'
class(`Euribor8M__SWIG_1`) = c("SWIGFunction", class('Euribor8M__SWIG_1'))

`Euribor8M` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- Euribor8M__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t')) {
      f <- Euribor8M__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Euribor8M with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_Euribor8M

`delete_Euribor8M` = function(self)
{
  ;.Call('R_swig_delete_Euribor8M', self, PACKAGE='QuantLib');
  
}

attr(`delete_Euribor8M`, 'returnType') = 'void'
attr(`delete_Euribor8M`, "inputTypes") = c('_p_Euribor8MPtr')
class(`delete_Euribor8M`) = c("SWIGFunction", class('delete_Euribor8M'))

setMethod('delete', '_p_Euribor8MPtr', function(obj) {delete_Euribor8MPtr(obj)})
# Start of new_Euribor9M

`Euribor9M__SWIG_0` = function(h)
{
  ;ans = .Call('R_swig_new_Euribor9M__SWIG_0', h, PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor9MPtr";
  
  reg.finalizer(ans, delete_Euribor9M)
  ans
  
}

attr(`Euribor9M__SWIG_0`, 'returnType') = '_p_Euribor9MPtr'
attr(`Euribor9M__SWIG_0`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`Euribor9M__SWIG_0`) = c("SWIGFunction", class('Euribor9M__SWIG_0'))

# Start of new_Euribor9M

`Euribor9M__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_Euribor9M__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor9MPtr";
  
  reg.finalizer(ans, delete_Euribor9M)
  ans
  
}

attr(`Euribor9M__SWIG_1`, 'returnType') = '_p_Euribor9MPtr'
class(`Euribor9M__SWIG_1`) = c("SWIGFunction", class('Euribor9M__SWIG_1'))

`Euribor9M` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- Euribor9M__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t')) {
      f <- Euribor9M__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Euribor9M with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_Euribor9M

`delete_Euribor9M` = function(self)
{
  ;.Call('R_swig_delete_Euribor9M', self, PACKAGE='QuantLib');
  
}

attr(`delete_Euribor9M`, 'returnType') = 'void'
attr(`delete_Euribor9M`, "inputTypes") = c('_p_Euribor9MPtr')
class(`delete_Euribor9M`) = c("SWIGFunction", class('delete_Euribor9M'))

setMethod('delete', '_p_Euribor9MPtr', function(obj) {delete_Euribor9MPtr(obj)})
# Start of new_Euribor10M

`Euribor10M__SWIG_0` = function(h)
{
  ;ans = .Call('R_swig_new_Euribor10M__SWIG_0', h, PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor10MPtr";
  
  reg.finalizer(ans, delete_Euribor10M)
  ans
  
}

attr(`Euribor10M__SWIG_0`, 'returnType') = '_p_Euribor10MPtr'
attr(`Euribor10M__SWIG_0`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`Euribor10M__SWIG_0`) = c("SWIGFunction", class('Euribor10M__SWIG_0'))

# Start of new_Euribor10M

`Euribor10M__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_Euribor10M__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor10MPtr";
  
  reg.finalizer(ans, delete_Euribor10M)
  ans
  
}

attr(`Euribor10M__SWIG_1`, 'returnType') = '_p_Euribor10MPtr'
class(`Euribor10M__SWIG_1`) = c("SWIGFunction", class('Euribor10M__SWIG_1'))

`Euribor10M` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- Euribor10M__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t')) {
      f <- Euribor10M__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Euribor10M with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_Euribor10M

`delete_Euribor10M` = function(self)
{
  ;.Call('R_swig_delete_Euribor10M', self, PACKAGE='QuantLib');
  
}

attr(`delete_Euribor10M`, 'returnType') = 'void'
attr(`delete_Euribor10M`, "inputTypes") = c('_p_Euribor10MPtr')
class(`delete_Euribor10M`) = c("SWIGFunction", class('delete_Euribor10M'))

setMethod('delete', '_p_Euribor10MPtr', function(obj) {delete_Euribor10MPtr(obj)})
# Start of new_Euribor11M

`Euribor11M__SWIG_0` = function(h)
{
  ;ans = .Call('R_swig_new_Euribor11M__SWIG_0', h, PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor11MPtr";
  
  reg.finalizer(ans, delete_Euribor11M)
  ans
  
}

attr(`Euribor11M__SWIG_0`, 'returnType') = '_p_Euribor11MPtr'
attr(`Euribor11M__SWIG_0`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`Euribor11M__SWIG_0`) = c("SWIGFunction", class('Euribor11M__SWIG_0'))

# Start of new_Euribor11M

`Euribor11M__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_Euribor11M__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor11MPtr";
  
  reg.finalizer(ans, delete_Euribor11M)
  ans
  
}

attr(`Euribor11M__SWIG_1`, 'returnType') = '_p_Euribor11MPtr'
class(`Euribor11M__SWIG_1`) = c("SWIGFunction", class('Euribor11M__SWIG_1'))

`Euribor11M` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- Euribor11M__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t')) {
      f <- Euribor11M__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Euribor11M with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_Euribor11M

`delete_Euribor11M` = function(self)
{
  ;.Call('R_swig_delete_Euribor11M', self, PACKAGE='QuantLib');
  
}

attr(`delete_Euribor11M`, 'returnType') = 'void'
attr(`delete_Euribor11M`, "inputTypes") = c('_p_Euribor11MPtr')
class(`delete_Euribor11M`) = c("SWIGFunction", class('delete_Euribor11M'))

setMethod('delete', '_p_Euribor11MPtr', function(obj) {delete_Euribor11MPtr(obj)})
# Start of new_Euribor1Y

`Euribor1Y__SWIG_0` = function(h)
{
  ;ans = .Call('R_swig_new_Euribor1Y__SWIG_0', h, PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor1YPtr";
  
  reg.finalizer(ans, delete_Euribor1Y)
  ans
  
}

attr(`Euribor1Y__SWIG_0`, 'returnType') = '_p_Euribor1YPtr'
attr(`Euribor1Y__SWIG_0`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`Euribor1Y__SWIG_0`) = c("SWIGFunction", class('Euribor1Y__SWIG_0'))

# Start of new_Euribor1Y

`Euribor1Y__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_Euribor1Y__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor1YPtr";
  
  reg.finalizer(ans, delete_Euribor1Y)
  ans
  
}

attr(`Euribor1Y__SWIG_1`, 'returnType') = '_p_Euribor1YPtr'
class(`Euribor1Y__SWIG_1`) = c("SWIGFunction", class('Euribor1Y__SWIG_1'))

`Euribor1Y` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- Euribor1Y__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t')) {
      f <- Euribor1Y__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Euribor1Y with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_Euribor1Y

`delete_Euribor1Y` = function(self)
{
  ;.Call('R_swig_delete_Euribor1Y', self, PACKAGE='QuantLib');
  
}

attr(`delete_Euribor1Y`, 'returnType') = 'void'
attr(`delete_Euribor1Y`, "inputTypes") = c('_p_Euribor1YPtr')
class(`delete_Euribor1Y`) = c("SWIGFunction", class('delete_Euribor1Y'))

setMethod('delete', '_p_Euribor1YPtr', function(obj) {delete_Euribor1YPtr(obj)})
# Start of new_Euribor365

`Euribor365__SWIG_0` = function(tenor, h)
{
  ;ans = .Call('R_swig_new_Euribor365__SWIG_0', tenor, h, PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor365Ptr";
  
  reg.finalizer(ans, delete_Euribor365)
  ans
  
}

attr(`Euribor365__SWIG_0`, 'returnType') = '_p_Euribor365Ptr'
attr(`Euribor365__SWIG_0`, "inputTypes") = c('_p_Period', '_p_HandleT_YieldTermStructure_t')
class(`Euribor365__SWIG_0`) = c("SWIGFunction", class('Euribor365__SWIG_0'))

# Start of new_Euribor365

`Euribor365__SWIG_1` = function(tenor)
{
  ;ans = .Call('R_swig_new_Euribor365__SWIG_1', tenor, PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor365Ptr";
  
  reg.finalizer(ans, delete_Euribor365)
  ans
  
}

attr(`Euribor365__SWIG_1`, 'returnType') = '_p_Euribor365Ptr'
attr(`Euribor365__SWIG_1`, "inputTypes") = c('_p_Period')
class(`Euribor365__SWIG_1`) = c("SWIGFunction", class('Euribor365__SWIG_1'))

`Euribor365` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_Period')) {
      f <- Euribor365__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_Period') && extends(argtypes[2], '_p_HandleT_YieldTermStructure_t')) {
      f <- Euribor365__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Euribor365 with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_Euribor365

`delete_Euribor365` = function(self)
{
  ;.Call('R_swig_delete_Euribor365', self, PACKAGE='QuantLib');
  
}

attr(`delete_Euribor365`, 'returnType') = 'void'
attr(`delete_Euribor365`, "inputTypes") = c('_p_Euribor365Ptr')
class(`delete_Euribor365`) = c("SWIGFunction", class('delete_Euribor365'))

setMethod('delete', '_p_Euribor365Ptr', function(obj) {delete_Euribor365Ptr(obj)})
# Start of new_Euribor365_SW

`Euribor365_SW__SWIG_0` = function(h)
{
  ;ans = .Call('R_swig_new_Euribor365_SW__SWIG_0', h, PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor365_SWPtr";
  
  reg.finalizer(ans, delete_Euribor365_SW)
  ans
  
}

attr(`Euribor365_SW__SWIG_0`, 'returnType') = '_p_Euribor365_SWPtr'
attr(`Euribor365_SW__SWIG_0`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`Euribor365_SW__SWIG_0`) = c("SWIGFunction", class('Euribor365_SW__SWIG_0'))

# Start of new_Euribor365_SW

`Euribor365_SW__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_Euribor365_SW__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor365_SWPtr";
  
  reg.finalizer(ans, delete_Euribor365_SW)
  ans
  
}

attr(`Euribor365_SW__SWIG_1`, 'returnType') = '_p_Euribor365_SWPtr'
class(`Euribor365_SW__SWIG_1`) = c("SWIGFunction", class('Euribor365_SW__SWIG_1'))

`Euribor365_SW` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- Euribor365_SW__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t')) {
      f <- Euribor365_SW__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Euribor365_SW with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_Euribor365_SW

`delete_Euribor365_SW` = function(self)
{
  ;.Call('R_swig_delete_Euribor365_SW', self, PACKAGE='QuantLib');
  
}

attr(`delete_Euribor365_SW`, 'returnType') = 'void'
attr(`delete_Euribor365_SW`, "inputTypes") = c('_p_Euribor365_SWPtr')
class(`delete_Euribor365_SW`) = c("SWIGFunction", class('delete_Euribor365_SW'))

setMethod('delete', '_p_Euribor365_SWPtr', function(obj) {delete_Euribor365_SWPtr(obj)})
# Start of new_Euribor365_2W

`Euribor365_2W__SWIG_0` = function(h)
{
  ;ans = .Call('R_swig_new_Euribor365_2W__SWIG_0', h, PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor365_2WPtr";
  
  reg.finalizer(ans, delete_Euribor365_2W)
  ans
  
}

attr(`Euribor365_2W__SWIG_0`, 'returnType') = '_p_Euribor365_2WPtr'
attr(`Euribor365_2W__SWIG_0`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`Euribor365_2W__SWIG_0`) = c("SWIGFunction", class('Euribor365_2W__SWIG_0'))

# Start of new_Euribor365_2W

`Euribor365_2W__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_Euribor365_2W__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor365_2WPtr";
  
  reg.finalizer(ans, delete_Euribor365_2W)
  ans
  
}

attr(`Euribor365_2W__SWIG_1`, 'returnType') = '_p_Euribor365_2WPtr'
class(`Euribor365_2W__SWIG_1`) = c("SWIGFunction", class('Euribor365_2W__SWIG_1'))

`Euribor365_2W` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- Euribor365_2W__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t')) {
      f <- Euribor365_2W__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Euribor365_2W with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_Euribor365_2W

`delete_Euribor365_2W` = function(self)
{
  ;.Call('R_swig_delete_Euribor365_2W', self, PACKAGE='QuantLib');
  
}

attr(`delete_Euribor365_2W`, 'returnType') = 'void'
attr(`delete_Euribor365_2W`, "inputTypes") = c('_p_Euribor365_2WPtr')
class(`delete_Euribor365_2W`) = c("SWIGFunction", class('delete_Euribor365_2W'))

setMethod('delete', '_p_Euribor365_2WPtr', function(obj) {delete_Euribor365_2WPtr(obj)})
# Start of new_Euribor365_3W

`Euribor365_3W__SWIG_0` = function(h)
{
  ;ans = .Call('R_swig_new_Euribor365_3W__SWIG_0', h, PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor365_3WPtr";
  
  reg.finalizer(ans, delete_Euribor365_3W)
  ans
  
}

attr(`Euribor365_3W__SWIG_0`, 'returnType') = '_p_Euribor365_3WPtr'
attr(`Euribor365_3W__SWIG_0`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`Euribor365_3W__SWIG_0`) = c("SWIGFunction", class('Euribor365_3W__SWIG_0'))

# Start of new_Euribor365_3W

`Euribor365_3W__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_Euribor365_3W__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor365_3WPtr";
  
  reg.finalizer(ans, delete_Euribor365_3W)
  ans
  
}

attr(`Euribor365_3W__SWIG_1`, 'returnType') = '_p_Euribor365_3WPtr'
class(`Euribor365_3W__SWIG_1`) = c("SWIGFunction", class('Euribor365_3W__SWIG_1'))

`Euribor365_3W` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- Euribor365_3W__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t')) {
      f <- Euribor365_3W__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Euribor365_3W with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_Euribor365_3W

`delete_Euribor365_3W` = function(self)
{
  ;.Call('R_swig_delete_Euribor365_3W', self, PACKAGE='QuantLib');
  
}

attr(`delete_Euribor365_3W`, 'returnType') = 'void'
attr(`delete_Euribor365_3W`, "inputTypes") = c('_p_Euribor365_3WPtr')
class(`delete_Euribor365_3W`) = c("SWIGFunction", class('delete_Euribor365_3W'))

setMethod('delete', '_p_Euribor365_3WPtr', function(obj) {delete_Euribor365_3WPtr(obj)})
# Start of new_Euribor365_1M

`Euribor365_1M__SWIG_0` = function(h)
{
  ;ans = .Call('R_swig_new_Euribor365_1M__SWIG_0', h, PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor365_1MPtr";
  
  reg.finalizer(ans, delete_Euribor365_1M)
  ans
  
}

attr(`Euribor365_1M__SWIG_0`, 'returnType') = '_p_Euribor365_1MPtr'
attr(`Euribor365_1M__SWIG_0`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`Euribor365_1M__SWIG_0`) = c("SWIGFunction", class('Euribor365_1M__SWIG_0'))

# Start of new_Euribor365_1M

`Euribor365_1M__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_Euribor365_1M__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor365_1MPtr";
  
  reg.finalizer(ans, delete_Euribor365_1M)
  ans
  
}

attr(`Euribor365_1M__SWIG_1`, 'returnType') = '_p_Euribor365_1MPtr'
class(`Euribor365_1M__SWIG_1`) = c("SWIGFunction", class('Euribor365_1M__SWIG_1'))

`Euribor365_1M` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- Euribor365_1M__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t')) {
      f <- Euribor365_1M__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Euribor365_1M with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_Euribor365_1M

`delete_Euribor365_1M` = function(self)
{
  ;.Call('R_swig_delete_Euribor365_1M', self, PACKAGE='QuantLib');
  
}

attr(`delete_Euribor365_1M`, 'returnType') = 'void'
attr(`delete_Euribor365_1M`, "inputTypes") = c('_p_Euribor365_1MPtr')
class(`delete_Euribor365_1M`) = c("SWIGFunction", class('delete_Euribor365_1M'))

setMethod('delete', '_p_Euribor365_1MPtr', function(obj) {delete_Euribor365_1MPtr(obj)})
# Start of new_Euribor365_2M

`Euribor365_2M__SWIG_0` = function(h)
{
  ;ans = .Call('R_swig_new_Euribor365_2M__SWIG_0', h, PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor365_2MPtr";
  
  reg.finalizer(ans, delete_Euribor365_2M)
  ans
  
}

attr(`Euribor365_2M__SWIG_0`, 'returnType') = '_p_Euribor365_2MPtr'
attr(`Euribor365_2M__SWIG_0`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`Euribor365_2M__SWIG_0`) = c("SWIGFunction", class('Euribor365_2M__SWIG_0'))

# Start of new_Euribor365_2M

`Euribor365_2M__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_Euribor365_2M__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor365_2MPtr";
  
  reg.finalizer(ans, delete_Euribor365_2M)
  ans
  
}

attr(`Euribor365_2M__SWIG_1`, 'returnType') = '_p_Euribor365_2MPtr'
class(`Euribor365_2M__SWIG_1`) = c("SWIGFunction", class('Euribor365_2M__SWIG_1'))

`Euribor365_2M` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- Euribor365_2M__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t')) {
      f <- Euribor365_2M__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Euribor365_2M with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_Euribor365_2M

`delete_Euribor365_2M` = function(self)
{
  ;.Call('R_swig_delete_Euribor365_2M', self, PACKAGE='QuantLib');
  
}

attr(`delete_Euribor365_2M`, 'returnType') = 'void'
attr(`delete_Euribor365_2M`, "inputTypes") = c('_p_Euribor365_2MPtr')
class(`delete_Euribor365_2M`) = c("SWIGFunction", class('delete_Euribor365_2M'))

setMethod('delete', '_p_Euribor365_2MPtr', function(obj) {delete_Euribor365_2MPtr(obj)})
# Start of new_Euribor365_3M

`Euribor365_3M__SWIG_0` = function(h)
{
  ;ans = .Call('R_swig_new_Euribor365_3M__SWIG_0', h, PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor365_3MPtr";
  
  reg.finalizer(ans, delete_Euribor365_3M)
  ans
  
}

attr(`Euribor365_3M__SWIG_0`, 'returnType') = '_p_Euribor365_3MPtr'
attr(`Euribor365_3M__SWIG_0`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`Euribor365_3M__SWIG_0`) = c("SWIGFunction", class('Euribor365_3M__SWIG_0'))

# Start of new_Euribor365_3M

`Euribor365_3M__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_Euribor365_3M__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor365_3MPtr";
  
  reg.finalizer(ans, delete_Euribor365_3M)
  ans
  
}

attr(`Euribor365_3M__SWIG_1`, 'returnType') = '_p_Euribor365_3MPtr'
class(`Euribor365_3M__SWIG_1`) = c("SWIGFunction", class('Euribor365_3M__SWIG_1'))

`Euribor365_3M` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- Euribor365_3M__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t')) {
      f <- Euribor365_3M__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Euribor365_3M with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_Euribor365_3M

`delete_Euribor365_3M` = function(self)
{
  ;.Call('R_swig_delete_Euribor365_3M', self, PACKAGE='QuantLib');
  
}

attr(`delete_Euribor365_3M`, 'returnType') = 'void'
attr(`delete_Euribor365_3M`, "inputTypes") = c('_p_Euribor365_3MPtr')
class(`delete_Euribor365_3M`) = c("SWIGFunction", class('delete_Euribor365_3M'))

setMethod('delete', '_p_Euribor365_3MPtr', function(obj) {delete_Euribor365_3MPtr(obj)})
# Start of new_Euribor365_4M

`Euribor365_4M__SWIG_0` = function(h)
{
  ;ans = .Call('R_swig_new_Euribor365_4M__SWIG_0', h, PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor365_4MPtr";
  
  reg.finalizer(ans, delete_Euribor365_4M)
  ans
  
}

attr(`Euribor365_4M__SWIG_0`, 'returnType') = '_p_Euribor365_4MPtr'
attr(`Euribor365_4M__SWIG_0`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`Euribor365_4M__SWIG_0`) = c("SWIGFunction", class('Euribor365_4M__SWIG_0'))

# Start of new_Euribor365_4M

`Euribor365_4M__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_Euribor365_4M__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor365_4MPtr";
  
  reg.finalizer(ans, delete_Euribor365_4M)
  ans
  
}

attr(`Euribor365_4M__SWIG_1`, 'returnType') = '_p_Euribor365_4MPtr'
class(`Euribor365_4M__SWIG_1`) = c("SWIGFunction", class('Euribor365_4M__SWIG_1'))

`Euribor365_4M` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- Euribor365_4M__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t')) {
      f <- Euribor365_4M__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Euribor365_4M with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_Euribor365_4M

`delete_Euribor365_4M` = function(self)
{
  ;.Call('R_swig_delete_Euribor365_4M', self, PACKAGE='QuantLib');
  
}

attr(`delete_Euribor365_4M`, 'returnType') = 'void'
attr(`delete_Euribor365_4M`, "inputTypes") = c('_p_Euribor365_4MPtr')
class(`delete_Euribor365_4M`) = c("SWIGFunction", class('delete_Euribor365_4M'))

setMethod('delete', '_p_Euribor365_4MPtr', function(obj) {delete_Euribor365_4MPtr(obj)})
# Start of new_Euribor365_5M

`Euribor365_5M__SWIG_0` = function(h)
{
  ;ans = .Call('R_swig_new_Euribor365_5M__SWIG_0', h, PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor365_5MPtr";
  
  reg.finalizer(ans, delete_Euribor365_5M)
  ans
  
}

attr(`Euribor365_5M__SWIG_0`, 'returnType') = '_p_Euribor365_5MPtr'
attr(`Euribor365_5M__SWIG_0`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`Euribor365_5M__SWIG_0`) = c("SWIGFunction", class('Euribor365_5M__SWIG_0'))

# Start of new_Euribor365_5M

`Euribor365_5M__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_Euribor365_5M__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor365_5MPtr";
  
  reg.finalizer(ans, delete_Euribor365_5M)
  ans
  
}

attr(`Euribor365_5M__SWIG_1`, 'returnType') = '_p_Euribor365_5MPtr'
class(`Euribor365_5M__SWIG_1`) = c("SWIGFunction", class('Euribor365_5M__SWIG_1'))

`Euribor365_5M` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- Euribor365_5M__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t')) {
      f <- Euribor365_5M__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Euribor365_5M with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_Euribor365_5M

`delete_Euribor365_5M` = function(self)
{
  ;.Call('R_swig_delete_Euribor365_5M', self, PACKAGE='QuantLib');
  
}

attr(`delete_Euribor365_5M`, 'returnType') = 'void'
attr(`delete_Euribor365_5M`, "inputTypes") = c('_p_Euribor365_5MPtr')
class(`delete_Euribor365_5M`) = c("SWIGFunction", class('delete_Euribor365_5M'))

setMethod('delete', '_p_Euribor365_5MPtr', function(obj) {delete_Euribor365_5MPtr(obj)})
# Start of new_Euribor365_6M

`Euribor365_6M__SWIG_0` = function(h)
{
  ;ans = .Call('R_swig_new_Euribor365_6M__SWIG_0', h, PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor365_6MPtr";
  
  reg.finalizer(ans, delete_Euribor365_6M)
  ans
  
}

attr(`Euribor365_6M__SWIG_0`, 'returnType') = '_p_Euribor365_6MPtr'
attr(`Euribor365_6M__SWIG_0`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`Euribor365_6M__SWIG_0`) = c("SWIGFunction", class('Euribor365_6M__SWIG_0'))

# Start of new_Euribor365_6M

`Euribor365_6M__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_Euribor365_6M__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor365_6MPtr";
  
  reg.finalizer(ans, delete_Euribor365_6M)
  ans
  
}

attr(`Euribor365_6M__SWIG_1`, 'returnType') = '_p_Euribor365_6MPtr'
class(`Euribor365_6M__SWIG_1`) = c("SWIGFunction", class('Euribor365_6M__SWIG_1'))

`Euribor365_6M` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- Euribor365_6M__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t')) {
      f <- Euribor365_6M__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Euribor365_6M with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_Euribor365_6M

`delete_Euribor365_6M` = function(self)
{
  ;.Call('R_swig_delete_Euribor365_6M', self, PACKAGE='QuantLib');
  
}

attr(`delete_Euribor365_6M`, 'returnType') = 'void'
attr(`delete_Euribor365_6M`, "inputTypes") = c('_p_Euribor365_6MPtr')
class(`delete_Euribor365_6M`) = c("SWIGFunction", class('delete_Euribor365_6M'))

setMethod('delete', '_p_Euribor365_6MPtr', function(obj) {delete_Euribor365_6MPtr(obj)})
# Start of new_Euribor365_7M

`Euribor365_7M__SWIG_0` = function(h)
{
  ;ans = .Call('R_swig_new_Euribor365_7M__SWIG_0', h, PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor365_7MPtr";
  
  reg.finalizer(ans, delete_Euribor365_7M)
  ans
  
}

attr(`Euribor365_7M__SWIG_0`, 'returnType') = '_p_Euribor365_7MPtr'
attr(`Euribor365_7M__SWIG_0`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`Euribor365_7M__SWIG_0`) = c("SWIGFunction", class('Euribor365_7M__SWIG_0'))

# Start of new_Euribor365_7M

`Euribor365_7M__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_Euribor365_7M__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor365_7MPtr";
  
  reg.finalizer(ans, delete_Euribor365_7M)
  ans
  
}

attr(`Euribor365_7M__SWIG_1`, 'returnType') = '_p_Euribor365_7MPtr'
class(`Euribor365_7M__SWIG_1`) = c("SWIGFunction", class('Euribor365_7M__SWIG_1'))

`Euribor365_7M` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- Euribor365_7M__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t')) {
      f <- Euribor365_7M__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Euribor365_7M with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_Euribor365_7M

`delete_Euribor365_7M` = function(self)
{
  ;.Call('R_swig_delete_Euribor365_7M', self, PACKAGE='QuantLib');
  
}

attr(`delete_Euribor365_7M`, 'returnType') = 'void'
attr(`delete_Euribor365_7M`, "inputTypes") = c('_p_Euribor365_7MPtr')
class(`delete_Euribor365_7M`) = c("SWIGFunction", class('delete_Euribor365_7M'))

setMethod('delete', '_p_Euribor365_7MPtr', function(obj) {delete_Euribor365_7MPtr(obj)})
# Start of new_Euribor365_8M

`Euribor365_8M__SWIG_0` = function(h)
{
  ;ans = .Call('R_swig_new_Euribor365_8M__SWIG_0', h, PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor365_8MPtr";
  
  reg.finalizer(ans, delete_Euribor365_8M)
  ans
  
}

attr(`Euribor365_8M__SWIG_0`, 'returnType') = '_p_Euribor365_8MPtr'
attr(`Euribor365_8M__SWIG_0`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`Euribor365_8M__SWIG_0`) = c("SWIGFunction", class('Euribor365_8M__SWIG_0'))

# Start of new_Euribor365_8M

`Euribor365_8M__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_Euribor365_8M__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor365_8MPtr";
  
  reg.finalizer(ans, delete_Euribor365_8M)
  ans
  
}

attr(`Euribor365_8M__SWIG_1`, 'returnType') = '_p_Euribor365_8MPtr'
class(`Euribor365_8M__SWIG_1`) = c("SWIGFunction", class('Euribor365_8M__SWIG_1'))

`Euribor365_8M` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- Euribor365_8M__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t')) {
      f <- Euribor365_8M__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Euribor365_8M with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_Euribor365_8M

`delete_Euribor365_8M` = function(self)
{
  ;.Call('R_swig_delete_Euribor365_8M', self, PACKAGE='QuantLib');
  
}

attr(`delete_Euribor365_8M`, 'returnType') = 'void'
attr(`delete_Euribor365_8M`, "inputTypes") = c('_p_Euribor365_8MPtr')
class(`delete_Euribor365_8M`) = c("SWIGFunction", class('delete_Euribor365_8M'))

setMethod('delete', '_p_Euribor365_8MPtr', function(obj) {delete_Euribor365_8MPtr(obj)})
# Start of new_Euribor365_9M

`Euribor365_9M__SWIG_0` = function(h)
{
  ;ans = .Call('R_swig_new_Euribor365_9M__SWIG_0', h, PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor365_9MPtr";
  
  reg.finalizer(ans, delete_Euribor365_9M)
  ans
  
}

attr(`Euribor365_9M__SWIG_0`, 'returnType') = '_p_Euribor365_9MPtr'
attr(`Euribor365_9M__SWIG_0`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`Euribor365_9M__SWIG_0`) = c("SWIGFunction", class('Euribor365_9M__SWIG_0'))

# Start of new_Euribor365_9M

`Euribor365_9M__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_Euribor365_9M__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor365_9MPtr";
  
  reg.finalizer(ans, delete_Euribor365_9M)
  ans
  
}

attr(`Euribor365_9M__SWIG_1`, 'returnType') = '_p_Euribor365_9MPtr'
class(`Euribor365_9M__SWIG_1`) = c("SWIGFunction", class('Euribor365_9M__SWIG_1'))

`Euribor365_9M` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- Euribor365_9M__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t')) {
      f <- Euribor365_9M__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Euribor365_9M with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_Euribor365_9M

`delete_Euribor365_9M` = function(self)
{
  ;.Call('R_swig_delete_Euribor365_9M', self, PACKAGE='QuantLib');
  
}

attr(`delete_Euribor365_9M`, 'returnType') = 'void'
attr(`delete_Euribor365_9M`, "inputTypes") = c('_p_Euribor365_9MPtr')
class(`delete_Euribor365_9M`) = c("SWIGFunction", class('delete_Euribor365_9M'))

setMethod('delete', '_p_Euribor365_9MPtr', function(obj) {delete_Euribor365_9MPtr(obj)})
# Start of new_Euribor365_10M

`Euribor365_10M__SWIG_0` = function(h)
{
  ;ans = .Call('R_swig_new_Euribor365_10M__SWIG_0', h, PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor365_10MPtr";
  
  reg.finalizer(ans, delete_Euribor365_10M)
  ans
  
}

attr(`Euribor365_10M__SWIG_0`, 'returnType') = '_p_Euribor365_10MPtr'
attr(`Euribor365_10M__SWIG_0`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`Euribor365_10M__SWIG_0`) = c("SWIGFunction", class('Euribor365_10M__SWIG_0'))

# Start of new_Euribor365_10M

`Euribor365_10M__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_Euribor365_10M__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor365_10MPtr";
  
  reg.finalizer(ans, delete_Euribor365_10M)
  ans
  
}

attr(`Euribor365_10M__SWIG_1`, 'returnType') = '_p_Euribor365_10MPtr'
class(`Euribor365_10M__SWIG_1`) = c("SWIGFunction", class('Euribor365_10M__SWIG_1'))

`Euribor365_10M` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- Euribor365_10M__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t')) {
      f <- Euribor365_10M__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Euribor365_10M with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_Euribor365_10M

`delete_Euribor365_10M` = function(self)
{
  ;.Call('R_swig_delete_Euribor365_10M', self, PACKAGE='QuantLib');
  
}

attr(`delete_Euribor365_10M`, 'returnType') = 'void'
attr(`delete_Euribor365_10M`, "inputTypes") = c('_p_Euribor365_10MPtr')
class(`delete_Euribor365_10M`) = c("SWIGFunction", class('delete_Euribor365_10M'))

setMethod('delete', '_p_Euribor365_10MPtr', function(obj) {delete_Euribor365_10MPtr(obj)})
# Start of new_Euribor365_11M

`Euribor365_11M__SWIG_0` = function(h)
{
  ;ans = .Call('R_swig_new_Euribor365_11M__SWIG_0', h, PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor365_11MPtr";
  
  reg.finalizer(ans, delete_Euribor365_11M)
  ans
  
}

attr(`Euribor365_11M__SWIG_0`, 'returnType') = '_p_Euribor365_11MPtr'
attr(`Euribor365_11M__SWIG_0`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`Euribor365_11M__SWIG_0`) = c("SWIGFunction", class('Euribor365_11M__SWIG_0'))

# Start of new_Euribor365_11M

`Euribor365_11M__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_Euribor365_11M__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor365_11MPtr";
  
  reg.finalizer(ans, delete_Euribor365_11M)
  ans
  
}

attr(`Euribor365_11M__SWIG_1`, 'returnType') = '_p_Euribor365_11MPtr'
class(`Euribor365_11M__SWIG_1`) = c("SWIGFunction", class('Euribor365_11M__SWIG_1'))

`Euribor365_11M` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- Euribor365_11M__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t')) {
      f <- Euribor365_11M__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Euribor365_11M with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_Euribor365_11M

`delete_Euribor365_11M` = function(self)
{
  ;.Call('R_swig_delete_Euribor365_11M', self, PACKAGE='QuantLib');
  
}

attr(`delete_Euribor365_11M`, 'returnType') = 'void'
attr(`delete_Euribor365_11M`, "inputTypes") = c('_p_Euribor365_11MPtr')
class(`delete_Euribor365_11M`) = c("SWIGFunction", class('delete_Euribor365_11M'))

setMethod('delete', '_p_Euribor365_11MPtr', function(obj) {delete_Euribor365_11MPtr(obj)})
# Start of new_Euribor365_1Y

`Euribor365_1Y__SWIG_0` = function(h)
{
  ;ans = .Call('R_swig_new_Euribor365_1Y__SWIG_0', h, PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor365_1YPtr";
  
  reg.finalizer(ans, delete_Euribor365_1Y)
  ans
  
}

attr(`Euribor365_1Y__SWIG_0`, 'returnType') = '_p_Euribor365_1YPtr'
attr(`Euribor365_1Y__SWIG_0`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`Euribor365_1Y__SWIG_0`) = c("SWIGFunction", class('Euribor365_1Y__SWIG_0'))

# Start of new_Euribor365_1Y

`Euribor365_1Y__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_Euribor365_1Y__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_Euribor365_1YPtr";
  
  reg.finalizer(ans, delete_Euribor365_1Y)
  ans
  
}

attr(`Euribor365_1Y__SWIG_1`, 'returnType') = '_p_Euribor365_1YPtr'
class(`Euribor365_1Y__SWIG_1`) = c("SWIGFunction", class('Euribor365_1Y__SWIG_1'))

`Euribor365_1Y` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- Euribor365_1Y__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t')) {
      f <- Euribor365_1Y__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Euribor365_1Y with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_Euribor365_1Y

`delete_Euribor365_1Y` = function(self)
{
  ;.Call('R_swig_delete_Euribor365_1Y', self, PACKAGE='QuantLib');
  
}

attr(`delete_Euribor365_1Y`, 'returnType') = 'void'
attr(`delete_Euribor365_1Y`, "inputTypes") = c('_p_Euribor365_1YPtr')
class(`delete_Euribor365_1Y`) = c("SWIGFunction", class('delete_Euribor365_1Y'))

setMethod('delete', '_p_Euribor365_1YPtr', function(obj) {delete_Euribor365_1YPtr(obj)})
# Start of new_EURLibor

`EURLibor__SWIG_0` = function(tenor, h)
{
  ;ans = .Call('R_swig_new_EURLibor__SWIG_0', tenor, h, PACKAGE='QuantLib');
  class(ans) <- "_p_EURLiborPtr";
  
  reg.finalizer(ans, delete_EURLibor)
  ans
  
}

attr(`EURLibor__SWIG_0`, 'returnType') = '_p_EURLiborPtr'
attr(`EURLibor__SWIG_0`, "inputTypes") = c('_p_Period', '_p_HandleT_YieldTermStructure_t')
class(`EURLibor__SWIG_0`) = c("SWIGFunction", class('EURLibor__SWIG_0'))

# Start of new_EURLibor

`EURLibor__SWIG_1` = function(tenor)
{
  ;ans = .Call('R_swig_new_EURLibor__SWIG_1', tenor, PACKAGE='QuantLib');
  class(ans) <- "_p_EURLiborPtr";
  
  reg.finalizer(ans, delete_EURLibor)
  ans
  
}

attr(`EURLibor__SWIG_1`, 'returnType') = '_p_EURLiborPtr'
attr(`EURLibor__SWIG_1`, "inputTypes") = c('_p_Period')
class(`EURLibor__SWIG_1`) = c("SWIGFunction", class('EURLibor__SWIG_1'))

`EURLibor` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_Period')) {
      f <- EURLibor__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_Period') && extends(argtypes[2], '_p_HandleT_YieldTermStructure_t')) {
      f <- EURLibor__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for EURLibor with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_EURLibor

`delete_EURLibor` = function(self)
{
  ;.Call('R_swig_delete_EURLibor', self, PACKAGE='QuantLib');
  
}

attr(`delete_EURLibor`, 'returnType') = 'void'
attr(`delete_EURLibor`, "inputTypes") = c('_p_EURLiborPtr')
class(`delete_EURLibor`) = c("SWIGFunction", class('delete_EURLibor'))

setMethod('delete', '_p_EURLiborPtr', function(obj) {delete_EURLiborPtr(obj)})
# Start of new_EURLiborSW

`EURLiborSW__SWIG_0` = function(h)
{
  ;ans = .Call('R_swig_new_EURLiborSW__SWIG_0', h, PACKAGE='QuantLib');
  class(ans) <- "_p_EURLiborSWPtr";
  
  reg.finalizer(ans, delete_EURLiborSW)
  ans
  
}

attr(`EURLiborSW__SWIG_0`, 'returnType') = '_p_EURLiborSWPtr'
attr(`EURLiborSW__SWIG_0`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`EURLiborSW__SWIG_0`) = c("SWIGFunction", class('EURLiborSW__SWIG_0'))

# Start of new_EURLiborSW

`EURLiborSW__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_EURLiborSW__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_EURLiborSWPtr";
  
  reg.finalizer(ans, delete_EURLiborSW)
  ans
  
}

attr(`EURLiborSW__SWIG_1`, 'returnType') = '_p_EURLiborSWPtr'
class(`EURLiborSW__SWIG_1`) = c("SWIGFunction", class('EURLiborSW__SWIG_1'))

`EURLiborSW` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- EURLiborSW__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t')) {
      f <- EURLiborSW__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for EURLiborSW with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_EURLiborSW

`delete_EURLiborSW` = function(self)
{
  ;.Call('R_swig_delete_EURLiborSW', self, PACKAGE='QuantLib');
  
}

attr(`delete_EURLiborSW`, 'returnType') = 'void'
attr(`delete_EURLiborSW`, "inputTypes") = c('_p_EURLiborSWPtr')
class(`delete_EURLiborSW`) = c("SWIGFunction", class('delete_EURLiborSW'))

setMethod('delete', '_p_EURLiborSWPtr', function(obj) {delete_EURLiborSWPtr(obj)})
# Start of new_EURLibor2W

`EURLibor2W__SWIG_0` = function(h)
{
  ;ans = .Call('R_swig_new_EURLibor2W__SWIG_0', h, PACKAGE='QuantLib');
  class(ans) <- "_p_EURLibor2WPtr";
  
  reg.finalizer(ans, delete_EURLibor2W)
  ans
  
}

attr(`EURLibor2W__SWIG_0`, 'returnType') = '_p_EURLibor2WPtr'
attr(`EURLibor2W__SWIG_0`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`EURLibor2W__SWIG_0`) = c("SWIGFunction", class('EURLibor2W__SWIG_0'))

# Start of new_EURLibor2W

`EURLibor2W__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_EURLibor2W__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_EURLibor2WPtr";
  
  reg.finalizer(ans, delete_EURLibor2W)
  ans
  
}

attr(`EURLibor2W__SWIG_1`, 'returnType') = '_p_EURLibor2WPtr'
class(`EURLibor2W__SWIG_1`) = c("SWIGFunction", class('EURLibor2W__SWIG_1'))

`EURLibor2W` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- EURLibor2W__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t')) {
      f <- EURLibor2W__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for EURLibor2W with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_EURLibor2W

`delete_EURLibor2W` = function(self)
{
  ;.Call('R_swig_delete_EURLibor2W', self, PACKAGE='QuantLib');
  
}

attr(`delete_EURLibor2W`, 'returnType') = 'void'
attr(`delete_EURLibor2W`, "inputTypes") = c('_p_EURLibor2WPtr')
class(`delete_EURLibor2W`) = c("SWIGFunction", class('delete_EURLibor2W'))

setMethod('delete', '_p_EURLibor2WPtr', function(obj) {delete_EURLibor2WPtr(obj)})
# Start of new_EURLibor1M

`EURLibor1M__SWIG_0` = function(h)
{
  ;ans = .Call('R_swig_new_EURLibor1M__SWIG_0', h, PACKAGE='QuantLib');
  class(ans) <- "_p_EURLibor1MPtr";
  
  reg.finalizer(ans, delete_EURLibor1M)
  ans
  
}

attr(`EURLibor1M__SWIG_0`, 'returnType') = '_p_EURLibor1MPtr'
attr(`EURLibor1M__SWIG_0`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`EURLibor1M__SWIG_0`) = c("SWIGFunction", class('EURLibor1M__SWIG_0'))

# Start of new_EURLibor1M

`EURLibor1M__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_EURLibor1M__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_EURLibor1MPtr";
  
  reg.finalizer(ans, delete_EURLibor1M)
  ans
  
}

attr(`EURLibor1M__SWIG_1`, 'returnType') = '_p_EURLibor1MPtr'
class(`EURLibor1M__SWIG_1`) = c("SWIGFunction", class('EURLibor1M__SWIG_1'))

`EURLibor1M` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- EURLibor1M__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t')) {
      f <- EURLibor1M__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for EURLibor1M with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_EURLibor1M

`delete_EURLibor1M` = function(self)
{
  ;.Call('R_swig_delete_EURLibor1M', self, PACKAGE='QuantLib');
  
}

attr(`delete_EURLibor1M`, 'returnType') = 'void'
attr(`delete_EURLibor1M`, "inputTypes") = c('_p_EURLibor1MPtr')
class(`delete_EURLibor1M`) = c("SWIGFunction", class('delete_EURLibor1M'))

setMethod('delete', '_p_EURLibor1MPtr', function(obj) {delete_EURLibor1MPtr(obj)})
# Start of new_EURLibor2M

`EURLibor2M__SWIG_0` = function(h)
{
  ;ans = .Call('R_swig_new_EURLibor2M__SWIG_0', h, PACKAGE='QuantLib');
  class(ans) <- "_p_EURLibor2MPtr";
  
  reg.finalizer(ans, delete_EURLibor2M)
  ans
  
}

attr(`EURLibor2M__SWIG_0`, 'returnType') = '_p_EURLibor2MPtr'
attr(`EURLibor2M__SWIG_0`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`EURLibor2M__SWIG_0`) = c("SWIGFunction", class('EURLibor2M__SWIG_0'))

# Start of new_EURLibor2M

`EURLibor2M__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_EURLibor2M__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_EURLibor2MPtr";
  
  reg.finalizer(ans, delete_EURLibor2M)
  ans
  
}

attr(`EURLibor2M__SWIG_1`, 'returnType') = '_p_EURLibor2MPtr'
class(`EURLibor2M__SWIG_1`) = c("SWIGFunction", class('EURLibor2M__SWIG_1'))

`EURLibor2M` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- EURLibor2M__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t')) {
      f <- EURLibor2M__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for EURLibor2M with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_EURLibor2M

`delete_EURLibor2M` = function(self)
{
  ;.Call('R_swig_delete_EURLibor2M', self, PACKAGE='QuantLib');
  
}

attr(`delete_EURLibor2M`, 'returnType') = 'void'
attr(`delete_EURLibor2M`, "inputTypes") = c('_p_EURLibor2MPtr')
class(`delete_EURLibor2M`) = c("SWIGFunction", class('delete_EURLibor2M'))

setMethod('delete', '_p_EURLibor2MPtr', function(obj) {delete_EURLibor2MPtr(obj)})
# Start of new_EURLibor3M

`EURLibor3M__SWIG_0` = function(h)
{
  ;ans = .Call('R_swig_new_EURLibor3M__SWIG_0', h, PACKAGE='QuantLib');
  class(ans) <- "_p_EURLibor3MPtr";
  
  reg.finalizer(ans, delete_EURLibor3M)
  ans
  
}

attr(`EURLibor3M__SWIG_0`, 'returnType') = '_p_EURLibor3MPtr'
attr(`EURLibor3M__SWIG_0`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`EURLibor3M__SWIG_0`) = c("SWIGFunction", class('EURLibor3M__SWIG_0'))

# Start of new_EURLibor3M

`EURLibor3M__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_EURLibor3M__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_EURLibor3MPtr";
  
  reg.finalizer(ans, delete_EURLibor3M)
  ans
  
}

attr(`EURLibor3M__SWIG_1`, 'returnType') = '_p_EURLibor3MPtr'
class(`EURLibor3M__SWIG_1`) = c("SWIGFunction", class('EURLibor3M__SWIG_1'))

`EURLibor3M` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- EURLibor3M__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t')) {
      f <- EURLibor3M__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for EURLibor3M with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_EURLibor3M

`delete_EURLibor3M` = function(self)
{
  ;.Call('R_swig_delete_EURLibor3M', self, PACKAGE='QuantLib');
  
}

attr(`delete_EURLibor3M`, 'returnType') = 'void'
attr(`delete_EURLibor3M`, "inputTypes") = c('_p_EURLibor3MPtr')
class(`delete_EURLibor3M`) = c("SWIGFunction", class('delete_EURLibor3M'))

setMethod('delete', '_p_EURLibor3MPtr', function(obj) {delete_EURLibor3MPtr(obj)})
# Start of new_EURLibor4M

`EURLibor4M__SWIG_0` = function(h)
{
  ;ans = .Call('R_swig_new_EURLibor4M__SWIG_0', h, PACKAGE='QuantLib');
  class(ans) <- "_p_EURLibor4MPtr";
  
  reg.finalizer(ans, delete_EURLibor4M)
  ans
  
}

attr(`EURLibor4M__SWIG_0`, 'returnType') = '_p_EURLibor4MPtr'
attr(`EURLibor4M__SWIG_0`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`EURLibor4M__SWIG_0`) = c("SWIGFunction", class('EURLibor4M__SWIG_0'))

# Start of new_EURLibor4M

`EURLibor4M__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_EURLibor4M__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_EURLibor4MPtr";
  
  reg.finalizer(ans, delete_EURLibor4M)
  ans
  
}

attr(`EURLibor4M__SWIG_1`, 'returnType') = '_p_EURLibor4MPtr'
class(`EURLibor4M__SWIG_1`) = c("SWIGFunction", class('EURLibor4M__SWIG_1'))

`EURLibor4M` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- EURLibor4M__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t')) {
      f <- EURLibor4M__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for EURLibor4M with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_EURLibor4M

`delete_EURLibor4M` = function(self)
{
  ;.Call('R_swig_delete_EURLibor4M', self, PACKAGE='QuantLib');
  
}

attr(`delete_EURLibor4M`, 'returnType') = 'void'
attr(`delete_EURLibor4M`, "inputTypes") = c('_p_EURLibor4MPtr')
class(`delete_EURLibor4M`) = c("SWIGFunction", class('delete_EURLibor4M'))

setMethod('delete', '_p_EURLibor4MPtr', function(obj) {delete_EURLibor4MPtr(obj)})
# Start of new_EURLibor5M

`EURLibor5M__SWIG_0` = function(h)
{
  ;ans = .Call('R_swig_new_EURLibor5M__SWIG_0', h, PACKAGE='QuantLib');
  class(ans) <- "_p_EURLibor5MPtr";
  
  reg.finalizer(ans, delete_EURLibor5M)
  ans
  
}

attr(`EURLibor5M__SWIG_0`, 'returnType') = '_p_EURLibor5MPtr'
attr(`EURLibor5M__SWIG_0`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`EURLibor5M__SWIG_0`) = c("SWIGFunction", class('EURLibor5M__SWIG_0'))

# Start of new_EURLibor5M

`EURLibor5M__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_EURLibor5M__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_EURLibor5MPtr";
  
  reg.finalizer(ans, delete_EURLibor5M)
  ans
  
}

attr(`EURLibor5M__SWIG_1`, 'returnType') = '_p_EURLibor5MPtr'
class(`EURLibor5M__SWIG_1`) = c("SWIGFunction", class('EURLibor5M__SWIG_1'))

`EURLibor5M` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- EURLibor5M__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t')) {
      f <- EURLibor5M__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for EURLibor5M with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_EURLibor5M

`delete_EURLibor5M` = function(self)
{
  ;.Call('R_swig_delete_EURLibor5M', self, PACKAGE='QuantLib');
  
}

attr(`delete_EURLibor5M`, 'returnType') = 'void'
attr(`delete_EURLibor5M`, "inputTypes") = c('_p_EURLibor5MPtr')
class(`delete_EURLibor5M`) = c("SWIGFunction", class('delete_EURLibor5M'))

setMethod('delete', '_p_EURLibor5MPtr', function(obj) {delete_EURLibor5MPtr(obj)})
# Start of new_EURLibor6M

`EURLibor6M__SWIG_0` = function(h)
{
  ;ans = .Call('R_swig_new_EURLibor6M__SWIG_0', h, PACKAGE='QuantLib');
  class(ans) <- "_p_EURLibor6MPtr";
  
  reg.finalizer(ans, delete_EURLibor6M)
  ans
  
}

attr(`EURLibor6M__SWIG_0`, 'returnType') = '_p_EURLibor6MPtr'
attr(`EURLibor6M__SWIG_0`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`EURLibor6M__SWIG_0`) = c("SWIGFunction", class('EURLibor6M__SWIG_0'))

# Start of new_EURLibor6M

`EURLibor6M__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_EURLibor6M__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_EURLibor6MPtr";
  
  reg.finalizer(ans, delete_EURLibor6M)
  ans
  
}

attr(`EURLibor6M__SWIG_1`, 'returnType') = '_p_EURLibor6MPtr'
class(`EURLibor6M__SWIG_1`) = c("SWIGFunction", class('EURLibor6M__SWIG_1'))

`EURLibor6M` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- EURLibor6M__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t')) {
      f <- EURLibor6M__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for EURLibor6M with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_EURLibor6M

`delete_EURLibor6M` = function(self)
{
  ;.Call('R_swig_delete_EURLibor6M', self, PACKAGE='QuantLib');
  
}

attr(`delete_EURLibor6M`, 'returnType') = 'void'
attr(`delete_EURLibor6M`, "inputTypes") = c('_p_EURLibor6MPtr')
class(`delete_EURLibor6M`) = c("SWIGFunction", class('delete_EURLibor6M'))

setMethod('delete', '_p_EURLibor6MPtr', function(obj) {delete_EURLibor6MPtr(obj)})
# Start of new_EURLibor7M

`EURLibor7M__SWIG_0` = function(h)
{
  ;ans = .Call('R_swig_new_EURLibor7M__SWIG_0', h, PACKAGE='QuantLib');
  class(ans) <- "_p_EURLibor7MPtr";
  
  reg.finalizer(ans, delete_EURLibor7M)
  ans
  
}

attr(`EURLibor7M__SWIG_0`, 'returnType') = '_p_EURLibor7MPtr'
attr(`EURLibor7M__SWIG_0`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`EURLibor7M__SWIG_0`) = c("SWIGFunction", class('EURLibor7M__SWIG_0'))

# Start of new_EURLibor7M

`EURLibor7M__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_EURLibor7M__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_EURLibor7MPtr";
  
  reg.finalizer(ans, delete_EURLibor7M)
  ans
  
}

attr(`EURLibor7M__SWIG_1`, 'returnType') = '_p_EURLibor7MPtr'
class(`EURLibor7M__SWIG_1`) = c("SWIGFunction", class('EURLibor7M__SWIG_1'))

`EURLibor7M` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- EURLibor7M__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t')) {
      f <- EURLibor7M__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for EURLibor7M with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_EURLibor7M

`delete_EURLibor7M` = function(self)
{
  ;.Call('R_swig_delete_EURLibor7M', self, PACKAGE='QuantLib');
  
}

attr(`delete_EURLibor7M`, 'returnType') = 'void'
attr(`delete_EURLibor7M`, "inputTypes") = c('_p_EURLibor7MPtr')
class(`delete_EURLibor7M`) = c("SWIGFunction", class('delete_EURLibor7M'))

setMethod('delete', '_p_EURLibor7MPtr', function(obj) {delete_EURLibor7MPtr(obj)})
# Start of new_EURLibor8M

`EURLibor8M__SWIG_0` = function(h)
{
  ;ans = .Call('R_swig_new_EURLibor8M__SWIG_0', h, PACKAGE='QuantLib');
  class(ans) <- "_p_EURLibor8MPtr";
  
  reg.finalizer(ans, delete_EURLibor8M)
  ans
  
}

attr(`EURLibor8M__SWIG_0`, 'returnType') = '_p_EURLibor8MPtr'
attr(`EURLibor8M__SWIG_0`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`EURLibor8M__SWIG_0`) = c("SWIGFunction", class('EURLibor8M__SWIG_0'))

# Start of new_EURLibor8M

`EURLibor8M__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_EURLibor8M__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_EURLibor8MPtr";
  
  reg.finalizer(ans, delete_EURLibor8M)
  ans
  
}

attr(`EURLibor8M__SWIG_1`, 'returnType') = '_p_EURLibor8MPtr'
class(`EURLibor8M__SWIG_1`) = c("SWIGFunction", class('EURLibor8M__SWIG_1'))

`EURLibor8M` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- EURLibor8M__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t')) {
      f <- EURLibor8M__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for EURLibor8M with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_EURLibor8M

`delete_EURLibor8M` = function(self)
{
  ;.Call('R_swig_delete_EURLibor8M', self, PACKAGE='QuantLib');
  
}

attr(`delete_EURLibor8M`, 'returnType') = 'void'
attr(`delete_EURLibor8M`, "inputTypes") = c('_p_EURLibor8MPtr')
class(`delete_EURLibor8M`) = c("SWIGFunction", class('delete_EURLibor8M'))

setMethod('delete', '_p_EURLibor8MPtr', function(obj) {delete_EURLibor8MPtr(obj)})
# Start of new_EURLibor9M

`EURLibor9M__SWIG_0` = function(h)
{
  ;ans = .Call('R_swig_new_EURLibor9M__SWIG_0', h, PACKAGE='QuantLib');
  class(ans) <- "_p_EURLibor9MPtr";
  
  reg.finalizer(ans, delete_EURLibor9M)
  ans
  
}

attr(`EURLibor9M__SWIG_0`, 'returnType') = '_p_EURLibor9MPtr'
attr(`EURLibor9M__SWIG_0`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`EURLibor9M__SWIG_0`) = c("SWIGFunction", class('EURLibor9M__SWIG_0'))

# Start of new_EURLibor9M

`EURLibor9M__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_EURLibor9M__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_EURLibor9MPtr";
  
  reg.finalizer(ans, delete_EURLibor9M)
  ans
  
}

attr(`EURLibor9M__SWIG_1`, 'returnType') = '_p_EURLibor9MPtr'
class(`EURLibor9M__SWIG_1`) = c("SWIGFunction", class('EURLibor9M__SWIG_1'))

`EURLibor9M` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- EURLibor9M__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t')) {
      f <- EURLibor9M__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for EURLibor9M with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_EURLibor9M

`delete_EURLibor9M` = function(self)
{
  ;.Call('R_swig_delete_EURLibor9M', self, PACKAGE='QuantLib');
  
}

attr(`delete_EURLibor9M`, 'returnType') = 'void'
attr(`delete_EURLibor9M`, "inputTypes") = c('_p_EURLibor9MPtr')
class(`delete_EURLibor9M`) = c("SWIGFunction", class('delete_EURLibor9M'))

setMethod('delete', '_p_EURLibor9MPtr', function(obj) {delete_EURLibor9MPtr(obj)})
# Start of new_EURLibor10M

`EURLibor10M__SWIG_0` = function(h)
{
  ;ans = .Call('R_swig_new_EURLibor10M__SWIG_0', h, PACKAGE='QuantLib');
  class(ans) <- "_p_EURLibor10MPtr";
  
  reg.finalizer(ans, delete_EURLibor10M)
  ans
  
}

attr(`EURLibor10M__SWIG_0`, 'returnType') = '_p_EURLibor10MPtr'
attr(`EURLibor10M__SWIG_0`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`EURLibor10M__SWIG_0`) = c("SWIGFunction", class('EURLibor10M__SWIG_0'))

# Start of new_EURLibor10M

`EURLibor10M__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_EURLibor10M__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_EURLibor10MPtr";
  
  reg.finalizer(ans, delete_EURLibor10M)
  ans
  
}

attr(`EURLibor10M__SWIG_1`, 'returnType') = '_p_EURLibor10MPtr'
class(`EURLibor10M__SWIG_1`) = c("SWIGFunction", class('EURLibor10M__SWIG_1'))

`EURLibor10M` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- EURLibor10M__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t')) {
      f <- EURLibor10M__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for EURLibor10M with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_EURLibor10M

`delete_EURLibor10M` = function(self)
{
  ;.Call('R_swig_delete_EURLibor10M', self, PACKAGE='QuantLib');
  
}

attr(`delete_EURLibor10M`, 'returnType') = 'void'
attr(`delete_EURLibor10M`, "inputTypes") = c('_p_EURLibor10MPtr')
class(`delete_EURLibor10M`) = c("SWIGFunction", class('delete_EURLibor10M'))

setMethod('delete', '_p_EURLibor10MPtr', function(obj) {delete_EURLibor10MPtr(obj)})
# Start of new_EURLibor11M

`EURLibor11M__SWIG_0` = function(h)
{
  ;ans = .Call('R_swig_new_EURLibor11M__SWIG_0', h, PACKAGE='QuantLib');
  class(ans) <- "_p_EURLibor11MPtr";
  
  reg.finalizer(ans, delete_EURLibor11M)
  ans
  
}

attr(`EURLibor11M__SWIG_0`, 'returnType') = '_p_EURLibor11MPtr'
attr(`EURLibor11M__SWIG_0`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`EURLibor11M__SWIG_0`) = c("SWIGFunction", class('EURLibor11M__SWIG_0'))

# Start of new_EURLibor11M

`EURLibor11M__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_EURLibor11M__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_EURLibor11MPtr";
  
  reg.finalizer(ans, delete_EURLibor11M)
  ans
  
}

attr(`EURLibor11M__SWIG_1`, 'returnType') = '_p_EURLibor11MPtr'
class(`EURLibor11M__SWIG_1`) = c("SWIGFunction", class('EURLibor11M__SWIG_1'))

`EURLibor11M` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- EURLibor11M__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t')) {
      f <- EURLibor11M__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for EURLibor11M with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_EURLibor11M

`delete_EURLibor11M` = function(self)
{
  ;.Call('R_swig_delete_EURLibor11M', self, PACKAGE='QuantLib');
  
}

attr(`delete_EURLibor11M`, 'returnType') = 'void'
attr(`delete_EURLibor11M`, "inputTypes") = c('_p_EURLibor11MPtr')
class(`delete_EURLibor11M`) = c("SWIGFunction", class('delete_EURLibor11M'))

setMethod('delete', '_p_EURLibor11MPtr', function(obj) {delete_EURLibor11MPtr(obj)})
# Start of new_EURLibor1Y

`EURLibor1Y__SWIG_0` = function(h)
{
  ;ans = .Call('R_swig_new_EURLibor1Y__SWIG_0', h, PACKAGE='QuantLib');
  class(ans) <- "_p_EURLibor1YPtr";
  
  reg.finalizer(ans, delete_EURLibor1Y)
  ans
  
}

attr(`EURLibor1Y__SWIG_0`, 'returnType') = '_p_EURLibor1YPtr'
attr(`EURLibor1Y__SWIG_0`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`EURLibor1Y__SWIG_0`) = c("SWIGFunction", class('EURLibor1Y__SWIG_0'))

# Start of new_EURLibor1Y

`EURLibor1Y__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_EURLibor1Y__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_EURLibor1YPtr";
  
  reg.finalizer(ans, delete_EURLibor1Y)
  ans
  
}

attr(`EURLibor1Y__SWIG_1`, 'returnType') = '_p_EURLibor1YPtr'
class(`EURLibor1Y__SWIG_1`) = c("SWIGFunction", class('EURLibor1Y__SWIG_1'))

`EURLibor1Y` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- EURLibor1Y__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t')) {
      f <- EURLibor1Y__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for EURLibor1Y with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_EURLibor1Y

`delete_EURLibor1Y` = function(self)
{
  ;.Call('R_swig_delete_EURLibor1Y', self, PACKAGE='QuantLib');
  
}

attr(`delete_EURLibor1Y`, 'returnType') = 'void'
attr(`delete_EURLibor1Y`, "inputTypes") = c('_p_EURLibor1YPtr')
class(`delete_EURLibor1Y`) = c("SWIGFunction", class('delete_EURLibor1Y'))

setMethod('delete', '_p_EURLibor1YPtr', function(obj) {delete_EURLibor1YPtr(obj)})
# Start of new_GBPLibor

`GBPLibor__SWIG_0` = function(tenor, h)
{
  ;ans = .Call('R_swig_new_GBPLibor__SWIG_0', tenor, h, PACKAGE='QuantLib');
  class(ans) <- "_p_GBPLiborPtr";
  
  reg.finalizer(ans, delete_GBPLibor)
  ans
  
}

attr(`GBPLibor__SWIG_0`, 'returnType') = '_p_GBPLiborPtr'
attr(`GBPLibor__SWIG_0`, "inputTypes") = c('_p_Period', '_p_HandleT_YieldTermStructure_t')
class(`GBPLibor__SWIG_0`) = c("SWIGFunction", class('GBPLibor__SWIG_0'))

# Start of new_GBPLibor

`GBPLibor__SWIG_1` = function(tenor)
{
  ;ans = .Call('R_swig_new_GBPLibor__SWIG_1', tenor, PACKAGE='QuantLib');
  class(ans) <- "_p_GBPLiborPtr";
  
  reg.finalizer(ans, delete_GBPLibor)
  ans
  
}

attr(`GBPLibor__SWIG_1`, 'returnType') = '_p_GBPLiborPtr'
attr(`GBPLibor__SWIG_1`, "inputTypes") = c('_p_Period')
class(`GBPLibor__SWIG_1`) = c("SWIGFunction", class('GBPLibor__SWIG_1'))

`GBPLibor` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_Period')) {
      f <- GBPLibor__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_Period') && extends(argtypes[2], '_p_HandleT_YieldTermStructure_t')) {
      f <- GBPLibor__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for GBPLibor with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_GBPLibor

`delete_GBPLibor` = function(self)
{
  ;.Call('R_swig_delete_GBPLibor', self, PACKAGE='QuantLib');
  
}

attr(`delete_GBPLibor`, 'returnType') = 'void'
attr(`delete_GBPLibor`, "inputTypes") = c('_p_GBPLiborPtr')
class(`delete_GBPLibor`) = c("SWIGFunction", class('delete_GBPLibor'))

setMethod('delete', '_p_GBPLiborPtr', function(obj) {delete_GBPLiborPtr(obj)})
# Start of new_Jibar

`Jibar__SWIG_0` = function(tenor, h)
{
  ;ans = .Call('R_swig_new_Jibar__SWIG_0', tenor, h, PACKAGE='QuantLib');
  class(ans) <- "_p_JibarPtr";
  
  reg.finalizer(ans, delete_Jibar)
  ans
  
}

attr(`Jibar__SWIG_0`, 'returnType') = '_p_JibarPtr'
attr(`Jibar__SWIG_0`, "inputTypes") = c('_p_Period', '_p_HandleT_YieldTermStructure_t')
class(`Jibar__SWIG_0`) = c("SWIGFunction", class('Jibar__SWIG_0'))

# Start of new_Jibar

`Jibar__SWIG_1` = function(tenor)
{
  ;ans = .Call('R_swig_new_Jibar__SWIG_1', tenor, PACKAGE='QuantLib');
  class(ans) <- "_p_JibarPtr";
  
  reg.finalizer(ans, delete_Jibar)
  ans
  
}

attr(`Jibar__SWIG_1`, 'returnType') = '_p_JibarPtr'
attr(`Jibar__SWIG_1`, "inputTypes") = c('_p_Period')
class(`Jibar__SWIG_1`) = c("SWIGFunction", class('Jibar__SWIG_1'))

`Jibar` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_Period')) {
      f <- Jibar__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_Period') && extends(argtypes[2], '_p_HandleT_YieldTermStructure_t')) {
      f <- Jibar__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Jibar with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_Jibar

`delete_Jibar` = function(self)
{
  ;.Call('R_swig_delete_Jibar', self, PACKAGE='QuantLib');
  
}

attr(`delete_Jibar`, 'returnType') = 'void'
attr(`delete_Jibar`, "inputTypes") = c('_p_JibarPtr')
class(`delete_Jibar`) = c("SWIGFunction", class('delete_Jibar'))

setMethod('delete', '_p_JibarPtr', function(obj) {delete_JibarPtr(obj)})
# Start of new_JPYLibor

`JPYLibor__SWIG_0` = function(tenor, h)
{
  ;ans = .Call('R_swig_new_JPYLibor__SWIG_0', tenor, h, PACKAGE='QuantLib');
  class(ans) <- "_p_JPYLiborPtr";
  
  reg.finalizer(ans, delete_JPYLibor)
  ans
  
}

attr(`JPYLibor__SWIG_0`, 'returnType') = '_p_JPYLiborPtr'
attr(`JPYLibor__SWIG_0`, "inputTypes") = c('_p_Period', '_p_HandleT_YieldTermStructure_t')
class(`JPYLibor__SWIG_0`) = c("SWIGFunction", class('JPYLibor__SWIG_0'))

# Start of new_JPYLibor

`JPYLibor__SWIG_1` = function(tenor)
{
  ;ans = .Call('R_swig_new_JPYLibor__SWIG_1', tenor, PACKAGE='QuantLib');
  class(ans) <- "_p_JPYLiborPtr";
  
  reg.finalizer(ans, delete_JPYLibor)
  ans
  
}

attr(`JPYLibor__SWIG_1`, 'returnType') = '_p_JPYLiborPtr'
attr(`JPYLibor__SWIG_1`, "inputTypes") = c('_p_Period')
class(`JPYLibor__SWIG_1`) = c("SWIGFunction", class('JPYLibor__SWIG_1'))

`JPYLibor` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_Period')) {
      f <- JPYLibor__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_Period') && extends(argtypes[2], '_p_HandleT_YieldTermStructure_t')) {
      f <- JPYLibor__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for JPYLibor with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_JPYLibor

`delete_JPYLibor` = function(self)
{
  ;.Call('R_swig_delete_JPYLibor', self, PACKAGE='QuantLib');
  
}

attr(`delete_JPYLibor`, 'returnType') = 'void'
attr(`delete_JPYLibor`, "inputTypes") = c('_p_JPYLiborPtr')
class(`delete_JPYLibor`) = c("SWIGFunction", class('delete_JPYLibor'))

setMethod('delete', '_p_JPYLiborPtr', function(obj) {delete_JPYLiborPtr(obj)})
# Start of new_NZDLibor

`NZDLibor__SWIG_0` = function(tenor, h)
{
  ;ans = .Call('R_swig_new_NZDLibor__SWIG_0', tenor, h, PACKAGE='QuantLib');
  class(ans) <- "_p_NZDLiborPtr";
  
  reg.finalizer(ans, delete_NZDLibor)
  ans
  
}

attr(`NZDLibor__SWIG_0`, 'returnType') = '_p_NZDLiborPtr'
attr(`NZDLibor__SWIG_0`, "inputTypes") = c('_p_Period', '_p_HandleT_YieldTermStructure_t')
class(`NZDLibor__SWIG_0`) = c("SWIGFunction", class('NZDLibor__SWIG_0'))

# Start of new_NZDLibor

`NZDLibor__SWIG_1` = function(tenor)
{
  ;ans = .Call('R_swig_new_NZDLibor__SWIG_1', tenor, PACKAGE='QuantLib');
  class(ans) <- "_p_NZDLiborPtr";
  
  reg.finalizer(ans, delete_NZDLibor)
  ans
  
}

attr(`NZDLibor__SWIG_1`, 'returnType') = '_p_NZDLiborPtr'
attr(`NZDLibor__SWIG_1`, "inputTypes") = c('_p_Period')
class(`NZDLibor__SWIG_1`) = c("SWIGFunction", class('NZDLibor__SWIG_1'))

`NZDLibor` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_Period')) {
      f <- NZDLibor__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_Period') && extends(argtypes[2], '_p_HandleT_YieldTermStructure_t')) {
      f <- NZDLibor__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for NZDLibor with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_NZDLibor

`delete_NZDLibor` = function(self)
{
  ;.Call('R_swig_delete_NZDLibor', self, PACKAGE='QuantLib');
  
}

attr(`delete_NZDLibor`, 'returnType') = 'void'
attr(`delete_NZDLibor`, "inputTypes") = c('_p_NZDLiborPtr')
class(`delete_NZDLibor`) = c("SWIGFunction", class('delete_NZDLibor'))

setMethod('delete', '_p_NZDLiborPtr', function(obj) {delete_NZDLiborPtr(obj)})
# Start of new_SEKLibor

`SEKLibor__SWIG_0` = function(tenor, h)
{
  ;ans = .Call('R_swig_new_SEKLibor__SWIG_0', tenor, h, PACKAGE='QuantLib');
  class(ans) <- "_p_SEKLiborPtr";
  
  reg.finalizer(ans, delete_SEKLibor)
  ans
  
}

attr(`SEKLibor__SWIG_0`, 'returnType') = '_p_SEKLiborPtr'
attr(`SEKLibor__SWIG_0`, "inputTypes") = c('_p_Period', '_p_HandleT_YieldTermStructure_t')
class(`SEKLibor__SWIG_0`) = c("SWIGFunction", class('SEKLibor__SWIG_0'))

# Start of new_SEKLibor

`SEKLibor__SWIG_1` = function(tenor)
{
  ;ans = .Call('R_swig_new_SEKLibor__SWIG_1', tenor, PACKAGE='QuantLib');
  class(ans) <- "_p_SEKLiborPtr";
  
  reg.finalizer(ans, delete_SEKLibor)
  ans
  
}

attr(`SEKLibor__SWIG_1`, 'returnType') = '_p_SEKLiborPtr'
attr(`SEKLibor__SWIG_1`, "inputTypes") = c('_p_Period')
class(`SEKLibor__SWIG_1`) = c("SWIGFunction", class('SEKLibor__SWIG_1'))

`SEKLibor` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_Period')) {
      f <- SEKLibor__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_Period') && extends(argtypes[2], '_p_HandleT_YieldTermStructure_t')) {
      f <- SEKLibor__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for SEKLibor with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_SEKLibor

`delete_SEKLibor` = function(self)
{
  ;.Call('R_swig_delete_SEKLibor', self, PACKAGE='QuantLib');
  
}

attr(`delete_SEKLibor`, 'returnType') = 'void'
attr(`delete_SEKLibor`, "inputTypes") = c('_p_SEKLiborPtr')
class(`delete_SEKLibor`) = c("SWIGFunction", class('delete_SEKLibor'))

setMethod('delete', '_p_SEKLiborPtr', function(obj) {delete_SEKLiborPtr(obj)})
# Start of new_Tibor

`Tibor__SWIG_0` = function(tenor, h)
{
  ;ans = .Call('R_swig_new_Tibor__SWIG_0', tenor, h, PACKAGE='QuantLib');
  class(ans) <- "_p_TiborPtr";
  
  reg.finalizer(ans, delete_Tibor)
  ans
  
}

attr(`Tibor__SWIG_0`, 'returnType') = '_p_TiborPtr'
attr(`Tibor__SWIG_0`, "inputTypes") = c('_p_Period', '_p_HandleT_YieldTermStructure_t')
class(`Tibor__SWIG_0`) = c("SWIGFunction", class('Tibor__SWIG_0'))

# Start of new_Tibor

`Tibor__SWIG_1` = function(tenor)
{
  ;ans = .Call('R_swig_new_Tibor__SWIG_1', tenor, PACKAGE='QuantLib');
  class(ans) <- "_p_TiborPtr";
  
  reg.finalizer(ans, delete_Tibor)
  ans
  
}

attr(`Tibor__SWIG_1`, 'returnType') = '_p_TiborPtr'
attr(`Tibor__SWIG_1`, "inputTypes") = c('_p_Period')
class(`Tibor__SWIG_1`) = c("SWIGFunction", class('Tibor__SWIG_1'))

`Tibor` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_Period')) {
      f <- Tibor__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_Period') && extends(argtypes[2], '_p_HandleT_YieldTermStructure_t')) {
      f <- Tibor__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Tibor with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_Tibor

`delete_Tibor` = function(self)
{
  ;.Call('R_swig_delete_Tibor', self, PACKAGE='QuantLib');
  
}

attr(`delete_Tibor`, 'returnType') = 'void'
attr(`delete_Tibor`, "inputTypes") = c('_p_TiborPtr')
class(`delete_Tibor`) = c("SWIGFunction", class('delete_Tibor'))

setMethod('delete', '_p_TiborPtr', function(obj) {delete_TiborPtr(obj)})
# Start of new_TRLibor

`TRLibor__SWIG_0` = function(tenor, h)
{
  ;ans = .Call('R_swig_new_TRLibor__SWIG_0', tenor, h, PACKAGE='QuantLib');
  class(ans) <- "_p_TRLiborPtr";
  
  reg.finalizer(ans, delete_TRLibor)
  ans
  
}

attr(`TRLibor__SWIG_0`, 'returnType') = '_p_TRLiborPtr'
attr(`TRLibor__SWIG_0`, "inputTypes") = c('_p_Period', '_p_HandleT_YieldTermStructure_t')
class(`TRLibor__SWIG_0`) = c("SWIGFunction", class('TRLibor__SWIG_0'))

# Start of new_TRLibor

`TRLibor__SWIG_1` = function(tenor)
{
  ;ans = .Call('R_swig_new_TRLibor__SWIG_1', tenor, PACKAGE='QuantLib');
  class(ans) <- "_p_TRLiborPtr";
  
  reg.finalizer(ans, delete_TRLibor)
  ans
  
}

attr(`TRLibor__SWIG_1`, 'returnType') = '_p_TRLiborPtr'
attr(`TRLibor__SWIG_1`, "inputTypes") = c('_p_Period')
class(`TRLibor__SWIG_1`) = c("SWIGFunction", class('TRLibor__SWIG_1'))

`TRLibor` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_Period')) {
      f <- TRLibor__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_Period') && extends(argtypes[2], '_p_HandleT_YieldTermStructure_t')) {
      f <- TRLibor__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for TRLibor with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_TRLibor

`delete_TRLibor` = function(self)
{
  ;.Call('R_swig_delete_TRLibor', self, PACKAGE='QuantLib');
  
}

attr(`delete_TRLibor`, 'returnType') = 'void'
attr(`delete_TRLibor`, "inputTypes") = c('_p_TRLiborPtr')
class(`delete_TRLibor`) = c("SWIGFunction", class('delete_TRLibor'))

setMethod('delete', '_p_TRLiborPtr', function(obj) {delete_TRLiborPtr(obj)})
# Start of new_USDLibor

`USDLibor__SWIG_0` = function(tenor, h)
{
  ;ans = .Call('R_swig_new_USDLibor__SWIG_0', tenor, h, PACKAGE='QuantLib');
  class(ans) <- "_p_USDLiborPtr";
  
  reg.finalizer(ans, delete_USDLibor)
  ans
  
}

attr(`USDLibor__SWIG_0`, 'returnType') = '_p_USDLiborPtr'
attr(`USDLibor__SWIG_0`, "inputTypes") = c('_p_Period', '_p_HandleT_YieldTermStructure_t')
class(`USDLibor__SWIG_0`) = c("SWIGFunction", class('USDLibor__SWIG_0'))

# Start of new_USDLibor

`USDLibor__SWIG_1` = function(tenor)
{
  ;ans = .Call('R_swig_new_USDLibor__SWIG_1', tenor, PACKAGE='QuantLib');
  class(ans) <- "_p_USDLiborPtr";
  
  reg.finalizer(ans, delete_USDLibor)
  ans
  
}

attr(`USDLibor__SWIG_1`, 'returnType') = '_p_USDLiborPtr'
attr(`USDLibor__SWIG_1`, "inputTypes") = c('_p_Period')
class(`USDLibor__SWIG_1`) = c("SWIGFunction", class('USDLibor__SWIG_1'))

`USDLibor` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_Period')) {
      f <- USDLibor__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_Period') && extends(argtypes[2], '_p_HandleT_YieldTermStructure_t')) {
      f <- USDLibor__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for USDLibor with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_USDLibor

`delete_USDLibor` = function(self)
{
  ;.Call('R_swig_delete_USDLibor', self, PACKAGE='QuantLib');
  
}

attr(`delete_USDLibor`, 'returnType') = 'void'
attr(`delete_USDLibor`, "inputTypes") = c('_p_USDLiborPtr')
class(`delete_USDLibor`) = c("SWIGFunction", class('delete_USDLibor'))

setMethod('delete', '_p_USDLiborPtr', function(obj) {delete_USDLiborPtr(obj)})
# Start of new_Zibor

`Zibor__SWIG_0` = function(tenor, h)
{
  ;ans = .Call('R_swig_new_Zibor__SWIG_0', tenor, h, PACKAGE='QuantLib');
  class(ans) <- "_p_ZiborPtr";
  
  reg.finalizer(ans, delete_Zibor)
  ans
  
}

attr(`Zibor__SWIG_0`, 'returnType') = '_p_ZiborPtr'
attr(`Zibor__SWIG_0`, "inputTypes") = c('_p_Period', '_p_HandleT_YieldTermStructure_t')
class(`Zibor__SWIG_0`) = c("SWIGFunction", class('Zibor__SWIG_0'))

# Start of new_Zibor

`Zibor__SWIG_1` = function(tenor)
{
  ;ans = .Call('R_swig_new_Zibor__SWIG_1', tenor, PACKAGE='QuantLib');
  class(ans) <- "_p_ZiborPtr";
  
  reg.finalizer(ans, delete_Zibor)
  ans
  
}

attr(`Zibor__SWIG_1`, 'returnType') = '_p_ZiborPtr'
attr(`Zibor__SWIG_1`, "inputTypes") = c('_p_Period')
class(`Zibor__SWIG_1`) = c("SWIGFunction", class('Zibor__SWIG_1'))

`Zibor` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_Period')) {
      f <- Zibor__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_Period') && extends(argtypes[2], '_p_HandleT_YieldTermStructure_t')) {
      f <- Zibor__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Zibor with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_Zibor

`delete_Zibor` = function(self)
{
  ;.Call('R_swig_delete_Zibor', self, PACKAGE='QuantLib');
  
}

attr(`delete_Zibor`, 'returnType') = 'void'
attr(`delete_Zibor`, "inputTypes") = c('_p_ZiborPtr')
class(`delete_Zibor`) = c("SWIGFunction", class('delete_Zibor'))

setMethod('delete', '_p_ZiborPtr', function(obj) {delete_ZiborPtr(obj)})
# Start of new_EuriborSwapIsdaFixA

`EuriborSwapIsdaFixA__SWIG_0` = function(tenor, h)
{
  ;ans = .Call('R_swig_new_EuriborSwapIsdaFixA__SWIG_0', tenor, h, PACKAGE='QuantLib');
  class(ans) <- "_p_EuriborSwapIsdaFixAPtr";
  
  reg.finalizer(ans, delete_EuriborSwapIsdaFixA)
  ans
  
}

attr(`EuriborSwapIsdaFixA__SWIG_0`, 'returnType') = '_p_EuriborSwapIsdaFixAPtr'
attr(`EuriborSwapIsdaFixA__SWIG_0`, "inputTypes") = c('_p_Period', '_p_HandleT_YieldTermStructure_t')
class(`EuriborSwapIsdaFixA__SWIG_0`) = c("SWIGFunction", class('EuriborSwapIsdaFixA__SWIG_0'))

# Start of new_EuriborSwapIsdaFixA

`EuriborSwapIsdaFixA__SWIG_1` = function(tenor)
{
  ;ans = .Call('R_swig_new_EuriborSwapIsdaFixA__SWIG_1', tenor, PACKAGE='QuantLib');
  class(ans) <- "_p_EuriborSwapIsdaFixAPtr";
  
  reg.finalizer(ans, delete_EuriborSwapIsdaFixA)
  ans
  
}

attr(`EuriborSwapIsdaFixA__SWIG_1`, 'returnType') = '_p_EuriborSwapIsdaFixAPtr'
attr(`EuriborSwapIsdaFixA__SWIG_1`, "inputTypes") = c('_p_Period')
class(`EuriborSwapIsdaFixA__SWIG_1`) = c("SWIGFunction", class('EuriborSwapIsdaFixA__SWIG_1'))

`EuriborSwapIsdaFixA` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_Period')) {
      f <- EuriborSwapIsdaFixA__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_Period') && extends(argtypes[2], '_p_HandleT_YieldTermStructure_t')) {
      f <- EuriborSwapIsdaFixA__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for EuriborSwapIsdaFixA with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_EuriborSwapIsdaFixA

`delete_EuriborSwapIsdaFixA` = function(self)
{
  ;.Call('R_swig_delete_EuriborSwapIsdaFixA', self, PACKAGE='QuantLib');
  
}

attr(`delete_EuriborSwapIsdaFixA`, 'returnType') = 'void'
attr(`delete_EuriborSwapIsdaFixA`, "inputTypes") = c('_p_EuriborSwapIsdaFixAPtr')
class(`delete_EuriborSwapIsdaFixA`) = c("SWIGFunction", class('delete_EuriborSwapIsdaFixA'))

setMethod('delete', '_p_EuriborSwapIsdaFixAPtr', function(obj) {delete_EuriborSwapIsdaFixAPtr(obj)})
# Start of new_EuriborSwapIsdaFixB

`EuriborSwapIsdaFixB__SWIG_0` = function(tenor, h)
{
  ;ans = .Call('R_swig_new_EuriborSwapIsdaFixB__SWIG_0', tenor, h, PACKAGE='QuantLib');
  class(ans) <- "_p_EuriborSwapIsdaFixBPtr";
  
  reg.finalizer(ans, delete_EuriborSwapIsdaFixB)
  ans
  
}

attr(`EuriborSwapIsdaFixB__SWIG_0`, 'returnType') = '_p_EuriborSwapIsdaFixBPtr'
attr(`EuriborSwapIsdaFixB__SWIG_0`, "inputTypes") = c('_p_Period', '_p_HandleT_YieldTermStructure_t')
class(`EuriborSwapIsdaFixB__SWIG_0`) = c("SWIGFunction", class('EuriborSwapIsdaFixB__SWIG_0'))

# Start of new_EuriborSwapIsdaFixB

`EuriborSwapIsdaFixB__SWIG_1` = function(tenor)
{
  ;ans = .Call('R_swig_new_EuriborSwapIsdaFixB__SWIG_1', tenor, PACKAGE='QuantLib');
  class(ans) <- "_p_EuriborSwapIsdaFixBPtr";
  
  reg.finalizer(ans, delete_EuriborSwapIsdaFixB)
  ans
  
}

attr(`EuriborSwapIsdaFixB__SWIG_1`, 'returnType') = '_p_EuriborSwapIsdaFixBPtr'
attr(`EuriborSwapIsdaFixB__SWIG_1`, "inputTypes") = c('_p_Period')
class(`EuriborSwapIsdaFixB__SWIG_1`) = c("SWIGFunction", class('EuriborSwapIsdaFixB__SWIG_1'))

`EuriborSwapIsdaFixB` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_Period')) {
      f <- EuriborSwapIsdaFixB__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_Period') && extends(argtypes[2], '_p_HandleT_YieldTermStructure_t')) {
      f <- EuriborSwapIsdaFixB__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for EuriborSwapIsdaFixB with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_EuriborSwapIsdaFixB

`delete_EuriborSwapIsdaFixB` = function(self)
{
  ;.Call('R_swig_delete_EuriborSwapIsdaFixB', self, PACKAGE='QuantLib');
  
}

attr(`delete_EuriborSwapIsdaFixB`, 'returnType') = 'void'
attr(`delete_EuriborSwapIsdaFixB`, "inputTypes") = c('_p_EuriborSwapIsdaFixBPtr')
class(`delete_EuriborSwapIsdaFixB`) = c("SWIGFunction", class('delete_EuriborSwapIsdaFixB'))

setMethod('delete', '_p_EuriborSwapIsdaFixBPtr', function(obj) {delete_EuriborSwapIsdaFixBPtr(obj)})
# Start of new_EuriborSwapIfrFix

`EuriborSwapIfrFix__SWIG_0` = function(tenor, h)
{
  ;ans = .Call('R_swig_new_EuriborSwapIfrFix__SWIG_0', tenor, h, PACKAGE='QuantLib');
  class(ans) <- "_p_EuriborSwapIfrFixPtr";
  
  reg.finalizer(ans, delete_EuriborSwapIfrFix)
  ans
  
}

attr(`EuriborSwapIfrFix__SWIG_0`, 'returnType') = '_p_EuriborSwapIfrFixPtr'
attr(`EuriborSwapIfrFix__SWIG_0`, "inputTypes") = c('_p_Period', '_p_HandleT_YieldTermStructure_t')
class(`EuriborSwapIfrFix__SWIG_0`) = c("SWIGFunction", class('EuriborSwapIfrFix__SWIG_0'))

# Start of new_EuriborSwapIfrFix

`EuriborSwapIfrFix__SWIG_1` = function(tenor)
{
  ;ans = .Call('R_swig_new_EuriborSwapIfrFix__SWIG_1', tenor, PACKAGE='QuantLib');
  class(ans) <- "_p_EuriborSwapIfrFixPtr";
  
  reg.finalizer(ans, delete_EuriborSwapIfrFix)
  ans
  
}

attr(`EuriborSwapIfrFix__SWIG_1`, 'returnType') = '_p_EuriborSwapIfrFixPtr'
attr(`EuriborSwapIfrFix__SWIG_1`, "inputTypes") = c('_p_Period')
class(`EuriborSwapIfrFix__SWIG_1`) = c("SWIGFunction", class('EuriborSwapIfrFix__SWIG_1'))

`EuriborSwapIfrFix` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_Period')) {
      f <- EuriborSwapIfrFix__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_Period') && extends(argtypes[2], '_p_HandleT_YieldTermStructure_t')) {
      f <- EuriborSwapIfrFix__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for EuriborSwapIfrFix with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_EuriborSwapIfrFix

`delete_EuriborSwapIfrFix` = function(self)
{
  ;.Call('R_swig_delete_EuriborSwapIfrFix', self, PACKAGE='QuantLib');
  
}

attr(`delete_EuriborSwapIfrFix`, 'returnType') = 'void'
attr(`delete_EuriborSwapIfrFix`, "inputTypes") = c('_p_EuriborSwapIfrFixPtr')
class(`delete_EuriborSwapIfrFix`) = c("SWIGFunction", class('delete_EuriborSwapIfrFix'))

setMethod('delete', '_p_EuriborSwapIfrFixPtr', function(obj) {delete_EuriborSwapIfrFixPtr(obj)})
# Start of new_EurLiborSwapIsdaFixA

`EurLiborSwapIsdaFixA__SWIG_0` = function(tenor, h)
{
  ;ans = .Call('R_swig_new_EurLiborSwapIsdaFixA__SWIG_0', tenor, h, PACKAGE='QuantLib');
  class(ans) <- "_p_EurLiborSwapIsdaFixAPtr";
  
  reg.finalizer(ans, delete_EurLiborSwapIsdaFixA)
  ans
  
}

attr(`EurLiborSwapIsdaFixA__SWIG_0`, 'returnType') = '_p_EurLiborSwapIsdaFixAPtr'
attr(`EurLiborSwapIsdaFixA__SWIG_0`, "inputTypes") = c('_p_Period', '_p_HandleT_YieldTermStructure_t')
class(`EurLiborSwapIsdaFixA__SWIG_0`) = c("SWIGFunction", class('EurLiborSwapIsdaFixA__SWIG_0'))

# Start of new_EurLiborSwapIsdaFixA

`EurLiborSwapIsdaFixA__SWIG_1` = function(tenor)
{
  ;ans = .Call('R_swig_new_EurLiborSwapIsdaFixA__SWIG_1', tenor, PACKAGE='QuantLib');
  class(ans) <- "_p_EurLiborSwapIsdaFixAPtr";
  
  reg.finalizer(ans, delete_EurLiborSwapIsdaFixA)
  ans
  
}

attr(`EurLiborSwapIsdaFixA__SWIG_1`, 'returnType') = '_p_EurLiborSwapIsdaFixAPtr'
attr(`EurLiborSwapIsdaFixA__SWIG_1`, "inputTypes") = c('_p_Period')
class(`EurLiborSwapIsdaFixA__SWIG_1`) = c("SWIGFunction", class('EurLiborSwapIsdaFixA__SWIG_1'))

`EurLiborSwapIsdaFixA` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_Period')) {
      f <- EurLiborSwapIsdaFixA__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_Period') && extends(argtypes[2], '_p_HandleT_YieldTermStructure_t')) {
      f <- EurLiborSwapIsdaFixA__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for EurLiborSwapIsdaFixA with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_EurLiborSwapIsdaFixA

`delete_EurLiborSwapIsdaFixA` = function(self)
{
  ;.Call('R_swig_delete_EurLiborSwapIsdaFixA', self, PACKAGE='QuantLib');
  
}

attr(`delete_EurLiborSwapIsdaFixA`, 'returnType') = 'void'
attr(`delete_EurLiborSwapIsdaFixA`, "inputTypes") = c('_p_EurLiborSwapIsdaFixAPtr')
class(`delete_EurLiborSwapIsdaFixA`) = c("SWIGFunction", class('delete_EurLiborSwapIsdaFixA'))

setMethod('delete', '_p_EurLiborSwapIsdaFixAPtr', function(obj) {delete_EurLiborSwapIsdaFixAPtr(obj)})
# Start of new_EurLiborSwapIsdaFixB

`EurLiborSwapIsdaFixB__SWIG_0` = function(tenor, h)
{
  ;ans = .Call('R_swig_new_EurLiborSwapIsdaFixB__SWIG_0', tenor, h, PACKAGE='QuantLib');
  class(ans) <- "_p_EurLiborSwapIsdaFixBPtr";
  
  reg.finalizer(ans, delete_EurLiborSwapIsdaFixB)
  ans
  
}

attr(`EurLiborSwapIsdaFixB__SWIG_0`, 'returnType') = '_p_EurLiborSwapIsdaFixBPtr'
attr(`EurLiborSwapIsdaFixB__SWIG_0`, "inputTypes") = c('_p_Period', '_p_HandleT_YieldTermStructure_t')
class(`EurLiborSwapIsdaFixB__SWIG_0`) = c("SWIGFunction", class('EurLiborSwapIsdaFixB__SWIG_0'))

# Start of new_EurLiborSwapIsdaFixB

`EurLiborSwapIsdaFixB__SWIG_1` = function(tenor)
{
  ;ans = .Call('R_swig_new_EurLiborSwapIsdaFixB__SWIG_1', tenor, PACKAGE='QuantLib');
  class(ans) <- "_p_EurLiborSwapIsdaFixBPtr";
  
  reg.finalizer(ans, delete_EurLiborSwapIsdaFixB)
  ans
  
}

attr(`EurLiborSwapIsdaFixB__SWIG_1`, 'returnType') = '_p_EurLiborSwapIsdaFixBPtr'
attr(`EurLiborSwapIsdaFixB__SWIG_1`, "inputTypes") = c('_p_Period')
class(`EurLiborSwapIsdaFixB__SWIG_1`) = c("SWIGFunction", class('EurLiborSwapIsdaFixB__SWIG_1'))

`EurLiborSwapIsdaFixB` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_Period')) {
      f <- EurLiborSwapIsdaFixB__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_Period') && extends(argtypes[2], '_p_HandleT_YieldTermStructure_t')) {
      f <- EurLiborSwapIsdaFixB__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for EurLiborSwapIsdaFixB with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_EurLiborSwapIsdaFixB

`delete_EurLiborSwapIsdaFixB` = function(self)
{
  ;.Call('R_swig_delete_EurLiborSwapIsdaFixB', self, PACKAGE='QuantLib');
  
}

attr(`delete_EurLiborSwapIsdaFixB`, 'returnType') = 'void'
attr(`delete_EurLiborSwapIsdaFixB`, "inputTypes") = c('_p_EurLiborSwapIsdaFixBPtr')
class(`delete_EurLiborSwapIsdaFixB`) = c("SWIGFunction", class('delete_EurLiborSwapIsdaFixB'))

setMethod('delete', '_p_EurLiborSwapIsdaFixBPtr', function(obj) {delete_EurLiborSwapIsdaFixBPtr(obj)})
# Start of new_EurLiborSwapIfrFix

`EurLiborSwapIfrFix__SWIG_0` = function(tenor, h)
{
  ;ans = .Call('R_swig_new_EurLiborSwapIfrFix__SWIG_0', tenor, h, PACKAGE='QuantLib');
  class(ans) <- "_p_EurLiborSwapIfrFixPtr";
  
  reg.finalizer(ans, delete_EurLiborSwapIfrFix)
  ans
  
}

attr(`EurLiborSwapIfrFix__SWIG_0`, 'returnType') = '_p_EurLiborSwapIfrFixPtr'
attr(`EurLiborSwapIfrFix__SWIG_0`, "inputTypes") = c('_p_Period', '_p_HandleT_YieldTermStructure_t')
class(`EurLiborSwapIfrFix__SWIG_0`) = c("SWIGFunction", class('EurLiborSwapIfrFix__SWIG_0'))

# Start of new_EurLiborSwapIfrFix

`EurLiborSwapIfrFix__SWIG_1` = function(tenor)
{
  ;ans = .Call('R_swig_new_EurLiborSwapIfrFix__SWIG_1', tenor, PACKAGE='QuantLib');
  class(ans) <- "_p_EurLiborSwapIfrFixPtr";
  
  reg.finalizer(ans, delete_EurLiborSwapIfrFix)
  ans
  
}

attr(`EurLiborSwapIfrFix__SWIG_1`, 'returnType') = '_p_EurLiborSwapIfrFixPtr'
attr(`EurLiborSwapIfrFix__SWIG_1`, "inputTypes") = c('_p_Period')
class(`EurLiborSwapIfrFix__SWIG_1`) = c("SWIGFunction", class('EurLiborSwapIfrFix__SWIG_1'))

`EurLiborSwapIfrFix` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_Period')) {
      f <- EurLiborSwapIfrFix__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_Period') && extends(argtypes[2], '_p_HandleT_YieldTermStructure_t')) {
      f <- EurLiborSwapIfrFix__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for EurLiborSwapIfrFix with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_EurLiborSwapIfrFix

`delete_EurLiborSwapIfrFix` = function(self)
{
  ;.Call('R_swig_delete_EurLiborSwapIfrFix', self, PACKAGE='QuantLib');
  
}

attr(`delete_EurLiborSwapIfrFix`, 'returnType') = 'void'
attr(`delete_EurLiborSwapIfrFix`, "inputTypes") = c('_p_EurLiborSwapIfrFixPtr')
class(`delete_EurLiborSwapIfrFix`) = c("SWIGFunction", class('delete_EurLiborSwapIfrFix'))

setMethod('delete', '_p_EurLiborSwapIfrFixPtr', function(obj) {delete_EurLiborSwapIfrFixPtr(obj)})
# Start of Brent_setMaxEvaluations

`Brent_setMaxEvaluations` = function(self, evaluations)
{
  if(length(evaluations) > 1) {
    warning("using only the first element of evaluations");
  };
  
  ;.Call('R_swig_Brent_setMaxEvaluations', self, evaluations, PACKAGE='QuantLib');
  
}

attr(`Brent_setMaxEvaluations`, 'returnType') = 'void'
attr(`Brent_setMaxEvaluations`, "inputTypes") = c('_p_Brent', 'integer')
class(`Brent_setMaxEvaluations`) = c("SWIGFunction", class('Brent_setMaxEvaluations'))

# Start of Brent_setLowerBound

`Brent_setLowerBound` = function(self, lowerBound)
{
  ;.Call('R_swig_Brent_setLowerBound', self, lowerBound, PACKAGE='QuantLib');
  
}

attr(`Brent_setLowerBound`, 'returnType') = 'void'
attr(`Brent_setLowerBound`, "inputTypes") = c('_p_Brent', 'numeric')
class(`Brent_setLowerBound`) = c("SWIGFunction", class('Brent_setLowerBound'))

# Start of Brent_setUpperBound

`Brent_setUpperBound` = function(self, upperBound)
{
  ;.Call('R_swig_Brent_setUpperBound', self, upperBound, PACKAGE='QuantLib');
  
}

attr(`Brent_setUpperBound`, 'returnType') = 'void'
attr(`Brent_setUpperBound`, "inputTypes") = c('_p_Brent', 'numeric')
class(`Brent_setUpperBound`) = c("SWIGFunction", class('Brent_setUpperBound'))

# Start of new_Brent

`Brent` = function()
{
  ;ans = .Call('R_swig_new_Brent', PACKAGE='QuantLib');
  class(ans) <- "_p_Brent";
  
  reg.finalizer(ans, delete_Brent)
  ans
  
}

attr(`Brent`, 'returnType') = '_p_Brent'
class(`Brent`) = c("SWIGFunction", class('Brent'))

# Start of delete_Brent

`delete_Brent` = function(self)
{
  ;.Call('R_swig_delete_Brent', self, PACKAGE='QuantLib');
  
}

attr(`delete_Brent`, 'returnType') = 'void'
attr(`delete_Brent`, "inputTypes") = c('_p_Brent')
class(`delete_Brent`) = c("SWIGFunction", class('delete_Brent'))

# Start of accessor method for Brent
setMethod('$', '_p_Brent', function(x, name)

{
  accessorFuns = list('setMaxEvaluations' = Brent_setMaxEvaluations, 'setLowerBound' = Brent_setLowerBound, 'setUpperBound' = Brent_setUpperBound);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for Brent
setMethod('delete', '_p_Brent', function(obj) {delete_Brent(obj)})
# Start of Bisection_setMaxEvaluations

`Bisection_setMaxEvaluations` = function(self, evaluations)
{
  if(length(evaluations) > 1) {
    warning("using only the first element of evaluations");
  };
  
  ;.Call('R_swig_Bisection_setMaxEvaluations', self, evaluations, PACKAGE='QuantLib');
  
}

attr(`Bisection_setMaxEvaluations`, 'returnType') = 'void'
attr(`Bisection_setMaxEvaluations`, "inputTypes") = c('_p_Bisection', 'integer')
class(`Bisection_setMaxEvaluations`) = c("SWIGFunction", class('Bisection_setMaxEvaluations'))

# Start of Bisection_setLowerBound

`Bisection_setLowerBound` = function(self, lowerBound)
{
  ;.Call('R_swig_Bisection_setLowerBound', self, lowerBound, PACKAGE='QuantLib');
  
}

attr(`Bisection_setLowerBound`, 'returnType') = 'void'
attr(`Bisection_setLowerBound`, "inputTypes") = c('_p_Bisection', 'numeric')
class(`Bisection_setLowerBound`) = c("SWIGFunction", class('Bisection_setLowerBound'))

# Start of Bisection_setUpperBound

`Bisection_setUpperBound` = function(self, upperBound)
{
  ;.Call('R_swig_Bisection_setUpperBound', self, upperBound, PACKAGE='QuantLib');
  
}

attr(`Bisection_setUpperBound`, 'returnType') = 'void'
attr(`Bisection_setUpperBound`, "inputTypes") = c('_p_Bisection', 'numeric')
class(`Bisection_setUpperBound`) = c("SWIGFunction", class('Bisection_setUpperBound'))

# Start of new_Bisection

`Bisection` = function()
{
  ;ans = .Call('R_swig_new_Bisection', PACKAGE='QuantLib');
  class(ans) <- "_p_Bisection";
  
  reg.finalizer(ans, delete_Bisection)
  ans
  
}

attr(`Bisection`, 'returnType') = '_p_Bisection'
class(`Bisection`) = c("SWIGFunction", class('Bisection'))

# Start of delete_Bisection

`delete_Bisection` = function(self)
{
  ;.Call('R_swig_delete_Bisection', self, PACKAGE='QuantLib');
  
}

attr(`delete_Bisection`, 'returnType') = 'void'
attr(`delete_Bisection`, "inputTypes") = c('_p_Bisection')
class(`delete_Bisection`) = c("SWIGFunction", class('delete_Bisection'))

# Start of accessor method for Bisection
setMethod('$', '_p_Bisection', function(x, name)

{
  accessorFuns = list('setMaxEvaluations' = Bisection_setMaxEvaluations, 'setLowerBound' = Bisection_setLowerBound, 'setUpperBound' = Bisection_setUpperBound);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for Bisection
setMethod('delete', '_p_Bisection', function(obj) {delete_Bisection(obj)})
# Start of FalsePosition_setMaxEvaluations

`FalsePosition_setMaxEvaluations` = function(self, evaluations)
{
  if(length(evaluations) > 1) {
    warning("using only the first element of evaluations");
  };
  
  ;.Call('R_swig_FalsePosition_setMaxEvaluations', self, evaluations, PACKAGE='QuantLib');
  
}

attr(`FalsePosition_setMaxEvaluations`, 'returnType') = 'void'
attr(`FalsePosition_setMaxEvaluations`, "inputTypes") = c('_p_FalsePosition', 'integer')
class(`FalsePosition_setMaxEvaluations`) = c("SWIGFunction", class('FalsePosition_setMaxEvaluations'))

# Start of FalsePosition_setLowerBound

`FalsePosition_setLowerBound` = function(self, lowerBound)
{
  ;.Call('R_swig_FalsePosition_setLowerBound', self, lowerBound, PACKAGE='QuantLib');
  
}

attr(`FalsePosition_setLowerBound`, 'returnType') = 'void'
attr(`FalsePosition_setLowerBound`, "inputTypes") = c('_p_FalsePosition', 'numeric')
class(`FalsePosition_setLowerBound`) = c("SWIGFunction", class('FalsePosition_setLowerBound'))

# Start of FalsePosition_setUpperBound

`FalsePosition_setUpperBound` = function(self, upperBound)
{
  ;.Call('R_swig_FalsePosition_setUpperBound', self, upperBound, PACKAGE='QuantLib');
  
}

attr(`FalsePosition_setUpperBound`, 'returnType') = 'void'
attr(`FalsePosition_setUpperBound`, "inputTypes") = c('_p_FalsePosition', 'numeric')
class(`FalsePosition_setUpperBound`) = c("SWIGFunction", class('FalsePosition_setUpperBound'))

# Start of new_FalsePosition

`FalsePosition` = function()
{
  ;ans = .Call('R_swig_new_FalsePosition', PACKAGE='QuantLib');
  class(ans) <- "_p_FalsePosition";
  
  reg.finalizer(ans, delete_FalsePosition)
  ans
  
}

attr(`FalsePosition`, 'returnType') = '_p_FalsePosition'
class(`FalsePosition`) = c("SWIGFunction", class('FalsePosition'))

# Start of delete_FalsePosition

`delete_FalsePosition` = function(self)
{
  ;.Call('R_swig_delete_FalsePosition', self, PACKAGE='QuantLib');
  
}

attr(`delete_FalsePosition`, 'returnType') = 'void'
attr(`delete_FalsePosition`, "inputTypes") = c('_p_FalsePosition')
class(`delete_FalsePosition`) = c("SWIGFunction", class('delete_FalsePosition'))

# Start of accessor method for FalsePosition
setMethod('$', '_p_FalsePosition', function(x, name)

{
  accessorFuns = list('setMaxEvaluations' = FalsePosition_setMaxEvaluations, 'setLowerBound' = FalsePosition_setLowerBound, 'setUpperBound' = FalsePosition_setUpperBound);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for FalsePosition
setMethod('delete', '_p_FalsePosition', function(obj) {delete_FalsePosition(obj)})
# Start of Ridder_setMaxEvaluations

`Ridder_setMaxEvaluations` = function(self, evaluations)
{
  if(length(evaluations) > 1) {
    warning("using only the first element of evaluations");
  };
  
  ;.Call('R_swig_Ridder_setMaxEvaluations', self, evaluations, PACKAGE='QuantLib');
  
}

attr(`Ridder_setMaxEvaluations`, 'returnType') = 'void'
attr(`Ridder_setMaxEvaluations`, "inputTypes") = c('_p_Ridder', 'integer')
class(`Ridder_setMaxEvaluations`) = c("SWIGFunction", class('Ridder_setMaxEvaluations'))

# Start of Ridder_setLowerBound

`Ridder_setLowerBound` = function(self, lowerBound)
{
  ;.Call('R_swig_Ridder_setLowerBound', self, lowerBound, PACKAGE='QuantLib');
  
}

attr(`Ridder_setLowerBound`, 'returnType') = 'void'
attr(`Ridder_setLowerBound`, "inputTypes") = c('_p_Ridder', 'numeric')
class(`Ridder_setLowerBound`) = c("SWIGFunction", class('Ridder_setLowerBound'))

# Start of Ridder_setUpperBound

`Ridder_setUpperBound` = function(self, upperBound)
{
  ;.Call('R_swig_Ridder_setUpperBound', self, upperBound, PACKAGE='QuantLib');
  
}

attr(`Ridder_setUpperBound`, 'returnType') = 'void'
attr(`Ridder_setUpperBound`, "inputTypes") = c('_p_Ridder', 'numeric')
class(`Ridder_setUpperBound`) = c("SWIGFunction", class('Ridder_setUpperBound'))

# Start of new_Ridder

`Ridder` = function()
{
  ;ans = .Call('R_swig_new_Ridder', PACKAGE='QuantLib');
  class(ans) <- "_p_Ridder";
  
  reg.finalizer(ans, delete_Ridder)
  ans
  
}

attr(`Ridder`, 'returnType') = '_p_Ridder'
class(`Ridder`) = c("SWIGFunction", class('Ridder'))

# Start of delete_Ridder

`delete_Ridder` = function(self)
{
  ;.Call('R_swig_delete_Ridder', self, PACKAGE='QuantLib');
  
}

attr(`delete_Ridder`, 'returnType') = 'void'
attr(`delete_Ridder`, "inputTypes") = c('_p_Ridder')
class(`delete_Ridder`) = c("SWIGFunction", class('delete_Ridder'))

# Start of accessor method for Ridder
setMethod('$', '_p_Ridder', function(x, name)

{
  accessorFuns = list('setMaxEvaluations' = Ridder_setMaxEvaluations, 'setLowerBound' = Ridder_setLowerBound, 'setUpperBound' = Ridder_setUpperBound);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for Ridder
setMethod('delete', '_p_Ridder', function(obj) {delete_Ridder(obj)})
# Start of Secant_setMaxEvaluations

`Secant_setMaxEvaluations` = function(self, evaluations)
{
  if(length(evaluations) > 1) {
    warning("using only the first element of evaluations");
  };
  
  ;.Call('R_swig_Secant_setMaxEvaluations', self, evaluations, PACKAGE='QuantLib');
  
}

attr(`Secant_setMaxEvaluations`, 'returnType') = 'void'
attr(`Secant_setMaxEvaluations`, "inputTypes") = c('_p_Secant', 'integer')
class(`Secant_setMaxEvaluations`) = c("SWIGFunction", class('Secant_setMaxEvaluations'))

# Start of Secant_setLowerBound

`Secant_setLowerBound` = function(self, lowerBound)
{
  ;.Call('R_swig_Secant_setLowerBound', self, lowerBound, PACKAGE='QuantLib');
  
}

attr(`Secant_setLowerBound`, 'returnType') = 'void'
attr(`Secant_setLowerBound`, "inputTypes") = c('_p_Secant', 'numeric')
class(`Secant_setLowerBound`) = c("SWIGFunction", class('Secant_setLowerBound'))

# Start of Secant_setUpperBound

`Secant_setUpperBound` = function(self, upperBound)
{
  ;.Call('R_swig_Secant_setUpperBound', self, upperBound, PACKAGE='QuantLib');
  
}

attr(`Secant_setUpperBound`, 'returnType') = 'void'
attr(`Secant_setUpperBound`, "inputTypes") = c('_p_Secant', 'numeric')
class(`Secant_setUpperBound`) = c("SWIGFunction", class('Secant_setUpperBound'))

# Start of new_Secant

`Secant` = function()
{
  ;ans = .Call('R_swig_new_Secant', PACKAGE='QuantLib');
  class(ans) <- "_p_Secant";
  
  reg.finalizer(ans, delete_Secant)
  ans
  
}

attr(`Secant`, 'returnType') = '_p_Secant'
class(`Secant`) = c("SWIGFunction", class('Secant'))

# Start of delete_Secant

`delete_Secant` = function(self)
{
  ;.Call('R_swig_delete_Secant', self, PACKAGE='QuantLib');
  
}

attr(`delete_Secant`, 'returnType') = 'void'
attr(`delete_Secant`, "inputTypes") = c('_p_Secant')
class(`delete_Secant`) = c("SWIGFunction", class('delete_Secant'))

# Start of accessor method for Secant
setMethod('$', '_p_Secant', function(x, name)

{
  accessorFuns = list('setMaxEvaluations' = Secant_setMaxEvaluations, 'setLowerBound' = Secant_setLowerBound, 'setUpperBound' = Secant_setUpperBound);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for Secant
setMethod('delete', '_p_Secant', function(obj) {delete_Secant(obj)})
# Start of delete_Constraint

`delete_Constraint` = function(self)
{
  ;.Call('R_swig_delete_Constraint', self, PACKAGE='QuantLib');
  
}

attr(`delete_Constraint`, 'returnType') = 'void'
attr(`delete_Constraint`, "inputTypes") = c('_p_Constraint')
class(`delete_Constraint`) = c("SWIGFunction", class('delete_Constraint'))

setMethod('delete', '_p_Constraint', function(obj) {delete_Constraint(obj)})
# Start of new_BoundaryConstraint

`BoundaryConstraint` = function(lower, upper)
{
  ;ans = .Call('R_swig_new_BoundaryConstraint', lower, upper, PACKAGE='QuantLib');
  class(ans) <- "_p_BoundaryConstraint";
  
  reg.finalizer(ans, delete_BoundaryConstraint)
  ans
  
}

attr(`BoundaryConstraint`, 'returnType') = '_p_BoundaryConstraint'
attr(`BoundaryConstraint`, "inputTypes") = c('numeric', 'numeric')
class(`BoundaryConstraint`) = c("SWIGFunction", class('BoundaryConstraint'))

# Start of delete_BoundaryConstraint

`delete_BoundaryConstraint` = function(self)
{
  ;.Call('R_swig_delete_BoundaryConstraint', self, PACKAGE='QuantLib');
  
}

attr(`delete_BoundaryConstraint`, 'returnType') = 'void'
attr(`delete_BoundaryConstraint`, "inputTypes") = c('_p_BoundaryConstraint')
class(`delete_BoundaryConstraint`) = c("SWIGFunction", class('delete_BoundaryConstraint'))

setMethod('delete', '_p_BoundaryConstraint', function(obj) {delete_BoundaryConstraint(obj)})
# Start of new_NoConstraint

`NoConstraint` = function()
{
  ;ans = .Call('R_swig_new_NoConstraint', PACKAGE='QuantLib');
  class(ans) <- "_p_NoConstraint";
  
  reg.finalizer(ans, delete_NoConstraint)
  ans
  
}

attr(`NoConstraint`, 'returnType') = '_p_NoConstraint'
class(`NoConstraint`) = c("SWIGFunction", class('NoConstraint'))

# Start of delete_NoConstraint

`delete_NoConstraint` = function(self)
{
  ;.Call('R_swig_delete_NoConstraint', self, PACKAGE='QuantLib');
  
}

attr(`delete_NoConstraint`, 'returnType') = 'void'
attr(`delete_NoConstraint`, "inputTypes") = c('_p_NoConstraint')
class(`delete_NoConstraint`) = c("SWIGFunction", class('delete_NoConstraint'))

setMethod('delete', '_p_NoConstraint', function(obj) {delete_NoConstraint(obj)})
# Start of new_PositiveConstraint

`PositiveConstraint` = function()
{
  ;ans = .Call('R_swig_new_PositiveConstraint', PACKAGE='QuantLib');
  class(ans) <- "_p_PositiveConstraint";
  
  reg.finalizer(ans, delete_PositiveConstraint)
  ans
  
}

attr(`PositiveConstraint`, 'returnType') = '_p_PositiveConstraint'
class(`PositiveConstraint`) = c("SWIGFunction", class('PositiveConstraint'))

# Start of delete_PositiveConstraint

`delete_PositiveConstraint` = function(self)
{
  ;.Call('R_swig_delete_PositiveConstraint', self, PACKAGE='QuantLib');
  
}

attr(`delete_PositiveConstraint`, 'returnType') = 'void'
attr(`delete_PositiveConstraint`, "inputTypes") = c('_p_PositiveConstraint')
class(`delete_PositiveConstraint`) = c("SWIGFunction", class('delete_PositiveConstraint'))

setMethod('delete', '_p_PositiveConstraint', function(obj) {delete_PositiveConstraint(obj)})
defineEnumeration('_EndCriteria__Type',
                    .values = c(
                        'None' = 0, 
                        'MaxIterations' = 1, 
                        'StationaryPoint' = 2, 
                        'StationaryFunctionValue' = 3, 
                        'StationaryFunctionAccuracy' = 4, 
                        'ZeroGradientNorm' = 5, 
                        'Unknown' = 6
))
# Start of new_EndCriteria

`EndCriteria` = function(maxIteration, maxStationaryStateIterations, rootEpsilon, functionEpsilon, gradientNormEpsilon)
{
  if(length(maxIteration) > 1) {
    warning("using only the first element of maxIteration");
  };
  
  
  
  if(length(maxStationaryStateIterations) > 1) {
    warning("using only the first element of maxStationaryStateIterations");
  };
  
  
  
  
  ;ans = .Call('R_swig_new_EndCriteria', maxIteration, maxStationaryStateIterations, rootEpsilon, functionEpsilon, gradientNormEpsilon, PACKAGE='QuantLib');
  class(ans) <- "_p_EndCriteria";
  
  reg.finalizer(ans, delete_EndCriteria)
  ans
  
}

attr(`EndCriteria`, 'returnType') = '_p_EndCriteria'
attr(`EndCriteria`, "inputTypes") = c('integer', 'integer', 'numeric', 'numeric', 'numeric')
class(`EndCriteria`) = c("SWIGFunction", class('EndCriteria'))

# Start of EndCriteria___call__

`EndCriteria___call__` = function(self, iteration, statState, positiveOptimization, fold, normgold, fnew, normgnewx, ecType, .copy = FALSE)
{
  if(length(iteration) > 1) {
    warning("using only the first element of iteration");
  };
  
  
  positiveOptimization = as.logical(positiveOptimization);
  
  
  
  
  ecType = enumToInteger(ecType, "_p_EndCriteria__Type"); 
  ;.Call('R_swig_EndCriteria___call__', self, iteration, statState, positiveOptimization, fold, normgold, fnew, normgnewx, ecType, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`EndCriteria___call__`, 'returnType') = 'logical'
attr(`EndCriteria___call__`, "inputTypes") = c('_p_EndCriteria', 'integer', '_p_std__size_t', 'logical', 'numeric', 'numeric', 'numeric', 'numeric', 'character')
class(`EndCriteria___call__`) = c("SWIGFunction", class('EndCriteria___call__'))

# Start of delete_EndCriteria

`delete_EndCriteria` = function(self)
{
  ;.Call('R_swig_delete_EndCriteria', self, PACKAGE='QuantLib');
  
}

attr(`delete_EndCriteria`, 'returnType') = 'void'
attr(`delete_EndCriteria`, "inputTypes") = c('_p_EndCriteria')
class(`delete_EndCriteria`) = c("SWIGFunction", class('delete_EndCriteria'))

# Start of accessor method for EndCriteria
setMethod('$', '_p_EndCriteria', function(x, name)

{
  accessorFuns = list('__call__' = EndCriteria___call__);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for EndCriteria
setMethod('delete', '_p_EndCriteria', function(obj) {delete_EndCriteria(obj)})
# Start of delete_OptimizationMethod

`delete_OptimizationMethod` = function(self)
{
  ;.Call('R_swig_delete_OptimizationMethod', self, PACKAGE='QuantLib');
  
}

attr(`delete_OptimizationMethod`, 'returnType') = 'void'
attr(`delete_OptimizationMethod`, "inputTypes") = c('_p_OptimizationMethod')
class(`delete_OptimizationMethod`) = c("SWIGFunction", class('delete_OptimizationMethod'))

setMethod('delete', '_p_OptimizationMethod', function(obj) {delete_OptimizationMethod(obj)})
# Start of new_ConjugateGradient

`ConjugateGradient` = function()
{
  ;ans = .Call('R_swig_new_ConjugateGradient', PACKAGE='QuantLib');
  class(ans) <- "_p_ConjugateGradient";
  
  reg.finalizer(ans, delete_ConjugateGradient)
  ans
  
}

attr(`ConjugateGradient`, 'returnType') = '_p_ConjugateGradient'
class(`ConjugateGradient`) = c("SWIGFunction", class('ConjugateGradient'))

# Start of delete_ConjugateGradient

`delete_ConjugateGradient` = function(self)
{
  ;.Call('R_swig_delete_ConjugateGradient', self, PACKAGE='QuantLib');
  
}

attr(`delete_ConjugateGradient`, 'returnType') = 'void'
attr(`delete_ConjugateGradient`, "inputTypes") = c('_p_ConjugateGradient')
class(`delete_ConjugateGradient`) = c("SWIGFunction", class('delete_ConjugateGradient'))

setMethod('delete', '_p_ConjugateGradient', function(obj) {delete_ConjugateGradient(obj)})
# Start of new_Simplex

`Simplex` = function(lambda)
{
  ;ans = .Call('R_swig_new_Simplex', lambda, PACKAGE='QuantLib');
  class(ans) <- "_p_Simplex";
  
  reg.finalizer(ans, delete_Simplex)
  ans
  
}

attr(`Simplex`, 'returnType') = '_p_Simplex'
attr(`Simplex`, "inputTypes") = c('numeric')
class(`Simplex`) = c("SWIGFunction", class('Simplex'))

# Start of delete_Simplex

`delete_Simplex` = function(self)
{
  ;.Call('R_swig_delete_Simplex', self, PACKAGE='QuantLib');
  
}

attr(`delete_Simplex`, 'returnType') = 'void'
attr(`delete_Simplex`, "inputTypes") = c('_p_Simplex')
class(`delete_Simplex`) = c("SWIGFunction", class('delete_Simplex'))

setMethod('delete', '_p_Simplex', function(obj) {delete_Simplex(obj)})
# Start of new_SteepestDescent

`SteepestDescent` = function()
{
  ;ans = .Call('R_swig_new_SteepestDescent', PACKAGE='QuantLib');
  class(ans) <- "_p_SteepestDescent";
  
  reg.finalizer(ans, delete_SteepestDescent)
  ans
  
}

attr(`SteepestDescent`, 'returnType') = '_p_SteepestDescent'
class(`SteepestDescent`) = c("SWIGFunction", class('SteepestDescent'))

# Start of delete_SteepestDescent

`delete_SteepestDescent` = function(self)
{
  ;.Call('R_swig_delete_SteepestDescent', self, PACKAGE='QuantLib');
  
}

attr(`delete_SteepestDescent`, 'returnType') = 'void'
attr(`delete_SteepestDescent`, "inputTypes") = c('_p_SteepestDescent')
class(`delete_SteepestDescent`) = c("SWIGFunction", class('delete_SteepestDescent'))

setMethod('delete', '_p_SteepestDescent', function(obj) {delete_SteepestDescent(obj)})
# Start of new_BFGS

`BFGS` = function()
{
  ;ans = .Call('R_swig_new_BFGS', PACKAGE='QuantLib');
  class(ans) <- "_p_BFGS";
  
  reg.finalizer(ans, delete_BFGS)
  ans
  
}

attr(`BFGS`, 'returnType') = '_p_BFGS'
class(`BFGS`) = c("SWIGFunction", class('BFGS'))

# Start of delete_BFGS

`delete_BFGS` = function(self)
{
  ;.Call('R_swig_delete_BFGS', self, PACKAGE='QuantLib');
  
}

attr(`delete_BFGS`, 'returnType') = 'void'
attr(`delete_BFGS`, "inputTypes") = c('_p_BFGS')
class(`delete_BFGS`) = c("SWIGFunction", class('delete_BFGS'))

setMethod('delete', '_p_BFGS', function(obj) {delete_BFGS(obj)})
# Start of new_Optimizer

`Optimizer` = function()
{
  ;ans = .Call('R_swig_new_Optimizer', PACKAGE='QuantLib');
  class(ans) <- "_p_Optimizer";
  
  reg.finalizer(ans, delete_Optimizer)
  ans
  
}

attr(`Optimizer`, 'returnType') = '_p_Optimizer'
class(`Optimizer`) = c("SWIGFunction", class('Optimizer'))

# Start of delete_Optimizer

`delete_Optimizer` = function(self)
{
  ;.Call('R_swig_delete_Optimizer', self, PACKAGE='QuantLib');
  
}

attr(`delete_Optimizer`, 'returnType') = 'void'
attr(`delete_Optimizer`, "inputTypes") = c('_p_Optimizer')
class(`delete_Optimizer`) = c("SWIGFunction", class('delete_Optimizer'))

setMethod('delete', '_p_Optimizer', function(obj) {delete_Optimizer(obj)})
# Start of BlackVolTermStructure___deref__

`BlackVolTermStructure___deref__` = function(self)
{
  ;ans = .Call('R_swig_BlackVolTermStructure___deref__', self, PACKAGE='QuantLib');
  class(ans) <- "_p_BlackVolTermStructure";
  
  ans
  
}

attr(`BlackVolTermStructure___deref__`, 'returnType') = '_p_BlackVolTermStructure'
attr(`BlackVolTermStructure___deref__`, "inputTypes") = c('_p_boost__shared_ptrT_BlackVolTermStructure_t')
class(`BlackVolTermStructure___deref__`) = c("SWIGFunction", class('BlackVolTermStructure___deref__'))

# Start of BlackVolTermStructure_isNull

`BlackVolTermStructure_isNull` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_BlackVolTermStructure_isNull', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackVolTermStructure_isNull`, 'returnType') = 'logical'
attr(`BlackVolTermStructure_isNull`, "inputTypes") = c('_p_boost__shared_ptrT_BlackVolTermStructure_t')
class(`BlackVolTermStructure_isNull`) = c("SWIGFunction", class('BlackVolTermStructure_isNull'))

# Start of BlackVolTermStructure_asObservable

`BlackVolTermStructure_asObservable` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_BlackVolTermStructure_asObservable', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_Observable_t";
  
  ans
  
}

attr(`BlackVolTermStructure_asObservable`, 'returnType') = '_p_boost__shared_ptrT_Observable_t'
attr(`BlackVolTermStructure_asObservable`, "inputTypes") = c('_p_boost__shared_ptrT_BlackVolTermStructure_t')
class(`BlackVolTermStructure_asObservable`) = c("SWIGFunction", class('BlackVolTermStructure_asObservable'))

# Start of new_BlackVolTermStructure

`BlackVolTermStructure` = function()
{
  ;ans = .Call('R_swig_new_BlackVolTermStructure', PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_BlackVolTermStructure_t";
  
  reg.finalizer(ans, delete_BlackVolTermStructure)
  ans
  
}

attr(`BlackVolTermStructure`, 'returnType') = '_p_boost__shared_ptrT_BlackVolTermStructure_t'
class(`BlackVolTermStructure`) = c("SWIGFunction", class('BlackVolTermStructure'))

# Start of delete_BlackVolTermStructure

`delete_BlackVolTermStructure` = function(self)
{
  ;.Call('R_swig_delete_BlackVolTermStructure', self, PACKAGE='QuantLib');
  
}

attr(`delete_BlackVolTermStructure`, 'returnType') = 'void'
attr(`delete_BlackVolTermStructure`, "inputTypes") = c('_p_boost__shared_ptrT_BlackVolTermStructure_t')
class(`delete_BlackVolTermStructure`) = c("SWIGFunction", class('delete_BlackVolTermStructure'))

# Start of BlackVolTermStructure_referenceDate

`BlackVolTermStructure_referenceDate` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_BlackVolTermStructure_referenceDate', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`BlackVolTermStructure_referenceDate`, 'returnType') = '_p_Date'
attr(`BlackVolTermStructure_referenceDate`, "inputTypes") = c('_p_boost__shared_ptrT_BlackVolTermStructure_t')
class(`BlackVolTermStructure_referenceDate`) = c("SWIGFunction", class('BlackVolTermStructure_referenceDate'))

# Start of BlackVolTermStructure_dayCounter

`BlackVolTermStructure_dayCounter` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_BlackVolTermStructure_dayCounter', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_DayCounter";
  
  ans
  
}

attr(`BlackVolTermStructure_dayCounter`, 'returnType') = '_p_DayCounter'
attr(`BlackVolTermStructure_dayCounter`, "inputTypes") = c('_p_boost__shared_ptrT_BlackVolTermStructure_t')
class(`BlackVolTermStructure_dayCounter`) = c("SWIGFunction", class('BlackVolTermStructure_dayCounter'))

# Start of BlackVolTermStructure_calendar

`BlackVolTermStructure_calendar` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_BlackVolTermStructure_calendar', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Calendar";
  
  ans
  
}

attr(`BlackVolTermStructure_calendar`, 'returnType') = '_p_Calendar'
attr(`BlackVolTermStructure_calendar`, "inputTypes") = c('_p_boost__shared_ptrT_BlackVolTermStructure_t')
class(`BlackVolTermStructure_calendar`) = c("SWIGFunction", class('BlackVolTermStructure_calendar'))

# Start of BlackVolTermStructure_maxDate

`BlackVolTermStructure_maxDate` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_BlackVolTermStructure_maxDate', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`BlackVolTermStructure_maxDate`, 'returnType') = '_p_Date'
attr(`BlackVolTermStructure_maxDate`, "inputTypes") = c('_p_boost__shared_ptrT_BlackVolTermStructure_t')
class(`BlackVolTermStructure_maxDate`) = c("SWIGFunction", class('BlackVolTermStructure_maxDate'))

# Start of BlackVolTermStructure_maxTime

`BlackVolTermStructure_maxTime` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_BlackVolTermStructure_maxTime', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackVolTermStructure_maxTime`, 'returnType') = 'numeric'
attr(`BlackVolTermStructure_maxTime`, "inputTypes") = c('_p_boost__shared_ptrT_BlackVolTermStructure_t')
class(`BlackVolTermStructure_maxTime`) = c("SWIGFunction", class('BlackVolTermStructure_maxTime'))

# Start of BlackVolTermStructure_minStrike

`BlackVolTermStructure_minStrike` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_BlackVolTermStructure_minStrike', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackVolTermStructure_minStrike`, 'returnType') = 'numeric'
attr(`BlackVolTermStructure_minStrike`, "inputTypes") = c('_p_boost__shared_ptrT_BlackVolTermStructure_t')
class(`BlackVolTermStructure_minStrike`) = c("SWIGFunction", class('BlackVolTermStructure_minStrike'))

# Start of BlackVolTermStructure_maxStrike

`BlackVolTermStructure_maxStrike` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_BlackVolTermStructure_maxStrike', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackVolTermStructure_maxStrike`, 'returnType') = 'numeric'
attr(`BlackVolTermStructure_maxStrike`, "inputTypes") = c('_p_boost__shared_ptrT_BlackVolTermStructure_t')
class(`BlackVolTermStructure_maxStrike`) = c("SWIGFunction", class('BlackVolTermStructure_maxStrike'))

# Start of BlackVolTermStructure_blackVol

`BlackVolTermStructure_blackVol__SWIG_0` = function(self, s_arg2, strike, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_BlackVolTermStructure_blackVol__SWIG_0', self, s_arg2, strike, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackVolTermStructure_blackVol__SWIG_0`, 'returnType') = 'numeric'
attr(`BlackVolTermStructure_blackVol__SWIG_0`, "inputTypes") = c('_p_boost__shared_ptrT_BlackVolTermStructure_t', '_p_Date', 'numeric', 'logical')
class(`BlackVolTermStructure_blackVol__SWIG_0`) = c("SWIGFunction", class('BlackVolTermStructure_blackVol__SWIG_0'))

# Start of BlackVolTermStructure_blackVol

`BlackVolTermStructure_blackVol__SWIG_1` = function(self, s_arg2, strike, .copy = FALSE)
{
  ;.Call('R_swig_BlackVolTermStructure_blackVol__SWIG_1', self, s_arg2, strike, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackVolTermStructure_blackVol__SWIG_1`, 'returnType') = 'numeric'
attr(`BlackVolTermStructure_blackVol__SWIG_1`, "inputTypes") = c('_p_boost__shared_ptrT_BlackVolTermStructure_t', '_p_Date', 'numeric')
class(`BlackVolTermStructure_blackVol__SWIG_1`) = c("SWIGFunction", class('BlackVolTermStructure_blackVol__SWIG_1'))

# Start of BlackVolTermStructure_blackVol

`BlackVolTermStructure_blackVol__SWIG_2` = function(self, s_arg2, strike, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_BlackVolTermStructure_blackVol__SWIG_2', self, s_arg2, strike, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackVolTermStructure_blackVol__SWIG_2`, 'returnType') = 'numeric'
attr(`BlackVolTermStructure_blackVol__SWIG_2`, "inputTypes") = c('_p_boost__shared_ptrT_BlackVolTermStructure_t', 'numeric', 'numeric', 'logical')
class(`BlackVolTermStructure_blackVol__SWIG_2`) = c("SWIGFunction", class('BlackVolTermStructure_blackVol__SWIG_2'))

# Start of BlackVolTermStructure_blackVol

`BlackVolTermStructure_blackVol__SWIG_3` = function(self, s_arg2, strike, .copy = FALSE)
{
  ;.Call('R_swig_BlackVolTermStructure_blackVol__SWIG_3', self, s_arg2, strike, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackVolTermStructure_blackVol__SWIG_3`, 'returnType') = 'numeric'
attr(`BlackVolTermStructure_blackVol__SWIG_3`, "inputTypes") = c('_p_boost__shared_ptrT_BlackVolTermStructure_t', 'numeric', 'numeric')
class(`BlackVolTermStructure_blackVol__SWIG_3`) = c("SWIGFunction", class('BlackVolTermStructure_blackVol__SWIG_3'))

`BlackVolTermStructure_blackVol` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 3) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_BlackVolTermStructure_t') && extends(argtypes[2], '_p_Date') && is.numeric(argv[[3]])) {
      f <- BlackVolTermStructure_blackVol__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_boost__shared_ptrT_BlackVolTermStructure_t') && is.numeric(argv[[2]]) && is.numeric(argv[[3]])) {
      f <- BlackVolTermStructure_blackVol__SWIG_3; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_BlackVolTermStructure_t') && extends(argtypes[2], '_p_Date') && is.numeric(argv[[3]]) && extends(argtypes[4], 'logical')) {
      f <- BlackVolTermStructure_blackVol__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_boost__shared_ptrT_BlackVolTermStructure_t') && is.numeric(argv[[2]]) && is.numeric(argv[[3]]) && extends(argtypes[4], 'logical')) {
      f <- BlackVolTermStructure_blackVol__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for BlackVolTermStructure_blackVol with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of BlackVolTermStructure_blackVariance

`BlackVolTermStructure_blackVariance__SWIG_0` = function(self, s_arg2, strike, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_BlackVolTermStructure_blackVariance__SWIG_0', self, s_arg2, strike, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackVolTermStructure_blackVariance__SWIG_0`, 'returnType') = 'numeric'
attr(`BlackVolTermStructure_blackVariance__SWIG_0`, "inputTypes") = c('_p_boost__shared_ptrT_BlackVolTermStructure_t', '_p_Date', 'numeric', 'logical')
class(`BlackVolTermStructure_blackVariance__SWIG_0`) = c("SWIGFunction", class('BlackVolTermStructure_blackVariance__SWIG_0'))

# Start of BlackVolTermStructure_blackVariance

`BlackVolTermStructure_blackVariance__SWIG_1` = function(self, s_arg2, strike, .copy = FALSE)
{
  ;.Call('R_swig_BlackVolTermStructure_blackVariance__SWIG_1', self, s_arg2, strike, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackVolTermStructure_blackVariance__SWIG_1`, 'returnType') = 'numeric'
attr(`BlackVolTermStructure_blackVariance__SWIG_1`, "inputTypes") = c('_p_boost__shared_ptrT_BlackVolTermStructure_t', '_p_Date', 'numeric')
class(`BlackVolTermStructure_blackVariance__SWIG_1`) = c("SWIGFunction", class('BlackVolTermStructure_blackVariance__SWIG_1'))

# Start of BlackVolTermStructure_blackVariance

`BlackVolTermStructure_blackVariance__SWIG_2` = function(self, s_arg2, strike, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_BlackVolTermStructure_blackVariance__SWIG_2', self, s_arg2, strike, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackVolTermStructure_blackVariance__SWIG_2`, 'returnType') = 'numeric'
attr(`BlackVolTermStructure_blackVariance__SWIG_2`, "inputTypes") = c('_p_boost__shared_ptrT_BlackVolTermStructure_t', 'numeric', 'numeric', 'logical')
class(`BlackVolTermStructure_blackVariance__SWIG_2`) = c("SWIGFunction", class('BlackVolTermStructure_blackVariance__SWIG_2'))

# Start of BlackVolTermStructure_blackVariance

`BlackVolTermStructure_blackVariance__SWIG_3` = function(self, s_arg2, strike, .copy = FALSE)
{
  ;.Call('R_swig_BlackVolTermStructure_blackVariance__SWIG_3', self, s_arg2, strike, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackVolTermStructure_blackVariance__SWIG_3`, 'returnType') = 'numeric'
attr(`BlackVolTermStructure_blackVariance__SWIG_3`, "inputTypes") = c('_p_boost__shared_ptrT_BlackVolTermStructure_t', 'numeric', 'numeric')
class(`BlackVolTermStructure_blackVariance__SWIG_3`) = c("SWIGFunction", class('BlackVolTermStructure_blackVariance__SWIG_3'))

`BlackVolTermStructure_blackVariance` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 3) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_BlackVolTermStructure_t') && extends(argtypes[2], '_p_Date') && is.numeric(argv[[3]])) {
      f <- BlackVolTermStructure_blackVariance__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_boost__shared_ptrT_BlackVolTermStructure_t') && is.numeric(argv[[2]]) && is.numeric(argv[[3]])) {
      f <- BlackVolTermStructure_blackVariance__SWIG_3; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_BlackVolTermStructure_t') && extends(argtypes[2], '_p_Date') && is.numeric(argv[[3]]) && extends(argtypes[4], 'logical')) {
      f <- BlackVolTermStructure_blackVariance__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_boost__shared_ptrT_BlackVolTermStructure_t') && is.numeric(argv[[2]]) && is.numeric(argv[[3]]) && extends(argtypes[4], 'logical')) {
      f <- BlackVolTermStructure_blackVariance__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for BlackVolTermStructure_blackVariance with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of BlackVolTermStructure_blackForwardVol

`BlackVolTermStructure_blackForwardVol__SWIG_0` = function(self, s_arg2, s_arg3, strike, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_BlackVolTermStructure_blackForwardVol__SWIG_0', self, s_arg2, s_arg3, strike, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackVolTermStructure_blackForwardVol__SWIG_0`, 'returnType') = 'numeric'
attr(`BlackVolTermStructure_blackForwardVol__SWIG_0`, "inputTypes") = c('_p_boost__shared_ptrT_BlackVolTermStructure_t', '_p_Date', '_p_Date', 'numeric', 'logical')
class(`BlackVolTermStructure_blackForwardVol__SWIG_0`) = c("SWIGFunction", class('BlackVolTermStructure_blackForwardVol__SWIG_0'))

# Start of BlackVolTermStructure_blackForwardVol

`BlackVolTermStructure_blackForwardVol__SWIG_1` = function(self, s_arg2, s_arg3, strike, .copy = FALSE)
{
  ;.Call('R_swig_BlackVolTermStructure_blackForwardVol__SWIG_1', self, s_arg2, s_arg3, strike, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackVolTermStructure_blackForwardVol__SWIG_1`, 'returnType') = 'numeric'
attr(`BlackVolTermStructure_blackForwardVol__SWIG_1`, "inputTypes") = c('_p_boost__shared_ptrT_BlackVolTermStructure_t', '_p_Date', '_p_Date', 'numeric')
class(`BlackVolTermStructure_blackForwardVol__SWIG_1`) = c("SWIGFunction", class('BlackVolTermStructure_blackForwardVol__SWIG_1'))

# Start of BlackVolTermStructure_blackForwardVol

`BlackVolTermStructure_blackForwardVol__SWIG_2` = function(self, s_arg2, s_arg3, strike, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_BlackVolTermStructure_blackForwardVol__SWIG_2', self, s_arg2, s_arg3, strike, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackVolTermStructure_blackForwardVol__SWIG_2`, 'returnType') = 'numeric'
attr(`BlackVolTermStructure_blackForwardVol__SWIG_2`, "inputTypes") = c('_p_boost__shared_ptrT_BlackVolTermStructure_t', 'numeric', 'numeric', 'numeric', 'logical')
class(`BlackVolTermStructure_blackForwardVol__SWIG_2`) = c("SWIGFunction", class('BlackVolTermStructure_blackForwardVol__SWIG_2'))

# Start of BlackVolTermStructure_blackForwardVol

`BlackVolTermStructure_blackForwardVol__SWIG_3` = function(self, s_arg2, s_arg3, strike, .copy = FALSE)
{
  ;.Call('R_swig_BlackVolTermStructure_blackForwardVol__SWIG_3', self, s_arg2, s_arg3, strike, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackVolTermStructure_blackForwardVol__SWIG_3`, 'returnType') = 'numeric'
attr(`BlackVolTermStructure_blackForwardVol__SWIG_3`, "inputTypes") = c('_p_boost__shared_ptrT_BlackVolTermStructure_t', 'numeric', 'numeric', 'numeric')
class(`BlackVolTermStructure_blackForwardVol__SWIG_3`) = c("SWIGFunction", class('BlackVolTermStructure_blackForwardVol__SWIG_3'))

`BlackVolTermStructure_blackForwardVol` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 4) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_BlackVolTermStructure_t') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_Date') && is.numeric(argv[[4]])) {
      f <- BlackVolTermStructure_blackForwardVol__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_boost__shared_ptrT_BlackVolTermStructure_t') && is.numeric(argv[[2]]) && is.numeric(argv[[3]]) && is.numeric(argv[[4]])) {
      f <- BlackVolTermStructure_blackForwardVol__SWIG_3; 
    }
  } else if (argc == 5) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_BlackVolTermStructure_t') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_Date') && is.numeric(argv[[4]]) && extends(argtypes[5], 'logical')) {
      f <- BlackVolTermStructure_blackForwardVol__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_boost__shared_ptrT_BlackVolTermStructure_t') && is.numeric(argv[[2]]) && is.numeric(argv[[3]]) && is.numeric(argv[[4]]) && extends(argtypes[5], 'logical')) {
      f <- BlackVolTermStructure_blackForwardVol__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for BlackVolTermStructure_blackForwardVol with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of BlackVolTermStructure_blackForwardVariance

`BlackVolTermStructure_blackForwardVariance__SWIG_0` = function(self, s_arg2, s_arg3, strike, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_BlackVolTermStructure_blackForwardVariance__SWIG_0', self, s_arg2, s_arg3, strike, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackVolTermStructure_blackForwardVariance__SWIG_0`, 'returnType') = 'numeric'
attr(`BlackVolTermStructure_blackForwardVariance__SWIG_0`, "inputTypes") = c('_p_boost__shared_ptrT_BlackVolTermStructure_t', '_p_Date', '_p_Date', 'numeric', 'logical')
class(`BlackVolTermStructure_blackForwardVariance__SWIG_0`) = c("SWIGFunction", class('BlackVolTermStructure_blackForwardVariance__SWIG_0'))

# Start of BlackVolTermStructure_blackForwardVariance

`BlackVolTermStructure_blackForwardVariance__SWIG_1` = function(self, s_arg2, s_arg3, strike, .copy = FALSE)
{
  ;.Call('R_swig_BlackVolTermStructure_blackForwardVariance__SWIG_1', self, s_arg2, s_arg3, strike, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackVolTermStructure_blackForwardVariance__SWIG_1`, 'returnType') = 'numeric'
attr(`BlackVolTermStructure_blackForwardVariance__SWIG_1`, "inputTypes") = c('_p_boost__shared_ptrT_BlackVolTermStructure_t', '_p_Date', '_p_Date', 'numeric')
class(`BlackVolTermStructure_blackForwardVariance__SWIG_1`) = c("SWIGFunction", class('BlackVolTermStructure_blackForwardVariance__SWIG_1'))

# Start of BlackVolTermStructure_blackForwardVariance

`BlackVolTermStructure_blackForwardVariance__SWIG_2` = function(self, s_arg2, s_arg3, strike, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_BlackVolTermStructure_blackForwardVariance__SWIG_2', self, s_arg2, s_arg3, strike, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackVolTermStructure_blackForwardVariance__SWIG_2`, 'returnType') = 'numeric'
attr(`BlackVolTermStructure_blackForwardVariance__SWIG_2`, "inputTypes") = c('_p_boost__shared_ptrT_BlackVolTermStructure_t', 'numeric', 'numeric', 'numeric', 'logical')
class(`BlackVolTermStructure_blackForwardVariance__SWIG_2`) = c("SWIGFunction", class('BlackVolTermStructure_blackForwardVariance__SWIG_2'))

# Start of BlackVolTermStructure_blackForwardVariance

`BlackVolTermStructure_blackForwardVariance__SWIG_3` = function(self, s_arg2, s_arg3, strike, .copy = FALSE)
{
  ;.Call('R_swig_BlackVolTermStructure_blackForwardVariance__SWIG_3', self, s_arg2, s_arg3, strike, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackVolTermStructure_blackForwardVariance__SWIG_3`, 'returnType') = 'numeric'
attr(`BlackVolTermStructure_blackForwardVariance__SWIG_3`, "inputTypes") = c('_p_boost__shared_ptrT_BlackVolTermStructure_t', 'numeric', 'numeric', 'numeric')
class(`BlackVolTermStructure_blackForwardVariance__SWIG_3`) = c("SWIGFunction", class('BlackVolTermStructure_blackForwardVariance__SWIG_3'))

`BlackVolTermStructure_blackForwardVariance` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 4) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_BlackVolTermStructure_t') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_Date') && is.numeric(argv[[4]])) {
      f <- BlackVolTermStructure_blackForwardVariance__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_boost__shared_ptrT_BlackVolTermStructure_t') && is.numeric(argv[[2]]) && is.numeric(argv[[3]]) && is.numeric(argv[[4]])) {
      f <- BlackVolTermStructure_blackForwardVariance__SWIG_3; 
    }
  } else if (argc == 5) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_BlackVolTermStructure_t') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_Date') && is.numeric(argv[[4]]) && extends(argtypes[5], 'logical')) {
      f <- BlackVolTermStructure_blackForwardVariance__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_boost__shared_ptrT_BlackVolTermStructure_t') && is.numeric(argv[[2]]) && is.numeric(argv[[3]]) && is.numeric(argv[[4]]) && extends(argtypes[5], 'logical')) {
      f <- BlackVolTermStructure_blackForwardVariance__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for BlackVolTermStructure_blackForwardVariance with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of BlackVolTermStructure_enableExtrapolation

`BlackVolTermStructure_enableExtrapolation` = function(self)
{
  ;.Call('R_swig_BlackVolTermStructure_enableExtrapolation', self, PACKAGE='QuantLib');
  
}

attr(`BlackVolTermStructure_enableExtrapolation`, 'returnType') = 'void'
attr(`BlackVolTermStructure_enableExtrapolation`, "inputTypes") = c('_p_boost__shared_ptrT_BlackVolTermStructure_t')
class(`BlackVolTermStructure_enableExtrapolation`) = c("SWIGFunction", class('BlackVolTermStructure_enableExtrapolation'))

# Start of BlackVolTermStructure_disableExtrapolation

`BlackVolTermStructure_disableExtrapolation` = function(self)
{
  ;.Call('R_swig_BlackVolTermStructure_disableExtrapolation', self, PACKAGE='QuantLib');
  
}

attr(`BlackVolTermStructure_disableExtrapolation`, 'returnType') = 'void'
attr(`BlackVolTermStructure_disableExtrapolation`, "inputTypes") = c('_p_boost__shared_ptrT_BlackVolTermStructure_t')
class(`BlackVolTermStructure_disableExtrapolation`) = c("SWIGFunction", class('BlackVolTermStructure_disableExtrapolation'))

# Start of BlackVolTermStructure_allowsExtrapolation

`BlackVolTermStructure_allowsExtrapolation` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_BlackVolTermStructure_allowsExtrapolation', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackVolTermStructure_allowsExtrapolation`, 'returnType') = 'logical'
attr(`BlackVolTermStructure_allowsExtrapolation`, "inputTypes") = c('_p_boost__shared_ptrT_BlackVolTermStructure_t')
class(`BlackVolTermStructure_allowsExtrapolation`) = c("SWIGFunction", class('BlackVolTermStructure_allowsExtrapolation'))

# Start of accessor method for boost::shared_ptr<(BlackVolTermStructure)>
setMethod('$', '_p_boost__shared_ptrT_BlackVolTermStructure_t', function(x, name)

{
  accessorFuns = list('__deref__' = BlackVolTermStructure___deref__, 'isNull' = BlackVolTermStructure_isNull, 'asObservable' = BlackVolTermStructure_asObservable, 'referenceDate' = BlackVolTermStructure_referenceDate, 'dayCounter' = BlackVolTermStructure_dayCounter, 'calendar' = BlackVolTermStructure_calendar, 'maxDate' = BlackVolTermStructure_maxDate, 'maxTime' = BlackVolTermStructure_maxTime, 'minStrike' = BlackVolTermStructure_minStrike, 'maxStrike' = BlackVolTermStructure_maxStrike, 'blackVol' = BlackVolTermStructure_blackVol, 'blackVariance' = BlackVolTermStructure_blackVariance, 'blackForwardVol' = BlackVolTermStructure_blackForwardVol, 'blackForwardVariance' = BlackVolTermStructure_blackForwardVariance, 'enableExtrapolation' = BlackVolTermStructure_enableExtrapolation, 'disableExtrapolation' = BlackVolTermStructure_disableExtrapolation, 'allowsExtrapolation' = BlackVolTermStructure_allowsExtrapolation);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for boost::shared_ptr<(BlackVolTermStructure)>
setMethod('delete', '_p_boost__shared_ptrT_BlackVolTermStructure_t', function(obj) {delete_boost__shared_ptrT_BlackVolTermStructure_t(obj)})
# Start of new_BlackVolTermStructureHandle

`BlackVolTermStructureHandle__SWIG_0` = function(s_arg1)
{
  ;ans = .Call('R_swig_new_BlackVolTermStructureHandle__SWIG_0', s_arg1, PACKAGE='QuantLib');
  class(ans) <- "_p_HandleT_BlackVolTermStructure_t";
  
  reg.finalizer(ans, delete_BlackVolTermStructureHandle)
  ans
  
}

attr(`BlackVolTermStructureHandle__SWIG_0`, 'returnType') = '_p_HandleT_BlackVolTermStructure_t'
attr(`BlackVolTermStructureHandle__SWIG_0`, "inputTypes") = c('_p_boost__shared_ptrT_BlackVolTermStructure_t')
class(`BlackVolTermStructureHandle__SWIG_0`) = c("SWIGFunction", class('BlackVolTermStructureHandle__SWIG_0'))

# Start of new_BlackVolTermStructureHandle

`BlackVolTermStructureHandle__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_BlackVolTermStructureHandle__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_HandleT_BlackVolTermStructure_t";
  
  reg.finalizer(ans, delete_BlackVolTermStructureHandle)
  ans
  
}

attr(`BlackVolTermStructureHandle__SWIG_1`, 'returnType') = '_p_HandleT_BlackVolTermStructure_t'
class(`BlackVolTermStructureHandle__SWIG_1`) = c("SWIGFunction", class('BlackVolTermStructureHandle__SWIG_1'))

`BlackVolTermStructureHandle` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- BlackVolTermStructureHandle__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_BlackVolTermStructure_t')) {
      f <- BlackVolTermStructureHandle__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for BlackVolTermStructureHandle with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of BlackVolTermStructureHandle___deref__

`BlackVolTermStructureHandle___deref__` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_BlackVolTermStructureHandle___deref__', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_BlackVolTermStructure_t";
  
  ans
  
}

attr(`BlackVolTermStructureHandle___deref__`, 'returnType') = '_p_boost__shared_ptrT_BlackVolTermStructure_t'
attr(`BlackVolTermStructureHandle___deref__`, "inputTypes") = c('_p_HandleT_BlackVolTermStructure_t')
class(`BlackVolTermStructureHandle___deref__`) = c("SWIGFunction", class('BlackVolTermStructureHandle___deref__'))

# Start of BlackVolTermStructureHandle_empty

`BlackVolTermStructureHandle_empty` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_BlackVolTermStructureHandle_empty', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackVolTermStructureHandle_empty`, 'returnType') = 'logical'
attr(`BlackVolTermStructureHandle_empty`, "inputTypes") = c('_p_HandleT_BlackVolTermStructure_t')
class(`BlackVolTermStructureHandle_empty`) = c("SWIGFunction", class('BlackVolTermStructureHandle_empty'))

# Start of BlackVolTermStructureHandle_asObservable

`BlackVolTermStructureHandle_asObservable` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_BlackVolTermStructureHandle_asObservable', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_Observable_t";
  
  ans
  
}

attr(`BlackVolTermStructureHandle_asObservable`, 'returnType') = '_p_boost__shared_ptrT_Observable_t'
attr(`BlackVolTermStructureHandle_asObservable`, "inputTypes") = c('_p_HandleT_BlackVolTermStructure_t')
class(`BlackVolTermStructureHandle_asObservable`) = c("SWIGFunction", class('BlackVolTermStructureHandle_asObservable'))

# Start of delete_BlackVolTermStructureHandle

`delete_BlackVolTermStructureHandle` = function(self)
{
  ;.Call('R_swig_delete_BlackVolTermStructureHandle', self, PACKAGE='QuantLib');
  
}

attr(`delete_BlackVolTermStructureHandle`, 'returnType') = 'void'
attr(`delete_BlackVolTermStructureHandle`, "inputTypes") = c('_p_HandleT_BlackVolTermStructure_t')
class(`delete_BlackVolTermStructureHandle`) = c("SWIGFunction", class('delete_BlackVolTermStructureHandle'))

# Start of BlackVolTermStructureHandle_referenceDate

`BlackVolTermStructureHandle_referenceDate` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_BlackVolTermStructureHandle_referenceDate', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`BlackVolTermStructureHandle_referenceDate`, 'returnType') = '_p_Date'
attr(`BlackVolTermStructureHandle_referenceDate`, "inputTypes") = c('_p_HandleT_BlackVolTermStructure_t')
class(`BlackVolTermStructureHandle_referenceDate`) = c("SWIGFunction", class('BlackVolTermStructureHandle_referenceDate'))

# Start of BlackVolTermStructureHandle_dayCounter

`BlackVolTermStructureHandle_dayCounter` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_BlackVolTermStructureHandle_dayCounter', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_DayCounter";
  
  ans
  
}

attr(`BlackVolTermStructureHandle_dayCounter`, 'returnType') = '_p_DayCounter'
attr(`BlackVolTermStructureHandle_dayCounter`, "inputTypes") = c('_p_HandleT_BlackVolTermStructure_t')
class(`BlackVolTermStructureHandle_dayCounter`) = c("SWIGFunction", class('BlackVolTermStructureHandle_dayCounter'))

# Start of BlackVolTermStructureHandle_calendar

`BlackVolTermStructureHandle_calendar` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_BlackVolTermStructureHandle_calendar', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Calendar";
  
  ans
  
}

attr(`BlackVolTermStructureHandle_calendar`, 'returnType') = '_p_Calendar'
attr(`BlackVolTermStructureHandle_calendar`, "inputTypes") = c('_p_HandleT_BlackVolTermStructure_t')
class(`BlackVolTermStructureHandle_calendar`) = c("SWIGFunction", class('BlackVolTermStructureHandle_calendar'))

# Start of BlackVolTermStructureHandle_maxDate

`BlackVolTermStructureHandle_maxDate` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_BlackVolTermStructureHandle_maxDate', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`BlackVolTermStructureHandle_maxDate`, 'returnType') = '_p_Date'
attr(`BlackVolTermStructureHandle_maxDate`, "inputTypes") = c('_p_HandleT_BlackVolTermStructure_t')
class(`BlackVolTermStructureHandle_maxDate`) = c("SWIGFunction", class('BlackVolTermStructureHandle_maxDate'))

# Start of BlackVolTermStructureHandle_maxTime

`BlackVolTermStructureHandle_maxTime` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_BlackVolTermStructureHandle_maxTime', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackVolTermStructureHandle_maxTime`, 'returnType') = 'numeric'
attr(`BlackVolTermStructureHandle_maxTime`, "inputTypes") = c('_p_HandleT_BlackVolTermStructure_t')
class(`BlackVolTermStructureHandle_maxTime`) = c("SWIGFunction", class('BlackVolTermStructureHandle_maxTime'))

# Start of BlackVolTermStructureHandle_minStrike

`BlackVolTermStructureHandle_minStrike` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_BlackVolTermStructureHandle_minStrike', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackVolTermStructureHandle_minStrike`, 'returnType') = 'numeric'
attr(`BlackVolTermStructureHandle_minStrike`, "inputTypes") = c('_p_HandleT_BlackVolTermStructure_t')
class(`BlackVolTermStructureHandle_minStrike`) = c("SWIGFunction", class('BlackVolTermStructureHandle_minStrike'))

# Start of BlackVolTermStructureHandle_maxStrike

`BlackVolTermStructureHandle_maxStrike` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_BlackVolTermStructureHandle_maxStrike', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackVolTermStructureHandle_maxStrike`, 'returnType') = 'numeric'
attr(`BlackVolTermStructureHandle_maxStrike`, "inputTypes") = c('_p_HandleT_BlackVolTermStructure_t')
class(`BlackVolTermStructureHandle_maxStrike`) = c("SWIGFunction", class('BlackVolTermStructureHandle_maxStrike'))

# Start of BlackVolTermStructureHandle_blackVol

`BlackVolTermStructureHandle_blackVol__SWIG_0` = function(self, s_arg2, strike, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_BlackVolTermStructureHandle_blackVol__SWIG_0', self, s_arg2, strike, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackVolTermStructureHandle_blackVol__SWIG_0`, 'returnType') = 'numeric'
attr(`BlackVolTermStructureHandle_blackVol__SWIG_0`, "inputTypes") = c('_p_HandleT_BlackVolTermStructure_t', '_p_Date', 'numeric', 'logical')
class(`BlackVolTermStructureHandle_blackVol__SWIG_0`) = c("SWIGFunction", class('BlackVolTermStructureHandle_blackVol__SWIG_0'))

# Start of BlackVolTermStructureHandle_blackVol

`BlackVolTermStructureHandle_blackVol__SWIG_1` = function(self, s_arg2, strike, .copy = FALSE)
{
  ;.Call('R_swig_BlackVolTermStructureHandle_blackVol__SWIG_1', self, s_arg2, strike, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackVolTermStructureHandle_blackVol__SWIG_1`, 'returnType') = 'numeric'
attr(`BlackVolTermStructureHandle_blackVol__SWIG_1`, "inputTypes") = c('_p_HandleT_BlackVolTermStructure_t', '_p_Date', 'numeric')
class(`BlackVolTermStructureHandle_blackVol__SWIG_1`) = c("SWIGFunction", class('BlackVolTermStructureHandle_blackVol__SWIG_1'))

# Start of BlackVolTermStructureHandle_blackVol

`BlackVolTermStructureHandle_blackVol__SWIG_2` = function(self, s_arg2, strike, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_BlackVolTermStructureHandle_blackVol__SWIG_2', self, s_arg2, strike, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackVolTermStructureHandle_blackVol__SWIG_2`, 'returnType') = 'numeric'
attr(`BlackVolTermStructureHandle_blackVol__SWIG_2`, "inputTypes") = c('_p_HandleT_BlackVolTermStructure_t', 'numeric', 'numeric', 'logical')
class(`BlackVolTermStructureHandle_blackVol__SWIG_2`) = c("SWIGFunction", class('BlackVolTermStructureHandle_blackVol__SWIG_2'))

# Start of BlackVolTermStructureHandle_blackVol

`BlackVolTermStructureHandle_blackVol__SWIG_3` = function(self, s_arg2, strike, .copy = FALSE)
{
  ;.Call('R_swig_BlackVolTermStructureHandle_blackVol__SWIG_3', self, s_arg2, strike, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackVolTermStructureHandle_blackVol__SWIG_3`, 'returnType') = 'numeric'
attr(`BlackVolTermStructureHandle_blackVol__SWIG_3`, "inputTypes") = c('_p_HandleT_BlackVolTermStructure_t', 'numeric', 'numeric')
class(`BlackVolTermStructureHandle_blackVol__SWIG_3`) = c("SWIGFunction", class('BlackVolTermStructureHandle_blackVol__SWIG_3'))

`BlackVolTermStructureHandle_blackVol` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 3) {
    if (extends(argtypes[1], '_p_HandleT_BlackVolTermStructure_t') && extends(argtypes[2], '_p_Date') && is.numeric(argv[[3]])) {
      f <- BlackVolTermStructureHandle_blackVol__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_HandleT_BlackVolTermStructure_t') && is.numeric(argv[[2]]) && is.numeric(argv[[3]])) {
      f <- BlackVolTermStructureHandle_blackVol__SWIG_3; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_HandleT_BlackVolTermStructure_t') && extends(argtypes[2], '_p_Date') && is.numeric(argv[[3]]) && extends(argtypes[4], 'logical')) {
      f <- BlackVolTermStructureHandle_blackVol__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_HandleT_BlackVolTermStructure_t') && is.numeric(argv[[2]]) && is.numeric(argv[[3]]) && extends(argtypes[4], 'logical')) {
      f <- BlackVolTermStructureHandle_blackVol__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for BlackVolTermStructureHandle_blackVol with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of BlackVolTermStructureHandle_blackVariance

`BlackVolTermStructureHandle_blackVariance__SWIG_0` = function(self, s_arg2, strike, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_BlackVolTermStructureHandle_blackVariance__SWIG_0', self, s_arg2, strike, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackVolTermStructureHandle_blackVariance__SWIG_0`, 'returnType') = 'numeric'
attr(`BlackVolTermStructureHandle_blackVariance__SWIG_0`, "inputTypes") = c('_p_HandleT_BlackVolTermStructure_t', '_p_Date', 'numeric', 'logical')
class(`BlackVolTermStructureHandle_blackVariance__SWIG_0`) = c("SWIGFunction", class('BlackVolTermStructureHandle_blackVariance__SWIG_0'))

# Start of BlackVolTermStructureHandle_blackVariance

`BlackVolTermStructureHandle_blackVariance__SWIG_1` = function(self, s_arg2, strike, .copy = FALSE)
{
  ;.Call('R_swig_BlackVolTermStructureHandle_blackVariance__SWIG_1', self, s_arg2, strike, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackVolTermStructureHandle_blackVariance__SWIG_1`, 'returnType') = 'numeric'
attr(`BlackVolTermStructureHandle_blackVariance__SWIG_1`, "inputTypes") = c('_p_HandleT_BlackVolTermStructure_t', '_p_Date', 'numeric')
class(`BlackVolTermStructureHandle_blackVariance__SWIG_1`) = c("SWIGFunction", class('BlackVolTermStructureHandle_blackVariance__SWIG_1'))

# Start of BlackVolTermStructureHandle_blackVariance

`BlackVolTermStructureHandle_blackVariance__SWIG_2` = function(self, s_arg2, strike, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_BlackVolTermStructureHandle_blackVariance__SWIG_2', self, s_arg2, strike, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackVolTermStructureHandle_blackVariance__SWIG_2`, 'returnType') = 'numeric'
attr(`BlackVolTermStructureHandle_blackVariance__SWIG_2`, "inputTypes") = c('_p_HandleT_BlackVolTermStructure_t', 'numeric', 'numeric', 'logical')
class(`BlackVolTermStructureHandle_blackVariance__SWIG_2`) = c("SWIGFunction", class('BlackVolTermStructureHandle_blackVariance__SWIG_2'))

# Start of BlackVolTermStructureHandle_blackVariance

`BlackVolTermStructureHandle_blackVariance__SWIG_3` = function(self, s_arg2, strike, .copy = FALSE)
{
  ;.Call('R_swig_BlackVolTermStructureHandle_blackVariance__SWIG_3', self, s_arg2, strike, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackVolTermStructureHandle_blackVariance__SWIG_3`, 'returnType') = 'numeric'
attr(`BlackVolTermStructureHandle_blackVariance__SWIG_3`, "inputTypes") = c('_p_HandleT_BlackVolTermStructure_t', 'numeric', 'numeric')
class(`BlackVolTermStructureHandle_blackVariance__SWIG_3`) = c("SWIGFunction", class('BlackVolTermStructureHandle_blackVariance__SWIG_3'))

`BlackVolTermStructureHandle_blackVariance` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 3) {
    if (extends(argtypes[1], '_p_HandleT_BlackVolTermStructure_t') && extends(argtypes[2], '_p_Date') && is.numeric(argv[[3]])) {
      f <- BlackVolTermStructureHandle_blackVariance__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_HandleT_BlackVolTermStructure_t') && is.numeric(argv[[2]]) && is.numeric(argv[[3]])) {
      f <- BlackVolTermStructureHandle_blackVariance__SWIG_3; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_HandleT_BlackVolTermStructure_t') && extends(argtypes[2], '_p_Date') && is.numeric(argv[[3]]) && extends(argtypes[4], 'logical')) {
      f <- BlackVolTermStructureHandle_blackVariance__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_HandleT_BlackVolTermStructure_t') && is.numeric(argv[[2]]) && is.numeric(argv[[3]]) && extends(argtypes[4], 'logical')) {
      f <- BlackVolTermStructureHandle_blackVariance__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for BlackVolTermStructureHandle_blackVariance with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of BlackVolTermStructureHandle_blackForwardVol

`BlackVolTermStructureHandle_blackForwardVol__SWIG_0` = function(self, s_arg2, s_arg3, strike, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_BlackVolTermStructureHandle_blackForwardVol__SWIG_0', self, s_arg2, s_arg3, strike, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackVolTermStructureHandle_blackForwardVol__SWIG_0`, 'returnType') = 'numeric'
attr(`BlackVolTermStructureHandle_blackForwardVol__SWIG_0`, "inputTypes") = c('_p_HandleT_BlackVolTermStructure_t', '_p_Date', '_p_Date', 'numeric', 'logical')
class(`BlackVolTermStructureHandle_blackForwardVol__SWIG_0`) = c("SWIGFunction", class('BlackVolTermStructureHandle_blackForwardVol__SWIG_0'))

# Start of BlackVolTermStructureHandle_blackForwardVol

`BlackVolTermStructureHandle_blackForwardVol__SWIG_1` = function(self, s_arg2, s_arg3, strike, .copy = FALSE)
{
  ;.Call('R_swig_BlackVolTermStructureHandle_blackForwardVol__SWIG_1', self, s_arg2, s_arg3, strike, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackVolTermStructureHandle_blackForwardVol__SWIG_1`, 'returnType') = 'numeric'
attr(`BlackVolTermStructureHandle_blackForwardVol__SWIG_1`, "inputTypes") = c('_p_HandleT_BlackVolTermStructure_t', '_p_Date', '_p_Date', 'numeric')
class(`BlackVolTermStructureHandle_blackForwardVol__SWIG_1`) = c("SWIGFunction", class('BlackVolTermStructureHandle_blackForwardVol__SWIG_1'))

# Start of BlackVolTermStructureHandle_blackForwardVol

`BlackVolTermStructureHandle_blackForwardVol__SWIG_2` = function(self, s_arg2, s_arg3, strike, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_BlackVolTermStructureHandle_blackForwardVol__SWIG_2', self, s_arg2, s_arg3, strike, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackVolTermStructureHandle_blackForwardVol__SWIG_2`, 'returnType') = 'numeric'
attr(`BlackVolTermStructureHandle_blackForwardVol__SWIG_2`, "inputTypes") = c('_p_HandleT_BlackVolTermStructure_t', 'numeric', 'numeric', 'numeric', 'logical')
class(`BlackVolTermStructureHandle_blackForwardVol__SWIG_2`) = c("SWIGFunction", class('BlackVolTermStructureHandle_blackForwardVol__SWIG_2'))

# Start of BlackVolTermStructureHandle_blackForwardVol

`BlackVolTermStructureHandle_blackForwardVol__SWIG_3` = function(self, s_arg2, s_arg3, strike, .copy = FALSE)
{
  ;.Call('R_swig_BlackVolTermStructureHandle_blackForwardVol__SWIG_3', self, s_arg2, s_arg3, strike, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackVolTermStructureHandle_blackForwardVol__SWIG_3`, 'returnType') = 'numeric'
attr(`BlackVolTermStructureHandle_blackForwardVol__SWIG_3`, "inputTypes") = c('_p_HandleT_BlackVolTermStructure_t', 'numeric', 'numeric', 'numeric')
class(`BlackVolTermStructureHandle_blackForwardVol__SWIG_3`) = c("SWIGFunction", class('BlackVolTermStructureHandle_blackForwardVol__SWIG_3'))

`BlackVolTermStructureHandle_blackForwardVol` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 4) {
    if (extends(argtypes[1], '_p_HandleT_BlackVolTermStructure_t') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_Date') && is.numeric(argv[[4]])) {
      f <- BlackVolTermStructureHandle_blackForwardVol__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_HandleT_BlackVolTermStructure_t') && is.numeric(argv[[2]]) && is.numeric(argv[[3]]) && is.numeric(argv[[4]])) {
      f <- BlackVolTermStructureHandle_blackForwardVol__SWIG_3; 
    }
  } else if (argc == 5) {
    if (extends(argtypes[1], '_p_HandleT_BlackVolTermStructure_t') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_Date') && is.numeric(argv[[4]]) && extends(argtypes[5], 'logical')) {
      f <- BlackVolTermStructureHandle_blackForwardVol__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_HandleT_BlackVolTermStructure_t') && is.numeric(argv[[2]]) && is.numeric(argv[[3]]) && is.numeric(argv[[4]]) && extends(argtypes[5], 'logical')) {
      f <- BlackVolTermStructureHandle_blackForwardVol__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for BlackVolTermStructureHandle_blackForwardVol with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of BlackVolTermStructureHandle_blackForwardVariance

`BlackVolTermStructureHandle_blackForwardVariance__SWIG_0` = function(self, s_arg2, s_arg3, strike, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_BlackVolTermStructureHandle_blackForwardVariance__SWIG_0', self, s_arg2, s_arg3, strike, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackVolTermStructureHandle_blackForwardVariance__SWIG_0`, 'returnType') = 'numeric'
attr(`BlackVolTermStructureHandle_blackForwardVariance__SWIG_0`, "inputTypes") = c('_p_HandleT_BlackVolTermStructure_t', '_p_Date', '_p_Date', 'numeric', 'logical')
class(`BlackVolTermStructureHandle_blackForwardVariance__SWIG_0`) = c("SWIGFunction", class('BlackVolTermStructureHandle_blackForwardVariance__SWIG_0'))

# Start of BlackVolTermStructureHandle_blackForwardVariance

`BlackVolTermStructureHandle_blackForwardVariance__SWIG_1` = function(self, s_arg2, s_arg3, strike, .copy = FALSE)
{
  ;.Call('R_swig_BlackVolTermStructureHandle_blackForwardVariance__SWIG_1', self, s_arg2, s_arg3, strike, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackVolTermStructureHandle_blackForwardVariance__SWIG_1`, 'returnType') = 'numeric'
attr(`BlackVolTermStructureHandle_blackForwardVariance__SWIG_1`, "inputTypes") = c('_p_HandleT_BlackVolTermStructure_t', '_p_Date', '_p_Date', 'numeric')
class(`BlackVolTermStructureHandle_blackForwardVariance__SWIG_1`) = c("SWIGFunction", class('BlackVolTermStructureHandle_blackForwardVariance__SWIG_1'))

# Start of BlackVolTermStructureHandle_blackForwardVariance

`BlackVolTermStructureHandle_blackForwardVariance__SWIG_2` = function(self, s_arg2, s_arg3, strike, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_BlackVolTermStructureHandle_blackForwardVariance__SWIG_2', self, s_arg2, s_arg3, strike, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackVolTermStructureHandle_blackForwardVariance__SWIG_2`, 'returnType') = 'numeric'
attr(`BlackVolTermStructureHandle_blackForwardVariance__SWIG_2`, "inputTypes") = c('_p_HandleT_BlackVolTermStructure_t', 'numeric', 'numeric', 'numeric', 'logical')
class(`BlackVolTermStructureHandle_blackForwardVariance__SWIG_2`) = c("SWIGFunction", class('BlackVolTermStructureHandle_blackForwardVariance__SWIG_2'))

# Start of BlackVolTermStructureHandle_blackForwardVariance

`BlackVolTermStructureHandle_blackForwardVariance__SWIG_3` = function(self, s_arg2, s_arg3, strike, .copy = FALSE)
{
  ;.Call('R_swig_BlackVolTermStructureHandle_blackForwardVariance__SWIG_3', self, s_arg2, s_arg3, strike, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackVolTermStructureHandle_blackForwardVariance__SWIG_3`, 'returnType') = 'numeric'
attr(`BlackVolTermStructureHandle_blackForwardVariance__SWIG_3`, "inputTypes") = c('_p_HandleT_BlackVolTermStructure_t', 'numeric', 'numeric', 'numeric')
class(`BlackVolTermStructureHandle_blackForwardVariance__SWIG_3`) = c("SWIGFunction", class('BlackVolTermStructureHandle_blackForwardVariance__SWIG_3'))

`BlackVolTermStructureHandle_blackForwardVariance` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 4) {
    if (extends(argtypes[1], '_p_HandleT_BlackVolTermStructure_t') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_Date') && is.numeric(argv[[4]])) {
      f <- BlackVolTermStructureHandle_blackForwardVariance__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_HandleT_BlackVolTermStructure_t') && is.numeric(argv[[2]]) && is.numeric(argv[[3]]) && is.numeric(argv[[4]])) {
      f <- BlackVolTermStructureHandle_blackForwardVariance__SWIG_3; 
    }
  } else if (argc == 5) {
    if (extends(argtypes[1], '_p_HandleT_BlackVolTermStructure_t') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_Date') && is.numeric(argv[[4]]) && extends(argtypes[5], 'logical')) {
      f <- BlackVolTermStructureHandle_blackForwardVariance__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_HandleT_BlackVolTermStructure_t') && is.numeric(argv[[2]]) && is.numeric(argv[[3]]) && is.numeric(argv[[4]]) && extends(argtypes[5], 'logical')) {
      f <- BlackVolTermStructureHandle_blackForwardVariance__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for BlackVolTermStructureHandle_blackForwardVariance with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of BlackVolTermStructureHandle_enableExtrapolation

`BlackVolTermStructureHandle_enableExtrapolation` = function(self)
{
  ;.Call('R_swig_BlackVolTermStructureHandle_enableExtrapolation', self, PACKAGE='QuantLib');
  
}

attr(`BlackVolTermStructureHandle_enableExtrapolation`, 'returnType') = 'void'
attr(`BlackVolTermStructureHandle_enableExtrapolation`, "inputTypes") = c('_p_HandleT_BlackVolTermStructure_t')
class(`BlackVolTermStructureHandle_enableExtrapolation`) = c("SWIGFunction", class('BlackVolTermStructureHandle_enableExtrapolation'))

# Start of BlackVolTermStructureHandle_disableExtrapolation

`BlackVolTermStructureHandle_disableExtrapolation` = function(self)
{
  ;.Call('R_swig_BlackVolTermStructureHandle_disableExtrapolation', self, PACKAGE='QuantLib');
  
}

attr(`BlackVolTermStructureHandle_disableExtrapolation`, 'returnType') = 'void'
attr(`BlackVolTermStructureHandle_disableExtrapolation`, "inputTypes") = c('_p_HandleT_BlackVolTermStructure_t')
class(`BlackVolTermStructureHandle_disableExtrapolation`) = c("SWIGFunction", class('BlackVolTermStructureHandle_disableExtrapolation'))

# Start of BlackVolTermStructureHandle_allowsExtrapolation

`BlackVolTermStructureHandle_allowsExtrapolation` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_BlackVolTermStructureHandle_allowsExtrapolation', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackVolTermStructureHandle_allowsExtrapolation`, 'returnType') = 'logical'
attr(`BlackVolTermStructureHandle_allowsExtrapolation`, "inputTypes") = c('_p_HandleT_BlackVolTermStructure_t')
class(`BlackVolTermStructureHandle_allowsExtrapolation`) = c("SWIGFunction", class('BlackVolTermStructureHandle_allowsExtrapolation'))

# Start of accessor method for Handle<(BlackVolTermStructure)>
setMethod('$', '_p_HandleT_BlackVolTermStructure_t', function(x, name)

{
  accessorFuns = list('__deref__' = BlackVolTermStructureHandle___deref__, 'empty' = BlackVolTermStructureHandle_empty, 'asObservable' = BlackVolTermStructureHandle_asObservable, 'referenceDate' = BlackVolTermStructureHandle_referenceDate, 'dayCounter' = BlackVolTermStructureHandle_dayCounter, 'calendar' = BlackVolTermStructureHandle_calendar, 'maxDate' = BlackVolTermStructureHandle_maxDate, 'maxTime' = BlackVolTermStructureHandle_maxTime, 'minStrike' = BlackVolTermStructureHandle_minStrike, 'maxStrike' = BlackVolTermStructureHandle_maxStrike, 'blackVol' = BlackVolTermStructureHandle_blackVol, 'blackVariance' = BlackVolTermStructureHandle_blackVariance, 'blackForwardVol' = BlackVolTermStructureHandle_blackForwardVol, 'blackForwardVariance' = BlackVolTermStructureHandle_blackForwardVariance, 'enableExtrapolation' = BlackVolTermStructureHandle_enableExtrapolation, 'disableExtrapolation' = BlackVolTermStructureHandle_disableExtrapolation, 'allowsExtrapolation' = BlackVolTermStructureHandle_allowsExtrapolation);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for Handle<(BlackVolTermStructure)>
setMethod('delete', '_p_HandleT_BlackVolTermStructure_t', function(obj) {delete_HandleT_BlackVolTermStructure_t(obj)})
# Start of new_RelinkableBlackVolTermStructureHandle

`RelinkableBlackVolTermStructureHandle__SWIG_0` = function(s_arg1)
{
  ;ans = .Call('R_swig_new_RelinkableBlackVolTermStructureHandle__SWIG_0', s_arg1, PACKAGE='QuantLib');
  class(ans) <- "_p_RelinkableHandleT_BlackVolTermStructure_t";
  
  reg.finalizer(ans, delete_RelinkableBlackVolTermStructureHandle)
  ans
  
}

attr(`RelinkableBlackVolTermStructureHandle__SWIG_0`, 'returnType') = '_p_RelinkableHandleT_BlackVolTermStructure_t'
attr(`RelinkableBlackVolTermStructureHandle__SWIG_0`, "inputTypes") = c('_p_boost__shared_ptrT_BlackVolTermStructure_t')
class(`RelinkableBlackVolTermStructureHandle__SWIG_0`) = c("SWIGFunction", class('RelinkableBlackVolTermStructureHandle__SWIG_0'))

# Start of new_RelinkableBlackVolTermStructureHandle

`RelinkableBlackVolTermStructureHandle__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_RelinkableBlackVolTermStructureHandle__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_RelinkableHandleT_BlackVolTermStructure_t";
  
  reg.finalizer(ans, delete_RelinkableBlackVolTermStructureHandle)
  ans
  
}

attr(`RelinkableBlackVolTermStructureHandle__SWIG_1`, 'returnType') = '_p_RelinkableHandleT_BlackVolTermStructure_t'
class(`RelinkableBlackVolTermStructureHandle__SWIG_1`) = c("SWIGFunction", class('RelinkableBlackVolTermStructureHandle__SWIG_1'))

`RelinkableBlackVolTermStructureHandle` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- RelinkableBlackVolTermStructureHandle__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_BlackVolTermStructure_t')) {
      f <- RelinkableBlackVolTermStructureHandle__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for RelinkableBlackVolTermStructureHandle with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of RelinkableBlackVolTermStructureHandle_linkTo

`RelinkableBlackVolTermStructureHandle_linkTo` = function(self, s_arg2)
{
  ;.Call('R_swig_RelinkableBlackVolTermStructureHandle_linkTo', self, s_arg2, PACKAGE='QuantLib');
  
}

attr(`RelinkableBlackVolTermStructureHandle_linkTo`, 'returnType') = 'void'
attr(`RelinkableBlackVolTermStructureHandle_linkTo`, "inputTypes") = c('_p_RelinkableHandleT_BlackVolTermStructure_t', '_p_boost__shared_ptrT_BlackVolTermStructure_t')
class(`RelinkableBlackVolTermStructureHandle_linkTo`) = c("SWIGFunction", class('RelinkableBlackVolTermStructureHandle_linkTo'))

# Start of delete_RelinkableBlackVolTermStructureHandle

`delete_RelinkableBlackVolTermStructureHandle` = function(self)
{
  ;.Call('R_swig_delete_RelinkableBlackVolTermStructureHandle', self, PACKAGE='QuantLib');
  
}

attr(`delete_RelinkableBlackVolTermStructureHandle`, 'returnType') = 'void'
attr(`delete_RelinkableBlackVolTermStructureHandle`, "inputTypes") = c('_p_RelinkableHandleT_BlackVolTermStructure_t')
class(`delete_RelinkableBlackVolTermStructureHandle`) = c("SWIGFunction", class('delete_RelinkableBlackVolTermStructureHandle'))

# Start of accessor method for RelinkableHandle<(BlackVolTermStructure)>
setMethod('$', '_p_RelinkableHandleT_BlackVolTermStructure_t', function(x, name)

{
  accessorFuns = list('linkTo' = RelinkableBlackVolTermStructureHandle_linkTo);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for RelinkableHandle<(BlackVolTermStructure)>
setMethod('delete', '_p_RelinkableHandleT_BlackVolTermStructure_t', function(obj) {delete_RelinkableHandleT_BlackVolTermStructure_t(obj)})
# Start of LocalVolTermStructure___deref__

`LocalVolTermStructure___deref__` = function(self)
{
  ;ans = .Call('R_swig_LocalVolTermStructure___deref__', self, PACKAGE='QuantLib');
  class(ans) <- "_p_LocalVolTermStructure";
  
  ans
  
}

attr(`LocalVolTermStructure___deref__`, 'returnType') = '_p_LocalVolTermStructure'
attr(`LocalVolTermStructure___deref__`, "inputTypes") = c('_p_boost__shared_ptrT_LocalVolTermStructure_t')
class(`LocalVolTermStructure___deref__`) = c("SWIGFunction", class('LocalVolTermStructure___deref__'))

# Start of LocalVolTermStructure_isNull

`LocalVolTermStructure_isNull` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_LocalVolTermStructure_isNull', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`LocalVolTermStructure_isNull`, 'returnType') = 'logical'
attr(`LocalVolTermStructure_isNull`, "inputTypes") = c('_p_boost__shared_ptrT_LocalVolTermStructure_t')
class(`LocalVolTermStructure_isNull`) = c("SWIGFunction", class('LocalVolTermStructure_isNull'))

# Start of LocalVolTermStructure_asObservable

`LocalVolTermStructure_asObservable` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_LocalVolTermStructure_asObservable', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_Observable_t";
  
  ans
  
}

attr(`LocalVolTermStructure_asObservable`, 'returnType') = '_p_boost__shared_ptrT_Observable_t'
attr(`LocalVolTermStructure_asObservable`, "inputTypes") = c('_p_boost__shared_ptrT_LocalVolTermStructure_t')
class(`LocalVolTermStructure_asObservable`) = c("SWIGFunction", class('LocalVolTermStructure_asObservable'))

# Start of new_LocalVolTermStructure

`LocalVolTermStructure` = function()
{
  ;ans = .Call('R_swig_new_LocalVolTermStructure', PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_LocalVolTermStructure_t";
  
  reg.finalizer(ans, delete_LocalVolTermStructure)
  ans
  
}

attr(`LocalVolTermStructure`, 'returnType') = '_p_boost__shared_ptrT_LocalVolTermStructure_t'
class(`LocalVolTermStructure`) = c("SWIGFunction", class('LocalVolTermStructure'))

# Start of delete_LocalVolTermStructure

`delete_LocalVolTermStructure` = function(self)
{
  ;.Call('R_swig_delete_LocalVolTermStructure', self, PACKAGE='QuantLib');
  
}

attr(`delete_LocalVolTermStructure`, 'returnType') = 'void'
attr(`delete_LocalVolTermStructure`, "inputTypes") = c('_p_boost__shared_ptrT_LocalVolTermStructure_t')
class(`delete_LocalVolTermStructure`) = c("SWIGFunction", class('delete_LocalVolTermStructure'))

# Start of LocalVolTermStructure_referenceDate

`LocalVolTermStructure_referenceDate` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_LocalVolTermStructure_referenceDate', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`LocalVolTermStructure_referenceDate`, 'returnType') = '_p_Date'
attr(`LocalVolTermStructure_referenceDate`, "inputTypes") = c('_p_boost__shared_ptrT_LocalVolTermStructure_t')
class(`LocalVolTermStructure_referenceDate`) = c("SWIGFunction", class('LocalVolTermStructure_referenceDate'))

# Start of LocalVolTermStructure_dayCounter

`LocalVolTermStructure_dayCounter` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_LocalVolTermStructure_dayCounter', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_DayCounter";
  
  ans
  
}

attr(`LocalVolTermStructure_dayCounter`, 'returnType') = '_p_DayCounter'
attr(`LocalVolTermStructure_dayCounter`, "inputTypes") = c('_p_boost__shared_ptrT_LocalVolTermStructure_t')
class(`LocalVolTermStructure_dayCounter`) = c("SWIGFunction", class('LocalVolTermStructure_dayCounter'))

# Start of LocalVolTermStructure_calendar

`LocalVolTermStructure_calendar` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_LocalVolTermStructure_calendar', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Calendar";
  
  ans
  
}

attr(`LocalVolTermStructure_calendar`, 'returnType') = '_p_Calendar'
attr(`LocalVolTermStructure_calendar`, "inputTypes") = c('_p_boost__shared_ptrT_LocalVolTermStructure_t')
class(`LocalVolTermStructure_calendar`) = c("SWIGFunction", class('LocalVolTermStructure_calendar'))

# Start of LocalVolTermStructure_maxDate

`LocalVolTermStructure_maxDate` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_LocalVolTermStructure_maxDate', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`LocalVolTermStructure_maxDate`, 'returnType') = '_p_Date'
attr(`LocalVolTermStructure_maxDate`, "inputTypes") = c('_p_boost__shared_ptrT_LocalVolTermStructure_t')
class(`LocalVolTermStructure_maxDate`) = c("SWIGFunction", class('LocalVolTermStructure_maxDate'))

# Start of LocalVolTermStructure_maxTime

`LocalVolTermStructure_maxTime` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_LocalVolTermStructure_maxTime', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`LocalVolTermStructure_maxTime`, 'returnType') = 'numeric'
attr(`LocalVolTermStructure_maxTime`, "inputTypes") = c('_p_boost__shared_ptrT_LocalVolTermStructure_t')
class(`LocalVolTermStructure_maxTime`) = c("SWIGFunction", class('LocalVolTermStructure_maxTime'))

# Start of LocalVolTermStructure_minStrike

`LocalVolTermStructure_minStrike` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_LocalVolTermStructure_minStrike', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`LocalVolTermStructure_minStrike`, 'returnType') = 'numeric'
attr(`LocalVolTermStructure_minStrike`, "inputTypes") = c('_p_boost__shared_ptrT_LocalVolTermStructure_t')
class(`LocalVolTermStructure_minStrike`) = c("SWIGFunction", class('LocalVolTermStructure_minStrike'))

# Start of LocalVolTermStructure_maxStrike

`LocalVolTermStructure_maxStrike` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_LocalVolTermStructure_maxStrike', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`LocalVolTermStructure_maxStrike`, 'returnType') = 'numeric'
attr(`LocalVolTermStructure_maxStrike`, "inputTypes") = c('_p_boost__shared_ptrT_LocalVolTermStructure_t')
class(`LocalVolTermStructure_maxStrike`) = c("SWIGFunction", class('LocalVolTermStructure_maxStrike'))

# Start of LocalVolTermStructure_localVol

`LocalVolTermStructure_localVol__SWIG_0` = function(self, s_arg2, u, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_LocalVolTermStructure_localVol__SWIG_0', self, s_arg2, u, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`LocalVolTermStructure_localVol__SWIG_0`, 'returnType') = 'numeric'
attr(`LocalVolTermStructure_localVol__SWIG_0`, "inputTypes") = c('_p_boost__shared_ptrT_LocalVolTermStructure_t', '_p_Date', 'numeric', 'logical')
class(`LocalVolTermStructure_localVol__SWIG_0`) = c("SWIGFunction", class('LocalVolTermStructure_localVol__SWIG_0'))

# Start of LocalVolTermStructure_localVol

`LocalVolTermStructure_localVol__SWIG_1` = function(self, s_arg2, u, .copy = FALSE)
{
  ;.Call('R_swig_LocalVolTermStructure_localVol__SWIG_1', self, s_arg2, u, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`LocalVolTermStructure_localVol__SWIG_1`, 'returnType') = 'numeric'
attr(`LocalVolTermStructure_localVol__SWIG_1`, "inputTypes") = c('_p_boost__shared_ptrT_LocalVolTermStructure_t', '_p_Date', 'numeric')
class(`LocalVolTermStructure_localVol__SWIG_1`) = c("SWIGFunction", class('LocalVolTermStructure_localVol__SWIG_1'))

# Start of LocalVolTermStructure_localVol

`LocalVolTermStructure_localVol__SWIG_2` = function(self, s_arg2, u, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_LocalVolTermStructure_localVol__SWIG_2', self, s_arg2, u, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`LocalVolTermStructure_localVol__SWIG_2`, 'returnType') = 'numeric'
attr(`LocalVolTermStructure_localVol__SWIG_2`, "inputTypes") = c('_p_boost__shared_ptrT_LocalVolTermStructure_t', 'numeric', 'numeric', 'logical')
class(`LocalVolTermStructure_localVol__SWIG_2`) = c("SWIGFunction", class('LocalVolTermStructure_localVol__SWIG_2'))

# Start of LocalVolTermStructure_localVol

`LocalVolTermStructure_localVol__SWIG_3` = function(self, s_arg2, u, .copy = FALSE)
{
  ;.Call('R_swig_LocalVolTermStructure_localVol__SWIG_3', self, s_arg2, u, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`LocalVolTermStructure_localVol__SWIG_3`, 'returnType') = 'numeric'
attr(`LocalVolTermStructure_localVol__SWIG_3`, "inputTypes") = c('_p_boost__shared_ptrT_LocalVolTermStructure_t', 'numeric', 'numeric')
class(`LocalVolTermStructure_localVol__SWIG_3`) = c("SWIGFunction", class('LocalVolTermStructure_localVol__SWIG_3'))

`LocalVolTermStructure_localVol` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 3) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_LocalVolTermStructure_t') && extends(argtypes[2], '_p_Date') && is.numeric(argv[[3]])) {
      f <- LocalVolTermStructure_localVol__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_boost__shared_ptrT_LocalVolTermStructure_t') && is.numeric(argv[[2]]) && is.numeric(argv[[3]])) {
      f <- LocalVolTermStructure_localVol__SWIG_3; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_LocalVolTermStructure_t') && extends(argtypes[2], '_p_Date') && is.numeric(argv[[3]]) && extends(argtypes[4], 'logical')) {
      f <- LocalVolTermStructure_localVol__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_boost__shared_ptrT_LocalVolTermStructure_t') && is.numeric(argv[[2]]) && is.numeric(argv[[3]]) && extends(argtypes[4], 'logical')) {
      f <- LocalVolTermStructure_localVol__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for LocalVolTermStructure_localVol with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of LocalVolTermStructure_enableExtrapolation

`LocalVolTermStructure_enableExtrapolation` = function(self)
{
  ;.Call('R_swig_LocalVolTermStructure_enableExtrapolation', self, PACKAGE='QuantLib');
  
}

attr(`LocalVolTermStructure_enableExtrapolation`, 'returnType') = 'void'
attr(`LocalVolTermStructure_enableExtrapolation`, "inputTypes") = c('_p_boost__shared_ptrT_LocalVolTermStructure_t')
class(`LocalVolTermStructure_enableExtrapolation`) = c("SWIGFunction", class('LocalVolTermStructure_enableExtrapolation'))

# Start of LocalVolTermStructure_disableExtrapolation

`LocalVolTermStructure_disableExtrapolation` = function(self)
{
  ;.Call('R_swig_LocalVolTermStructure_disableExtrapolation', self, PACKAGE='QuantLib');
  
}

attr(`LocalVolTermStructure_disableExtrapolation`, 'returnType') = 'void'
attr(`LocalVolTermStructure_disableExtrapolation`, "inputTypes") = c('_p_boost__shared_ptrT_LocalVolTermStructure_t')
class(`LocalVolTermStructure_disableExtrapolation`) = c("SWIGFunction", class('LocalVolTermStructure_disableExtrapolation'))

# Start of LocalVolTermStructure_allowsExtrapolation

`LocalVolTermStructure_allowsExtrapolation` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_LocalVolTermStructure_allowsExtrapolation', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`LocalVolTermStructure_allowsExtrapolation`, 'returnType') = 'logical'
attr(`LocalVolTermStructure_allowsExtrapolation`, "inputTypes") = c('_p_boost__shared_ptrT_LocalVolTermStructure_t')
class(`LocalVolTermStructure_allowsExtrapolation`) = c("SWIGFunction", class('LocalVolTermStructure_allowsExtrapolation'))

# Start of accessor method for boost::shared_ptr<(LocalVolTermStructure)>
setMethod('$', '_p_boost__shared_ptrT_LocalVolTermStructure_t', function(x, name)

{
  accessorFuns = list('__deref__' = LocalVolTermStructure___deref__, 'isNull' = LocalVolTermStructure_isNull, 'asObservable' = LocalVolTermStructure_asObservable, 'referenceDate' = LocalVolTermStructure_referenceDate, 'dayCounter' = LocalVolTermStructure_dayCounter, 'calendar' = LocalVolTermStructure_calendar, 'maxDate' = LocalVolTermStructure_maxDate, 'maxTime' = LocalVolTermStructure_maxTime, 'minStrike' = LocalVolTermStructure_minStrike, 'maxStrike' = LocalVolTermStructure_maxStrike, 'localVol' = LocalVolTermStructure_localVol, 'enableExtrapolation' = LocalVolTermStructure_enableExtrapolation, 'disableExtrapolation' = LocalVolTermStructure_disableExtrapolation, 'allowsExtrapolation' = LocalVolTermStructure_allowsExtrapolation);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for boost::shared_ptr<(LocalVolTermStructure)>
setMethod('delete', '_p_boost__shared_ptrT_LocalVolTermStructure_t', function(obj) {delete_boost__shared_ptrT_LocalVolTermStructure_t(obj)})
# Start of new_LocalVolTermStructureHandle

`LocalVolTermStructureHandle__SWIG_0` = function(s_arg1)
{
  ;ans = .Call('R_swig_new_LocalVolTermStructureHandle__SWIG_0', s_arg1, PACKAGE='QuantLib');
  class(ans) <- "_p_HandleT_LocalVolTermStructure_t";
  
  reg.finalizer(ans, delete_LocalVolTermStructureHandle)
  ans
  
}

attr(`LocalVolTermStructureHandle__SWIG_0`, 'returnType') = '_p_HandleT_LocalVolTermStructure_t'
attr(`LocalVolTermStructureHandle__SWIG_0`, "inputTypes") = c('_p_boost__shared_ptrT_LocalVolTermStructure_t')
class(`LocalVolTermStructureHandle__SWIG_0`) = c("SWIGFunction", class('LocalVolTermStructureHandle__SWIG_0'))

# Start of new_LocalVolTermStructureHandle

`LocalVolTermStructureHandle__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_LocalVolTermStructureHandle__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_HandleT_LocalVolTermStructure_t";
  
  reg.finalizer(ans, delete_LocalVolTermStructureHandle)
  ans
  
}

attr(`LocalVolTermStructureHandle__SWIG_1`, 'returnType') = '_p_HandleT_LocalVolTermStructure_t'
class(`LocalVolTermStructureHandle__SWIG_1`) = c("SWIGFunction", class('LocalVolTermStructureHandle__SWIG_1'))

`LocalVolTermStructureHandle` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- LocalVolTermStructureHandle__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_LocalVolTermStructure_t')) {
      f <- LocalVolTermStructureHandle__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for LocalVolTermStructureHandle with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of LocalVolTermStructureHandle___deref__

`LocalVolTermStructureHandle___deref__` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_LocalVolTermStructureHandle___deref__', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_LocalVolTermStructure_t";
  
  ans
  
}

attr(`LocalVolTermStructureHandle___deref__`, 'returnType') = '_p_boost__shared_ptrT_LocalVolTermStructure_t'
attr(`LocalVolTermStructureHandle___deref__`, "inputTypes") = c('_p_HandleT_LocalVolTermStructure_t')
class(`LocalVolTermStructureHandle___deref__`) = c("SWIGFunction", class('LocalVolTermStructureHandle___deref__'))

# Start of LocalVolTermStructureHandle_empty

`LocalVolTermStructureHandle_empty` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_LocalVolTermStructureHandle_empty', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`LocalVolTermStructureHandle_empty`, 'returnType') = 'logical'
attr(`LocalVolTermStructureHandle_empty`, "inputTypes") = c('_p_HandleT_LocalVolTermStructure_t')
class(`LocalVolTermStructureHandle_empty`) = c("SWIGFunction", class('LocalVolTermStructureHandle_empty'))

# Start of LocalVolTermStructureHandle_asObservable

`LocalVolTermStructureHandle_asObservable` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_LocalVolTermStructureHandle_asObservable', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_Observable_t";
  
  ans
  
}

attr(`LocalVolTermStructureHandle_asObservable`, 'returnType') = '_p_boost__shared_ptrT_Observable_t'
attr(`LocalVolTermStructureHandle_asObservable`, "inputTypes") = c('_p_HandleT_LocalVolTermStructure_t')
class(`LocalVolTermStructureHandle_asObservable`) = c("SWIGFunction", class('LocalVolTermStructureHandle_asObservable'))

# Start of delete_LocalVolTermStructureHandle

`delete_LocalVolTermStructureHandle` = function(self)
{
  ;.Call('R_swig_delete_LocalVolTermStructureHandle', self, PACKAGE='QuantLib');
  
}

attr(`delete_LocalVolTermStructureHandle`, 'returnType') = 'void'
attr(`delete_LocalVolTermStructureHandle`, "inputTypes") = c('_p_HandleT_LocalVolTermStructure_t')
class(`delete_LocalVolTermStructureHandle`) = c("SWIGFunction", class('delete_LocalVolTermStructureHandle'))

# Start of LocalVolTermStructureHandle_referenceDate

`LocalVolTermStructureHandle_referenceDate` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_LocalVolTermStructureHandle_referenceDate', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`LocalVolTermStructureHandle_referenceDate`, 'returnType') = '_p_Date'
attr(`LocalVolTermStructureHandle_referenceDate`, "inputTypes") = c('_p_HandleT_LocalVolTermStructure_t')
class(`LocalVolTermStructureHandle_referenceDate`) = c("SWIGFunction", class('LocalVolTermStructureHandle_referenceDate'))

# Start of LocalVolTermStructureHandle_dayCounter

`LocalVolTermStructureHandle_dayCounter` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_LocalVolTermStructureHandle_dayCounter', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_DayCounter";
  
  ans
  
}

attr(`LocalVolTermStructureHandle_dayCounter`, 'returnType') = '_p_DayCounter'
attr(`LocalVolTermStructureHandle_dayCounter`, "inputTypes") = c('_p_HandleT_LocalVolTermStructure_t')
class(`LocalVolTermStructureHandle_dayCounter`) = c("SWIGFunction", class('LocalVolTermStructureHandle_dayCounter'))

# Start of LocalVolTermStructureHandle_calendar

`LocalVolTermStructureHandle_calendar` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_LocalVolTermStructureHandle_calendar', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Calendar";
  
  ans
  
}

attr(`LocalVolTermStructureHandle_calendar`, 'returnType') = '_p_Calendar'
attr(`LocalVolTermStructureHandle_calendar`, "inputTypes") = c('_p_HandleT_LocalVolTermStructure_t')
class(`LocalVolTermStructureHandle_calendar`) = c("SWIGFunction", class('LocalVolTermStructureHandle_calendar'))

# Start of LocalVolTermStructureHandle_maxDate

`LocalVolTermStructureHandle_maxDate` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_LocalVolTermStructureHandle_maxDate', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`LocalVolTermStructureHandle_maxDate`, 'returnType') = '_p_Date'
attr(`LocalVolTermStructureHandle_maxDate`, "inputTypes") = c('_p_HandleT_LocalVolTermStructure_t')
class(`LocalVolTermStructureHandle_maxDate`) = c("SWIGFunction", class('LocalVolTermStructureHandle_maxDate'))

# Start of LocalVolTermStructureHandle_maxTime

`LocalVolTermStructureHandle_maxTime` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_LocalVolTermStructureHandle_maxTime', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`LocalVolTermStructureHandle_maxTime`, 'returnType') = 'numeric'
attr(`LocalVolTermStructureHandle_maxTime`, "inputTypes") = c('_p_HandleT_LocalVolTermStructure_t')
class(`LocalVolTermStructureHandle_maxTime`) = c("SWIGFunction", class('LocalVolTermStructureHandle_maxTime'))

# Start of LocalVolTermStructureHandle_minStrike

`LocalVolTermStructureHandle_minStrike` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_LocalVolTermStructureHandle_minStrike', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`LocalVolTermStructureHandle_minStrike`, 'returnType') = 'numeric'
attr(`LocalVolTermStructureHandle_minStrike`, "inputTypes") = c('_p_HandleT_LocalVolTermStructure_t')
class(`LocalVolTermStructureHandle_minStrike`) = c("SWIGFunction", class('LocalVolTermStructureHandle_minStrike'))

# Start of LocalVolTermStructureHandle_maxStrike

`LocalVolTermStructureHandle_maxStrike` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_LocalVolTermStructureHandle_maxStrike', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`LocalVolTermStructureHandle_maxStrike`, 'returnType') = 'numeric'
attr(`LocalVolTermStructureHandle_maxStrike`, "inputTypes") = c('_p_HandleT_LocalVolTermStructure_t')
class(`LocalVolTermStructureHandle_maxStrike`) = c("SWIGFunction", class('LocalVolTermStructureHandle_maxStrike'))

# Start of LocalVolTermStructureHandle_localVol

`LocalVolTermStructureHandle_localVol__SWIG_0` = function(self, s_arg2, u, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_LocalVolTermStructureHandle_localVol__SWIG_0', self, s_arg2, u, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`LocalVolTermStructureHandle_localVol__SWIG_0`, 'returnType') = 'numeric'
attr(`LocalVolTermStructureHandle_localVol__SWIG_0`, "inputTypes") = c('_p_HandleT_LocalVolTermStructure_t', '_p_Date', 'numeric', 'logical')
class(`LocalVolTermStructureHandle_localVol__SWIG_0`) = c("SWIGFunction", class('LocalVolTermStructureHandle_localVol__SWIG_0'))

# Start of LocalVolTermStructureHandle_localVol

`LocalVolTermStructureHandle_localVol__SWIG_1` = function(self, s_arg2, u, .copy = FALSE)
{
  ;.Call('R_swig_LocalVolTermStructureHandle_localVol__SWIG_1', self, s_arg2, u, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`LocalVolTermStructureHandle_localVol__SWIG_1`, 'returnType') = 'numeric'
attr(`LocalVolTermStructureHandle_localVol__SWIG_1`, "inputTypes") = c('_p_HandleT_LocalVolTermStructure_t', '_p_Date', 'numeric')
class(`LocalVolTermStructureHandle_localVol__SWIG_1`) = c("SWIGFunction", class('LocalVolTermStructureHandle_localVol__SWIG_1'))

# Start of LocalVolTermStructureHandle_localVol

`LocalVolTermStructureHandle_localVol__SWIG_2` = function(self, s_arg2, u, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_LocalVolTermStructureHandle_localVol__SWIG_2', self, s_arg2, u, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`LocalVolTermStructureHandle_localVol__SWIG_2`, 'returnType') = 'numeric'
attr(`LocalVolTermStructureHandle_localVol__SWIG_2`, "inputTypes") = c('_p_HandleT_LocalVolTermStructure_t', 'numeric', 'numeric', 'logical')
class(`LocalVolTermStructureHandle_localVol__SWIG_2`) = c("SWIGFunction", class('LocalVolTermStructureHandle_localVol__SWIG_2'))

# Start of LocalVolTermStructureHandle_localVol

`LocalVolTermStructureHandle_localVol__SWIG_3` = function(self, s_arg2, u, .copy = FALSE)
{
  ;.Call('R_swig_LocalVolTermStructureHandle_localVol__SWIG_3', self, s_arg2, u, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`LocalVolTermStructureHandle_localVol__SWIG_3`, 'returnType') = 'numeric'
attr(`LocalVolTermStructureHandle_localVol__SWIG_3`, "inputTypes") = c('_p_HandleT_LocalVolTermStructure_t', 'numeric', 'numeric')
class(`LocalVolTermStructureHandle_localVol__SWIG_3`) = c("SWIGFunction", class('LocalVolTermStructureHandle_localVol__SWIG_3'))

`LocalVolTermStructureHandle_localVol` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 3) {
    if (extends(argtypes[1], '_p_HandleT_LocalVolTermStructure_t') && extends(argtypes[2], '_p_Date') && is.numeric(argv[[3]])) {
      f <- LocalVolTermStructureHandle_localVol__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_HandleT_LocalVolTermStructure_t') && is.numeric(argv[[2]]) && is.numeric(argv[[3]])) {
      f <- LocalVolTermStructureHandle_localVol__SWIG_3; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_HandleT_LocalVolTermStructure_t') && extends(argtypes[2], '_p_Date') && is.numeric(argv[[3]]) && extends(argtypes[4], 'logical')) {
      f <- LocalVolTermStructureHandle_localVol__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_HandleT_LocalVolTermStructure_t') && is.numeric(argv[[2]]) && is.numeric(argv[[3]]) && extends(argtypes[4], 'logical')) {
      f <- LocalVolTermStructureHandle_localVol__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for LocalVolTermStructureHandle_localVol with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of LocalVolTermStructureHandle_enableExtrapolation

`LocalVolTermStructureHandle_enableExtrapolation` = function(self)
{
  ;.Call('R_swig_LocalVolTermStructureHandle_enableExtrapolation', self, PACKAGE='QuantLib');
  
}

attr(`LocalVolTermStructureHandle_enableExtrapolation`, 'returnType') = 'void'
attr(`LocalVolTermStructureHandle_enableExtrapolation`, "inputTypes") = c('_p_HandleT_LocalVolTermStructure_t')
class(`LocalVolTermStructureHandle_enableExtrapolation`) = c("SWIGFunction", class('LocalVolTermStructureHandle_enableExtrapolation'))

# Start of LocalVolTermStructureHandle_disableExtrapolation

`LocalVolTermStructureHandle_disableExtrapolation` = function(self)
{
  ;.Call('R_swig_LocalVolTermStructureHandle_disableExtrapolation', self, PACKAGE='QuantLib');
  
}

attr(`LocalVolTermStructureHandle_disableExtrapolation`, 'returnType') = 'void'
attr(`LocalVolTermStructureHandle_disableExtrapolation`, "inputTypes") = c('_p_HandleT_LocalVolTermStructure_t')
class(`LocalVolTermStructureHandle_disableExtrapolation`) = c("SWIGFunction", class('LocalVolTermStructureHandle_disableExtrapolation'))

# Start of LocalVolTermStructureHandle_allowsExtrapolation

`LocalVolTermStructureHandle_allowsExtrapolation` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_LocalVolTermStructureHandle_allowsExtrapolation', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`LocalVolTermStructureHandle_allowsExtrapolation`, 'returnType') = 'logical'
attr(`LocalVolTermStructureHandle_allowsExtrapolation`, "inputTypes") = c('_p_HandleT_LocalVolTermStructure_t')
class(`LocalVolTermStructureHandle_allowsExtrapolation`) = c("SWIGFunction", class('LocalVolTermStructureHandle_allowsExtrapolation'))

# Start of accessor method for Handle<(LocalVolTermStructure)>
setMethod('$', '_p_HandleT_LocalVolTermStructure_t', function(x, name)

{
  accessorFuns = list('__deref__' = LocalVolTermStructureHandle___deref__, 'empty' = LocalVolTermStructureHandle_empty, 'asObservable' = LocalVolTermStructureHandle_asObservable, 'referenceDate' = LocalVolTermStructureHandle_referenceDate, 'dayCounter' = LocalVolTermStructureHandle_dayCounter, 'calendar' = LocalVolTermStructureHandle_calendar, 'maxDate' = LocalVolTermStructureHandle_maxDate, 'maxTime' = LocalVolTermStructureHandle_maxTime, 'minStrike' = LocalVolTermStructureHandle_minStrike, 'maxStrike' = LocalVolTermStructureHandle_maxStrike, 'localVol' = LocalVolTermStructureHandle_localVol, 'enableExtrapolation' = LocalVolTermStructureHandle_enableExtrapolation, 'disableExtrapolation' = LocalVolTermStructureHandle_disableExtrapolation, 'allowsExtrapolation' = LocalVolTermStructureHandle_allowsExtrapolation);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for Handle<(LocalVolTermStructure)>
setMethod('delete', '_p_HandleT_LocalVolTermStructure_t', function(obj) {delete_HandleT_LocalVolTermStructure_t(obj)})
# Start of new_RelinkableLocalVolTermStructureHandle

`RelinkableLocalVolTermStructureHandle__SWIG_0` = function(s_arg1)
{
  ;ans = .Call('R_swig_new_RelinkableLocalVolTermStructureHandle__SWIG_0', s_arg1, PACKAGE='QuantLib');
  class(ans) <- "_p_RelinkableHandleT_LocalVolTermStructure_t";
  
  reg.finalizer(ans, delete_RelinkableLocalVolTermStructureHandle)
  ans
  
}

attr(`RelinkableLocalVolTermStructureHandle__SWIG_0`, 'returnType') = '_p_RelinkableHandleT_LocalVolTermStructure_t'
attr(`RelinkableLocalVolTermStructureHandle__SWIG_0`, "inputTypes") = c('_p_boost__shared_ptrT_LocalVolTermStructure_t')
class(`RelinkableLocalVolTermStructureHandle__SWIG_0`) = c("SWIGFunction", class('RelinkableLocalVolTermStructureHandle__SWIG_0'))

# Start of new_RelinkableLocalVolTermStructureHandle

`RelinkableLocalVolTermStructureHandle__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_RelinkableLocalVolTermStructureHandle__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_RelinkableHandleT_LocalVolTermStructure_t";
  
  reg.finalizer(ans, delete_RelinkableLocalVolTermStructureHandle)
  ans
  
}

attr(`RelinkableLocalVolTermStructureHandle__SWIG_1`, 'returnType') = '_p_RelinkableHandleT_LocalVolTermStructure_t'
class(`RelinkableLocalVolTermStructureHandle__SWIG_1`) = c("SWIGFunction", class('RelinkableLocalVolTermStructureHandle__SWIG_1'))

`RelinkableLocalVolTermStructureHandle` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- RelinkableLocalVolTermStructureHandle__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_LocalVolTermStructure_t')) {
      f <- RelinkableLocalVolTermStructureHandle__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for RelinkableLocalVolTermStructureHandle with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of RelinkableLocalVolTermStructureHandle_linkTo

`RelinkableLocalVolTermStructureHandle_linkTo` = function(self, s_arg2)
{
  ;.Call('R_swig_RelinkableLocalVolTermStructureHandle_linkTo', self, s_arg2, PACKAGE='QuantLib');
  
}

attr(`RelinkableLocalVolTermStructureHandle_linkTo`, 'returnType') = 'void'
attr(`RelinkableLocalVolTermStructureHandle_linkTo`, "inputTypes") = c('_p_RelinkableHandleT_LocalVolTermStructure_t', '_p_boost__shared_ptrT_LocalVolTermStructure_t')
class(`RelinkableLocalVolTermStructureHandle_linkTo`) = c("SWIGFunction", class('RelinkableLocalVolTermStructureHandle_linkTo'))

# Start of delete_RelinkableLocalVolTermStructureHandle

`delete_RelinkableLocalVolTermStructureHandle` = function(self)
{
  ;.Call('R_swig_delete_RelinkableLocalVolTermStructureHandle', self, PACKAGE='QuantLib');
  
}

attr(`delete_RelinkableLocalVolTermStructureHandle`, 'returnType') = 'void'
attr(`delete_RelinkableLocalVolTermStructureHandle`, "inputTypes") = c('_p_RelinkableHandleT_LocalVolTermStructure_t')
class(`delete_RelinkableLocalVolTermStructureHandle`) = c("SWIGFunction", class('delete_RelinkableLocalVolTermStructureHandle'))

# Start of accessor method for RelinkableHandle<(LocalVolTermStructure)>
setMethod('$', '_p_RelinkableHandleT_LocalVolTermStructure_t', function(x, name)

{
  accessorFuns = list('linkTo' = RelinkableLocalVolTermStructureHandle_linkTo);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for RelinkableHandle<(LocalVolTermStructure)>
setMethod('delete', '_p_RelinkableHandleT_LocalVolTermStructure_t', function(obj) {delete_RelinkableHandleT_LocalVolTermStructure_t(obj)})
# Start of OptionletVolatilityStructure___deref__

`OptionletVolatilityStructure___deref__` = function(self)
{
  ;ans = .Call('R_swig_OptionletVolatilityStructure___deref__', self, PACKAGE='QuantLib');
  class(ans) <- "_p_OptionletVolatilityStructure";
  
  ans
  
}

attr(`OptionletVolatilityStructure___deref__`, 'returnType') = '_p_OptionletVolatilityStructure'
attr(`OptionletVolatilityStructure___deref__`, "inputTypes") = c('_p_boost__shared_ptrT_OptionletVolatilityStructure_t')
class(`OptionletVolatilityStructure___deref__`) = c("SWIGFunction", class('OptionletVolatilityStructure___deref__'))

# Start of OptionletVolatilityStructure_isNull

`OptionletVolatilityStructure_isNull` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_OptionletVolatilityStructure_isNull', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`OptionletVolatilityStructure_isNull`, 'returnType') = 'logical'
attr(`OptionletVolatilityStructure_isNull`, "inputTypes") = c('_p_boost__shared_ptrT_OptionletVolatilityStructure_t')
class(`OptionletVolatilityStructure_isNull`) = c("SWIGFunction", class('OptionletVolatilityStructure_isNull'))

# Start of OptionletVolatilityStructure_asObservable

`OptionletVolatilityStructure_asObservable` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_OptionletVolatilityStructure_asObservable', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_Observable_t";
  
  ans
  
}

attr(`OptionletVolatilityStructure_asObservable`, 'returnType') = '_p_boost__shared_ptrT_Observable_t'
attr(`OptionletVolatilityStructure_asObservable`, "inputTypes") = c('_p_boost__shared_ptrT_OptionletVolatilityStructure_t')
class(`OptionletVolatilityStructure_asObservable`) = c("SWIGFunction", class('OptionletVolatilityStructure_asObservable'))

# Start of new_OptionletVolatilityStructure

`OptionletVolatilityStructure` = function()
{
  ;ans = .Call('R_swig_new_OptionletVolatilityStructure', PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_OptionletVolatilityStructure_t";
  
  reg.finalizer(ans, delete_OptionletVolatilityStructure)
  ans
  
}

attr(`OptionletVolatilityStructure`, 'returnType') = '_p_boost__shared_ptrT_OptionletVolatilityStructure_t'
class(`OptionletVolatilityStructure`) = c("SWIGFunction", class('OptionletVolatilityStructure'))

# Start of delete_OptionletVolatilityStructure

`delete_OptionletVolatilityStructure` = function(self)
{
  ;.Call('R_swig_delete_OptionletVolatilityStructure', self, PACKAGE='QuantLib');
  
}

attr(`delete_OptionletVolatilityStructure`, 'returnType') = 'void'
attr(`delete_OptionletVolatilityStructure`, "inputTypes") = c('_p_boost__shared_ptrT_OptionletVolatilityStructure_t')
class(`delete_OptionletVolatilityStructure`) = c("SWIGFunction", class('delete_OptionletVolatilityStructure'))

# Start of OptionletVolatilityStructure_referenceDate

`OptionletVolatilityStructure_referenceDate` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_OptionletVolatilityStructure_referenceDate', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`OptionletVolatilityStructure_referenceDate`, 'returnType') = '_p_Date'
attr(`OptionletVolatilityStructure_referenceDate`, "inputTypes") = c('_p_boost__shared_ptrT_OptionletVolatilityStructure_t')
class(`OptionletVolatilityStructure_referenceDate`) = c("SWIGFunction", class('OptionletVolatilityStructure_referenceDate'))

# Start of OptionletVolatilityStructure_dayCounter

`OptionletVolatilityStructure_dayCounter` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_OptionletVolatilityStructure_dayCounter', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_DayCounter";
  
  ans
  
}

attr(`OptionletVolatilityStructure_dayCounter`, 'returnType') = '_p_DayCounter'
attr(`OptionletVolatilityStructure_dayCounter`, "inputTypes") = c('_p_boost__shared_ptrT_OptionletVolatilityStructure_t')
class(`OptionletVolatilityStructure_dayCounter`) = c("SWIGFunction", class('OptionletVolatilityStructure_dayCounter'))

# Start of OptionletVolatilityStructure_calendar

`OptionletVolatilityStructure_calendar` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_OptionletVolatilityStructure_calendar', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Calendar";
  
  ans
  
}

attr(`OptionletVolatilityStructure_calendar`, 'returnType') = '_p_Calendar'
attr(`OptionletVolatilityStructure_calendar`, "inputTypes") = c('_p_boost__shared_ptrT_OptionletVolatilityStructure_t')
class(`OptionletVolatilityStructure_calendar`) = c("SWIGFunction", class('OptionletVolatilityStructure_calendar'))

# Start of OptionletVolatilityStructure_maxDate

`OptionletVolatilityStructure_maxDate` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_OptionletVolatilityStructure_maxDate', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`OptionletVolatilityStructure_maxDate`, 'returnType') = '_p_Date'
attr(`OptionletVolatilityStructure_maxDate`, "inputTypes") = c('_p_boost__shared_ptrT_OptionletVolatilityStructure_t')
class(`OptionletVolatilityStructure_maxDate`) = c("SWIGFunction", class('OptionletVolatilityStructure_maxDate'))

# Start of OptionletVolatilityStructure_maxTime

`OptionletVolatilityStructure_maxTime` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_OptionletVolatilityStructure_maxTime', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`OptionletVolatilityStructure_maxTime`, 'returnType') = 'numeric'
attr(`OptionletVolatilityStructure_maxTime`, "inputTypes") = c('_p_boost__shared_ptrT_OptionletVolatilityStructure_t')
class(`OptionletVolatilityStructure_maxTime`) = c("SWIGFunction", class('OptionletVolatilityStructure_maxTime'))

# Start of OptionletVolatilityStructure_minStrike

`OptionletVolatilityStructure_minStrike` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_OptionletVolatilityStructure_minStrike', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`OptionletVolatilityStructure_minStrike`, 'returnType') = 'numeric'
attr(`OptionletVolatilityStructure_minStrike`, "inputTypes") = c('_p_boost__shared_ptrT_OptionletVolatilityStructure_t')
class(`OptionletVolatilityStructure_minStrike`) = c("SWIGFunction", class('OptionletVolatilityStructure_minStrike'))

# Start of OptionletVolatilityStructure_maxStrike

`OptionletVolatilityStructure_maxStrike` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_OptionletVolatilityStructure_maxStrike', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`OptionletVolatilityStructure_maxStrike`, 'returnType') = 'numeric'
attr(`OptionletVolatilityStructure_maxStrike`, "inputTypes") = c('_p_boost__shared_ptrT_OptionletVolatilityStructure_t')
class(`OptionletVolatilityStructure_maxStrike`) = c("SWIGFunction", class('OptionletVolatilityStructure_maxStrike'))

# Start of OptionletVolatilityStructure_volatility

`OptionletVolatilityStructure_volatility__SWIG_0` = function(self, s_arg2, strike, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_OptionletVolatilityStructure_volatility__SWIG_0', self, s_arg2, strike, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`OptionletVolatilityStructure_volatility__SWIG_0`, 'returnType') = 'numeric'
attr(`OptionletVolatilityStructure_volatility__SWIG_0`, "inputTypes") = c('_p_boost__shared_ptrT_OptionletVolatilityStructure_t', '_p_Date', 'numeric', 'logical')
class(`OptionletVolatilityStructure_volatility__SWIG_0`) = c("SWIGFunction", class('OptionletVolatilityStructure_volatility__SWIG_0'))

# Start of OptionletVolatilityStructure_volatility

`OptionletVolatilityStructure_volatility__SWIG_1` = function(self, s_arg2, strike, .copy = FALSE)
{
  ;.Call('R_swig_OptionletVolatilityStructure_volatility__SWIG_1', self, s_arg2, strike, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`OptionletVolatilityStructure_volatility__SWIG_1`, 'returnType') = 'numeric'
attr(`OptionletVolatilityStructure_volatility__SWIG_1`, "inputTypes") = c('_p_boost__shared_ptrT_OptionletVolatilityStructure_t', '_p_Date', 'numeric')
class(`OptionletVolatilityStructure_volatility__SWIG_1`) = c("SWIGFunction", class('OptionletVolatilityStructure_volatility__SWIG_1'))

# Start of OptionletVolatilityStructure_volatility

`OptionletVolatilityStructure_volatility__SWIG_2` = function(self, s_arg2, strike, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_OptionletVolatilityStructure_volatility__SWIG_2', self, s_arg2, strike, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`OptionletVolatilityStructure_volatility__SWIG_2`, 'returnType') = 'numeric'
attr(`OptionletVolatilityStructure_volatility__SWIG_2`, "inputTypes") = c('_p_boost__shared_ptrT_OptionletVolatilityStructure_t', 'numeric', 'numeric', 'logical')
class(`OptionletVolatilityStructure_volatility__SWIG_2`) = c("SWIGFunction", class('OptionletVolatilityStructure_volatility__SWIG_2'))

# Start of OptionletVolatilityStructure_volatility

`OptionletVolatilityStructure_volatility__SWIG_3` = function(self, s_arg2, strike, .copy = FALSE)
{
  ;.Call('R_swig_OptionletVolatilityStructure_volatility__SWIG_3', self, s_arg2, strike, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`OptionletVolatilityStructure_volatility__SWIG_3`, 'returnType') = 'numeric'
attr(`OptionletVolatilityStructure_volatility__SWIG_3`, "inputTypes") = c('_p_boost__shared_ptrT_OptionletVolatilityStructure_t', 'numeric', 'numeric')
class(`OptionletVolatilityStructure_volatility__SWIG_3`) = c("SWIGFunction", class('OptionletVolatilityStructure_volatility__SWIG_3'))

`OptionletVolatilityStructure_volatility` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 3) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_OptionletVolatilityStructure_t') && extends(argtypes[2], '_p_Date') && is.numeric(argv[[3]])) {
      f <- OptionletVolatilityStructure_volatility__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_boost__shared_ptrT_OptionletVolatilityStructure_t') && is.numeric(argv[[2]]) && is.numeric(argv[[3]])) {
      f <- OptionletVolatilityStructure_volatility__SWIG_3; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_OptionletVolatilityStructure_t') && extends(argtypes[2], '_p_Date') && is.numeric(argv[[3]]) && extends(argtypes[4], 'logical')) {
      f <- OptionletVolatilityStructure_volatility__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_boost__shared_ptrT_OptionletVolatilityStructure_t') && is.numeric(argv[[2]]) && is.numeric(argv[[3]]) && extends(argtypes[4], 'logical')) {
      f <- OptionletVolatilityStructure_volatility__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for OptionletVolatilityStructure_volatility with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of OptionletVolatilityStructure_blackVariance

`OptionletVolatilityStructure_blackVariance__SWIG_0` = function(self, s_arg2, strike, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_OptionletVolatilityStructure_blackVariance__SWIG_0', self, s_arg2, strike, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`OptionletVolatilityStructure_blackVariance__SWIG_0`, 'returnType') = 'numeric'
attr(`OptionletVolatilityStructure_blackVariance__SWIG_0`, "inputTypes") = c('_p_boost__shared_ptrT_OptionletVolatilityStructure_t', '_p_Date', 'numeric', 'logical')
class(`OptionletVolatilityStructure_blackVariance__SWIG_0`) = c("SWIGFunction", class('OptionletVolatilityStructure_blackVariance__SWIG_0'))

# Start of OptionletVolatilityStructure_blackVariance

`OptionletVolatilityStructure_blackVariance__SWIG_1` = function(self, s_arg2, strike, .copy = FALSE)
{
  ;.Call('R_swig_OptionletVolatilityStructure_blackVariance__SWIG_1', self, s_arg2, strike, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`OptionletVolatilityStructure_blackVariance__SWIG_1`, 'returnType') = 'numeric'
attr(`OptionletVolatilityStructure_blackVariance__SWIG_1`, "inputTypes") = c('_p_boost__shared_ptrT_OptionletVolatilityStructure_t', '_p_Date', 'numeric')
class(`OptionletVolatilityStructure_blackVariance__SWIG_1`) = c("SWIGFunction", class('OptionletVolatilityStructure_blackVariance__SWIG_1'))

# Start of OptionletVolatilityStructure_blackVariance

`OptionletVolatilityStructure_blackVariance__SWIG_2` = function(self, s_arg2, strike, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_OptionletVolatilityStructure_blackVariance__SWIG_2', self, s_arg2, strike, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`OptionletVolatilityStructure_blackVariance__SWIG_2`, 'returnType') = 'numeric'
attr(`OptionletVolatilityStructure_blackVariance__SWIG_2`, "inputTypes") = c('_p_boost__shared_ptrT_OptionletVolatilityStructure_t', 'numeric', 'numeric', 'logical')
class(`OptionletVolatilityStructure_blackVariance__SWIG_2`) = c("SWIGFunction", class('OptionletVolatilityStructure_blackVariance__SWIG_2'))

# Start of OptionletVolatilityStructure_blackVariance

`OptionletVolatilityStructure_blackVariance__SWIG_3` = function(self, s_arg2, strike, .copy = FALSE)
{
  ;.Call('R_swig_OptionletVolatilityStructure_blackVariance__SWIG_3', self, s_arg2, strike, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`OptionletVolatilityStructure_blackVariance__SWIG_3`, 'returnType') = 'numeric'
attr(`OptionletVolatilityStructure_blackVariance__SWIG_3`, "inputTypes") = c('_p_boost__shared_ptrT_OptionletVolatilityStructure_t', 'numeric', 'numeric')
class(`OptionletVolatilityStructure_blackVariance__SWIG_3`) = c("SWIGFunction", class('OptionletVolatilityStructure_blackVariance__SWIG_3'))

`OptionletVolatilityStructure_blackVariance` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 3) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_OptionletVolatilityStructure_t') && extends(argtypes[2], '_p_Date') && is.numeric(argv[[3]])) {
      f <- OptionletVolatilityStructure_blackVariance__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_boost__shared_ptrT_OptionletVolatilityStructure_t') && is.numeric(argv[[2]]) && is.numeric(argv[[3]])) {
      f <- OptionletVolatilityStructure_blackVariance__SWIG_3; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_OptionletVolatilityStructure_t') && extends(argtypes[2], '_p_Date') && is.numeric(argv[[3]]) && extends(argtypes[4], 'logical')) {
      f <- OptionletVolatilityStructure_blackVariance__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_boost__shared_ptrT_OptionletVolatilityStructure_t') && is.numeric(argv[[2]]) && is.numeric(argv[[3]]) && extends(argtypes[4], 'logical')) {
      f <- OptionletVolatilityStructure_blackVariance__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for OptionletVolatilityStructure_blackVariance with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of OptionletVolatilityStructure_enableExtrapolation

`OptionletVolatilityStructure_enableExtrapolation` = function(self)
{
  ;.Call('R_swig_OptionletVolatilityStructure_enableExtrapolation', self, PACKAGE='QuantLib');
  
}

attr(`OptionletVolatilityStructure_enableExtrapolation`, 'returnType') = 'void'
attr(`OptionletVolatilityStructure_enableExtrapolation`, "inputTypes") = c('_p_boost__shared_ptrT_OptionletVolatilityStructure_t')
class(`OptionletVolatilityStructure_enableExtrapolation`) = c("SWIGFunction", class('OptionletVolatilityStructure_enableExtrapolation'))

# Start of OptionletVolatilityStructure_disableExtrapolation

`OptionletVolatilityStructure_disableExtrapolation` = function(self)
{
  ;.Call('R_swig_OptionletVolatilityStructure_disableExtrapolation', self, PACKAGE='QuantLib');
  
}

attr(`OptionletVolatilityStructure_disableExtrapolation`, 'returnType') = 'void'
attr(`OptionletVolatilityStructure_disableExtrapolation`, "inputTypes") = c('_p_boost__shared_ptrT_OptionletVolatilityStructure_t')
class(`OptionletVolatilityStructure_disableExtrapolation`) = c("SWIGFunction", class('OptionletVolatilityStructure_disableExtrapolation'))

# Start of OptionletVolatilityStructure_allowsExtrapolation

`OptionletVolatilityStructure_allowsExtrapolation` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_OptionletVolatilityStructure_allowsExtrapolation', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`OptionletVolatilityStructure_allowsExtrapolation`, 'returnType') = 'logical'
attr(`OptionletVolatilityStructure_allowsExtrapolation`, "inputTypes") = c('_p_boost__shared_ptrT_OptionletVolatilityStructure_t')
class(`OptionletVolatilityStructure_allowsExtrapolation`) = c("SWIGFunction", class('OptionletVolatilityStructure_allowsExtrapolation'))

# Start of accessor method for boost::shared_ptr<(OptionletVolatilityStructure)>
setMethod('$', '_p_boost__shared_ptrT_OptionletVolatilityStructure_t', function(x, name)

{
  accessorFuns = list('__deref__' = OptionletVolatilityStructure___deref__, 'isNull' = OptionletVolatilityStructure_isNull, 'asObservable' = OptionletVolatilityStructure_asObservable, 'referenceDate' = OptionletVolatilityStructure_referenceDate, 'dayCounter' = OptionletVolatilityStructure_dayCounter, 'calendar' = OptionletVolatilityStructure_calendar, 'maxDate' = OptionletVolatilityStructure_maxDate, 'maxTime' = OptionletVolatilityStructure_maxTime, 'minStrike' = OptionletVolatilityStructure_minStrike, 'maxStrike' = OptionletVolatilityStructure_maxStrike, 'volatility' = OptionletVolatilityStructure_volatility, 'blackVariance' = OptionletVolatilityStructure_blackVariance, 'enableExtrapolation' = OptionletVolatilityStructure_enableExtrapolation, 'disableExtrapolation' = OptionletVolatilityStructure_disableExtrapolation, 'allowsExtrapolation' = OptionletVolatilityStructure_allowsExtrapolation);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for boost::shared_ptr<(OptionletVolatilityStructure)>
setMethod('delete', '_p_boost__shared_ptrT_OptionletVolatilityStructure_t', function(obj) {delete_boost__shared_ptrT_OptionletVolatilityStructure_t(obj)})
# Start of new_OptionletVolatilityStructureHandle

`OptionletVolatilityStructureHandle__SWIG_0` = function(s_arg1)
{
  ;ans = .Call('R_swig_new_OptionletVolatilityStructureHandle__SWIG_0', s_arg1, PACKAGE='QuantLib');
  class(ans) <- "_p_HandleT_OptionletVolatilityStructure_t";
  
  reg.finalizer(ans, delete_OptionletVolatilityStructureHandle)
  ans
  
}

attr(`OptionletVolatilityStructureHandle__SWIG_0`, 'returnType') = '_p_HandleT_OptionletVolatilityStructure_t'
attr(`OptionletVolatilityStructureHandle__SWIG_0`, "inputTypes") = c('_p_boost__shared_ptrT_OptionletVolatilityStructure_t')
class(`OptionletVolatilityStructureHandle__SWIG_0`) = c("SWIGFunction", class('OptionletVolatilityStructureHandle__SWIG_0'))

# Start of new_OptionletVolatilityStructureHandle

`OptionletVolatilityStructureHandle__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_OptionletVolatilityStructureHandle__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_HandleT_OptionletVolatilityStructure_t";
  
  reg.finalizer(ans, delete_OptionletVolatilityStructureHandle)
  ans
  
}

attr(`OptionletVolatilityStructureHandle__SWIG_1`, 'returnType') = '_p_HandleT_OptionletVolatilityStructure_t'
class(`OptionletVolatilityStructureHandle__SWIG_1`) = c("SWIGFunction", class('OptionletVolatilityStructureHandle__SWIG_1'))

`OptionletVolatilityStructureHandle` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- OptionletVolatilityStructureHandle__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_OptionletVolatilityStructure_t')) {
      f <- OptionletVolatilityStructureHandle__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for OptionletVolatilityStructureHandle with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of OptionletVolatilityStructureHandle___deref__

`OptionletVolatilityStructureHandle___deref__` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_OptionletVolatilityStructureHandle___deref__', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_OptionletVolatilityStructure_t";
  
  ans
  
}

attr(`OptionletVolatilityStructureHandle___deref__`, 'returnType') = '_p_boost__shared_ptrT_OptionletVolatilityStructure_t'
attr(`OptionletVolatilityStructureHandle___deref__`, "inputTypes") = c('_p_HandleT_OptionletVolatilityStructure_t')
class(`OptionletVolatilityStructureHandle___deref__`) = c("SWIGFunction", class('OptionletVolatilityStructureHandle___deref__'))

# Start of OptionletVolatilityStructureHandle_empty

`OptionletVolatilityStructureHandle_empty` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_OptionletVolatilityStructureHandle_empty', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`OptionletVolatilityStructureHandle_empty`, 'returnType') = 'logical'
attr(`OptionletVolatilityStructureHandle_empty`, "inputTypes") = c('_p_HandleT_OptionletVolatilityStructure_t')
class(`OptionletVolatilityStructureHandle_empty`) = c("SWIGFunction", class('OptionletVolatilityStructureHandle_empty'))

# Start of OptionletVolatilityStructureHandle_asObservable

`OptionletVolatilityStructureHandle_asObservable` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_OptionletVolatilityStructureHandle_asObservable', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_Observable_t";
  
  ans
  
}

attr(`OptionletVolatilityStructureHandle_asObservable`, 'returnType') = '_p_boost__shared_ptrT_Observable_t'
attr(`OptionletVolatilityStructureHandle_asObservable`, "inputTypes") = c('_p_HandleT_OptionletVolatilityStructure_t')
class(`OptionletVolatilityStructureHandle_asObservable`) = c("SWIGFunction", class('OptionletVolatilityStructureHandle_asObservable'))

# Start of delete_OptionletVolatilityStructureHandle

`delete_OptionletVolatilityStructureHandle` = function(self)
{
  ;.Call('R_swig_delete_OptionletVolatilityStructureHandle', self, PACKAGE='QuantLib');
  
}

attr(`delete_OptionletVolatilityStructureHandle`, 'returnType') = 'void'
attr(`delete_OptionletVolatilityStructureHandle`, "inputTypes") = c('_p_HandleT_OptionletVolatilityStructure_t')
class(`delete_OptionletVolatilityStructureHandle`) = c("SWIGFunction", class('delete_OptionletVolatilityStructureHandle'))

# Start of OptionletVolatilityStructureHandle_referenceDate

`OptionletVolatilityStructureHandle_referenceDate` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_OptionletVolatilityStructureHandle_referenceDate', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`OptionletVolatilityStructureHandle_referenceDate`, 'returnType') = '_p_Date'
attr(`OptionletVolatilityStructureHandle_referenceDate`, "inputTypes") = c('_p_HandleT_OptionletVolatilityStructure_t')
class(`OptionletVolatilityStructureHandle_referenceDate`) = c("SWIGFunction", class('OptionletVolatilityStructureHandle_referenceDate'))

# Start of OptionletVolatilityStructureHandle_dayCounter

`OptionletVolatilityStructureHandle_dayCounter` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_OptionletVolatilityStructureHandle_dayCounter', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_DayCounter";
  
  ans
  
}

attr(`OptionletVolatilityStructureHandle_dayCounter`, 'returnType') = '_p_DayCounter'
attr(`OptionletVolatilityStructureHandle_dayCounter`, "inputTypes") = c('_p_HandleT_OptionletVolatilityStructure_t')
class(`OptionletVolatilityStructureHandle_dayCounter`) = c("SWIGFunction", class('OptionletVolatilityStructureHandle_dayCounter'))

# Start of OptionletVolatilityStructureHandle_calendar

`OptionletVolatilityStructureHandle_calendar` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_OptionletVolatilityStructureHandle_calendar', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Calendar";
  
  ans
  
}

attr(`OptionletVolatilityStructureHandle_calendar`, 'returnType') = '_p_Calendar'
attr(`OptionletVolatilityStructureHandle_calendar`, "inputTypes") = c('_p_HandleT_OptionletVolatilityStructure_t')
class(`OptionletVolatilityStructureHandle_calendar`) = c("SWIGFunction", class('OptionletVolatilityStructureHandle_calendar'))

# Start of OptionletVolatilityStructureHandle_maxDate

`OptionletVolatilityStructureHandle_maxDate` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_OptionletVolatilityStructureHandle_maxDate', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`OptionletVolatilityStructureHandle_maxDate`, 'returnType') = '_p_Date'
attr(`OptionletVolatilityStructureHandle_maxDate`, "inputTypes") = c('_p_HandleT_OptionletVolatilityStructure_t')
class(`OptionletVolatilityStructureHandle_maxDate`) = c("SWIGFunction", class('OptionletVolatilityStructureHandle_maxDate'))

# Start of OptionletVolatilityStructureHandle_maxTime

`OptionletVolatilityStructureHandle_maxTime` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_OptionletVolatilityStructureHandle_maxTime', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`OptionletVolatilityStructureHandle_maxTime`, 'returnType') = 'numeric'
attr(`OptionletVolatilityStructureHandle_maxTime`, "inputTypes") = c('_p_HandleT_OptionletVolatilityStructure_t')
class(`OptionletVolatilityStructureHandle_maxTime`) = c("SWIGFunction", class('OptionletVolatilityStructureHandle_maxTime'))

# Start of OptionletVolatilityStructureHandle_minStrike

`OptionletVolatilityStructureHandle_minStrike` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_OptionletVolatilityStructureHandle_minStrike', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`OptionletVolatilityStructureHandle_minStrike`, 'returnType') = 'numeric'
attr(`OptionletVolatilityStructureHandle_minStrike`, "inputTypes") = c('_p_HandleT_OptionletVolatilityStructure_t')
class(`OptionletVolatilityStructureHandle_minStrike`) = c("SWIGFunction", class('OptionletVolatilityStructureHandle_minStrike'))

# Start of OptionletVolatilityStructureHandle_maxStrike

`OptionletVolatilityStructureHandle_maxStrike` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_OptionletVolatilityStructureHandle_maxStrike', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`OptionletVolatilityStructureHandle_maxStrike`, 'returnType') = 'numeric'
attr(`OptionletVolatilityStructureHandle_maxStrike`, "inputTypes") = c('_p_HandleT_OptionletVolatilityStructure_t')
class(`OptionletVolatilityStructureHandle_maxStrike`) = c("SWIGFunction", class('OptionletVolatilityStructureHandle_maxStrike'))

# Start of OptionletVolatilityStructureHandle_volatility

`OptionletVolatilityStructureHandle_volatility__SWIG_0` = function(self, s_arg2, strike, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_OptionletVolatilityStructureHandle_volatility__SWIG_0', self, s_arg2, strike, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`OptionletVolatilityStructureHandle_volatility__SWIG_0`, 'returnType') = 'numeric'
attr(`OptionletVolatilityStructureHandle_volatility__SWIG_0`, "inputTypes") = c('_p_HandleT_OptionletVolatilityStructure_t', '_p_Date', 'numeric', 'logical')
class(`OptionletVolatilityStructureHandle_volatility__SWIG_0`) = c("SWIGFunction", class('OptionletVolatilityStructureHandle_volatility__SWIG_0'))

# Start of OptionletVolatilityStructureHandle_volatility

`OptionletVolatilityStructureHandle_volatility__SWIG_1` = function(self, s_arg2, strike, .copy = FALSE)
{
  ;.Call('R_swig_OptionletVolatilityStructureHandle_volatility__SWIG_1', self, s_arg2, strike, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`OptionletVolatilityStructureHandle_volatility__SWIG_1`, 'returnType') = 'numeric'
attr(`OptionletVolatilityStructureHandle_volatility__SWIG_1`, "inputTypes") = c('_p_HandleT_OptionletVolatilityStructure_t', '_p_Date', 'numeric')
class(`OptionletVolatilityStructureHandle_volatility__SWIG_1`) = c("SWIGFunction", class('OptionletVolatilityStructureHandle_volatility__SWIG_1'))

# Start of OptionletVolatilityStructureHandle_volatility

`OptionletVolatilityStructureHandle_volatility__SWIG_2` = function(self, s_arg2, strike, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_OptionletVolatilityStructureHandle_volatility__SWIG_2', self, s_arg2, strike, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`OptionletVolatilityStructureHandle_volatility__SWIG_2`, 'returnType') = 'numeric'
attr(`OptionletVolatilityStructureHandle_volatility__SWIG_2`, "inputTypes") = c('_p_HandleT_OptionletVolatilityStructure_t', 'numeric', 'numeric', 'logical')
class(`OptionletVolatilityStructureHandle_volatility__SWIG_2`) = c("SWIGFunction", class('OptionletVolatilityStructureHandle_volatility__SWIG_2'))

# Start of OptionletVolatilityStructureHandle_volatility

`OptionletVolatilityStructureHandle_volatility__SWIG_3` = function(self, s_arg2, strike, .copy = FALSE)
{
  ;.Call('R_swig_OptionletVolatilityStructureHandle_volatility__SWIG_3', self, s_arg2, strike, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`OptionletVolatilityStructureHandle_volatility__SWIG_3`, 'returnType') = 'numeric'
attr(`OptionletVolatilityStructureHandle_volatility__SWIG_3`, "inputTypes") = c('_p_HandleT_OptionletVolatilityStructure_t', 'numeric', 'numeric')
class(`OptionletVolatilityStructureHandle_volatility__SWIG_3`) = c("SWIGFunction", class('OptionletVolatilityStructureHandle_volatility__SWIG_3'))

`OptionletVolatilityStructureHandle_volatility` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 3) {
    if (extends(argtypes[1], '_p_HandleT_OptionletVolatilityStructure_t') && extends(argtypes[2], '_p_Date') && is.numeric(argv[[3]])) {
      f <- OptionletVolatilityStructureHandle_volatility__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_HandleT_OptionletVolatilityStructure_t') && is.numeric(argv[[2]]) && is.numeric(argv[[3]])) {
      f <- OptionletVolatilityStructureHandle_volatility__SWIG_3; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_HandleT_OptionletVolatilityStructure_t') && extends(argtypes[2], '_p_Date') && is.numeric(argv[[3]]) && extends(argtypes[4], 'logical')) {
      f <- OptionletVolatilityStructureHandle_volatility__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_HandleT_OptionletVolatilityStructure_t') && is.numeric(argv[[2]]) && is.numeric(argv[[3]]) && extends(argtypes[4], 'logical')) {
      f <- OptionletVolatilityStructureHandle_volatility__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for OptionletVolatilityStructureHandle_volatility with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of OptionletVolatilityStructureHandle_blackVariance

`OptionletVolatilityStructureHandle_blackVariance__SWIG_0` = function(self, s_arg2, strike, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_OptionletVolatilityStructureHandle_blackVariance__SWIG_0', self, s_arg2, strike, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`OptionletVolatilityStructureHandle_blackVariance__SWIG_0`, 'returnType') = 'numeric'
attr(`OptionletVolatilityStructureHandle_blackVariance__SWIG_0`, "inputTypes") = c('_p_HandleT_OptionletVolatilityStructure_t', '_p_Date', 'numeric', 'logical')
class(`OptionletVolatilityStructureHandle_blackVariance__SWIG_0`) = c("SWIGFunction", class('OptionletVolatilityStructureHandle_blackVariance__SWIG_0'))

# Start of OptionletVolatilityStructureHandle_blackVariance

`OptionletVolatilityStructureHandle_blackVariance__SWIG_1` = function(self, s_arg2, strike, .copy = FALSE)
{
  ;.Call('R_swig_OptionletVolatilityStructureHandle_blackVariance__SWIG_1', self, s_arg2, strike, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`OptionletVolatilityStructureHandle_blackVariance__SWIG_1`, 'returnType') = 'numeric'
attr(`OptionletVolatilityStructureHandle_blackVariance__SWIG_1`, "inputTypes") = c('_p_HandleT_OptionletVolatilityStructure_t', '_p_Date', 'numeric')
class(`OptionletVolatilityStructureHandle_blackVariance__SWIG_1`) = c("SWIGFunction", class('OptionletVolatilityStructureHandle_blackVariance__SWIG_1'))

# Start of OptionletVolatilityStructureHandle_blackVariance

`OptionletVolatilityStructureHandle_blackVariance__SWIG_2` = function(self, s_arg2, strike, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_OptionletVolatilityStructureHandle_blackVariance__SWIG_2', self, s_arg2, strike, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`OptionletVolatilityStructureHandle_blackVariance__SWIG_2`, 'returnType') = 'numeric'
attr(`OptionletVolatilityStructureHandle_blackVariance__SWIG_2`, "inputTypes") = c('_p_HandleT_OptionletVolatilityStructure_t', 'numeric', 'numeric', 'logical')
class(`OptionletVolatilityStructureHandle_blackVariance__SWIG_2`) = c("SWIGFunction", class('OptionletVolatilityStructureHandle_blackVariance__SWIG_2'))

# Start of OptionletVolatilityStructureHandle_blackVariance

`OptionletVolatilityStructureHandle_blackVariance__SWIG_3` = function(self, s_arg2, strike, .copy = FALSE)
{
  ;.Call('R_swig_OptionletVolatilityStructureHandle_blackVariance__SWIG_3', self, s_arg2, strike, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`OptionletVolatilityStructureHandle_blackVariance__SWIG_3`, 'returnType') = 'numeric'
attr(`OptionletVolatilityStructureHandle_blackVariance__SWIG_3`, "inputTypes") = c('_p_HandleT_OptionletVolatilityStructure_t', 'numeric', 'numeric')
class(`OptionletVolatilityStructureHandle_blackVariance__SWIG_3`) = c("SWIGFunction", class('OptionletVolatilityStructureHandle_blackVariance__SWIG_3'))

`OptionletVolatilityStructureHandle_blackVariance` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 3) {
    if (extends(argtypes[1], '_p_HandleT_OptionletVolatilityStructure_t') && extends(argtypes[2], '_p_Date') && is.numeric(argv[[3]])) {
      f <- OptionletVolatilityStructureHandle_blackVariance__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_HandleT_OptionletVolatilityStructure_t') && is.numeric(argv[[2]]) && is.numeric(argv[[3]])) {
      f <- OptionletVolatilityStructureHandle_blackVariance__SWIG_3; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_HandleT_OptionletVolatilityStructure_t') && extends(argtypes[2], '_p_Date') && is.numeric(argv[[3]]) && extends(argtypes[4], 'logical')) {
      f <- OptionletVolatilityStructureHandle_blackVariance__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_HandleT_OptionletVolatilityStructure_t') && is.numeric(argv[[2]]) && is.numeric(argv[[3]]) && extends(argtypes[4], 'logical')) {
      f <- OptionletVolatilityStructureHandle_blackVariance__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for OptionletVolatilityStructureHandle_blackVariance with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of OptionletVolatilityStructureHandle_enableExtrapolation

`OptionletVolatilityStructureHandle_enableExtrapolation` = function(self)
{
  ;.Call('R_swig_OptionletVolatilityStructureHandle_enableExtrapolation', self, PACKAGE='QuantLib');
  
}

attr(`OptionletVolatilityStructureHandle_enableExtrapolation`, 'returnType') = 'void'
attr(`OptionletVolatilityStructureHandle_enableExtrapolation`, "inputTypes") = c('_p_HandleT_OptionletVolatilityStructure_t')
class(`OptionletVolatilityStructureHandle_enableExtrapolation`) = c("SWIGFunction", class('OptionletVolatilityStructureHandle_enableExtrapolation'))

# Start of OptionletVolatilityStructureHandle_disableExtrapolation

`OptionletVolatilityStructureHandle_disableExtrapolation` = function(self)
{
  ;.Call('R_swig_OptionletVolatilityStructureHandle_disableExtrapolation', self, PACKAGE='QuantLib');
  
}

attr(`OptionletVolatilityStructureHandle_disableExtrapolation`, 'returnType') = 'void'
attr(`OptionletVolatilityStructureHandle_disableExtrapolation`, "inputTypes") = c('_p_HandleT_OptionletVolatilityStructure_t')
class(`OptionletVolatilityStructureHandle_disableExtrapolation`) = c("SWIGFunction", class('OptionletVolatilityStructureHandle_disableExtrapolation'))

# Start of OptionletVolatilityStructureHandle_allowsExtrapolation

`OptionletVolatilityStructureHandle_allowsExtrapolation` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_OptionletVolatilityStructureHandle_allowsExtrapolation', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`OptionletVolatilityStructureHandle_allowsExtrapolation`, 'returnType') = 'logical'
attr(`OptionletVolatilityStructureHandle_allowsExtrapolation`, "inputTypes") = c('_p_HandleT_OptionletVolatilityStructure_t')
class(`OptionletVolatilityStructureHandle_allowsExtrapolation`) = c("SWIGFunction", class('OptionletVolatilityStructureHandle_allowsExtrapolation'))

# Start of accessor method for Handle<(OptionletVolatilityStructure)>
setMethod('$', '_p_HandleT_OptionletVolatilityStructure_t', function(x, name)

{
  accessorFuns = list('__deref__' = OptionletVolatilityStructureHandle___deref__, 'empty' = OptionletVolatilityStructureHandle_empty, 'asObservable' = OptionletVolatilityStructureHandle_asObservable, 'referenceDate' = OptionletVolatilityStructureHandle_referenceDate, 'dayCounter' = OptionletVolatilityStructureHandle_dayCounter, 'calendar' = OptionletVolatilityStructureHandle_calendar, 'maxDate' = OptionletVolatilityStructureHandle_maxDate, 'maxTime' = OptionletVolatilityStructureHandle_maxTime, 'minStrike' = OptionletVolatilityStructureHandle_minStrike, 'maxStrike' = OptionletVolatilityStructureHandle_maxStrike, 'volatility' = OptionletVolatilityStructureHandle_volatility, 'blackVariance' = OptionletVolatilityStructureHandle_blackVariance, 'enableExtrapolation' = OptionletVolatilityStructureHandle_enableExtrapolation, 'disableExtrapolation' = OptionletVolatilityStructureHandle_disableExtrapolation, 'allowsExtrapolation' = OptionletVolatilityStructureHandle_allowsExtrapolation);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for Handle<(OptionletVolatilityStructure)>
setMethod('delete', '_p_HandleT_OptionletVolatilityStructure_t', function(obj) {delete_HandleT_OptionletVolatilityStructure_t(obj)})
# Start of new_RelinkableOptionletVolatilityStructureHandle

`RelinkableOptionletVolatilityStructureHandle__SWIG_0` = function(s_arg1)
{
  ;ans = .Call('R_swig_new_RelinkableOptionletVolatilityStructureHandle__SWIG_0', s_arg1, PACKAGE='QuantLib');
  class(ans) <- "_p_RelinkableHandleT_OptionletVolatilityStructure_t";
  
  reg.finalizer(ans, delete_RelinkableOptionletVolatilityStructureHandle)
  ans
  
}

attr(`RelinkableOptionletVolatilityStructureHandle__SWIG_0`, 'returnType') = '_p_RelinkableHandleT_OptionletVolatilityStructure_t'
attr(`RelinkableOptionletVolatilityStructureHandle__SWIG_0`, "inputTypes") = c('_p_boost__shared_ptrT_OptionletVolatilityStructure_t')
class(`RelinkableOptionletVolatilityStructureHandle__SWIG_0`) = c("SWIGFunction", class('RelinkableOptionletVolatilityStructureHandle__SWIG_0'))

# Start of new_RelinkableOptionletVolatilityStructureHandle

`RelinkableOptionletVolatilityStructureHandle__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_RelinkableOptionletVolatilityStructureHandle__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_RelinkableHandleT_OptionletVolatilityStructure_t";
  
  reg.finalizer(ans, delete_RelinkableOptionletVolatilityStructureHandle)
  ans
  
}

attr(`RelinkableOptionletVolatilityStructureHandle__SWIG_1`, 'returnType') = '_p_RelinkableHandleT_OptionletVolatilityStructure_t'
class(`RelinkableOptionletVolatilityStructureHandle__SWIG_1`) = c("SWIGFunction", class('RelinkableOptionletVolatilityStructureHandle__SWIG_1'))

`RelinkableOptionletVolatilityStructureHandle` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- RelinkableOptionletVolatilityStructureHandle__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_OptionletVolatilityStructure_t')) {
      f <- RelinkableOptionletVolatilityStructureHandle__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for RelinkableOptionletVolatilityStructureHandle with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of RelinkableOptionletVolatilityStructureHandle_linkTo

`RelinkableOptionletVolatilityStructureHandle_linkTo` = function(self, s_arg2)
{
  ;.Call('R_swig_RelinkableOptionletVolatilityStructureHandle_linkTo', self, s_arg2, PACKAGE='QuantLib');
  
}

attr(`RelinkableOptionletVolatilityStructureHandle_linkTo`, 'returnType') = 'void'
attr(`RelinkableOptionletVolatilityStructureHandle_linkTo`, "inputTypes") = c('_p_RelinkableHandleT_OptionletVolatilityStructure_t', '_p_boost__shared_ptrT_OptionletVolatilityStructure_t')
class(`RelinkableOptionletVolatilityStructureHandle_linkTo`) = c("SWIGFunction", class('RelinkableOptionletVolatilityStructureHandle_linkTo'))

# Start of delete_RelinkableOptionletVolatilityStructureHandle

`delete_RelinkableOptionletVolatilityStructureHandle` = function(self)
{
  ;.Call('R_swig_delete_RelinkableOptionletVolatilityStructureHandle', self, PACKAGE='QuantLib');
  
}

attr(`delete_RelinkableOptionletVolatilityStructureHandle`, 'returnType') = 'void'
attr(`delete_RelinkableOptionletVolatilityStructureHandle`, "inputTypes") = c('_p_RelinkableHandleT_OptionletVolatilityStructure_t')
class(`delete_RelinkableOptionletVolatilityStructureHandle`) = c("SWIGFunction", class('delete_RelinkableOptionletVolatilityStructureHandle'))

# Start of accessor method for RelinkableHandle<(OptionletVolatilityStructure)>
setMethod('$', '_p_RelinkableHandleT_OptionletVolatilityStructure_t', function(x, name)

{
  accessorFuns = list('linkTo' = RelinkableOptionletVolatilityStructureHandle_linkTo);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for RelinkableHandle<(OptionletVolatilityStructure)>
setMethod('delete', '_p_RelinkableHandleT_OptionletVolatilityStructure_t', function(obj) {delete_RelinkableHandleT_OptionletVolatilityStructure_t(obj)})
# Start of SwaptionVolatilityStructure___deref__

`SwaptionVolatilityStructure___deref__` = function(self)
{
  ;ans = .Call('R_swig_SwaptionVolatilityStructure___deref__', self, PACKAGE='QuantLib');
  class(ans) <- "_p_SwaptionVolatilityStructure";
  
  ans
  
}

attr(`SwaptionVolatilityStructure___deref__`, 'returnType') = '_p_SwaptionVolatilityStructure'
attr(`SwaptionVolatilityStructure___deref__`, "inputTypes") = c('_p_boost__shared_ptrT_SwaptionVolatilityStructure_t')
class(`SwaptionVolatilityStructure___deref__`) = c("SWIGFunction", class('SwaptionVolatilityStructure___deref__'))

# Start of SwaptionVolatilityStructure_isNull

`SwaptionVolatilityStructure_isNull` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_SwaptionVolatilityStructure_isNull', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`SwaptionVolatilityStructure_isNull`, 'returnType') = 'logical'
attr(`SwaptionVolatilityStructure_isNull`, "inputTypes") = c('_p_boost__shared_ptrT_SwaptionVolatilityStructure_t')
class(`SwaptionVolatilityStructure_isNull`) = c("SWIGFunction", class('SwaptionVolatilityStructure_isNull'))

# Start of SwaptionVolatilityStructure_asObservable

`SwaptionVolatilityStructure_asObservable` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_SwaptionVolatilityStructure_asObservable', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_Observable_t";
  
  ans
  
}

attr(`SwaptionVolatilityStructure_asObservable`, 'returnType') = '_p_boost__shared_ptrT_Observable_t'
attr(`SwaptionVolatilityStructure_asObservable`, "inputTypes") = c('_p_boost__shared_ptrT_SwaptionVolatilityStructure_t')
class(`SwaptionVolatilityStructure_asObservable`) = c("SWIGFunction", class('SwaptionVolatilityStructure_asObservable'))

# Start of new_SwaptionVolatilityStructure

`SwaptionVolatilityStructure` = function()
{
  ;ans = .Call('R_swig_new_SwaptionVolatilityStructure', PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_SwaptionVolatilityStructure_t";
  
  reg.finalizer(ans, delete_SwaptionVolatilityStructure)
  ans
  
}

attr(`SwaptionVolatilityStructure`, 'returnType') = '_p_boost__shared_ptrT_SwaptionVolatilityStructure_t'
class(`SwaptionVolatilityStructure`) = c("SWIGFunction", class('SwaptionVolatilityStructure'))

# Start of delete_SwaptionVolatilityStructure

`delete_SwaptionVolatilityStructure` = function(self)
{
  ;.Call('R_swig_delete_SwaptionVolatilityStructure', self, PACKAGE='QuantLib');
  
}

attr(`delete_SwaptionVolatilityStructure`, 'returnType') = 'void'
attr(`delete_SwaptionVolatilityStructure`, "inputTypes") = c('_p_boost__shared_ptrT_SwaptionVolatilityStructure_t')
class(`delete_SwaptionVolatilityStructure`) = c("SWIGFunction", class('delete_SwaptionVolatilityStructure'))

# Start of SwaptionVolatilityStructure_referenceDate

`SwaptionVolatilityStructure_referenceDate` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_SwaptionVolatilityStructure_referenceDate', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`SwaptionVolatilityStructure_referenceDate`, 'returnType') = '_p_Date'
attr(`SwaptionVolatilityStructure_referenceDate`, "inputTypes") = c('_p_boost__shared_ptrT_SwaptionVolatilityStructure_t')
class(`SwaptionVolatilityStructure_referenceDate`) = c("SWIGFunction", class('SwaptionVolatilityStructure_referenceDate'))

# Start of SwaptionVolatilityStructure_dayCounter

`SwaptionVolatilityStructure_dayCounter` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_SwaptionVolatilityStructure_dayCounter', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_DayCounter";
  
  ans
  
}

attr(`SwaptionVolatilityStructure_dayCounter`, 'returnType') = '_p_DayCounter'
attr(`SwaptionVolatilityStructure_dayCounter`, "inputTypes") = c('_p_boost__shared_ptrT_SwaptionVolatilityStructure_t')
class(`SwaptionVolatilityStructure_dayCounter`) = c("SWIGFunction", class('SwaptionVolatilityStructure_dayCounter'))

# Start of SwaptionVolatilityStructure_calendar

`SwaptionVolatilityStructure_calendar` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_SwaptionVolatilityStructure_calendar', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Calendar";
  
  ans
  
}

attr(`SwaptionVolatilityStructure_calendar`, 'returnType') = '_p_Calendar'
attr(`SwaptionVolatilityStructure_calendar`, "inputTypes") = c('_p_boost__shared_ptrT_SwaptionVolatilityStructure_t')
class(`SwaptionVolatilityStructure_calendar`) = c("SWIGFunction", class('SwaptionVolatilityStructure_calendar'))

# Start of SwaptionVolatilityStructure_maxSwapTenor

`SwaptionVolatilityStructure_maxSwapTenor` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_SwaptionVolatilityStructure_maxSwapTenor', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Period";
  
  ans
  
}

attr(`SwaptionVolatilityStructure_maxSwapTenor`, 'returnType') = '_p_Period'
attr(`SwaptionVolatilityStructure_maxSwapTenor`, "inputTypes") = c('_p_boost__shared_ptrT_SwaptionVolatilityStructure_t')
class(`SwaptionVolatilityStructure_maxSwapTenor`) = c("SWIGFunction", class('SwaptionVolatilityStructure_maxSwapTenor'))

# Start of SwaptionVolatilityStructure_maxSwapLength

`SwaptionVolatilityStructure_maxSwapLength` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_SwaptionVolatilityStructure_maxSwapLength', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`SwaptionVolatilityStructure_maxSwapLength`, 'returnType') = 'numeric'
attr(`SwaptionVolatilityStructure_maxSwapLength`, "inputTypes") = c('_p_boost__shared_ptrT_SwaptionVolatilityStructure_t')
class(`SwaptionVolatilityStructure_maxSwapLength`) = c("SWIGFunction", class('SwaptionVolatilityStructure_maxSwapLength'))

# Start of SwaptionVolatilityStructure_minStrike

`SwaptionVolatilityStructure_minStrike` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_SwaptionVolatilityStructure_minStrike', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`SwaptionVolatilityStructure_minStrike`, 'returnType') = 'numeric'
attr(`SwaptionVolatilityStructure_minStrike`, "inputTypes") = c('_p_boost__shared_ptrT_SwaptionVolatilityStructure_t')
class(`SwaptionVolatilityStructure_minStrike`) = c("SWIGFunction", class('SwaptionVolatilityStructure_minStrike'))

# Start of SwaptionVolatilityStructure_maxStrike

`SwaptionVolatilityStructure_maxStrike` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_SwaptionVolatilityStructure_maxStrike', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`SwaptionVolatilityStructure_maxStrike`, 'returnType') = 'numeric'
attr(`SwaptionVolatilityStructure_maxStrike`, "inputTypes") = c('_p_boost__shared_ptrT_SwaptionVolatilityStructure_t')
class(`SwaptionVolatilityStructure_maxStrike`) = c("SWIGFunction", class('SwaptionVolatilityStructure_maxStrike'))

# Start of SwaptionVolatilityStructure_volatility

`SwaptionVolatilityStructure_volatility__SWIG_0` = function(self, start, length, strike, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_SwaptionVolatilityStructure_volatility__SWIG_0', self, start, length, strike, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`SwaptionVolatilityStructure_volatility__SWIG_0`, 'returnType') = 'numeric'
attr(`SwaptionVolatilityStructure_volatility__SWIG_0`, "inputTypes") = c('_p_boost__shared_ptrT_SwaptionVolatilityStructure_t', '_p_Date', '_p_Period', 'numeric', 'logical')
class(`SwaptionVolatilityStructure_volatility__SWIG_0`) = c("SWIGFunction", class('SwaptionVolatilityStructure_volatility__SWIG_0'))

# Start of SwaptionVolatilityStructure_volatility

`SwaptionVolatilityStructure_volatility__SWIG_1` = function(self, start, length, strike, .copy = FALSE)
{
  ;.Call('R_swig_SwaptionVolatilityStructure_volatility__SWIG_1', self, start, length, strike, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`SwaptionVolatilityStructure_volatility__SWIG_1`, 'returnType') = 'numeric'
attr(`SwaptionVolatilityStructure_volatility__SWIG_1`, "inputTypes") = c('_p_boost__shared_ptrT_SwaptionVolatilityStructure_t', '_p_Date', '_p_Period', 'numeric')
class(`SwaptionVolatilityStructure_volatility__SWIG_1`) = c("SWIGFunction", class('SwaptionVolatilityStructure_volatility__SWIG_1'))

# Start of SwaptionVolatilityStructure_volatility

`SwaptionVolatilityStructure_volatility__SWIG_2` = function(self, start, length, strike, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_SwaptionVolatilityStructure_volatility__SWIG_2', self, start, length, strike, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`SwaptionVolatilityStructure_volatility__SWIG_2`, 'returnType') = 'numeric'
attr(`SwaptionVolatilityStructure_volatility__SWIG_2`, "inputTypes") = c('_p_boost__shared_ptrT_SwaptionVolatilityStructure_t', 'numeric', 'numeric', 'numeric', 'logical')
class(`SwaptionVolatilityStructure_volatility__SWIG_2`) = c("SWIGFunction", class('SwaptionVolatilityStructure_volatility__SWIG_2'))

# Start of SwaptionVolatilityStructure_volatility

`SwaptionVolatilityStructure_volatility__SWIG_3` = function(self, start, length, strike, .copy = FALSE)
{
  ;.Call('R_swig_SwaptionVolatilityStructure_volatility__SWIG_3', self, start, length, strike, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`SwaptionVolatilityStructure_volatility__SWIG_3`, 'returnType') = 'numeric'
attr(`SwaptionVolatilityStructure_volatility__SWIG_3`, "inputTypes") = c('_p_boost__shared_ptrT_SwaptionVolatilityStructure_t', 'numeric', 'numeric', 'numeric')
class(`SwaptionVolatilityStructure_volatility__SWIG_3`) = c("SWIGFunction", class('SwaptionVolatilityStructure_volatility__SWIG_3'))

`SwaptionVolatilityStructure_volatility` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 4) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_SwaptionVolatilityStructure_t') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_Period') && is.numeric(argv[[4]])) {
      f <- SwaptionVolatilityStructure_volatility__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_boost__shared_ptrT_SwaptionVolatilityStructure_t') && is.numeric(argv[[2]]) && is.numeric(argv[[3]]) && is.numeric(argv[[4]])) {
      f <- SwaptionVolatilityStructure_volatility__SWIG_3; 
    }
  } else if (argc == 5) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_SwaptionVolatilityStructure_t') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_Period') && is.numeric(argv[[4]]) && extends(argtypes[5], 'logical')) {
      f <- SwaptionVolatilityStructure_volatility__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_boost__shared_ptrT_SwaptionVolatilityStructure_t') && is.numeric(argv[[2]]) && is.numeric(argv[[3]]) && is.numeric(argv[[4]]) && extends(argtypes[5], 'logical')) {
      f <- SwaptionVolatilityStructure_volatility__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for SwaptionVolatilityStructure_volatility with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of SwaptionVolatilityStructure_blackVariance

`SwaptionVolatilityStructure_blackVariance__SWIG_0` = function(self, start, length, strike, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_SwaptionVolatilityStructure_blackVariance__SWIG_0', self, start, length, strike, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`SwaptionVolatilityStructure_blackVariance__SWIG_0`, 'returnType') = 'numeric'
attr(`SwaptionVolatilityStructure_blackVariance__SWIG_0`, "inputTypes") = c('_p_boost__shared_ptrT_SwaptionVolatilityStructure_t', '_p_Date', '_p_Period', 'numeric', 'logical')
class(`SwaptionVolatilityStructure_blackVariance__SWIG_0`) = c("SWIGFunction", class('SwaptionVolatilityStructure_blackVariance__SWIG_0'))

# Start of SwaptionVolatilityStructure_blackVariance

`SwaptionVolatilityStructure_blackVariance__SWIG_1` = function(self, start, length, strike, .copy = FALSE)
{
  ;.Call('R_swig_SwaptionVolatilityStructure_blackVariance__SWIG_1', self, start, length, strike, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`SwaptionVolatilityStructure_blackVariance__SWIG_1`, 'returnType') = 'numeric'
attr(`SwaptionVolatilityStructure_blackVariance__SWIG_1`, "inputTypes") = c('_p_boost__shared_ptrT_SwaptionVolatilityStructure_t', '_p_Date', '_p_Period', 'numeric')
class(`SwaptionVolatilityStructure_blackVariance__SWIG_1`) = c("SWIGFunction", class('SwaptionVolatilityStructure_blackVariance__SWIG_1'))

# Start of SwaptionVolatilityStructure_blackVariance

`SwaptionVolatilityStructure_blackVariance__SWIG_2` = function(self, start, length, strike, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_SwaptionVolatilityStructure_blackVariance__SWIG_2', self, start, length, strike, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`SwaptionVolatilityStructure_blackVariance__SWIG_2`, 'returnType') = 'numeric'
attr(`SwaptionVolatilityStructure_blackVariance__SWIG_2`, "inputTypes") = c('_p_boost__shared_ptrT_SwaptionVolatilityStructure_t', 'numeric', 'numeric', 'numeric', 'logical')
class(`SwaptionVolatilityStructure_blackVariance__SWIG_2`) = c("SWIGFunction", class('SwaptionVolatilityStructure_blackVariance__SWIG_2'))

# Start of SwaptionVolatilityStructure_blackVariance

`SwaptionVolatilityStructure_blackVariance__SWIG_3` = function(self, start, length, strike, .copy = FALSE)
{
  ;.Call('R_swig_SwaptionVolatilityStructure_blackVariance__SWIG_3', self, start, length, strike, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`SwaptionVolatilityStructure_blackVariance__SWIG_3`, 'returnType') = 'numeric'
attr(`SwaptionVolatilityStructure_blackVariance__SWIG_3`, "inputTypes") = c('_p_boost__shared_ptrT_SwaptionVolatilityStructure_t', 'numeric', 'numeric', 'numeric')
class(`SwaptionVolatilityStructure_blackVariance__SWIG_3`) = c("SWIGFunction", class('SwaptionVolatilityStructure_blackVariance__SWIG_3'))

`SwaptionVolatilityStructure_blackVariance` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 4) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_SwaptionVolatilityStructure_t') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_Period') && is.numeric(argv[[4]])) {
      f <- SwaptionVolatilityStructure_blackVariance__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_boost__shared_ptrT_SwaptionVolatilityStructure_t') && is.numeric(argv[[2]]) && is.numeric(argv[[3]]) && is.numeric(argv[[4]])) {
      f <- SwaptionVolatilityStructure_blackVariance__SWIG_3; 
    }
  } else if (argc == 5) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_SwaptionVolatilityStructure_t') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_Period') && is.numeric(argv[[4]]) && extends(argtypes[5], 'logical')) {
      f <- SwaptionVolatilityStructure_blackVariance__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_boost__shared_ptrT_SwaptionVolatilityStructure_t') && is.numeric(argv[[2]]) && is.numeric(argv[[3]]) && is.numeric(argv[[4]]) && extends(argtypes[5], 'logical')) {
      f <- SwaptionVolatilityStructure_blackVariance__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for SwaptionVolatilityStructure_blackVariance with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of SwaptionVolatilityStructure_enableExtrapolation

`SwaptionVolatilityStructure_enableExtrapolation` = function(self)
{
  ;.Call('R_swig_SwaptionVolatilityStructure_enableExtrapolation', self, PACKAGE='QuantLib');
  
}

attr(`SwaptionVolatilityStructure_enableExtrapolation`, 'returnType') = 'void'
attr(`SwaptionVolatilityStructure_enableExtrapolation`, "inputTypes") = c('_p_boost__shared_ptrT_SwaptionVolatilityStructure_t')
class(`SwaptionVolatilityStructure_enableExtrapolation`) = c("SWIGFunction", class('SwaptionVolatilityStructure_enableExtrapolation'))

# Start of SwaptionVolatilityStructure_disableExtrapolation

`SwaptionVolatilityStructure_disableExtrapolation` = function(self)
{
  ;.Call('R_swig_SwaptionVolatilityStructure_disableExtrapolation', self, PACKAGE='QuantLib');
  
}

attr(`SwaptionVolatilityStructure_disableExtrapolation`, 'returnType') = 'void'
attr(`SwaptionVolatilityStructure_disableExtrapolation`, "inputTypes") = c('_p_boost__shared_ptrT_SwaptionVolatilityStructure_t')
class(`SwaptionVolatilityStructure_disableExtrapolation`) = c("SWIGFunction", class('SwaptionVolatilityStructure_disableExtrapolation'))

# Start of SwaptionVolatilityStructure_allowsExtrapolation

`SwaptionVolatilityStructure_allowsExtrapolation` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_SwaptionVolatilityStructure_allowsExtrapolation', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`SwaptionVolatilityStructure_allowsExtrapolation`, 'returnType') = 'logical'
attr(`SwaptionVolatilityStructure_allowsExtrapolation`, "inputTypes") = c('_p_boost__shared_ptrT_SwaptionVolatilityStructure_t')
class(`SwaptionVolatilityStructure_allowsExtrapolation`) = c("SWIGFunction", class('SwaptionVolatilityStructure_allowsExtrapolation'))

# Start of accessor method for boost::shared_ptr<(SwaptionVolatilityStructure)>
setMethod('$', '_p_boost__shared_ptrT_SwaptionVolatilityStructure_t', function(x, name)

{
  accessorFuns = list('__deref__' = SwaptionVolatilityStructure___deref__, 'isNull' = SwaptionVolatilityStructure_isNull, 'asObservable' = SwaptionVolatilityStructure_asObservable, 'referenceDate' = SwaptionVolatilityStructure_referenceDate, 'dayCounter' = SwaptionVolatilityStructure_dayCounter, 'calendar' = SwaptionVolatilityStructure_calendar, 'maxSwapTenor' = SwaptionVolatilityStructure_maxSwapTenor, 'maxSwapLength' = SwaptionVolatilityStructure_maxSwapLength, 'minStrike' = SwaptionVolatilityStructure_minStrike, 'maxStrike' = SwaptionVolatilityStructure_maxStrike, 'volatility' = SwaptionVolatilityStructure_volatility, 'blackVariance' = SwaptionVolatilityStructure_blackVariance, 'enableExtrapolation' = SwaptionVolatilityStructure_enableExtrapolation, 'disableExtrapolation' = SwaptionVolatilityStructure_disableExtrapolation, 'allowsExtrapolation' = SwaptionVolatilityStructure_allowsExtrapolation);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for boost::shared_ptr<(SwaptionVolatilityStructure)>
setMethod('delete', '_p_boost__shared_ptrT_SwaptionVolatilityStructure_t', function(obj) {delete_boost__shared_ptrT_SwaptionVolatilityStructure_t(obj)})
# Start of new_SwaptionVolatilityStructureHandle

`SwaptionVolatilityStructureHandle__SWIG_0` = function(s_arg1)
{
  ;ans = .Call('R_swig_new_SwaptionVolatilityStructureHandle__SWIG_0', s_arg1, PACKAGE='QuantLib');
  class(ans) <- "_p_HandleT_SwaptionVolatilityStructure_t";
  
  reg.finalizer(ans, delete_SwaptionVolatilityStructureHandle)
  ans
  
}

attr(`SwaptionVolatilityStructureHandle__SWIG_0`, 'returnType') = '_p_HandleT_SwaptionVolatilityStructure_t'
attr(`SwaptionVolatilityStructureHandle__SWIG_0`, "inputTypes") = c('_p_boost__shared_ptrT_SwaptionVolatilityStructure_t')
class(`SwaptionVolatilityStructureHandle__SWIG_0`) = c("SWIGFunction", class('SwaptionVolatilityStructureHandle__SWIG_0'))

# Start of new_SwaptionVolatilityStructureHandle

`SwaptionVolatilityStructureHandle__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_SwaptionVolatilityStructureHandle__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_HandleT_SwaptionVolatilityStructure_t";
  
  reg.finalizer(ans, delete_SwaptionVolatilityStructureHandle)
  ans
  
}

attr(`SwaptionVolatilityStructureHandle__SWIG_1`, 'returnType') = '_p_HandleT_SwaptionVolatilityStructure_t'
class(`SwaptionVolatilityStructureHandle__SWIG_1`) = c("SWIGFunction", class('SwaptionVolatilityStructureHandle__SWIG_1'))

`SwaptionVolatilityStructureHandle` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- SwaptionVolatilityStructureHandle__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_SwaptionVolatilityStructure_t')) {
      f <- SwaptionVolatilityStructureHandle__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for SwaptionVolatilityStructureHandle with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of SwaptionVolatilityStructureHandle___deref__

`SwaptionVolatilityStructureHandle___deref__` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_SwaptionVolatilityStructureHandle___deref__', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_SwaptionVolatilityStructure_t";
  
  ans
  
}

attr(`SwaptionVolatilityStructureHandle___deref__`, 'returnType') = '_p_boost__shared_ptrT_SwaptionVolatilityStructure_t'
attr(`SwaptionVolatilityStructureHandle___deref__`, "inputTypes") = c('_p_HandleT_SwaptionVolatilityStructure_t')
class(`SwaptionVolatilityStructureHandle___deref__`) = c("SWIGFunction", class('SwaptionVolatilityStructureHandle___deref__'))

# Start of SwaptionVolatilityStructureHandle_empty

`SwaptionVolatilityStructureHandle_empty` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_SwaptionVolatilityStructureHandle_empty', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`SwaptionVolatilityStructureHandle_empty`, 'returnType') = 'logical'
attr(`SwaptionVolatilityStructureHandle_empty`, "inputTypes") = c('_p_HandleT_SwaptionVolatilityStructure_t')
class(`SwaptionVolatilityStructureHandle_empty`) = c("SWIGFunction", class('SwaptionVolatilityStructureHandle_empty'))

# Start of SwaptionVolatilityStructureHandle_asObservable

`SwaptionVolatilityStructureHandle_asObservable` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_SwaptionVolatilityStructureHandle_asObservable', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_Observable_t";
  
  ans
  
}

attr(`SwaptionVolatilityStructureHandle_asObservable`, 'returnType') = '_p_boost__shared_ptrT_Observable_t'
attr(`SwaptionVolatilityStructureHandle_asObservable`, "inputTypes") = c('_p_HandleT_SwaptionVolatilityStructure_t')
class(`SwaptionVolatilityStructureHandle_asObservable`) = c("SWIGFunction", class('SwaptionVolatilityStructureHandle_asObservable'))

# Start of delete_SwaptionVolatilityStructureHandle

`delete_SwaptionVolatilityStructureHandle` = function(self)
{
  ;.Call('R_swig_delete_SwaptionVolatilityStructureHandle', self, PACKAGE='QuantLib');
  
}

attr(`delete_SwaptionVolatilityStructureHandle`, 'returnType') = 'void'
attr(`delete_SwaptionVolatilityStructureHandle`, "inputTypes") = c('_p_HandleT_SwaptionVolatilityStructure_t')
class(`delete_SwaptionVolatilityStructureHandle`) = c("SWIGFunction", class('delete_SwaptionVolatilityStructureHandle'))

# Start of SwaptionVolatilityStructureHandle_referenceDate

`SwaptionVolatilityStructureHandle_referenceDate` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_SwaptionVolatilityStructureHandle_referenceDate', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`SwaptionVolatilityStructureHandle_referenceDate`, 'returnType') = '_p_Date'
attr(`SwaptionVolatilityStructureHandle_referenceDate`, "inputTypes") = c('_p_HandleT_SwaptionVolatilityStructure_t')
class(`SwaptionVolatilityStructureHandle_referenceDate`) = c("SWIGFunction", class('SwaptionVolatilityStructureHandle_referenceDate'))

# Start of SwaptionVolatilityStructureHandle_dayCounter

`SwaptionVolatilityStructureHandle_dayCounter` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_SwaptionVolatilityStructureHandle_dayCounter', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_DayCounter";
  
  ans
  
}

attr(`SwaptionVolatilityStructureHandle_dayCounter`, 'returnType') = '_p_DayCounter'
attr(`SwaptionVolatilityStructureHandle_dayCounter`, "inputTypes") = c('_p_HandleT_SwaptionVolatilityStructure_t')
class(`SwaptionVolatilityStructureHandle_dayCounter`) = c("SWIGFunction", class('SwaptionVolatilityStructureHandle_dayCounter'))

# Start of SwaptionVolatilityStructureHandle_calendar

`SwaptionVolatilityStructureHandle_calendar` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_SwaptionVolatilityStructureHandle_calendar', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Calendar";
  
  ans
  
}

attr(`SwaptionVolatilityStructureHandle_calendar`, 'returnType') = '_p_Calendar'
attr(`SwaptionVolatilityStructureHandle_calendar`, "inputTypes") = c('_p_HandleT_SwaptionVolatilityStructure_t')
class(`SwaptionVolatilityStructureHandle_calendar`) = c("SWIGFunction", class('SwaptionVolatilityStructureHandle_calendar'))

# Start of SwaptionVolatilityStructureHandle_maxSwapTenor

`SwaptionVolatilityStructureHandle_maxSwapTenor` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_SwaptionVolatilityStructureHandle_maxSwapTenor', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Period";
  
  ans
  
}

attr(`SwaptionVolatilityStructureHandle_maxSwapTenor`, 'returnType') = '_p_Period'
attr(`SwaptionVolatilityStructureHandle_maxSwapTenor`, "inputTypes") = c('_p_HandleT_SwaptionVolatilityStructure_t')
class(`SwaptionVolatilityStructureHandle_maxSwapTenor`) = c("SWIGFunction", class('SwaptionVolatilityStructureHandle_maxSwapTenor'))

# Start of SwaptionVolatilityStructureHandle_maxSwapLength

`SwaptionVolatilityStructureHandle_maxSwapLength` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_SwaptionVolatilityStructureHandle_maxSwapLength', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`SwaptionVolatilityStructureHandle_maxSwapLength`, 'returnType') = 'numeric'
attr(`SwaptionVolatilityStructureHandle_maxSwapLength`, "inputTypes") = c('_p_HandleT_SwaptionVolatilityStructure_t')
class(`SwaptionVolatilityStructureHandle_maxSwapLength`) = c("SWIGFunction", class('SwaptionVolatilityStructureHandle_maxSwapLength'))

# Start of SwaptionVolatilityStructureHandle_minStrike

`SwaptionVolatilityStructureHandle_minStrike` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_SwaptionVolatilityStructureHandle_minStrike', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`SwaptionVolatilityStructureHandle_minStrike`, 'returnType') = 'numeric'
attr(`SwaptionVolatilityStructureHandle_minStrike`, "inputTypes") = c('_p_HandleT_SwaptionVolatilityStructure_t')
class(`SwaptionVolatilityStructureHandle_minStrike`) = c("SWIGFunction", class('SwaptionVolatilityStructureHandle_minStrike'))

# Start of SwaptionVolatilityStructureHandle_maxStrike

`SwaptionVolatilityStructureHandle_maxStrike` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_SwaptionVolatilityStructureHandle_maxStrike', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`SwaptionVolatilityStructureHandle_maxStrike`, 'returnType') = 'numeric'
attr(`SwaptionVolatilityStructureHandle_maxStrike`, "inputTypes") = c('_p_HandleT_SwaptionVolatilityStructure_t')
class(`SwaptionVolatilityStructureHandle_maxStrike`) = c("SWIGFunction", class('SwaptionVolatilityStructureHandle_maxStrike'))

# Start of SwaptionVolatilityStructureHandle_volatility

`SwaptionVolatilityStructureHandle_volatility__SWIG_0` = function(self, start, length, strike, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_SwaptionVolatilityStructureHandle_volatility__SWIG_0', self, start, length, strike, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`SwaptionVolatilityStructureHandle_volatility__SWIG_0`, 'returnType') = 'numeric'
attr(`SwaptionVolatilityStructureHandle_volatility__SWIG_0`, "inputTypes") = c('_p_HandleT_SwaptionVolatilityStructure_t', '_p_Date', '_p_Period', 'numeric', 'logical')
class(`SwaptionVolatilityStructureHandle_volatility__SWIG_0`) = c("SWIGFunction", class('SwaptionVolatilityStructureHandle_volatility__SWIG_0'))

# Start of SwaptionVolatilityStructureHandle_volatility

`SwaptionVolatilityStructureHandle_volatility__SWIG_1` = function(self, start, length, strike, .copy = FALSE)
{
  ;.Call('R_swig_SwaptionVolatilityStructureHandle_volatility__SWIG_1', self, start, length, strike, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`SwaptionVolatilityStructureHandle_volatility__SWIG_1`, 'returnType') = 'numeric'
attr(`SwaptionVolatilityStructureHandle_volatility__SWIG_1`, "inputTypes") = c('_p_HandleT_SwaptionVolatilityStructure_t', '_p_Date', '_p_Period', 'numeric')
class(`SwaptionVolatilityStructureHandle_volatility__SWIG_1`) = c("SWIGFunction", class('SwaptionVolatilityStructureHandle_volatility__SWIG_1'))

# Start of SwaptionVolatilityStructureHandle_volatility

`SwaptionVolatilityStructureHandle_volatility__SWIG_2` = function(self, start, length, strike, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_SwaptionVolatilityStructureHandle_volatility__SWIG_2', self, start, length, strike, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`SwaptionVolatilityStructureHandle_volatility__SWIG_2`, 'returnType') = 'numeric'
attr(`SwaptionVolatilityStructureHandle_volatility__SWIG_2`, "inputTypes") = c('_p_HandleT_SwaptionVolatilityStructure_t', 'numeric', 'numeric', 'numeric', 'logical')
class(`SwaptionVolatilityStructureHandle_volatility__SWIG_2`) = c("SWIGFunction", class('SwaptionVolatilityStructureHandle_volatility__SWIG_2'))

# Start of SwaptionVolatilityStructureHandle_volatility

`SwaptionVolatilityStructureHandle_volatility__SWIG_3` = function(self, start, length, strike, .copy = FALSE)
{
  ;.Call('R_swig_SwaptionVolatilityStructureHandle_volatility__SWIG_3', self, start, length, strike, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`SwaptionVolatilityStructureHandle_volatility__SWIG_3`, 'returnType') = 'numeric'
attr(`SwaptionVolatilityStructureHandle_volatility__SWIG_3`, "inputTypes") = c('_p_HandleT_SwaptionVolatilityStructure_t', 'numeric', 'numeric', 'numeric')
class(`SwaptionVolatilityStructureHandle_volatility__SWIG_3`) = c("SWIGFunction", class('SwaptionVolatilityStructureHandle_volatility__SWIG_3'))

`SwaptionVolatilityStructureHandle_volatility` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 4) {
    if (extends(argtypes[1], '_p_HandleT_SwaptionVolatilityStructure_t') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_Period') && is.numeric(argv[[4]])) {
      f <- SwaptionVolatilityStructureHandle_volatility__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_HandleT_SwaptionVolatilityStructure_t') && is.numeric(argv[[2]]) && is.numeric(argv[[3]]) && is.numeric(argv[[4]])) {
      f <- SwaptionVolatilityStructureHandle_volatility__SWIG_3; 
    }
  } else if (argc == 5) {
    if (extends(argtypes[1], '_p_HandleT_SwaptionVolatilityStructure_t') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_Period') && is.numeric(argv[[4]]) && extends(argtypes[5], 'logical')) {
      f <- SwaptionVolatilityStructureHandle_volatility__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_HandleT_SwaptionVolatilityStructure_t') && is.numeric(argv[[2]]) && is.numeric(argv[[3]]) && is.numeric(argv[[4]]) && extends(argtypes[5], 'logical')) {
      f <- SwaptionVolatilityStructureHandle_volatility__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for SwaptionVolatilityStructureHandle_volatility with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of SwaptionVolatilityStructureHandle_blackVariance

`SwaptionVolatilityStructureHandle_blackVariance__SWIG_0` = function(self, start, length, strike, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_SwaptionVolatilityStructureHandle_blackVariance__SWIG_0', self, start, length, strike, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`SwaptionVolatilityStructureHandle_blackVariance__SWIG_0`, 'returnType') = 'numeric'
attr(`SwaptionVolatilityStructureHandle_blackVariance__SWIG_0`, "inputTypes") = c('_p_HandleT_SwaptionVolatilityStructure_t', '_p_Date', '_p_Period', 'numeric', 'logical')
class(`SwaptionVolatilityStructureHandle_blackVariance__SWIG_0`) = c("SWIGFunction", class('SwaptionVolatilityStructureHandle_blackVariance__SWIG_0'))

# Start of SwaptionVolatilityStructureHandle_blackVariance

`SwaptionVolatilityStructureHandle_blackVariance__SWIG_1` = function(self, start, length, strike, .copy = FALSE)
{
  ;.Call('R_swig_SwaptionVolatilityStructureHandle_blackVariance__SWIG_1', self, start, length, strike, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`SwaptionVolatilityStructureHandle_blackVariance__SWIG_1`, 'returnType') = 'numeric'
attr(`SwaptionVolatilityStructureHandle_blackVariance__SWIG_1`, "inputTypes") = c('_p_HandleT_SwaptionVolatilityStructure_t', '_p_Date', '_p_Period', 'numeric')
class(`SwaptionVolatilityStructureHandle_blackVariance__SWIG_1`) = c("SWIGFunction", class('SwaptionVolatilityStructureHandle_blackVariance__SWIG_1'))

# Start of SwaptionVolatilityStructureHandle_blackVariance

`SwaptionVolatilityStructureHandle_blackVariance__SWIG_2` = function(self, start, length, strike, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_SwaptionVolatilityStructureHandle_blackVariance__SWIG_2', self, start, length, strike, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`SwaptionVolatilityStructureHandle_blackVariance__SWIG_2`, 'returnType') = 'numeric'
attr(`SwaptionVolatilityStructureHandle_blackVariance__SWIG_2`, "inputTypes") = c('_p_HandleT_SwaptionVolatilityStructure_t', 'numeric', 'numeric', 'numeric', 'logical')
class(`SwaptionVolatilityStructureHandle_blackVariance__SWIG_2`) = c("SWIGFunction", class('SwaptionVolatilityStructureHandle_blackVariance__SWIG_2'))

# Start of SwaptionVolatilityStructureHandle_blackVariance

`SwaptionVolatilityStructureHandle_blackVariance__SWIG_3` = function(self, start, length, strike, .copy = FALSE)
{
  ;.Call('R_swig_SwaptionVolatilityStructureHandle_blackVariance__SWIG_3', self, start, length, strike, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`SwaptionVolatilityStructureHandle_blackVariance__SWIG_3`, 'returnType') = 'numeric'
attr(`SwaptionVolatilityStructureHandle_blackVariance__SWIG_3`, "inputTypes") = c('_p_HandleT_SwaptionVolatilityStructure_t', 'numeric', 'numeric', 'numeric')
class(`SwaptionVolatilityStructureHandle_blackVariance__SWIG_3`) = c("SWIGFunction", class('SwaptionVolatilityStructureHandle_blackVariance__SWIG_3'))

`SwaptionVolatilityStructureHandle_blackVariance` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 4) {
    if (extends(argtypes[1], '_p_HandleT_SwaptionVolatilityStructure_t') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_Period') && is.numeric(argv[[4]])) {
      f <- SwaptionVolatilityStructureHandle_blackVariance__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_HandleT_SwaptionVolatilityStructure_t') && is.numeric(argv[[2]]) && is.numeric(argv[[3]]) && is.numeric(argv[[4]])) {
      f <- SwaptionVolatilityStructureHandle_blackVariance__SWIG_3; 
    }
  } else if (argc == 5) {
    if (extends(argtypes[1], '_p_HandleT_SwaptionVolatilityStructure_t') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_Period') && is.numeric(argv[[4]]) && extends(argtypes[5], 'logical')) {
      f <- SwaptionVolatilityStructureHandle_blackVariance__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_HandleT_SwaptionVolatilityStructure_t') && is.numeric(argv[[2]]) && is.numeric(argv[[3]]) && is.numeric(argv[[4]]) && extends(argtypes[5], 'logical')) {
      f <- SwaptionVolatilityStructureHandle_blackVariance__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for SwaptionVolatilityStructureHandle_blackVariance with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of SwaptionVolatilityStructureHandle_enableExtrapolation

`SwaptionVolatilityStructureHandle_enableExtrapolation` = function(self)
{
  ;.Call('R_swig_SwaptionVolatilityStructureHandle_enableExtrapolation', self, PACKAGE='QuantLib');
  
}

attr(`SwaptionVolatilityStructureHandle_enableExtrapolation`, 'returnType') = 'void'
attr(`SwaptionVolatilityStructureHandle_enableExtrapolation`, "inputTypes") = c('_p_HandleT_SwaptionVolatilityStructure_t')
class(`SwaptionVolatilityStructureHandle_enableExtrapolation`) = c("SWIGFunction", class('SwaptionVolatilityStructureHandle_enableExtrapolation'))

# Start of SwaptionVolatilityStructureHandle_disableExtrapolation

`SwaptionVolatilityStructureHandle_disableExtrapolation` = function(self)
{
  ;.Call('R_swig_SwaptionVolatilityStructureHandle_disableExtrapolation', self, PACKAGE='QuantLib');
  
}

attr(`SwaptionVolatilityStructureHandle_disableExtrapolation`, 'returnType') = 'void'
attr(`SwaptionVolatilityStructureHandle_disableExtrapolation`, "inputTypes") = c('_p_HandleT_SwaptionVolatilityStructure_t')
class(`SwaptionVolatilityStructureHandle_disableExtrapolation`) = c("SWIGFunction", class('SwaptionVolatilityStructureHandle_disableExtrapolation'))

# Start of SwaptionVolatilityStructureHandle_allowsExtrapolation

`SwaptionVolatilityStructureHandle_allowsExtrapolation` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_SwaptionVolatilityStructureHandle_allowsExtrapolation', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`SwaptionVolatilityStructureHandle_allowsExtrapolation`, 'returnType') = 'logical'
attr(`SwaptionVolatilityStructureHandle_allowsExtrapolation`, "inputTypes") = c('_p_HandleT_SwaptionVolatilityStructure_t')
class(`SwaptionVolatilityStructureHandle_allowsExtrapolation`) = c("SWIGFunction", class('SwaptionVolatilityStructureHandle_allowsExtrapolation'))

# Start of accessor method for Handle<(SwaptionVolatilityStructure)>
setMethod('$', '_p_HandleT_SwaptionVolatilityStructure_t', function(x, name)

{
  accessorFuns = list('__deref__' = SwaptionVolatilityStructureHandle___deref__, 'empty' = SwaptionVolatilityStructureHandle_empty, 'asObservable' = SwaptionVolatilityStructureHandle_asObservable, 'referenceDate' = SwaptionVolatilityStructureHandle_referenceDate, 'dayCounter' = SwaptionVolatilityStructureHandle_dayCounter, 'calendar' = SwaptionVolatilityStructureHandle_calendar, 'maxSwapTenor' = SwaptionVolatilityStructureHandle_maxSwapTenor, 'maxSwapLength' = SwaptionVolatilityStructureHandle_maxSwapLength, 'minStrike' = SwaptionVolatilityStructureHandle_minStrike, 'maxStrike' = SwaptionVolatilityStructureHandle_maxStrike, 'volatility' = SwaptionVolatilityStructureHandle_volatility, 'blackVariance' = SwaptionVolatilityStructureHandle_blackVariance, 'enableExtrapolation' = SwaptionVolatilityStructureHandle_enableExtrapolation, 'disableExtrapolation' = SwaptionVolatilityStructureHandle_disableExtrapolation, 'allowsExtrapolation' = SwaptionVolatilityStructureHandle_allowsExtrapolation);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for Handle<(SwaptionVolatilityStructure)>
setMethod('delete', '_p_HandleT_SwaptionVolatilityStructure_t', function(obj) {delete_HandleT_SwaptionVolatilityStructure_t(obj)})
# Start of new_RelinkableSwaptionVolatilityStructureHandle

`RelinkableSwaptionVolatilityStructureHandle__SWIG_0` = function(s_arg1)
{
  ;ans = .Call('R_swig_new_RelinkableSwaptionVolatilityStructureHandle__SWIG_0', s_arg1, PACKAGE='QuantLib');
  class(ans) <- "_p_RelinkableHandleT_SwaptionVolatilityStructure_t";
  
  reg.finalizer(ans, delete_RelinkableSwaptionVolatilityStructureHandle)
  ans
  
}

attr(`RelinkableSwaptionVolatilityStructureHandle__SWIG_0`, 'returnType') = '_p_RelinkableHandleT_SwaptionVolatilityStructure_t'
attr(`RelinkableSwaptionVolatilityStructureHandle__SWIG_0`, "inputTypes") = c('_p_boost__shared_ptrT_SwaptionVolatilityStructure_t')
class(`RelinkableSwaptionVolatilityStructureHandle__SWIG_0`) = c("SWIGFunction", class('RelinkableSwaptionVolatilityStructureHandle__SWIG_0'))

# Start of new_RelinkableSwaptionVolatilityStructureHandle

`RelinkableSwaptionVolatilityStructureHandle__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_RelinkableSwaptionVolatilityStructureHandle__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_RelinkableHandleT_SwaptionVolatilityStructure_t";
  
  reg.finalizer(ans, delete_RelinkableSwaptionVolatilityStructureHandle)
  ans
  
}

attr(`RelinkableSwaptionVolatilityStructureHandle__SWIG_1`, 'returnType') = '_p_RelinkableHandleT_SwaptionVolatilityStructure_t'
class(`RelinkableSwaptionVolatilityStructureHandle__SWIG_1`) = c("SWIGFunction", class('RelinkableSwaptionVolatilityStructureHandle__SWIG_1'))

`RelinkableSwaptionVolatilityStructureHandle` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- RelinkableSwaptionVolatilityStructureHandle__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_SwaptionVolatilityStructure_t')) {
      f <- RelinkableSwaptionVolatilityStructureHandle__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for RelinkableSwaptionVolatilityStructureHandle with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of RelinkableSwaptionVolatilityStructureHandle_linkTo

`RelinkableSwaptionVolatilityStructureHandle_linkTo` = function(self, s_arg2)
{
  ;.Call('R_swig_RelinkableSwaptionVolatilityStructureHandle_linkTo', self, s_arg2, PACKAGE='QuantLib');
  
}

attr(`RelinkableSwaptionVolatilityStructureHandle_linkTo`, 'returnType') = 'void'
attr(`RelinkableSwaptionVolatilityStructureHandle_linkTo`, "inputTypes") = c('_p_RelinkableHandleT_SwaptionVolatilityStructure_t', '_p_boost__shared_ptrT_SwaptionVolatilityStructure_t')
class(`RelinkableSwaptionVolatilityStructureHandle_linkTo`) = c("SWIGFunction", class('RelinkableSwaptionVolatilityStructureHandle_linkTo'))

# Start of delete_RelinkableSwaptionVolatilityStructureHandle

`delete_RelinkableSwaptionVolatilityStructureHandle` = function(self)
{
  ;.Call('R_swig_delete_RelinkableSwaptionVolatilityStructureHandle', self, PACKAGE='QuantLib');
  
}

attr(`delete_RelinkableSwaptionVolatilityStructureHandle`, 'returnType') = 'void'
attr(`delete_RelinkableSwaptionVolatilityStructureHandle`, "inputTypes") = c('_p_RelinkableHandleT_SwaptionVolatilityStructure_t')
class(`delete_RelinkableSwaptionVolatilityStructureHandle`) = c("SWIGFunction", class('delete_RelinkableSwaptionVolatilityStructureHandle'))

# Start of accessor method for RelinkableHandle<(SwaptionVolatilityStructure)>
setMethod('$', '_p_RelinkableHandleT_SwaptionVolatilityStructure_t', function(x, name)

{
  accessorFuns = list('linkTo' = RelinkableSwaptionVolatilityStructureHandle_linkTo);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for RelinkableHandle<(SwaptionVolatilityStructure)>
setMethod('delete', '_p_RelinkableHandleT_SwaptionVolatilityStructure_t', function(obj) {delete_RelinkableHandleT_SwaptionVolatilityStructure_t(obj)})
# Start of new_BlackConstantVol

`BlackConstantVol__SWIG_0` = function(referenceDate, c, volatility, dayCounter)
{
  ;ans = .Call('R_swig_new_BlackConstantVol__SWIG_0', referenceDate, c, volatility, dayCounter, PACKAGE='QuantLib');
  class(ans) <- "_p_BlackConstantVolPtr";
  
  reg.finalizer(ans, delete_BlackConstantVol)
  ans
  
}

attr(`BlackConstantVol__SWIG_0`, 'returnType') = '_p_BlackConstantVolPtr'
attr(`BlackConstantVol__SWIG_0`, "inputTypes") = c('_p_Date', '_p_Calendar', 'numeric', '_p_DayCounter')
class(`BlackConstantVol__SWIG_0`) = c("SWIGFunction", class('BlackConstantVol__SWIG_0'))

# Start of new_BlackConstantVol

`BlackConstantVol__SWIG_1` = function(referenceDate, c, volatility, dayCounter)
{
  ;ans = .Call('R_swig_new_BlackConstantVol__SWIG_1', referenceDate, c, volatility, dayCounter, PACKAGE='QuantLib');
  class(ans) <- "_p_BlackConstantVolPtr";
  
  reg.finalizer(ans, delete_BlackConstantVol)
  ans
  
}

attr(`BlackConstantVol__SWIG_1`, 'returnType') = '_p_BlackConstantVolPtr'
attr(`BlackConstantVol__SWIG_1`, "inputTypes") = c('_p_Date', '_p_Calendar', '_p_HandleT_Quote_t', '_p_DayCounter')
class(`BlackConstantVol__SWIG_1`) = c("SWIGFunction", class('BlackConstantVol__SWIG_1'))

# Start of new_BlackConstantVol

`BlackConstantVol__SWIG_2` = function(settlementDays, calendar, volatility, dayCounter)
{
  if(length(settlementDays) > 1) {
    warning("using only the first element of settlementDays");
  };
  
  
  
  
  ;ans = .Call('R_swig_new_BlackConstantVol__SWIG_2', settlementDays, calendar, volatility, dayCounter, PACKAGE='QuantLib');
  class(ans) <- "_p_BlackConstantVolPtr";
  
  reg.finalizer(ans, delete_BlackConstantVol)
  ans
  
}

attr(`BlackConstantVol__SWIG_2`, 'returnType') = '_p_BlackConstantVolPtr'
attr(`BlackConstantVol__SWIG_2`, "inputTypes") = c('integer', '_p_Calendar', 'numeric', '_p_DayCounter')
class(`BlackConstantVol__SWIG_2`) = c("SWIGFunction", class('BlackConstantVol__SWIG_2'))

# Start of new_BlackConstantVol

`BlackConstantVol__SWIG_3` = function(settlementDays, calendar, volatility, dayCounter)
{
  if(length(settlementDays) > 1) {
    warning("using only the first element of settlementDays");
  };
  
  
  
  
  ;ans = .Call('R_swig_new_BlackConstantVol__SWIG_3', settlementDays, calendar, volatility, dayCounter, PACKAGE='QuantLib');
  class(ans) <- "_p_BlackConstantVolPtr";
  
  reg.finalizer(ans, delete_BlackConstantVol)
  ans
  
}

attr(`BlackConstantVol__SWIG_3`, 'returnType') = '_p_BlackConstantVolPtr'
attr(`BlackConstantVol__SWIG_3`, "inputTypes") = c('integer', '_p_Calendar', '_p_HandleT_Quote_t', '_p_DayCounter')
class(`BlackConstantVol__SWIG_3`) = c("SWIGFunction", class('BlackConstantVol__SWIG_3'))

`BlackConstantVol` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 4) {
    if (extends(argtypes[1], '_p_Date') && extends(argtypes[2], '_p_Calendar') && extends(argtypes[3], '_p_HandleT_Quote_t') && extends(argtypes[4], '_p_DayCounter')) {
      f <- BlackConstantVol__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_Date') && extends(argtypes[2], '_p_Calendar') && is.numeric(argv[[3]]) && extends(argtypes[4], '_p_DayCounter')) {
      f <- BlackConstantVol__SWIG_0; 
    }
    else if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && extends(argtypes[2], '_p_Calendar') && extends(argtypes[3], '_p_HandleT_Quote_t') && extends(argtypes[4], '_p_DayCounter')) {
      f <- BlackConstantVol__SWIG_3; 
    }
    else if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && extends(argtypes[2], '_p_Calendar') && is.numeric(argv[[3]]) && extends(argtypes[4], '_p_DayCounter')) {
      f <- BlackConstantVol__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for BlackConstantVol with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_BlackConstantVol

`delete_BlackConstantVol` = function(self)
{
  ;.Call('R_swig_delete_BlackConstantVol', self, PACKAGE='QuantLib');
  
}

attr(`delete_BlackConstantVol`, 'returnType') = 'void'
attr(`delete_BlackConstantVol`, "inputTypes") = c('_p_BlackConstantVolPtr')
class(`delete_BlackConstantVol`) = c("SWIGFunction", class('delete_BlackConstantVol'))

setMethod('delete', '_p_BlackConstantVolPtr', function(obj) {delete_BlackConstantVolPtr(obj)})
# Start of new_BlackVarianceCurve

`BlackVarianceCurve__SWIG_0` = function(referenceDate, dates, volatilities, dayCounter, forceMonotoneVariance)
{
  forceMonotoneVariance = as.logical(forceMonotoneVariance);
  ;ans = .Call('R_swig_new_BlackVarianceCurve__SWIG_0', referenceDate, dates, volatilities, dayCounter, forceMonotoneVariance, PACKAGE='QuantLib');
  class(ans) <- "_p_BlackVarianceCurvePtr";
  
  reg.finalizer(ans, delete_BlackVarianceCurve)
  ans
  
}

attr(`BlackVarianceCurve__SWIG_0`, 'returnType') = '_p_BlackVarianceCurvePtr'
attr(`BlackVarianceCurve__SWIG_0`, "inputTypes") = c('_p_Date', '_p_std__vectorT_Date_std__allocatorT_Date_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_DayCounter', 'logical')
class(`BlackVarianceCurve__SWIG_0`) = c("SWIGFunction", class('BlackVarianceCurve__SWIG_0'))

# Start of new_BlackVarianceCurve

`BlackVarianceCurve__SWIG_1` = function(referenceDate, dates, volatilities, dayCounter)
{
  ;ans = .Call('R_swig_new_BlackVarianceCurve__SWIG_1', referenceDate, dates, volatilities, dayCounter, PACKAGE='QuantLib');
  class(ans) <- "_p_BlackVarianceCurvePtr";
  
  reg.finalizer(ans, delete_BlackVarianceCurve)
  ans
  
}

attr(`BlackVarianceCurve__SWIG_1`, 'returnType') = '_p_BlackVarianceCurvePtr'
attr(`BlackVarianceCurve__SWIG_1`, "inputTypes") = c('_p_Date', '_p_std__vectorT_Date_std__allocatorT_Date_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_DayCounter')
class(`BlackVarianceCurve__SWIG_1`) = c("SWIGFunction", class('BlackVarianceCurve__SWIG_1'))

`BlackVarianceCurve` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 4) {
    if (extends(argtypes[1], '_p_Date') && extends(argtypes[2], '_p_std__vectorT_Date_std__allocatorT_Date_t_t') && extends(argtypes[3], '_p_std__vectorT_double_std__allocatorT_double_t_t') && extends(argtypes[4], '_p_DayCounter')) {
      f <- BlackVarianceCurve__SWIG_1; 
    }
  } else if (argc == 5) {
    if (extends(argtypes[1], '_p_Date') && extends(argtypes[2], '_p_std__vectorT_Date_std__allocatorT_Date_t_t') && extends(argtypes[3], '_p_std__vectorT_double_std__allocatorT_double_t_t') && extends(argtypes[4], '_p_DayCounter') && extends(argtypes[5], 'logical')) {
      f <- BlackVarianceCurve__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for BlackVarianceCurve with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_BlackVarianceCurve

`delete_BlackVarianceCurve` = function(self)
{
  ;.Call('R_swig_delete_BlackVarianceCurve', self, PACKAGE='QuantLib');
  
}

attr(`delete_BlackVarianceCurve`, 'returnType') = 'void'
attr(`delete_BlackVarianceCurve`, "inputTypes") = c('_p_BlackVarianceCurvePtr')
class(`delete_BlackVarianceCurve`) = c("SWIGFunction", class('delete_BlackVarianceCurve'))

setMethod('delete', '_p_BlackVarianceCurvePtr', function(obj) {delete_BlackVarianceCurvePtr(obj)})
# Start of new_BlackVarianceSurface

`BlackVarianceSurface__SWIG_0` = function(referenceDate, cal, dates, strikes, blackVols, dayCounter, lower, upper)
{
  lower = enumToInteger(lower, "_BlackVarianceSurface__Extrapolation"); 
  
  if(length(lower) > 1) {
    warning("using only the first element of lower");
  };
  
  upper = enumToInteger(upper, "_BlackVarianceSurface__Extrapolation"); 
  
  if(length(upper) > 1) {
    warning("using only the first element of upper");
  };
  
  ;ans = .Call('R_swig_new_BlackVarianceSurface__SWIG_0', referenceDate, cal, dates, strikes, blackVols, dayCounter, lower, upper, PACKAGE='QuantLib');
  class(ans) <- "_p_BlackVarianceSurfacePtr";
  
  reg.finalizer(ans, delete_BlackVarianceSurface)
  ans
  
}

attr(`BlackVarianceSurface__SWIG_0`, 'returnType') = '_p_BlackVarianceSurfacePtr'
attr(`BlackVarianceSurface__SWIG_0`, "inputTypes") = c('_p_Date', '_p_Calendar', '_p_std__vectorT_Date_std__allocatorT_Date_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_Matrix', '_p_DayCounter', 'character', 'character')
class(`BlackVarianceSurface__SWIG_0`) = c("SWIGFunction", class('BlackVarianceSurface__SWIG_0'))

# Start of new_BlackVarianceSurface

`BlackVarianceSurface__SWIG_1` = function(referenceDate, cal, dates, strikes, blackVols, dayCounter, lower)
{
  lower = enumToInteger(lower, "_BlackVarianceSurface__Extrapolation"); 
  
  if(length(lower) > 1) {
    warning("using only the first element of lower");
  };
  
  ;ans = .Call('R_swig_new_BlackVarianceSurface__SWIG_1', referenceDate, cal, dates, strikes, blackVols, dayCounter, lower, PACKAGE='QuantLib');
  class(ans) <- "_p_BlackVarianceSurfacePtr";
  
  reg.finalizer(ans, delete_BlackVarianceSurface)
  ans
  
}

attr(`BlackVarianceSurface__SWIG_1`, 'returnType') = '_p_BlackVarianceSurfacePtr'
attr(`BlackVarianceSurface__SWIG_1`, "inputTypes") = c('_p_Date', '_p_Calendar', '_p_std__vectorT_Date_std__allocatorT_Date_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_Matrix', '_p_DayCounter', 'character')
class(`BlackVarianceSurface__SWIG_1`) = c("SWIGFunction", class('BlackVarianceSurface__SWIG_1'))

# Start of new_BlackVarianceSurface

`BlackVarianceSurface__SWIG_2` = function(referenceDate, cal, dates, strikes, blackVols, dayCounter)
{
  ;ans = .Call('R_swig_new_BlackVarianceSurface__SWIG_2', referenceDate, cal, dates, strikes, blackVols, dayCounter, PACKAGE='QuantLib');
  class(ans) <- "_p_BlackVarianceSurfacePtr";
  
  reg.finalizer(ans, delete_BlackVarianceSurface)
  ans
  
}

attr(`BlackVarianceSurface__SWIG_2`, 'returnType') = '_p_BlackVarianceSurfacePtr'
attr(`BlackVarianceSurface__SWIG_2`, "inputTypes") = c('_p_Date', '_p_Calendar', '_p_std__vectorT_Date_std__allocatorT_Date_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_Matrix', '_p_DayCounter')
class(`BlackVarianceSurface__SWIG_2`) = c("SWIGFunction", class('BlackVarianceSurface__SWIG_2'))

`BlackVarianceSurface` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 6) {
    if (extends(argtypes[1], '_p_Date') && extends(argtypes[2], '_p_Calendar') && extends(argtypes[3], '_p_std__vectorT_Date_std__allocatorT_Date_t_t') && extends(argtypes[4], '_p_std__vectorT_double_std__allocatorT_double_t_t') && extends(argtypes[5], '_p_Matrix') && extends(argtypes[6], '_p_DayCounter')) {
      f <- BlackVarianceSurface__SWIG_2; 
    }
  } else if (argc == 7) {
    if (extends(argtypes[1], '_p_Date') && extends(argtypes[2], '_p_Calendar') && extends(argtypes[3], '_p_std__vectorT_Date_std__allocatorT_Date_t_t') && extends(argtypes[4], '_p_std__vectorT_double_std__allocatorT_double_t_t') && extends(argtypes[5], '_p_Matrix') && extends(argtypes[6], '_p_DayCounter') && is.character(argv[[7]])) {
      f <- BlackVarianceSurface__SWIG_1; 
    }
  } else if (argc == 8) {
    if (extends(argtypes[1], '_p_Date') && extends(argtypes[2], '_p_Calendar') && extends(argtypes[3], '_p_std__vectorT_Date_std__allocatorT_Date_t_t') && extends(argtypes[4], '_p_std__vectorT_double_std__allocatorT_double_t_t') && extends(argtypes[5], '_p_Matrix') && extends(argtypes[6], '_p_DayCounter') && is.character(argv[[7]]) && is.character(argv[[8]])) {
      f <- BlackVarianceSurface__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for BlackVarianceSurface with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_BlackVarianceSurface

`delete_BlackVarianceSurface` = function(self)
{
  ;.Call('R_swig_delete_BlackVarianceSurface', self, PACKAGE='QuantLib');
  
}

attr(`delete_BlackVarianceSurface`, 'returnType') = 'void'
attr(`delete_BlackVarianceSurface`, "inputTypes") = c('_p_BlackVarianceSurfacePtr')
class(`delete_BlackVarianceSurface`) = c("SWIGFunction", class('delete_BlackVarianceSurface'))

setMethod('delete', '_p_BlackVarianceSurfacePtr', function(obj) {delete_BlackVarianceSurfacePtr(obj)})
# Start of new_LocalConstantVol

`LocalConstantVol__SWIG_0` = function(referenceDate, volatility, dayCounter)
{
  ;ans = .Call('R_swig_new_LocalConstantVol__SWIG_0', referenceDate, volatility, dayCounter, PACKAGE='QuantLib');
  class(ans) <- "_p_LocalConstantVolPtr";
  
  reg.finalizer(ans, delete_LocalConstantVol)
  ans
  
}

attr(`LocalConstantVol__SWIG_0`, 'returnType') = '_p_LocalConstantVolPtr'
attr(`LocalConstantVol__SWIG_0`, "inputTypes") = c('_p_Date', 'numeric', '_p_DayCounter')
class(`LocalConstantVol__SWIG_0`) = c("SWIGFunction", class('LocalConstantVol__SWIG_0'))

# Start of new_LocalConstantVol

`LocalConstantVol__SWIG_1` = function(referenceDate, volatility, dayCounter)
{
  ;ans = .Call('R_swig_new_LocalConstantVol__SWIG_1', referenceDate, volatility, dayCounter, PACKAGE='QuantLib');
  class(ans) <- "_p_LocalConstantVolPtr";
  
  reg.finalizer(ans, delete_LocalConstantVol)
  ans
  
}

attr(`LocalConstantVol__SWIG_1`, 'returnType') = '_p_LocalConstantVolPtr'
attr(`LocalConstantVol__SWIG_1`, "inputTypes") = c('_p_Date', '_p_HandleT_Quote_t', '_p_DayCounter')
class(`LocalConstantVol__SWIG_1`) = c("SWIGFunction", class('LocalConstantVol__SWIG_1'))

# Start of new_LocalConstantVol

`LocalConstantVol__SWIG_2` = function(settlementDays, calendar, volatility, dayCounter)
{
  settlementDays = as.integer(settlementDays); 
  
  if(length(settlementDays) > 1) {
    warning("using only the first element of settlementDays");
  };
  
  
  
  
  ;ans = .Call('R_swig_new_LocalConstantVol__SWIG_2', settlementDays, calendar, volatility, dayCounter, PACKAGE='QuantLib');
  class(ans) <- "_p_LocalConstantVolPtr";
  
  reg.finalizer(ans, delete_LocalConstantVol)
  ans
  
}

attr(`LocalConstantVol__SWIG_2`, 'returnType') = '_p_LocalConstantVolPtr'
attr(`LocalConstantVol__SWIG_2`, "inputTypes") = c('integer', '_p_Calendar', 'numeric', '_p_DayCounter')
class(`LocalConstantVol__SWIG_2`) = c("SWIGFunction", class('LocalConstantVol__SWIG_2'))

# Start of new_LocalConstantVol

`LocalConstantVol__SWIG_3` = function(settlementDays, calendar, volatility, dayCounter)
{
  settlementDays = as.integer(settlementDays); 
  
  if(length(settlementDays) > 1) {
    warning("using only the first element of settlementDays");
  };
  
  
  
  
  ;ans = .Call('R_swig_new_LocalConstantVol__SWIG_3', settlementDays, calendar, volatility, dayCounter, PACKAGE='QuantLib');
  class(ans) <- "_p_LocalConstantVolPtr";
  
  reg.finalizer(ans, delete_LocalConstantVol)
  ans
  
}

attr(`LocalConstantVol__SWIG_3`, 'returnType') = '_p_LocalConstantVolPtr'
attr(`LocalConstantVol__SWIG_3`, "inputTypes") = c('integer', '_p_Calendar', '_p_HandleT_Quote_t', '_p_DayCounter')
class(`LocalConstantVol__SWIG_3`) = c("SWIGFunction", class('LocalConstantVol__SWIG_3'))

`LocalConstantVol` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 3) {
    if (extends(argtypes[1], '_p_Date') && extends(argtypes[2], '_p_HandleT_Quote_t') && extends(argtypes[3], '_p_DayCounter')) {
      f <- LocalConstantVol__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_Date') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_DayCounter')) {
      f <- LocalConstantVol__SWIG_0; 
    }
  } else if (argc == 4) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && extends(argtypes[2], '_p_Calendar') && extends(argtypes[3], '_p_HandleT_Quote_t') && extends(argtypes[4], '_p_DayCounter')) {
      f <- LocalConstantVol__SWIG_3; 
    }
    else if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && extends(argtypes[2], '_p_Calendar') && is.numeric(argv[[3]]) && extends(argtypes[4], '_p_DayCounter')) {
      f <- LocalConstantVol__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for LocalConstantVol with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_LocalConstantVol

`delete_LocalConstantVol` = function(self)
{
  ;.Call('R_swig_delete_LocalConstantVol', self, PACKAGE='QuantLib');
  
}

attr(`delete_LocalConstantVol`, 'returnType') = 'void'
attr(`delete_LocalConstantVol`, "inputTypes") = c('_p_LocalConstantVolPtr')
class(`delete_LocalConstantVol`) = c("SWIGFunction", class('delete_LocalConstantVol'))

setMethod('delete', '_p_LocalConstantVolPtr', function(obj) {delete_LocalConstantVolPtr(obj)})
# Start of new_ConstantOptionletVolatility

`ConstantOptionletVolatility__SWIG_0` = function(referenceDate, cal, bdc, volatility, dayCounter)
{
  bdc = enumToInteger(bdc, "_BusinessDayConvention"); 
  
  if(length(bdc) > 1) {
    warning("using only the first element of bdc");
  };
  
  
  
  ;ans = .Call('R_swig_new_ConstantOptionletVolatility__SWIG_0', referenceDate, cal, bdc, volatility, dayCounter, PACKAGE='QuantLib');
  class(ans) <- "_p_ConstantOptionletVolatilityPtr";
  
  reg.finalizer(ans, delete_ConstantOptionletVolatility)
  ans
  
}

attr(`ConstantOptionletVolatility__SWIG_0`, 'returnType') = '_p_ConstantOptionletVolatilityPtr'
attr(`ConstantOptionletVolatility__SWIG_0`, "inputTypes") = c('_p_Date', '_p_Calendar', 'character', 'numeric', '_p_DayCounter')
class(`ConstantOptionletVolatility__SWIG_0`) = c("SWIGFunction", class('ConstantOptionletVolatility__SWIG_0'))

# Start of new_ConstantOptionletVolatility

`ConstantOptionletVolatility__SWIG_1` = function(referenceDate, cal, bdc, volatility, dayCounter)
{
  bdc = enumToInteger(bdc, "_BusinessDayConvention"); 
  
  if(length(bdc) > 1) {
    warning("using only the first element of bdc");
  };
  
  
  
  ;ans = .Call('R_swig_new_ConstantOptionletVolatility__SWIG_1', referenceDate, cal, bdc, volatility, dayCounter, PACKAGE='QuantLib');
  class(ans) <- "_p_ConstantOptionletVolatilityPtr";
  
  reg.finalizer(ans, delete_ConstantOptionletVolatility)
  ans
  
}

attr(`ConstantOptionletVolatility__SWIG_1`, 'returnType') = '_p_ConstantOptionletVolatilityPtr'
attr(`ConstantOptionletVolatility__SWIG_1`, "inputTypes") = c('_p_Date', '_p_Calendar', 'character', '_p_HandleT_Quote_t', '_p_DayCounter')
class(`ConstantOptionletVolatility__SWIG_1`) = c("SWIGFunction", class('ConstantOptionletVolatility__SWIG_1'))

# Start of new_ConstantOptionletVolatility

`ConstantOptionletVolatility__SWIG_2` = function(settlementDays, cal, bdc, volatility, dayCounter)
{
  if(length(settlementDays) > 1) {
    warning("using only the first element of settlementDays");
  };
  
  
  bdc = enumToInteger(bdc, "_BusinessDayConvention"); 
  
  if(length(bdc) > 1) {
    warning("using only the first element of bdc");
  };
  
  
  
  ;ans = .Call('R_swig_new_ConstantOptionletVolatility__SWIG_2', settlementDays, cal, bdc, volatility, dayCounter, PACKAGE='QuantLib');
  class(ans) <- "_p_ConstantOptionletVolatilityPtr";
  
  reg.finalizer(ans, delete_ConstantOptionletVolatility)
  ans
  
}

attr(`ConstantOptionletVolatility__SWIG_2`, 'returnType') = '_p_ConstantOptionletVolatilityPtr'
attr(`ConstantOptionletVolatility__SWIG_2`, "inputTypes") = c('integer', '_p_Calendar', 'character', 'numeric', '_p_DayCounter')
class(`ConstantOptionletVolatility__SWIG_2`) = c("SWIGFunction", class('ConstantOptionletVolatility__SWIG_2'))

# Start of new_ConstantOptionletVolatility

`ConstantOptionletVolatility__SWIG_3` = function(settlementDays, cal, bdc, volatility, dayCounter)
{
  if(length(settlementDays) > 1) {
    warning("using only the first element of settlementDays");
  };
  
  
  bdc = enumToInteger(bdc, "_BusinessDayConvention"); 
  
  if(length(bdc) > 1) {
    warning("using only the first element of bdc");
  };
  
  
  
  ;ans = .Call('R_swig_new_ConstantOptionletVolatility__SWIG_3', settlementDays, cal, bdc, volatility, dayCounter, PACKAGE='QuantLib');
  class(ans) <- "_p_ConstantOptionletVolatilityPtr";
  
  reg.finalizer(ans, delete_ConstantOptionletVolatility)
  ans
  
}

attr(`ConstantOptionletVolatility__SWIG_3`, 'returnType') = '_p_ConstantOptionletVolatilityPtr'
attr(`ConstantOptionletVolatility__SWIG_3`, "inputTypes") = c('integer', '_p_Calendar', 'character', '_p_HandleT_Quote_t', '_p_DayCounter')
class(`ConstantOptionletVolatility__SWIG_3`) = c("SWIGFunction", class('ConstantOptionletVolatility__SWIG_3'))

`ConstantOptionletVolatility` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 5) {
    if (extends(argtypes[1], '_p_Date') && extends(argtypes[2], '_p_Calendar') && is.character(argv[[3]]) && extends(argtypes[4], '_p_HandleT_Quote_t') && extends(argtypes[5], '_p_DayCounter')) {
      f <- ConstantOptionletVolatility__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_Date') && extends(argtypes[2], '_p_Calendar') && is.character(argv[[3]]) && is.numeric(argv[[4]]) && extends(argtypes[5], '_p_DayCounter')) {
      f <- ConstantOptionletVolatility__SWIG_0; 
    }
    else if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && extends(argtypes[2], '_p_Calendar') && is.character(argv[[3]]) && extends(argtypes[4], '_p_HandleT_Quote_t') && extends(argtypes[5], '_p_DayCounter')) {
      f <- ConstantOptionletVolatility__SWIG_3; 
    }
    else if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && extends(argtypes[2], '_p_Calendar') && is.character(argv[[3]]) && is.numeric(argv[[4]]) && extends(argtypes[5], '_p_DayCounter')) {
      f <- ConstantOptionletVolatility__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for ConstantOptionletVolatility with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_ConstantOptionletVolatility

`delete_ConstantOptionletVolatility` = function(self)
{
  ;.Call('R_swig_delete_ConstantOptionletVolatility', self, PACKAGE='QuantLib');
  
}

attr(`delete_ConstantOptionletVolatility`, 'returnType') = 'void'
attr(`delete_ConstantOptionletVolatility`, "inputTypes") = c('_p_ConstantOptionletVolatilityPtr')
class(`delete_ConstantOptionletVolatility`) = c("SWIGFunction", class('delete_ConstantOptionletVolatility'))

setMethod('delete', '_p_ConstantOptionletVolatilityPtr', function(obj) {delete_ConstantOptionletVolatilityPtr(obj)})
# Start of new_ConstantSwaptionVolatility

`ConstantSwaptionVolatility__SWIG_0` = function(settlementDays, cal, bdc, volatility, dc)
{
  if(length(settlementDays) > 1) {
    warning("using only the first element of settlementDays");
  };
  
  
  bdc = enumToInteger(bdc, "_BusinessDayConvention"); 
  
  if(length(bdc) > 1) {
    warning("using only the first element of bdc");
  };
  
  
  
  ;ans = .Call('R_swig_new_ConstantSwaptionVolatility__SWIG_0', settlementDays, cal, bdc, volatility, dc, PACKAGE='QuantLib');
  class(ans) <- "_p_ConstantSwaptionVolatilityPtr";
  
  reg.finalizer(ans, delete_ConstantSwaptionVolatility)
  ans
  
}

attr(`ConstantSwaptionVolatility__SWIG_0`, 'returnType') = '_p_ConstantSwaptionVolatilityPtr'
attr(`ConstantSwaptionVolatility__SWIG_0`, "inputTypes") = c('integer', '_p_Calendar', 'character', '_p_HandleT_Quote_t', '_p_DayCounter')
class(`ConstantSwaptionVolatility__SWIG_0`) = c("SWIGFunction", class('ConstantSwaptionVolatility__SWIG_0'))

# Start of new_ConstantSwaptionVolatility

`ConstantSwaptionVolatility__SWIG_1` = function(referenceDate, cal, bdc, volatility, dc)
{
  bdc = enumToInteger(bdc, "_BusinessDayConvention"); 
  
  if(length(bdc) > 1) {
    warning("using only the first element of bdc");
  };
  
  
  
  ;ans = .Call('R_swig_new_ConstantSwaptionVolatility__SWIG_1', referenceDate, cal, bdc, volatility, dc, PACKAGE='QuantLib');
  class(ans) <- "_p_ConstantSwaptionVolatilityPtr";
  
  reg.finalizer(ans, delete_ConstantSwaptionVolatility)
  ans
  
}

attr(`ConstantSwaptionVolatility__SWIG_1`, 'returnType') = '_p_ConstantSwaptionVolatilityPtr'
attr(`ConstantSwaptionVolatility__SWIG_1`, "inputTypes") = c('_p_Date', '_p_Calendar', 'character', '_p_HandleT_Quote_t', '_p_DayCounter')
class(`ConstantSwaptionVolatility__SWIG_1`) = c("SWIGFunction", class('ConstantSwaptionVolatility__SWIG_1'))

# Start of new_ConstantSwaptionVolatility

`ConstantSwaptionVolatility__SWIG_2` = function(settlementDays, cal, bdc, volatility, dc)
{
  if(length(settlementDays) > 1) {
    warning("using only the first element of settlementDays");
  };
  
  
  bdc = enumToInteger(bdc, "_BusinessDayConvention"); 
  
  if(length(bdc) > 1) {
    warning("using only the first element of bdc");
  };
  
  
  
  ;ans = .Call('R_swig_new_ConstantSwaptionVolatility__SWIG_2', settlementDays, cal, bdc, volatility, dc, PACKAGE='QuantLib');
  class(ans) <- "_p_ConstantSwaptionVolatilityPtr";
  
  reg.finalizer(ans, delete_ConstantSwaptionVolatility)
  ans
  
}

attr(`ConstantSwaptionVolatility__SWIG_2`, 'returnType') = '_p_ConstantSwaptionVolatilityPtr'
attr(`ConstantSwaptionVolatility__SWIG_2`, "inputTypes") = c('integer', '_p_Calendar', 'character', 'numeric', '_p_DayCounter')
class(`ConstantSwaptionVolatility__SWIG_2`) = c("SWIGFunction", class('ConstantSwaptionVolatility__SWIG_2'))

# Start of new_ConstantSwaptionVolatility

`ConstantSwaptionVolatility__SWIG_3` = function(referenceDate, cal, bdc, volatility, dc)
{
  bdc = enumToInteger(bdc, "_BusinessDayConvention"); 
  
  if(length(bdc) > 1) {
    warning("using only the first element of bdc");
  };
  
  
  
  ;ans = .Call('R_swig_new_ConstantSwaptionVolatility__SWIG_3', referenceDate, cal, bdc, volatility, dc, PACKAGE='QuantLib');
  class(ans) <- "_p_ConstantSwaptionVolatilityPtr";
  
  reg.finalizer(ans, delete_ConstantSwaptionVolatility)
  ans
  
}

attr(`ConstantSwaptionVolatility__SWIG_3`, 'returnType') = '_p_ConstantSwaptionVolatilityPtr'
attr(`ConstantSwaptionVolatility__SWIG_3`, "inputTypes") = c('_p_Date', '_p_Calendar', 'character', 'numeric', '_p_DayCounter')
class(`ConstantSwaptionVolatility__SWIG_3`) = c("SWIGFunction", class('ConstantSwaptionVolatility__SWIG_3'))

`ConstantSwaptionVolatility` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 5) {
    if (extends(argtypes[1], '_p_Date') && extends(argtypes[2], '_p_Calendar') && is.character(argv[[3]]) && extends(argtypes[4], '_p_HandleT_Quote_t') && extends(argtypes[5], '_p_DayCounter')) {
      f <- ConstantSwaptionVolatility__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_Date') && extends(argtypes[2], '_p_Calendar') && is.character(argv[[3]]) && is.numeric(argv[[4]]) && extends(argtypes[5], '_p_DayCounter')) {
      f <- ConstantSwaptionVolatility__SWIG_3; 
    }
    else if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && extends(argtypes[2], '_p_Calendar') && is.character(argv[[3]]) && extends(argtypes[4], '_p_HandleT_Quote_t') && extends(argtypes[5], '_p_DayCounter')) {
      f <- ConstantSwaptionVolatility__SWIG_0; 
    }
    else if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && extends(argtypes[2], '_p_Calendar') && is.character(argv[[3]]) && is.numeric(argv[[4]]) && extends(argtypes[5], '_p_DayCounter')) {
      f <- ConstantSwaptionVolatility__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for ConstantSwaptionVolatility with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_ConstantSwaptionVolatility

`delete_ConstantSwaptionVolatility` = function(self)
{
  ;.Call('R_swig_delete_ConstantSwaptionVolatility', self, PACKAGE='QuantLib');
  
}

attr(`delete_ConstantSwaptionVolatility`, 'returnType') = 'void'
attr(`delete_ConstantSwaptionVolatility`, "inputTypes") = c('_p_ConstantSwaptionVolatilityPtr')
class(`delete_ConstantSwaptionVolatility`) = c("SWIGFunction", class('delete_ConstantSwaptionVolatility'))

setMethod('delete', '_p_ConstantSwaptionVolatilityPtr', function(obj) {delete_ConstantSwaptionVolatilityPtr(obj)})
# Start of new_SwaptionVolatilityMatrix

`SwaptionVolatilityMatrix__SWIG_0` = function(referenceDate, dates, lengths, vols, dayCounter)
{
  ;ans = .Call('R_swig_new_SwaptionVolatilityMatrix__SWIG_0', referenceDate, dates, lengths, vols, dayCounter, PACKAGE='QuantLib');
  class(ans) <- "_p_SwaptionVolatilityMatrixPtr";
  
  reg.finalizer(ans, delete_SwaptionVolatilityMatrix)
  ans
  
}

attr(`SwaptionVolatilityMatrix__SWIG_0`, 'returnType') = '_p_SwaptionVolatilityMatrixPtr'
attr(`SwaptionVolatilityMatrix__SWIG_0`, "inputTypes") = c('_p_Date', '_p_std__vectorT_Date_std__allocatorT_Date_t_t', '_p_std__vectorT_Period_std__allocatorT_Period_t_t', '_p_Matrix', '_p_DayCounter')
class(`SwaptionVolatilityMatrix__SWIG_0`) = c("SWIGFunction", class('SwaptionVolatilityMatrix__SWIG_0'))

# Start of new_SwaptionVolatilityMatrix

`SwaptionVolatilityMatrix__SWIG_1` = function(calendar, bdc, optionTenors, swapTenors, vols, dayCounter)
{
  bdc = enumToInteger(bdc, "_BusinessDayConvention"); 
  
  if(length(bdc) > 1) {
    warning("using only the first element of bdc");
  };
  
  
  
  
  
  ;ans = .Call('R_swig_new_SwaptionVolatilityMatrix__SWIG_1', calendar, bdc, optionTenors, swapTenors, vols, dayCounter, PACKAGE='QuantLib');
  class(ans) <- "_p_SwaptionVolatilityMatrixPtr";
  
  reg.finalizer(ans, delete_SwaptionVolatilityMatrix)
  ans
  
}

attr(`SwaptionVolatilityMatrix__SWIG_1`, 'returnType') = '_p_SwaptionVolatilityMatrixPtr'
attr(`SwaptionVolatilityMatrix__SWIG_1`, "inputTypes") = c('_p_Calendar', 'character', '_p_std__vectorT_Period_std__allocatorT_Period_t_t', '_p_std__vectorT_Period_std__allocatorT_Period_t_t', '_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t', '_p_DayCounter')
class(`SwaptionVolatilityMatrix__SWIG_1`) = c("SWIGFunction", class('SwaptionVolatilityMatrix__SWIG_1'))

# Start of new_SwaptionVolatilityMatrix

`SwaptionVolatilityMatrix__SWIG_2` = function(calendar, bdc, optionTenors, swapTenors, vols, dayCounter)
{
  bdc = enumToInteger(bdc, "_BusinessDayConvention"); 
  
  if(length(bdc) > 1) {
    warning("using only the first element of bdc");
  };
  
  
  
  
  
  ;ans = .Call('R_swig_new_SwaptionVolatilityMatrix__SWIG_2', calendar, bdc, optionTenors, swapTenors, vols, dayCounter, PACKAGE='QuantLib');
  class(ans) <- "_p_SwaptionVolatilityMatrixPtr";
  
  reg.finalizer(ans, delete_SwaptionVolatilityMatrix)
  ans
  
}

attr(`SwaptionVolatilityMatrix__SWIG_2`, 'returnType') = '_p_SwaptionVolatilityMatrixPtr'
attr(`SwaptionVolatilityMatrix__SWIG_2`, "inputTypes") = c('_p_Calendar', 'character', '_p_std__vectorT_Period_std__allocatorT_Period_t_t', '_p_std__vectorT_Period_std__allocatorT_Period_t_t', '_p_Matrix', '_p_DayCounter')
class(`SwaptionVolatilityMatrix__SWIG_2`) = c("SWIGFunction", class('SwaptionVolatilityMatrix__SWIG_2'))

`SwaptionVolatilityMatrix` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 5) {
    if (extends(argtypes[1], '_p_Date') && extends(argtypes[2], '_p_std__vectorT_Date_std__allocatorT_Date_t_t') && extends(argtypes[3], '_p_std__vectorT_Period_std__allocatorT_Period_t_t') && extends(argtypes[4], '_p_Matrix') && extends(argtypes[5], '_p_DayCounter')) {
      f <- SwaptionVolatilityMatrix__SWIG_0; 
    }
  } else if (argc == 6) {
    if (extends(argtypes[1], '_p_Calendar') && is.character(argv[[2]]) && extends(argtypes[3], '_p_std__vectorT_Period_std__allocatorT_Period_t_t') && extends(argtypes[4], '_p_std__vectorT_Period_std__allocatorT_Period_t_t') && extends(argtypes[5], '_p_Matrix') && extends(argtypes[6], '_p_DayCounter')) {
      f <- SwaptionVolatilityMatrix__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_Calendar') && is.character(argv[[2]]) && extends(argtypes[3], '_p_std__vectorT_Period_std__allocatorT_Period_t_t') && extends(argtypes[4], '_p_std__vectorT_Period_std__allocatorT_Period_t_t') && extends(argtypes[5], '_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t') && extends(argtypes[6], '_p_DayCounter')) {
      f <- SwaptionVolatilityMatrix__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for SwaptionVolatilityMatrix with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_SwaptionVolatilityMatrix

`delete_SwaptionVolatilityMatrix` = function(self)
{
  ;.Call('R_swig_delete_SwaptionVolatilityMatrix', self, PACKAGE='QuantLib');
  
}

attr(`delete_SwaptionVolatilityMatrix`, 'returnType') = 'void'
attr(`delete_SwaptionVolatilityMatrix`, "inputTypes") = c('_p_SwaptionVolatilityMatrixPtr')
class(`delete_SwaptionVolatilityMatrix`) = c("SWIGFunction", class('delete_SwaptionVolatilityMatrix'))

setMethod('delete', '_p_SwaptionVolatilityMatrixPtr', function(obj) {delete_SwaptionVolatilityMatrixPtr(obj)})
# Start of new_SwaptionVolCube1

`SwaptionVolCube1__SWIG_0` = function(atmVolStructure, optionTenors, swapTenors, strikeSpreads, volSpreads, swapIndexBase, shortSwapIndexBase, vegaWeightedSmileFit, parametersGuess, isParameterFixed, isAtmCalibrated, endCriteria, maxErrorTolerance, optMethod)
{
  vegaWeightedSmileFit = as.logical(vegaWeightedSmileFit);
  
  
  isAtmCalibrated = as.logical(isAtmCalibrated);
  
  
  
  ;ans = .Call('R_swig_new_SwaptionVolCube1__SWIG_0', atmVolStructure, optionTenors, swapTenors, strikeSpreads, volSpreads, swapIndexBase, shortSwapIndexBase, vegaWeightedSmileFit, parametersGuess, isParameterFixed, isAtmCalibrated, endCriteria, maxErrorTolerance, optMethod, PACKAGE='QuantLib');
  class(ans) <- "_p_SwaptionVolCube1Ptr";
  
  reg.finalizer(ans, delete_SwaptionVolCube1)
  ans
  
}

attr(`SwaptionVolCube1__SWIG_0`, 'returnType') = '_p_SwaptionVolCube1Ptr'
attr(`SwaptionVolCube1__SWIG_0`, "inputTypes") = c('_p_HandleT_SwaptionVolatilityStructure_t', '_p_std__vectorT_Period_std__allocatorT_Period_t_t', '_p_std__vectorT_Period_std__allocatorT_Period_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t', '_p_SwapIndexPtr', '_p_SwapIndexPtr', 'logical', '_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t', '_p_std__vectorT_bool_std__allocatorT_bool_t_t', 'logical', '_p_boost__shared_ptrT_EndCriteria_t', 'numeric', '_p_boost__shared_ptrT_OptimizationMethod_t')
class(`SwaptionVolCube1__SWIG_0`) = c("SWIGFunction", class('SwaptionVolCube1__SWIG_0'))

# Start of new_SwaptionVolCube1

`SwaptionVolCube1__SWIG_1` = function(atmVolStructure, optionTenors, swapTenors, strikeSpreads, volSpreads, swapIndexBase, shortSwapIndexBase, vegaWeightedSmileFit, parametersGuess, isParameterFixed, isAtmCalibrated, endCriteria, maxErrorTolerance)
{
  vegaWeightedSmileFit = as.logical(vegaWeightedSmileFit);
  
  
  isAtmCalibrated = as.logical(isAtmCalibrated);
  
  
  ;ans = .Call('R_swig_new_SwaptionVolCube1__SWIG_1', atmVolStructure, optionTenors, swapTenors, strikeSpreads, volSpreads, swapIndexBase, shortSwapIndexBase, vegaWeightedSmileFit, parametersGuess, isParameterFixed, isAtmCalibrated, endCriteria, maxErrorTolerance, PACKAGE='QuantLib');
  class(ans) <- "_p_SwaptionVolCube1Ptr";
  
  reg.finalizer(ans, delete_SwaptionVolCube1)
  ans
  
}

attr(`SwaptionVolCube1__SWIG_1`, 'returnType') = '_p_SwaptionVolCube1Ptr'
attr(`SwaptionVolCube1__SWIG_1`, "inputTypes") = c('_p_HandleT_SwaptionVolatilityStructure_t', '_p_std__vectorT_Period_std__allocatorT_Period_t_t', '_p_std__vectorT_Period_std__allocatorT_Period_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t', '_p_SwapIndexPtr', '_p_SwapIndexPtr', 'logical', '_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t', '_p_std__vectorT_bool_std__allocatorT_bool_t_t', 'logical', '_p_boost__shared_ptrT_EndCriteria_t', 'numeric')
class(`SwaptionVolCube1__SWIG_1`) = c("SWIGFunction", class('SwaptionVolCube1__SWIG_1'))

# Start of new_SwaptionVolCube1

`SwaptionVolCube1__SWIG_2` = function(atmVolStructure, optionTenors, swapTenors, strikeSpreads, volSpreads, swapIndexBase, shortSwapIndexBase, vegaWeightedSmileFit, parametersGuess, isParameterFixed, isAtmCalibrated, endCriteria)
{
  vegaWeightedSmileFit = as.logical(vegaWeightedSmileFit);
  
  
  isAtmCalibrated = as.logical(isAtmCalibrated);
  
  ;ans = .Call('R_swig_new_SwaptionVolCube1__SWIG_2', atmVolStructure, optionTenors, swapTenors, strikeSpreads, volSpreads, swapIndexBase, shortSwapIndexBase, vegaWeightedSmileFit, parametersGuess, isParameterFixed, isAtmCalibrated, endCriteria, PACKAGE='QuantLib');
  class(ans) <- "_p_SwaptionVolCube1Ptr";
  
  reg.finalizer(ans, delete_SwaptionVolCube1)
  ans
  
}

attr(`SwaptionVolCube1__SWIG_2`, 'returnType') = '_p_SwaptionVolCube1Ptr'
attr(`SwaptionVolCube1__SWIG_2`, "inputTypes") = c('_p_HandleT_SwaptionVolatilityStructure_t', '_p_std__vectorT_Period_std__allocatorT_Period_t_t', '_p_std__vectorT_Period_std__allocatorT_Period_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t', '_p_SwapIndexPtr', '_p_SwapIndexPtr', 'logical', '_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t', '_p_std__vectorT_bool_std__allocatorT_bool_t_t', 'logical', '_p_boost__shared_ptrT_EndCriteria_t')
class(`SwaptionVolCube1__SWIG_2`) = c("SWIGFunction", class('SwaptionVolCube1__SWIG_2'))

# Start of new_SwaptionVolCube1

`SwaptionVolCube1__SWIG_3` = function(atmVolStructure, optionTenors, swapTenors, strikeSpreads, volSpreads, swapIndexBase, shortSwapIndexBase, vegaWeightedSmileFit, parametersGuess, isParameterFixed, isAtmCalibrated)
{
  vegaWeightedSmileFit = as.logical(vegaWeightedSmileFit);
  
  
  isAtmCalibrated = as.logical(isAtmCalibrated);
  ;ans = .Call('R_swig_new_SwaptionVolCube1__SWIG_3', atmVolStructure, optionTenors, swapTenors, strikeSpreads, volSpreads, swapIndexBase, shortSwapIndexBase, vegaWeightedSmileFit, parametersGuess, isParameterFixed, isAtmCalibrated, PACKAGE='QuantLib');
  class(ans) <- "_p_SwaptionVolCube1Ptr";
  
  reg.finalizer(ans, delete_SwaptionVolCube1)
  ans
  
}

attr(`SwaptionVolCube1__SWIG_3`, 'returnType') = '_p_SwaptionVolCube1Ptr'
attr(`SwaptionVolCube1__SWIG_3`, "inputTypes") = c('_p_HandleT_SwaptionVolatilityStructure_t', '_p_std__vectorT_Period_std__allocatorT_Period_t_t', '_p_std__vectorT_Period_std__allocatorT_Period_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t', '_p_SwapIndexPtr', '_p_SwapIndexPtr', 'logical', '_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t', '_p_std__vectorT_bool_std__allocatorT_bool_t_t', 'logical')
class(`SwaptionVolCube1__SWIG_3`) = c("SWIGFunction", class('SwaptionVolCube1__SWIG_3'))

`SwaptionVolCube1` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 11) {
    if (extends(argtypes[1], '_p_HandleT_SwaptionVolatilityStructure_t') && extends(argtypes[2], '_p_std__vectorT_Period_std__allocatorT_Period_t_t') && extends(argtypes[3], '_p_std__vectorT_Period_std__allocatorT_Period_t_t') && extends(argtypes[4], '_p_std__vectorT_double_std__allocatorT_double_t_t') && extends(argtypes[5], '_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t') && extends(argtypes[6], '_p_SwapIndexPtr') && extends(argtypes[7], '_p_SwapIndexPtr') && extends(argtypes[8], 'logical') && extends(argtypes[9], '_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t') && extends(argtypes[10], '_p_std__vectorT_bool_std__allocatorT_bool_t_t') && extends(argtypes[11], 'logical')) {
      f <- SwaptionVolCube1__SWIG_3; 
    }
  } else if (argc == 12) {
    if (extends(argtypes[1], '_p_HandleT_SwaptionVolatilityStructure_t') && extends(argtypes[2], '_p_std__vectorT_Period_std__allocatorT_Period_t_t') && extends(argtypes[3], '_p_std__vectorT_Period_std__allocatorT_Period_t_t') && extends(argtypes[4], '_p_std__vectorT_double_std__allocatorT_double_t_t') && extends(argtypes[5], '_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t') && extends(argtypes[6], '_p_SwapIndexPtr') && extends(argtypes[7], '_p_SwapIndexPtr') && extends(argtypes[8], 'logical') && extends(argtypes[9], '_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t') && extends(argtypes[10], '_p_std__vectorT_bool_std__allocatorT_bool_t_t') && extends(argtypes[11], 'logical') && extends(argtypes[12], '_p_boost__shared_ptrT_EndCriteria_t')) {
      f <- SwaptionVolCube1__SWIG_2; 
    }
  } else if (argc == 13) {
    if (extends(argtypes[1], '_p_HandleT_SwaptionVolatilityStructure_t') && extends(argtypes[2], '_p_std__vectorT_Period_std__allocatorT_Period_t_t') && extends(argtypes[3], '_p_std__vectorT_Period_std__allocatorT_Period_t_t') && extends(argtypes[4], '_p_std__vectorT_double_std__allocatorT_double_t_t') && extends(argtypes[5], '_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t') && extends(argtypes[6], '_p_SwapIndexPtr') && extends(argtypes[7], '_p_SwapIndexPtr') && extends(argtypes[8], 'logical') && extends(argtypes[9], '_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t') && extends(argtypes[10], '_p_std__vectorT_bool_std__allocatorT_bool_t_t') && extends(argtypes[11], 'logical') && extends(argtypes[12], '_p_boost__shared_ptrT_EndCriteria_t') && is.numeric(argv[[13]])) {
      f <- SwaptionVolCube1__SWIG_1; 
    }
  } else if (argc == 14) {
    if (extends(argtypes[1], '_p_HandleT_SwaptionVolatilityStructure_t') && extends(argtypes[2], '_p_std__vectorT_Period_std__allocatorT_Period_t_t') && extends(argtypes[3], '_p_std__vectorT_Period_std__allocatorT_Period_t_t') && extends(argtypes[4], '_p_std__vectorT_double_std__allocatorT_double_t_t') && extends(argtypes[5], '_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t') && extends(argtypes[6], '_p_SwapIndexPtr') && extends(argtypes[7], '_p_SwapIndexPtr') && extends(argtypes[8], 'logical') && extends(argtypes[9], '_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t') && extends(argtypes[10], '_p_std__vectorT_bool_std__allocatorT_bool_t_t') && extends(argtypes[11], 'logical') && extends(argtypes[12], '_p_boost__shared_ptrT_EndCriteria_t') && is.numeric(argv[[13]]) && extends(argtypes[14], '_p_boost__shared_ptrT_OptimizationMethod_t')) {
      f <- SwaptionVolCube1__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for SwaptionVolCube1 with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_SwaptionVolCube1

`delete_SwaptionVolCube1` = function(self)
{
  ;.Call('R_swig_delete_SwaptionVolCube1', self, PACKAGE='QuantLib');
  
}

attr(`delete_SwaptionVolCube1`, 'returnType') = 'void'
attr(`delete_SwaptionVolCube1`, "inputTypes") = c('_p_SwaptionVolCube1Ptr')
class(`delete_SwaptionVolCube1`) = c("SWIGFunction", class('delete_SwaptionVolCube1'))

setMethod('delete', '_p_SwaptionVolCube1Ptr', function(obj) {delete_SwaptionVolCube1Ptr(obj)})
# Start of new_SwaptionVolCube2

`SwaptionVolCube2` = function(atmVolStructure, optionTenors, swapTenors, strikeSpreads, volSpreads, swapIndexBase, shortSwapIndexBase, vegaWeightedSmileFit)
{
  vegaWeightedSmileFit = as.logical(vegaWeightedSmileFit);
  ;ans = .Call('R_swig_new_SwaptionVolCube2', atmVolStructure, optionTenors, swapTenors, strikeSpreads, volSpreads, swapIndexBase, shortSwapIndexBase, vegaWeightedSmileFit, PACKAGE='QuantLib');
  class(ans) <- "_p_SwaptionVolCube2Ptr";
  
  reg.finalizer(ans, delete_SwaptionVolCube2)
  ans
  
}

attr(`SwaptionVolCube2`, 'returnType') = '_p_SwaptionVolCube2Ptr'
attr(`SwaptionVolCube2`, "inputTypes") = c('_p_HandleT_SwaptionVolatilityStructure_t', '_p_std__vectorT_Period_std__allocatorT_Period_t_t', '_p_std__vectorT_Period_std__allocatorT_Period_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_std__allocatorT_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t_t_t', '_p_SwapIndexPtr', '_p_SwapIndexPtr', 'logical')
class(`SwaptionVolCube2`) = c("SWIGFunction", class('SwaptionVolCube2'))

# Start of delete_SwaptionVolCube2

`delete_SwaptionVolCube2` = function(self)
{
  ;.Call('R_swig_delete_SwaptionVolCube2', self, PACKAGE='QuantLib');
  
}

attr(`delete_SwaptionVolCube2`, 'returnType') = 'void'
attr(`delete_SwaptionVolCube2`, "inputTypes") = c('_p_SwaptionVolCube2Ptr')
class(`delete_SwaptionVolCube2`) = c("SWIGFunction", class('delete_SwaptionVolCube2'))

setMethod('delete', '_p_SwaptionVolCube2Ptr', function(obj) {delete_SwaptionVolCube2Ptr(obj)})
# Start of StochasticProcess___deref__

`StochasticProcess___deref__` = function(self)
{
  ;ans = .Call('R_swig_StochasticProcess___deref__', self, PACKAGE='QuantLib');
  class(ans) <- "_p_StochasticProcess";
  
  ans
  
}

attr(`StochasticProcess___deref__`, 'returnType') = '_p_StochasticProcess'
attr(`StochasticProcess___deref__`, "inputTypes") = c('_p_boost__shared_ptrT_StochasticProcess_t')
class(`StochasticProcess___deref__`) = c("SWIGFunction", class('StochasticProcess___deref__'))

# Start of StochasticProcess_isNull

`StochasticProcess_isNull` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_StochasticProcess_isNull', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`StochasticProcess_isNull`, 'returnType') = 'logical'
attr(`StochasticProcess_isNull`, "inputTypes") = c('_p_boost__shared_ptrT_StochasticProcess_t')
class(`StochasticProcess_isNull`) = c("SWIGFunction", class('StochasticProcess_isNull'))

# Start of StochasticProcess_asObservable

`StochasticProcess_asObservable` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_StochasticProcess_asObservable', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_Observable_t";
  
  ans
  
}

attr(`StochasticProcess_asObservable`, 'returnType') = '_p_boost__shared_ptrT_Observable_t'
attr(`StochasticProcess_asObservable`, "inputTypes") = c('_p_boost__shared_ptrT_StochasticProcess_t')
class(`StochasticProcess_asObservable`) = c("SWIGFunction", class('StochasticProcess_asObservable'))

# Start of new_StochasticProcess

`StochasticProcess` = function()
{
  ;ans = .Call('R_swig_new_StochasticProcess', PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_StochasticProcess_t";
  
  reg.finalizer(ans, delete_StochasticProcess)
  ans
  
}

attr(`StochasticProcess`, 'returnType') = '_p_boost__shared_ptrT_StochasticProcess_t'
class(`StochasticProcess`) = c("SWIGFunction", class('StochasticProcess'))

# Start of delete_StochasticProcess

`delete_StochasticProcess` = function(self)
{
  ;.Call('R_swig_delete_StochasticProcess', self, PACKAGE='QuantLib');
  
}

attr(`delete_StochasticProcess`, 'returnType') = 'void'
attr(`delete_StochasticProcess`, "inputTypes") = c('_p_boost__shared_ptrT_StochasticProcess_t')
class(`delete_StochasticProcess`) = c("SWIGFunction", class('delete_StochasticProcess'))

# Start of accessor method for boost::shared_ptr<(StochasticProcess)>
setMethod('$', '_p_boost__shared_ptrT_StochasticProcess_t', function(x, name)

{
  accessorFuns = list('__deref__' = StochasticProcess___deref__, 'isNull' = StochasticProcess_isNull, 'asObservable' = StochasticProcess_asObservable);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for boost::shared_ptr<(StochasticProcess)>
setMethod('delete', '_p_boost__shared_ptrT_StochasticProcess_t', function(obj) {delete_boost__shared_ptrT_StochasticProcess_t(obj)})
# Start of delete_StochasticProcess1D

`delete_StochasticProcess1D` = function(self)
{
  ;.Call('R_swig_delete_StochasticProcess1D', self, PACKAGE='QuantLib');
  
}

attr(`delete_StochasticProcess1D`, 'returnType') = 'void'
attr(`delete_StochasticProcess1D`, "inputTypes") = c('_p_StochasticProcess1DPtr')
class(`delete_StochasticProcess1D`) = c("SWIGFunction", class('delete_StochasticProcess1D'))

setMethod('delete', '_p_StochasticProcess1DPtr', function(obj) {delete_StochasticProcess1DPtr(obj)})
# Start of new_GeneralizedBlackScholesProcess

`GeneralizedBlackScholesProcess` = function(s0, dividendTS, riskFreeTS, volTS)
{
  ;ans = .Call('R_swig_new_GeneralizedBlackScholesProcess', s0, dividendTS, riskFreeTS, volTS, PACKAGE='QuantLib');
  class(ans) <- "_p_GeneralizedBlackScholesProcessPtr";
  
  reg.finalizer(ans, delete_GeneralizedBlackScholesProcess)
  ans
  
}

attr(`GeneralizedBlackScholesProcess`, 'returnType') = '_p_GeneralizedBlackScholesProcessPtr'
attr(`GeneralizedBlackScholesProcess`, "inputTypes") = c('_p_HandleT_Quote_t', '_p_HandleT_YieldTermStructure_t', '_p_HandleT_YieldTermStructure_t', '_p_HandleT_BlackVolTermStructure_t')
class(`GeneralizedBlackScholesProcess`) = c("SWIGFunction", class('GeneralizedBlackScholesProcess'))

# Start of GeneralizedBlackScholesProcess_stateVariable

`GeneralizedBlackScholesProcess_stateVariable` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_GeneralizedBlackScholesProcess_stateVariable', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_HandleT_Quote_t";
  
  ans
  
}

attr(`GeneralizedBlackScholesProcess_stateVariable`, 'returnType') = '_p_HandleT_Quote_t'
attr(`GeneralizedBlackScholesProcess_stateVariable`, "inputTypes") = c('_p_GeneralizedBlackScholesProcessPtr')
class(`GeneralizedBlackScholesProcess_stateVariable`) = c("SWIGFunction", class('GeneralizedBlackScholesProcess_stateVariable'))

# Start of GeneralizedBlackScholesProcess_dividendYield

`GeneralizedBlackScholesProcess_dividendYield` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_GeneralizedBlackScholesProcess_dividendYield', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_HandleT_YieldTermStructure_t";
  
  ans
  
}

attr(`GeneralizedBlackScholesProcess_dividendYield`, 'returnType') = '_p_HandleT_YieldTermStructure_t'
attr(`GeneralizedBlackScholesProcess_dividendYield`, "inputTypes") = c('_p_GeneralizedBlackScholesProcessPtr')
class(`GeneralizedBlackScholesProcess_dividendYield`) = c("SWIGFunction", class('GeneralizedBlackScholesProcess_dividendYield'))

# Start of GeneralizedBlackScholesProcess_riskFreeRate

`GeneralizedBlackScholesProcess_riskFreeRate` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_GeneralizedBlackScholesProcess_riskFreeRate', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_HandleT_YieldTermStructure_t";
  
  ans
  
}

attr(`GeneralizedBlackScholesProcess_riskFreeRate`, 'returnType') = '_p_HandleT_YieldTermStructure_t'
attr(`GeneralizedBlackScholesProcess_riskFreeRate`, "inputTypes") = c('_p_GeneralizedBlackScholesProcessPtr')
class(`GeneralizedBlackScholesProcess_riskFreeRate`) = c("SWIGFunction", class('GeneralizedBlackScholesProcess_riskFreeRate'))

# Start of GeneralizedBlackScholesProcess_blackVolatility

`GeneralizedBlackScholesProcess_blackVolatility` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_GeneralizedBlackScholesProcess_blackVolatility', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_HandleT_BlackVolTermStructure_t";
  
  ans
  
}

attr(`GeneralizedBlackScholesProcess_blackVolatility`, 'returnType') = '_p_HandleT_BlackVolTermStructure_t'
attr(`GeneralizedBlackScholesProcess_blackVolatility`, "inputTypes") = c('_p_GeneralizedBlackScholesProcessPtr')
class(`GeneralizedBlackScholesProcess_blackVolatility`) = c("SWIGFunction", class('GeneralizedBlackScholesProcess_blackVolatility'))

# Start of delete_GeneralizedBlackScholesProcess

`delete_GeneralizedBlackScholesProcess` = function(self)
{
  ;.Call('R_swig_delete_GeneralizedBlackScholesProcess', self, PACKAGE='QuantLib');
  
}

attr(`delete_GeneralizedBlackScholesProcess`, 'returnType') = 'void'
attr(`delete_GeneralizedBlackScholesProcess`, "inputTypes") = c('_p_GeneralizedBlackScholesProcessPtr')
class(`delete_GeneralizedBlackScholesProcess`) = c("SWIGFunction", class('delete_GeneralizedBlackScholesProcess'))

# Start of accessor method for GeneralizedBlackScholesProcessPtr
setMethod('$', '_p_GeneralizedBlackScholesProcessPtr', function(x, name)

{
  accessorFuns = list('stateVariable' = GeneralizedBlackScholesProcess_stateVariable, 'dividendYield' = GeneralizedBlackScholesProcess_dividendYield, 'riskFreeRate' = GeneralizedBlackScholesProcess_riskFreeRate, 'blackVolatility' = GeneralizedBlackScholesProcess_blackVolatility);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for GeneralizedBlackScholesProcessPtr
setMethod('delete', '_p_GeneralizedBlackScholesProcessPtr', function(obj) {delete_GeneralizedBlackScholesProcessPtr(obj)})
# Start of new_BlackScholesProcess

`BlackScholesProcess` = function(s0, riskFreeTS, volTS)
{
  ;ans = .Call('R_swig_new_BlackScholesProcess', s0, riskFreeTS, volTS, PACKAGE='QuantLib');
  class(ans) <- "_p_BlackScholesProcessPtr";
  
  reg.finalizer(ans, delete_BlackScholesProcess)
  ans
  
}

attr(`BlackScholesProcess`, 'returnType') = '_p_BlackScholesProcessPtr'
attr(`BlackScholesProcess`, "inputTypes") = c('_p_HandleT_Quote_t', '_p_HandleT_YieldTermStructure_t', '_p_HandleT_BlackVolTermStructure_t')
class(`BlackScholesProcess`) = c("SWIGFunction", class('BlackScholesProcess'))

# Start of delete_BlackScholesProcess

`delete_BlackScholesProcess` = function(self)
{
  ;.Call('R_swig_delete_BlackScholesProcess', self, PACKAGE='QuantLib');
  
}

attr(`delete_BlackScholesProcess`, 'returnType') = 'void'
attr(`delete_BlackScholesProcess`, "inputTypes") = c('_p_BlackScholesProcessPtr')
class(`delete_BlackScholesProcess`) = c("SWIGFunction", class('delete_BlackScholesProcess'))

setMethod('delete', '_p_BlackScholesProcessPtr', function(obj) {delete_BlackScholesProcessPtr(obj)})
# Start of new_BlackScholesMertonProcess

`BlackScholesMertonProcess` = function(s0, dividendTS, riskFreeTS, volTS)
{
  ;ans = .Call('R_swig_new_BlackScholesMertonProcess', s0, dividendTS, riskFreeTS, volTS, PACKAGE='QuantLib');
  class(ans) <- "_p_BlackScholesMertonProcessPtr";
  
  reg.finalizer(ans, delete_BlackScholesMertonProcess)
  ans
  
}

attr(`BlackScholesMertonProcess`, 'returnType') = '_p_BlackScholesMertonProcessPtr'
attr(`BlackScholesMertonProcess`, "inputTypes") = c('_p_HandleT_Quote_t', '_p_HandleT_YieldTermStructure_t', '_p_HandleT_YieldTermStructure_t', '_p_HandleT_BlackVolTermStructure_t')
class(`BlackScholesMertonProcess`) = c("SWIGFunction", class('BlackScholesMertonProcess'))

# Start of delete_BlackScholesMertonProcess

`delete_BlackScholesMertonProcess` = function(self)
{
  ;.Call('R_swig_delete_BlackScholesMertonProcess', self, PACKAGE='QuantLib');
  
}

attr(`delete_BlackScholesMertonProcess`, 'returnType') = 'void'
attr(`delete_BlackScholesMertonProcess`, "inputTypes") = c('_p_BlackScholesMertonProcessPtr')
class(`delete_BlackScholesMertonProcess`) = c("SWIGFunction", class('delete_BlackScholesMertonProcess'))

setMethod('delete', '_p_BlackScholesMertonProcessPtr', function(obj) {delete_BlackScholesMertonProcessPtr(obj)})
# Start of new_BlackProcess

`BlackProcess` = function(s0, riskFreeTS, volTS)
{
  ;ans = .Call('R_swig_new_BlackProcess', s0, riskFreeTS, volTS, PACKAGE='QuantLib');
  class(ans) <- "_p_BlackProcessPtr";
  
  reg.finalizer(ans, delete_BlackProcess)
  ans
  
}

attr(`BlackProcess`, 'returnType') = '_p_BlackProcessPtr'
attr(`BlackProcess`, "inputTypes") = c('_p_HandleT_Quote_t', '_p_HandleT_YieldTermStructure_t', '_p_HandleT_BlackVolTermStructure_t')
class(`BlackProcess`) = c("SWIGFunction", class('BlackProcess'))

# Start of delete_BlackProcess

`delete_BlackProcess` = function(self)
{
  ;.Call('R_swig_delete_BlackProcess', self, PACKAGE='QuantLib');
  
}

attr(`delete_BlackProcess`, 'returnType') = 'void'
attr(`delete_BlackProcess`, "inputTypes") = c('_p_BlackProcessPtr')
class(`delete_BlackProcess`) = c("SWIGFunction", class('delete_BlackProcess'))

setMethod('delete', '_p_BlackProcessPtr', function(obj) {delete_BlackProcessPtr(obj)})
# Start of new_GarmanKohlagenProcess

`GarmanKohlagenProcess` = function(s0, foreignRiskFreeTS, domesticRiskFreeTS, volTS)
{
  ;ans = .Call('R_swig_new_GarmanKohlagenProcess', s0, foreignRiskFreeTS, domesticRiskFreeTS, volTS, PACKAGE='QuantLib');
  class(ans) <- "_p_GarmanKohlagenProcessPtr";
  
  reg.finalizer(ans, delete_GarmanKohlagenProcess)
  ans
  
}

attr(`GarmanKohlagenProcess`, 'returnType') = '_p_GarmanKohlagenProcessPtr'
attr(`GarmanKohlagenProcess`, "inputTypes") = c('_p_HandleT_Quote_t', '_p_HandleT_YieldTermStructure_t', '_p_HandleT_YieldTermStructure_t', '_p_HandleT_BlackVolTermStructure_t')
class(`GarmanKohlagenProcess`) = c("SWIGFunction", class('GarmanKohlagenProcess'))

# Start of delete_GarmanKohlagenProcess

`delete_GarmanKohlagenProcess` = function(self)
{
  ;.Call('R_swig_delete_GarmanKohlagenProcess', self, PACKAGE='QuantLib');
  
}

attr(`delete_GarmanKohlagenProcess`, 'returnType') = 'void'
attr(`delete_GarmanKohlagenProcess`, "inputTypes") = c('_p_GarmanKohlagenProcessPtr')
class(`delete_GarmanKohlagenProcess`) = c("SWIGFunction", class('delete_GarmanKohlagenProcess'))

setMethod('delete', '_p_GarmanKohlagenProcessPtr', function(obj) {delete_GarmanKohlagenProcessPtr(obj)})
# Start of new_Merton76Process

`Merton76Process` = function(stateVariable, dividendTS, riskFreeTS, volTS, jumpIntensity, meanLogJump, jumpVolatility)
{
  ;ans = .Call('R_swig_new_Merton76Process', stateVariable, dividendTS, riskFreeTS, volTS, jumpIntensity, meanLogJump, jumpVolatility, PACKAGE='QuantLib');
  class(ans) <- "_p_Merton76ProcessPtr";
  
  reg.finalizer(ans, delete_Merton76Process)
  ans
  
}

attr(`Merton76Process`, 'returnType') = '_p_Merton76ProcessPtr'
attr(`Merton76Process`, "inputTypes") = c('_p_HandleT_Quote_t', '_p_HandleT_YieldTermStructure_t', '_p_HandleT_YieldTermStructure_t', '_p_HandleT_BlackVolTermStructure_t', '_p_HandleT_Quote_t', '_p_HandleT_Quote_t', '_p_HandleT_Quote_t')
class(`Merton76Process`) = c("SWIGFunction", class('Merton76Process'))

# Start of delete_Merton76Process

`delete_Merton76Process` = function(self)
{
  ;.Call('R_swig_delete_Merton76Process', self, PACKAGE='QuantLib');
  
}

attr(`delete_Merton76Process`, 'returnType') = 'void'
attr(`delete_Merton76Process`, "inputTypes") = c('_p_Merton76ProcessPtr')
class(`delete_Merton76Process`) = c("SWIGFunction", class('delete_Merton76Process'))

setMethod('delete', '_p_Merton76ProcessPtr', function(obj) {delete_Merton76ProcessPtr(obj)})
# Start of new_StochasticProcessArray

`StochasticProcessArray` = function(array, correlation)
{
  ;ans = .Call('R_swig_new_StochasticProcessArray', array, correlation, PACKAGE='QuantLib');
  class(ans) <- "_p_StochasticProcessArrayPtr";
  
  reg.finalizer(ans, delete_StochasticProcessArray)
  ans
  
}

attr(`StochasticProcessArray`, 'returnType') = '_p_StochasticProcessArrayPtr'
attr(`StochasticProcessArray`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_StochasticProcess_t_std__allocatorT_boost__shared_ptrT_StochasticProcess_t_t_t', '_p_Matrix')
class(`StochasticProcessArray`) = c("SWIGFunction", class('StochasticProcessArray'))

# Start of delete_StochasticProcessArray

`delete_StochasticProcessArray` = function(self)
{
  ;.Call('R_swig_delete_StochasticProcessArray', self, PACKAGE='QuantLib');
  
}

attr(`delete_StochasticProcessArray`, 'returnType') = 'void'
attr(`delete_StochasticProcessArray`, "inputTypes") = c('_p_StochasticProcessArrayPtr')
class(`delete_StochasticProcessArray`) = c("SWIGFunction", class('delete_StochasticProcessArray'))

setMethod('delete', '_p_StochasticProcessArrayPtr', function(obj) {delete_StochasticProcessArrayPtr(obj)})
# Start of new_GeometricBrownianMotionProcess

`GeometricBrownianMotionProcess` = function(initialValue, mu, sigma)
{
  ;ans = .Call('R_swig_new_GeometricBrownianMotionProcess', initialValue, mu, sigma, PACKAGE='QuantLib');
  class(ans) <- "_p_GeometricBrownianMotionProcessPtr";
  
  reg.finalizer(ans, delete_GeometricBrownianMotionProcess)
  ans
  
}

attr(`GeometricBrownianMotionProcess`, 'returnType') = '_p_GeometricBrownianMotionProcessPtr'
attr(`GeometricBrownianMotionProcess`, "inputTypes") = c('numeric', 'numeric', 'numeric')
class(`GeometricBrownianMotionProcess`) = c("SWIGFunction", class('GeometricBrownianMotionProcess'))

# Start of delete_GeometricBrownianMotionProcess

`delete_GeometricBrownianMotionProcess` = function(self)
{
  ;.Call('R_swig_delete_GeometricBrownianMotionProcess', self, PACKAGE='QuantLib');
  
}

attr(`delete_GeometricBrownianMotionProcess`, 'returnType') = 'void'
attr(`delete_GeometricBrownianMotionProcess`, "inputTypes") = c('_p_GeometricBrownianMotionProcessPtr')
class(`delete_GeometricBrownianMotionProcess`) = c("SWIGFunction", class('delete_GeometricBrownianMotionProcess'))

setMethod('delete', '_p_GeometricBrownianMotionProcessPtr', function(obj) {delete_GeometricBrownianMotionProcessPtr(obj)})
# Start of new_VarianceGammaProcess

`VarianceGammaProcess` = function(s0, dividendYield, riskFreeRate, sigma, nu, theta)
{
  ;ans = .Call('R_swig_new_VarianceGammaProcess', s0, dividendYield, riskFreeRate, sigma, nu, theta, PACKAGE='QuantLib');
  class(ans) <- "_p_VarianceGammaProcessPtr";
  
  reg.finalizer(ans, delete_VarianceGammaProcess)
  ans
  
}

attr(`VarianceGammaProcess`, 'returnType') = '_p_VarianceGammaProcessPtr'
attr(`VarianceGammaProcess`, "inputTypes") = c('_p_HandleT_Quote_t', '_p_HandleT_YieldTermStructure_t', '_p_HandleT_YieldTermStructure_t', 'numeric', 'numeric', 'numeric')
class(`VarianceGammaProcess`) = c("SWIGFunction", class('VarianceGammaProcess'))

# Start of delete_VarianceGammaProcess

`delete_VarianceGammaProcess` = function(self)
{
  ;.Call('R_swig_delete_VarianceGammaProcess', self, PACKAGE='QuantLib');
  
}

attr(`delete_VarianceGammaProcess`, 'returnType') = 'void'
attr(`delete_VarianceGammaProcess`, "inputTypes") = c('_p_VarianceGammaProcessPtr')
class(`delete_VarianceGammaProcess`) = c("SWIGFunction", class('delete_VarianceGammaProcess'))

setMethod('delete', '_p_VarianceGammaProcessPtr', function(obj) {delete_VarianceGammaProcessPtr(obj)})
# Start of new_HestonProcess

`HestonProcess` = function(riskFreeTS, dividendTS, s0, v0, kappa, theta, sigma, rho)
{
  ;ans = .Call('R_swig_new_HestonProcess', riskFreeTS, dividendTS, s0, v0, kappa, theta, sigma, rho, PACKAGE='QuantLib');
  class(ans) <- "_p_HestonProcessPtr";
  
  reg.finalizer(ans, delete_HestonProcess)
  ans
  
}

attr(`HestonProcess`, 'returnType') = '_p_HestonProcessPtr'
attr(`HestonProcess`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t', '_p_HandleT_YieldTermStructure_t', '_p_HandleT_Quote_t', 'numeric', 'numeric', 'numeric', 'numeric', 'numeric')
class(`HestonProcess`) = c("SWIGFunction", class('HestonProcess'))

# Start of HestonProcess_s0

`HestonProcess_s0` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_HestonProcess_s0', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_HandleT_Quote_t";
  
  ans
  
}

attr(`HestonProcess_s0`, 'returnType') = '_p_HandleT_Quote_t'
attr(`HestonProcess_s0`, "inputTypes") = c('_p_HestonProcessPtr')
class(`HestonProcess_s0`) = c("SWIGFunction", class('HestonProcess_s0'))

# Start of HestonProcess_dividendYield

`HestonProcess_dividendYield` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_HestonProcess_dividendYield', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_HandleT_YieldTermStructure_t";
  
  ans
  
}

attr(`HestonProcess_dividendYield`, 'returnType') = '_p_HandleT_YieldTermStructure_t'
attr(`HestonProcess_dividendYield`, "inputTypes") = c('_p_HestonProcessPtr')
class(`HestonProcess_dividendYield`) = c("SWIGFunction", class('HestonProcess_dividendYield'))

# Start of HestonProcess_riskFreeRate

`HestonProcess_riskFreeRate` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_HestonProcess_riskFreeRate', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_HandleT_YieldTermStructure_t";
  
  ans
  
}

attr(`HestonProcess_riskFreeRate`, 'returnType') = '_p_HandleT_YieldTermStructure_t'
attr(`HestonProcess_riskFreeRate`, "inputTypes") = c('_p_HestonProcessPtr')
class(`HestonProcess_riskFreeRate`) = c("SWIGFunction", class('HestonProcess_riskFreeRate'))

# Start of delete_HestonProcess

`delete_HestonProcess` = function(self)
{
  ;.Call('R_swig_delete_HestonProcess', self, PACKAGE='QuantLib');
  
}

attr(`delete_HestonProcess`, 'returnType') = 'void'
attr(`delete_HestonProcess`, "inputTypes") = c('_p_HestonProcessPtr')
class(`delete_HestonProcess`) = c("SWIGFunction", class('delete_HestonProcess'))

# Start of accessor method for HestonProcessPtr
setMethod('$', '_p_HestonProcessPtr', function(x, name)

{
  accessorFuns = list('s0' = HestonProcess_s0, 'dividendYield' = HestonProcess_dividendYield, 'riskFreeRate' = HestonProcess_riskFreeRate);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for HestonProcessPtr
setMethod('delete', '_p_HestonProcessPtr', function(obj) {delete_HestonProcessPtr(obj)})
# Start of new_BatesProcess

`BatesProcess` = function(riskFreeRate, dividendYield, s0, v0, kappa, theta, sigma, rho, lambda, nu, delta)
{
  ;ans = .Call('R_swig_new_BatesProcess', riskFreeRate, dividendYield, s0, v0, kappa, theta, sigma, rho, lambda, nu, delta, PACKAGE='QuantLib');
  class(ans) <- "_p_BatesProcessPtr";
  
  reg.finalizer(ans, delete_BatesProcess)
  ans
  
}

attr(`BatesProcess`, 'returnType') = '_p_BatesProcessPtr'
attr(`BatesProcess`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t', '_p_HandleT_YieldTermStructure_t', '_p_HandleT_Quote_t', 'numeric', 'numeric', 'numeric', 'numeric', 'numeric', 'numeric', 'numeric', 'numeric')
class(`BatesProcess`) = c("SWIGFunction", class('BatesProcess'))

# Start of delete_BatesProcess

`delete_BatesProcess` = function(self)
{
  ;.Call('R_swig_delete_BatesProcess', self, PACKAGE='QuantLib');
  
}

attr(`delete_BatesProcess`, 'returnType') = 'void'
attr(`delete_BatesProcess`, "inputTypes") = c('_p_BatesProcessPtr')
class(`delete_BatesProcess`) = c("SWIGFunction", class('delete_BatesProcess'))

setMethod('delete', '_p_BatesProcessPtr', function(obj) {delete_BatesProcessPtr(obj)})
# Start of StochasticProcessVector___nonzero__

`StochasticProcessVector___nonzero__` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_StochasticProcessVector___nonzero__', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`StochasticProcessVector___nonzero__`, 'returnType') = 'logical'
attr(`StochasticProcessVector___nonzero__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_StochasticProcess_t_std__allocatorT_boost__shared_ptrT_StochasticProcess_t_t_t')
class(`StochasticProcessVector___nonzero__`) = c("SWIGFunction", class('StochasticProcessVector___nonzero__'))

# Start of StochasticProcessVector___len__

`StochasticProcessVector___len__` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_StochasticProcessVector___len__', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`StochasticProcessVector___len__`, 'returnType') = 'integer'
attr(`StochasticProcessVector___len__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_StochasticProcess_t_std__allocatorT_boost__shared_ptrT_StochasticProcess_t_t_t')
class(`StochasticProcessVector___len__`) = c("SWIGFunction", class('StochasticProcessVector___len__'))

# Start of StochasticProcessVector_pop

`StochasticProcessVector_pop` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_StochasticProcessVector_pop', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_StochasticProcess_t";
  
  ans
  
}

attr(`StochasticProcessVector_pop`, 'returnType') = '_p_boost__shared_ptrT_StochasticProcess_t'
attr(`StochasticProcessVector_pop`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_StochasticProcess_t_std__allocatorT_boost__shared_ptrT_StochasticProcess_t_t_t')
class(`StochasticProcessVector_pop`) = c("SWIGFunction", class('StochasticProcessVector_pop'))

# Start of StochasticProcessVector___getslice__

`StochasticProcessVector___getslice__` = function(self, i, j)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;ans = .Call('R_swig_StochasticProcessVector___getslice__', self, i, j, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_StochasticProcess_t_std__allocatorT_boost__shared_ptrT_StochasticProcess_t_t_t";
  
  ans
  
}

attr(`StochasticProcessVector___getslice__`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_StochasticProcess_t_std__allocatorT_boost__shared_ptrT_StochasticProcess_t_t_t'
attr(`StochasticProcessVector___getslice__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_StochasticProcess_t_std__allocatorT_boost__shared_ptrT_StochasticProcess_t_t_t', 'integer', 'integer')
class(`StochasticProcessVector___getslice__`) = c("SWIGFunction", class('StochasticProcessVector___getslice__'))

# Start of StochasticProcessVector___setslice__

`StochasticProcessVector___setslice__` = function(self, i, j, v)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  
  ;.Call('R_swig_StochasticProcessVector___setslice__', self, i, j, v, PACKAGE='QuantLib');
  
}

attr(`StochasticProcessVector___setslice__`, 'returnType') = 'void'
attr(`StochasticProcessVector___setslice__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_StochasticProcess_t_std__allocatorT_boost__shared_ptrT_StochasticProcess_t_t_t', 'integer', 'integer', '_p_std__vectorT_boost__shared_ptrT_StochasticProcess_t_std__allocatorT_boost__shared_ptrT_StochasticProcess_t_t_t')
class(`StochasticProcessVector___setslice__`) = c("SWIGFunction", class('StochasticProcessVector___setslice__'))

# Start of StochasticProcessVector___delslice__

`StochasticProcessVector___delslice__` = function(self, i, j)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_StochasticProcessVector___delslice__', self, i, j, PACKAGE='QuantLib');
  
}

attr(`StochasticProcessVector___delslice__`, 'returnType') = 'void'
attr(`StochasticProcessVector___delslice__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_StochasticProcess_t_std__allocatorT_boost__shared_ptrT_StochasticProcess_t_t_t', 'integer', 'integer')
class(`StochasticProcessVector___delslice__`) = c("SWIGFunction", class('StochasticProcessVector___delslice__'))

# Start of StochasticProcessVector___delitem__

`StochasticProcessVector___delitem__` = function(self, i)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_StochasticProcessVector___delitem__', self, i, PACKAGE='QuantLib');
  
}

attr(`StochasticProcessVector___delitem__`, 'returnType') = 'void'
attr(`StochasticProcessVector___delitem__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_StochasticProcess_t_std__allocatorT_boost__shared_ptrT_StochasticProcess_t_t_t', 'integer')
class(`StochasticProcessVector___delitem__`) = c("SWIGFunction", class('StochasticProcessVector___delitem__'))

# Start of StochasticProcessVector___getitem__

`StochasticProcessVector___getitem__` = function(self, i, .copy = FALSE)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;ans = .Call('R_swig_StochasticProcessVector___getitem__', self, i, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_StochasticProcess_t";
  
  ans
  
}

attr(`StochasticProcessVector___getitem__`, 'returnType') = '_p_boost__shared_ptrT_StochasticProcess_t'
attr(`StochasticProcessVector___getitem__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_StochasticProcess_t_std__allocatorT_boost__shared_ptrT_StochasticProcess_t_t_t', 'integer')
class(`StochasticProcessVector___getitem__`) = c("SWIGFunction", class('StochasticProcessVector___getitem__'))

# Start of StochasticProcessVector___setitem__

`StochasticProcessVector___setitem__` = function(self, i, x)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  ;.Call('R_swig_StochasticProcessVector___setitem__', self, i, x, PACKAGE='QuantLib');
  
}

attr(`StochasticProcessVector___setitem__`, 'returnType') = 'void'
attr(`StochasticProcessVector___setitem__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_StochasticProcess_t_std__allocatorT_boost__shared_ptrT_StochasticProcess_t_t_t', 'integer', '_p_boost__shared_ptrT_StochasticProcess_t')
class(`StochasticProcessVector___setitem__`) = c("SWIGFunction", class('StochasticProcessVector___setitem__'))

# Start of StochasticProcessVector_append

`StochasticProcessVector_append` = function(self, x)
{
  ;.Call('R_swig_StochasticProcessVector_append', self, x, PACKAGE='QuantLib');
  
}

attr(`StochasticProcessVector_append`, 'returnType') = 'void'
attr(`StochasticProcessVector_append`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_StochasticProcess_t_std__allocatorT_boost__shared_ptrT_StochasticProcess_t_t_t', '_p_boost__shared_ptrT_StochasticProcess_t')
class(`StochasticProcessVector_append`) = c("SWIGFunction", class('StochasticProcessVector_append'))

# Start of new_StochasticProcessVector

`StochasticProcessVector__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_StochasticProcessVector__SWIG_0', PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_StochasticProcess_t_std__allocatorT_boost__shared_ptrT_StochasticProcess_t_t_t";
  
  reg.finalizer(ans, delete_StochasticProcessVector)
  ans
  
}

attr(`StochasticProcessVector__SWIG_0`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_StochasticProcess_t_std__allocatorT_boost__shared_ptrT_StochasticProcess_t_t_t'
class(`StochasticProcessVector__SWIG_0`) = c("SWIGFunction", class('StochasticProcessVector__SWIG_0'))

# Start of new_StochasticProcessVector

`StochasticProcessVector__SWIG_1` = function(s_arg1)
{
  ;ans = .Call('R_swig_new_StochasticProcessVector__SWIG_1', s_arg1, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_StochasticProcess_t_std__allocatorT_boost__shared_ptrT_StochasticProcess_t_t_t";
  
  reg.finalizer(ans, delete_StochasticProcessVector)
  ans
  
}

attr(`StochasticProcessVector__SWIG_1`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_StochasticProcess_t_std__allocatorT_boost__shared_ptrT_StochasticProcess_t_t_t'
attr(`StochasticProcessVector__SWIG_1`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_StochasticProcess_t_std__allocatorT_boost__shared_ptrT_StochasticProcess_t_t_t')
class(`StochasticProcessVector__SWIG_1`) = c("SWIGFunction", class('StochasticProcessVector__SWIG_1'))

# Start of StochasticProcessVector_empty

`StochasticProcessVector_empty` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_StochasticProcessVector_empty', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`StochasticProcessVector_empty`, 'returnType') = 'logical'
attr(`StochasticProcessVector_empty`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_StochasticProcess_t_std__allocatorT_boost__shared_ptrT_StochasticProcess_t_t_t')
class(`StochasticProcessVector_empty`) = c("SWIGFunction", class('StochasticProcessVector_empty'))

# Start of StochasticProcessVector_size

`StochasticProcessVector_size` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_StochasticProcessVector_size', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`StochasticProcessVector_size`, 'returnType') = 'integer'
attr(`StochasticProcessVector_size`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_StochasticProcess_t_std__allocatorT_boost__shared_ptrT_StochasticProcess_t_t_t')
class(`StochasticProcessVector_size`) = c("SWIGFunction", class('StochasticProcessVector_size'))

# Start of StochasticProcessVector_clear

`StochasticProcessVector_clear` = function(self)
{
  ;.Call('R_swig_StochasticProcessVector_clear', self, PACKAGE='QuantLib');
  
}

attr(`StochasticProcessVector_clear`, 'returnType') = 'void'
attr(`StochasticProcessVector_clear`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_StochasticProcess_t_std__allocatorT_boost__shared_ptrT_StochasticProcess_t_t_t')
class(`StochasticProcessVector_clear`) = c("SWIGFunction", class('StochasticProcessVector_clear'))

# Start of StochasticProcessVector_swap

`StochasticProcessVector_swap` = function(self, v)
{
  ;.Call('R_swig_StochasticProcessVector_swap', self, v, PACKAGE='QuantLib');
  
}

attr(`StochasticProcessVector_swap`, 'returnType') = 'void'
attr(`StochasticProcessVector_swap`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_StochasticProcess_t_std__allocatorT_boost__shared_ptrT_StochasticProcess_t_t_t', '_p_std__vectorT_boost__shared_ptrT_StochasticProcess_t_std__allocatorT_boost__shared_ptrT_StochasticProcess_t_t_t')
class(`StochasticProcessVector_swap`) = c("SWIGFunction", class('StochasticProcessVector_swap'))

# Start of StochasticProcessVector_get_allocator

`StochasticProcessVector_get_allocator` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_StochasticProcessVector_get_allocator', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__allocatorT_boost__shared_ptrT_StochasticProcess_t_t";
  
  ans
  
}

attr(`StochasticProcessVector_get_allocator`, 'returnType') = '_p_std__allocatorT_boost__shared_ptrT_StochasticProcess_t_t'
attr(`StochasticProcessVector_get_allocator`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_StochasticProcess_t_std__allocatorT_boost__shared_ptrT_StochasticProcess_t_t_t')
class(`StochasticProcessVector_get_allocator`) = c("SWIGFunction", class('StochasticProcessVector_get_allocator'))

# Start of new_StochasticProcessVector

`StochasticProcessVector__SWIG_2` = function(size)
{
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_new_StochasticProcessVector__SWIG_2', size, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_StochasticProcess_t_std__allocatorT_boost__shared_ptrT_StochasticProcess_t_t_t";
  
  reg.finalizer(ans, delete_StochasticProcessVector)
  ans
  
}

attr(`StochasticProcessVector__SWIG_2`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_StochasticProcess_t_std__allocatorT_boost__shared_ptrT_StochasticProcess_t_t_t'
attr(`StochasticProcessVector__SWIG_2`, "inputTypes") = c('integer')
class(`StochasticProcessVector__SWIG_2`) = c("SWIGFunction", class('StochasticProcessVector__SWIG_2'))

# Start of StochasticProcessVector_pop_back

`StochasticProcessVector_pop_back` = function(self)
{
  ;.Call('R_swig_StochasticProcessVector_pop_back', self, PACKAGE='QuantLib');
  
}

attr(`StochasticProcessVector_pop_back`, 'returnType') = 'void'
attr(`StochasticProcessVector_pop_back`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_StochasticProcess_t_std__allocatorT_boost__shared_ptrT_StochasticProcess_t_t_t')
class(`StochasticProcessVector_pop_back`) = c("SWIGFunction", class('StochasticProcessVector_pop_back'))

# Start of StochasticProcessVector_resize

`StochasticProcessVector_resize__SWIG_0` = function(self, new_size)
{
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_StochasticProcessVector_resize__SWIG_0', self, new_size, PACKAGE='QuantLib');
  
}

attr(`StochasticProcessVector_resize__SWIG_0`, 'returnType') = 'void'
attr(`StochasticProcessVector_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_StochasticProcess_t_std__allocatorT_boost__shared_ptrT_StochasticProcess_t_t_t', 'integer')
class(`StochasticProcessVector_resize__SWIG_0`) = c("SWIGFunction", class('StochasticProcessVector_resize__SWIG_0'))

# Start of new_StochasticProcessVector

`StochasticProcessVector__SWIG_3` = function(size, value)
{
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  
  ;ans = .Call('R_swig_new_StochasticProcessVector__SWIG_3', size, value, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_StochasticProcess_t_std__allocatorT_boost__shared_ptrT_StochasticProcess_t_t_t";
  
  reg.finalizer(ans, delete_StochasticProcessVector)
  ans
  
}

attr(`StochasticProcessVector__SWIG_3`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_StochasticProcess_t_std__allocatorT_boost__shared_ptrT_StochasticProcess_t_t_t'
attr(`StochasticProcessVector__SWIG_3`, "inputTypes") = c('integer', '_p_boost__shared_ptrT_StochasticProcess_t')
class(`StochasticProcessVector__SWIG_3`) = c("SWIGFunction", class('StochasticProcessVector__SWIG_3'))

`StochasticProcessVector` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- StochasticProcessVector__SWIG_0; 
  } else if (argc == 1) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]]))) {
      f <- StochasticProcessVector__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_StochasticProcess_t_std__allocatorT_boost__shared_ptrT_StochasticProcess_t_t_t')) {
      f <- StochasticProcessVector__SWIG_1; 
    }
  } else if (argc == 2) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && extends(argtypes[2], '_p_boost__shared_ptrT_StochasticProcess_t')) {
      f <- StochasticProcessVector__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for StochasticProcessVector with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of StochasticProcessVector_push_back

`StochasticProcessVector_push_back` = function(self, x)
{
  ;.Call('R_swig_StochasticProcessVector_push_back', self, x, PACKAGE='QuantLib');
  
}

attr(`StochasticProcessVector_push_back`, 'returnType') = 'void'
attr(`StochasticProcessVector_push_back`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_StochasticProcess_t_std__allocatorT_boost__shared_ptrT_StochasticProcess_t_t_t', '_p_boost__shared_ptrT_StochasticProcess_t')
class(`StochasticProcessVector_push_back`) = c("SWIGFunction", class('StochasticProcessVector_push_back'))

# Start of StochasticProcessVector_front

`StochasticProcessVector_front` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_StochasticProcessVector_front', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_StochasticProcess_t";
  
  ans
  
}

attr(`StochasticProcessVector_front`, 'returnType') = '_p_boost__shared_ptrT_StochasticProcess_t'
attr(`StochasticProcessVector_front`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_StochasticProcess_t_std__allocatorT_boost__shared_ptrT_StochasticProcess_t_t_t')
class(`StochasticProcessVector_front`) = c("SWIGFunction", class('StochasticProcessVector_front'))

# Start of StochasticProcessVector_back

`StochasticProcessVector_back` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_StochasticProcessVector_back', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_StochasticProcess_t";
  
  ans
  
}

attr(`StochasticProcessVector_back`, 'returnType') = '_p_boost__shared_ptrT_StochasticProcess_t'
attr(`StochasticProcessVector_back`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_StochasticProcess_t_std__allocatorT_boost__shared_ptrT_StochasticProcess_t_t_t')
class(`StochasticProcessVector_back`) = c("SWIGFunction", class('StochasticProcessVector_back'))

# Start of StochasticProcessVector_assign

`StochasticProcessVector_assign` = function(self, n, x)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  
  ;.Call('R_swig_StochasticProcessVector_assign', self, n, x, PACKAGE='QuantLib');
  
}

attr(`StochasticProcessVector_assign`, 'returnType') = 'void'
attr(`StochasticProcessVector_assign`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_StochasticProcess_t_std__allocatorT_boost__shared_ptrT_StochasticProcess_t_t_t', 'integer', '_p_boost__shared_ptrT_StochasticProcess_t')
class(`StochasticProcessVector_assign`) = c("SWIGFunction", class('StochasticProcessVector_assign'))

# Start of StochasticProcessVector_resize

`StochasticProcessVector_resize__SWIG_1` = function(self, new_size, x)
{
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  
  ;.Call('R_swig_StochasticProcessVector_resize__SWIG_1', self, new_size, x, PACKAGE='QuantLib');
  
}

attr(`StochasticProcessVector_resize__SWIG_1`, 'returnType') = 'void'
attr(`StochasticProcessVector_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_StochasticProcess_t_std__allocatorT_boost__shared_ptrT_StochasticProcess_t_t_t', 'integer', '_p_boost__shared_ptrT_StochasticProcess_t')
class(`StochasticProcessVector_resize__SWIG_1`) = c("SWIGFunction", class('StochasticProcessVector_resize__SWIG_1'))

`StochasticProcessVector_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_StochasticProcess_t_std__allocatorT_boost__shared_ptrT_StochasticProcess_t_t_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]]))) {
      f <- StochasticProcessVector_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_StochasticProcess_t_std__allocatorT_boost__shared_ptrT_StochasticProcess_t_t_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && extends(argtypes[3], '_p_boost__shared_ptrT_StochasticProcess_t')) {
      f <- StochasticProcessVector_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for StochasticProcessVector_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of StochasticProcessVector_reserve

`StochasticProcessVector_reserve` = function(self, n)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_StochasticProcessVector_reserve', self, n, PACKAGE='QuantLib');
  
}

attr(`StochasticProcessVector_reserve`, 'returnType') = 'void'
attr(`StochasticProcessVector_reserve`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_StochasticProcess_t_std__allocatorT_boost__shared_ptrT_StochasticProcess_t_t_t', 'integer')
class(`StochasticProcessVector_reserve`) = c("SWIGFunction", class('StochasticProcessVector_reserve'))

# Start of StochasticProcessVector_capacity

`StochasticProcessVector_capacity` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_StochasticProcessVector_capacity', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`StochasticProcessVector_capacity`, 'returnType') = 'integer'
attr(`StochasticProcessVector_capacity`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_StochasticProcess_t_std__allocatorT_boost__shared_ptrT_StochasticProcess_t_t_t')
class(`StochasticProcessVector_capacity`) = c("SWIGFunction", class('StochasticProcessVector_capacity'))

# Start of delete_StochasticProcessVector

`delete_StochasticProcessVector` = function(self)
{
  ;.Call('R_swig_delete_StochasticProcessVector', self, PACKAGE='QuantLib');
  
}

attr(`delete_StochasticProcessVector`, 'returnType') = 'void'
attr(`delete_StochasticProcessVector`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_StochasticProcess_t_std__allocatorT_boost__shared_ptrT_StochasticProcess_t_t_t')
class(`delete_StochasticProcessVector`) = c("SWIGFunction", class('delete_StochasticProcessVector'))

# Start of accessor method for std::vector<(boost::shared_ptr<(StochasticProcess)>)>
setMethod('$', '_p_std__vectorT_boost__shared_ptrT_StochasticProcess_t_std__allocatorT_boost__shared_ptrT_StochasticProcess_t_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = StochasticProcessVector___nonzero__, '__len__' = StochasticProcessVector___len__, 'pop' = StochasticProcessVector_pop, '__getslice__' = StochasticProcessVector___getslice__, '__setslice__' = StochasticProcessVector___setslice__, '__delslice__' = StochasticProcessVector___delslice__, '__delitem__' = StochasticProcessVector___delitem__, '__getitem__' = StochasticProcessVector___getitem__, '__setitem__' = StochasticProcessVector___setitem__, 'append' = StochasticProcessVector_append, 'empty' = StochasticProcessVector_empty, 'size' = StochasticProcessVector_size, 'clear' = StochasticProcessVector_clear, 'swap' = StochasticProcessVector_swap, 'get_allocator' = StochasticProcessVector_get_allocator, 'pop_back' = StochasticProcessVector_pop_back, 'resize' = StochasticProcessVector_resize, 'push_back' = StochasticProcessVector_push_back, 'front' = StochasticProcessVector_front, 'back' = StochasticProcessVector_back, 'assign' = StochasticProcessVector_assign, 'reserve' = StochasticProcessVector_reserve, 'capacity' = StochasticProcessVector_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for std::vector<(boost::shared_ptr<(StochasticProcess)>)>
setMethod('delete', '_p_std__vectorT_boost__shared_ptrT_StochasticProcess_t_std__allocatorT_boost__shared_ptrT_StochasticProcess_t_t_t', function(obj) {delete_std__vectorT_boost__shared_ptrT_StochasticProcess_t_std__allocatorT_boost__shared_ptrT_StochasticProcess_t_t_t(obj)})
# Start of PricingEngine___deref__

`PricingEngine___deref__` = function(self)
{
  ;ans = .Call('R_swig_PricingEngine___deref__', self, PACKAGE='QuantLib');
  class(ans) <- "_p_PricingEngine";
  
  ans
  
}

attr(`PricingEngine___deref__`, 'returnType') = '_p_PricingEngine'
attr(`PricingEngine___deref__`, "inputTypes") = c('_p_boost__shared_ptrT_PricingEngine_t')
class(`PricingEngine___deref__`) = c("SWIGFunction", class('PricingEngine___deref__'))

# Start of PricingEngine_isNull

`PricingEngine_isNull` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_PricingEngine_isNull', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`PricingEngine_isNull`, 'returnType') = 'logical'
attr(`PricingEngine_isNull`, "inputTypes") = c('_p_boost__shared_ptrT_PricingEngine_t')
class(`PricingEngine_isNull`) = c("SWIGFunction", class('PricingEngine_isNull'))

# Start of new_PricingEngine

`PricingEngine` = function()
{
  ;ans = .Call('R_swig_new_PricingEngine', PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_PricingEngine_t";
  
  reg.finalizer(ans, delete_PricingEngine)
  ans
  
}

attr(`PricingEngine`, 'returnType') = '_p_boost__shared_ptrT_PricingEngine_t'
class(`PricingEngine`) = c("SWIGFunction", class('PricingEngine'))

# Start of delete_PricingEngine

`delete_PricingEngine` = function(self)
{
  ;.Call('R_swig_delete_PricingEngine', self, PACKAGE='QuantLib');
  
}

attr(`delete_PricingEngine`, 'returnType') = 'void'
attr(`delete_PricingEngine`, "inputTypes") = c('_p_boost__shared_ptrT_PricingEngine_t')
class(`delete_PricingEngine`) = c("SWIGFunction", class('delete_PricingEngine'))

# Start of accessor method for boost::shared_ptr<(PricingEngine)>
setMethod('$', '_p_boost__shared_ptrT_PricingEngine_t', function(x, name)

{
  accessorFuns = list('__deref__' = PricingEngine___deref__, 'isNull' = PricingEngine_isNull);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for boost::shared_ptr<(PricingEngine)>
setMethod('delete', '_p_boost__shared_ptrT_PricingEngine_t', function(obj) {delete_boost__shared_ptrT_PricingEngine_t(obj)})

setMethod("summary", "_p_boost__shared_ptrTInstrument_t",
function(object) c(value=object$NPV()))

setMethod("print", "_p_boost__shared_ptrTInstrument_t",
function(x) print(summary(x)))

# Start of Instrument___deref__

`Instrument___deref__` = function(self)
{
  ;ans = .Call('R_swig_Instrument___deref__', self, PACKAGE='QuantLib');
  class(ans) <- "_p_Instrument";
  
  ans
  
}

attr(`Instrument___deref__`, 'returnType') = '_p_Instrument'
attr(`Instrument___deref__`, "inputTypes") = c('_p_boost__shared_ptrT_Instrument_t')
class(`Instrument___deref__`) = c("SWIGFunction", class('Instrument___deref__'))

# Start of Instrument_isNull

`Instrument_isNull` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Instrument_isNull', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Instrument_isNull`, 'returnType') = 'logical'
attr(`Instrument_isNull`, "inputTypes") = c('_p_boost__shared_ptrT_Instrument_t')
class(`Instrument_isNull`) = c("SWIGFunction", class('Instrument_isNull'))

# Start of Instrument_asObservable

`Instrument_asObservable` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_Instrument_asObservable', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_Observable_t";
  
  ans
  
}

attr(`Instrument_asObservable`, 'returnType') = '_p_boost__shared_ptrT_Observable_t'
attr(`Instrument_asObservable`, "inputTypes") = c('_p_boost__shared_ptrT_Instrument_t')
class(`Instrument_asObservable`) = c("SWIGFunction", class('Instrument_asObservable'))

# Start of new_Instrument

`Instrument` = function()
{
  ;ans = .Call('R_swig_new_Instrument', PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_Instrument_t";
  
  reg.finalizer(ans, delete_Instrument)
  ans
  
}

attr(`Instrument`, 'returnType') = '_p_boost__shared_ptrT_Instrument_t'
class(`Instrument`) = c("SWIGFunction", class('Instrument'))

# Start of delete_Instrument

`delete_Instrument` = function(self)
{
  ;.Call('R_swig_delete_Instrument', self, PACKAGE='QuantLib');
  
}

attr(`delete_Instrument`, 'returnType') = 'void'
attr(`delete_Instrument`, "inputTypes") = c('_p_boost__shared_ptrT_Instrument_t')
class(`delete_Instrument`) = c("SWIGFunction", class('delete_Instrument'))

# Start of Instrument_NPV

`Instrument_NPV` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Instrument_NPV', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Instrument_NPV`, 'returnType') = 'numeric'
attr(`Instrument_NPV`, "inputTypes") = c('_p_boost__shared_ptrT_Instrument_t')
class(`Instrument_NPV`) = c("SWIGFunction", class('Instrument_NPV'))

# Start of Instrument_errorEstimate

`Instrument_errorEstimate` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Instrument_errorEstimate', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Instrument_errorEstimate`, 'returnType') = 'numeric'
attr(`Instrument_errorEstimate`, "inputTypes") = c('_p_boost__shared_ptrT_Instrument_t')
class(`Instrument_errorEstimate`) = c("SWIGFunction", class('Instrument_errorEstimate'))

# Start of Instrument_isExpired

`Instrument_isExpired` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Instrument_isExpired', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Instrument_isExpired`, 'returnType') = 'logical'
attr(`Instrument_isExpired`, "inputTypes") = c('_p_boost__shared_ptrT_Instrument_t')
class(`Instrument_isExpired`) = c("SWIGFunction", class('Instrument_isExpired'))

# Start of Instrument_setPricingEngine

`Instrument_setPricingEngine` = function(self, s_arg2)
{
  ;.Call('R_swig_Instrument_setPricingEngine', self, s_arg2, PACKAGE='QuantLib');
  
}

attr(`Instrument_setPricingEngine`, 'returnType') = 'void'
attr(`Instrument_setPricingEngine`, "inputTypes") = c('_p_boost__shared_ptrT_Instrument_t', '_p_boost__shared_ptrT_PricingEngine_t')
class(`Instrument_setPricingEngine`) = c("SWIGFunction", class('Instrument_setPricingEngine'))

# Start of Instrument_recalculate

`Instrument_recalculate` = function(self)
{
  ;.Call('R_swig_Instrument_recalculate', self, PACKAGE='QuantLib');
  
}

attr(`Instrument_recalculate`, 'returnType') = 'void'
attr(`Instrument_recalculate`, "inputTypes") = c('_p_boost__shared_ptrT_Instrument_t')
class(`Instrument_recalculate`) = c("SWIGFunction", class('Instrument_recalculate'))

# Start of Instrument_freeze

`Instrument_freeze` = function(self)
{
  ;.Call('R_swig_Instrument_freeze', self, PACKAGE='QuantLib');
  
}

attr(`Instrument_freeze`, 'returnType') = 'void'
attr(`Instrument_freeze`, "inputTypes") = c('_p_boost__shared_ptrT_Instrument_t')
class(`Instrument_freeze`) = c("SWIGFunction", class('Instrument_freeze'))

# Start of Instrument_unfreeze

`Instrument_unfreeze` = function(self)
{
  ;.Call('R_swig_Instrument_unfreeze', self, PACKAGE='QuantLib');
  
}

attr(`Instrument_unfreeze`, 'returnType') = 'void'
attr(`Instrument_unfreeze`, "inputTypes") = c('_p_boost__shared_ptrT_Instrument_t')
class(`Instrument_unfreeze`) = c("SWIGFunction", class('Instrument_unfreeze'))

# Start of accessor method for boost::shared_ptr<(Instrument)>
setMethod('$', '_p_boost__shared_ptrT_Instrument_t', function(x, name)

{
  accessorFuns = list('__deref__' = Instrument___deref__, 'isNull' = Instrument_isNull, 'asObservable' = Instrument_asObservable, 'NPV' = Instrument_NPV, 'errorEstimate' = Instrument_errorEstimate, 'isExpired' = Instrument_isExpired, 'setPricingEngine' = Instrument_setPricingEngine, 'recalculate' = Instrument_recalculate, 'freeze' = Instrument_freeze, 'unfreeze' = Instrument_unfreeze);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for boost::shared_ptr<(Instrument)>
setMethod('delete', '_p_boost__shared_ptrT_Instrument_t', function(obj) {delete_boost__shared_ptrT_Instrument_t(obj)})
# Start of new_Stock

`Stock` = function(quote)
{
  ;ans = .Call('R_swig_new_Stock', quote, PACKAGE='QuantLib');
  class(ans) <- "_p_StockPtr";
  
  reg.finalizer(ans, delete_Stock)
  ans
  
}

attr(`Stock`, 'returnType') = '_p_StockPtr'
attr(`Stock`, "inputTypes") = c('_p_HandleT_Quote_t')
class(`Stock`) = c("SWIGFunction", class('Stock'))

# Start of delete_Stock

`delete_Stock` = function(self)
{
  ;.Call('R_swig_delete_Stock', self, PACKAGE='QuantLib');
  
}

attr(`delete_Stock`, 'returnType') = 'void'
attr(`delete_Stock`, "inputTypes") = c('_p_StockPtr')
class(`delete_Stock`) = c("SWIGFunction", class('delete_Stock'))

setMethod('delete', '_p_StockPtr', function(obj) {delete_StockPtr(obj)})
# Start of new_CompositeInstrument

`CompositeInstrument` = function()
{
  ;ans = .Call('R_swig_new_CompositeInstrument', PACKAGE='QuantLib');
  class(ans) <- "_p_CompositeInstrumentPtr";
  
  reg.finalizer(ans, delete_CompositeInstrument)
  ans
  
}

attr(`CompositeInstrument`, 'returnType') = '_p_CompositeInstrumentPtr'
class(`CompositeInstrument`) = c("SWIGFunction", class('CompositeInstrument'))

# Start of CompositeInstrument_add

`CompositeInstrument_add__SWIG_0` = function(self, instrument, multiplier)
{
  ;.Call('R_swig_CompositeInstrument_add__SWIG_0', self, instrument, multiplier, PACKAGE='QuantLib');
  
}

attr(`CompositeInstrument_add__SWIG_0`, 'returnType') = 'void'
attr(`CompositeInstrument_add__SWIG_0`, "inputTypes") = c('_p_CompositeInstrumentPtr', '_p_boost__shared_ptrT_Instrument_t', 'numeric')
class(`CompositeInstrument_add__SWIG_0`) = c("SWIGFunction", class('CompositeInstrument_add__SWIG_0'))

# Start of CompositeInstrument_add

`CompositeInstrument_add__SWIG_1` = function(self, instrument)
{
  ;.Call('R_swig_CompositeInstrument_add__SWIG_1', self, instrument, PACKAGE='QuantLib');
  
}

attr(`CompositeInstrument_add__SWIG_1`, 'returnType') = 'void'
attr(`CompositeInstrument_add__SWIG_1`, "inputTypes") = c('_p_CompositeInstrumentPtr', '_p_boost__shared_ptrT_Instrument_t')
class(`CompositeInstrument_add__SWIG_1`) = c("SWIGFunction", class('CompositeInstrument_add__SWIG_1'))

`CompositeInstrument_add` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_CompositeInstrumentPtr') && extends(argtypes[2], '_p_boost__shared_ptrT_Instrument_t')) {
      f <- CompositeInstrument_add__SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_CompositeInstrumentPtr') && extends(argtypes[2], '_p_boost__shared_ptrT_Instrument_t') && is.numeric(argv[[3]])) {
      f <- CompositeInstrument_add__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for CompositeInstrument_add with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of CompositeInstrument_subtract

`CompositeInstrument_subtract__SWIG_0` = function(self, instrument, multiplier)
{
  ;.Call('R_swig_CompositeInstrument_subtract__SWIG_0', self, instrument, multiplier, PACKAGE='QuantLib');
  
}

attr(`CompositeInstrument_subtract__SWIG_0`, 'returnType') = 'void'
attr(`CompositeInstrument_subtract__SWIG_0`, "inputTypes") = c('_p_CompositeInstrumentPtr', '_p_boost__shared_ptrT_Instrument_t', 'numeric')
class(`CompositeInstrument_subtract__SWIG_0`) = c("SWIGFunction", class('CompositeInstrument_subtract__SWIG_0'))

# Start of CompositeInstrument_subtract

`CompositeInstrument_subtract__SWIG_1` = function(self, instrument)
{
  ;.Call('R_swig_CompositeInstrument_subtract__SWIG_1', self, instrument, PACKAGE='QuantLib');
  
}

attr(`CompositeInstrument_subtract__SWIG_1`, 'returnType') = 'void'
attr(`CompositeInstrument_subtract__SWIG_1`, "inputTypes") = c('_p_CompositeInstrumentPtr', '_p_boost__shared_ptrT_Instrument_t')
class(`CompositeInstrument_subtract__SWIG_1`) = c("SWIGFunction", class('CompositeInstrument_subtract__SWIG_1'))

`CompositeInstrument_subtract` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_CompositeInstrumentPtr') && extends(argtypes[2], '_p_boost__shared_ptrT_Instrument_t')) {
      f <- CompositeInstrument_subtract__SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_CompositeInstrumentPtr') && extends(argtypes[2], '_p_boost__shared_ptrT_Instrument_t') && is.numeric(argv[[3]])) {
      f <- CompositeInstrument_subtract__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for CompositeInstrument_subtract with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_CompositeInstrument

`delete_CompositeInstrument` = function(self)
{
  ;.Call('R_swig_delete_CompositeInstrument', self, PACKAGE='QuantLib');
  
}

attr(`delete_CompositeInstrument`, 'returnType') = 'void'
attr(`delete_CompositeInstrument`, "inputTypes") = c('_p_CompositeInstrumentPtr')
class(`delete_CompositeInstrument`) = c("SWIGFunction", class('delete_CompositeInstrument'))

# Start of accessor method for CompositeInstrumentPtr
setMethod('$', '_p_CompositeInstrumentPtr', function(x, name)

{
  accessorFuns = list('add' = CompositeInstrument_add, 'subtract' = CompositeInstrument_subtract);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for CompositeInstrumentPtr
setMethod('delete', '_p_CompositeInstrumentPtr', function(obj) {delete_CompositeInstrumentPtr(obj)})
defineEnumeration('_Option__Type',
                    .values = c(
                        'Put' = -1, 
                        'Call' = 1
))
# Start of delete_Option

`delete_Option` = function(self)
{
  ;.Call('R_swig_delete_Option', self, PACKAGE='QuantLib');
  
}

attr(`delete_Option`, 'returnType') = 'void'
attr(`delete_Option`, "inputTypes") = c('_p_Option')
class(`delete_Option`) = c("SWIGFunction", class('delete_Option'))

setMethod('delete', '_p_Option', function(obj) {delete_Option(obj)})
defineEnumeration('_Barrier__Type',
                    .values = c(
                        'DownIn' = 0, 
                        'UpIn' = 1, 
                        'DownOut' = 2, 
                        'UpOut' = 3
))
# Start of new_Barrier

`Barrier` = function()
{
  ;ans = .Call('R_swig_new_Barrier', PACKAGE='QuantLib');
  class(ans) <- "_p_Barrier";
  
  reg.finalizer(ans, delete_Barrier)
  ans
  
}

attr(`Barrier`, 'returnType') = '_p_Barrier'
class(`Barrier`) = c("SWIGFunction", class('Barrier'))

# Start of delete_Barrier

`delete_Barrier` = function(self)
{
  ;.Call('R_swig_delete_Barrier', self, PACKAGE='QuantLib');
  
}

attr(`delete_Barrier`, 'returnType') = 'void'
attr(`delete_Barrier`, "inputTypes") = c('_p_Barrier')
class(`delete_Barrier`) = c("SWIGFunction", class('delete_Barrier'))

setMethod('delete', '_p_Barrier', function(obj) {delete_Barrier(obj)})
# Start definition of copy functions & methods for Barrier
CopyToR_Barrier = function(value, obj = new("Barrier"))
{
  obj;
}



CopyToC_Barrier = function(value, obj)
{
  obj
}



# Start definition of copy methods for Barrier
setMethod('copyToR', '_p_Barrier', CopyToR_Barrier);
setMethod('copyToC', 'Barrier', CopyToC_Barrier);

# End definition of copy methods for Barrier
# End definition of copy functions & methods for Barrier
# Start of Payoff___deref__

`Payoff___deref__` = function(self)
{
  ;ans = .Call('R_swig_Payoff___deref__', self, PACKAGE='QuantLib');
  class(ans) <- "_p_Payoff";
  
  ans
  
}

attr(`Payoff___deref__`, 'returnType') = '_p_Payoff'
attr(`Payoff___deref__`, "inputTypes") = c('_p_boost__shared_ptrT_Payoff_t')
class(`Payoff___deref__`) = c("SWIGFunction", class('Payoff___deref__'))

# Start of Payoff_isNull

`Payoff_isNull` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Payoff_isNull', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Payoff_isNull`, 'returnType') = 'logical'
attr(`Payoff_isNull`, "inputTypes") = c('_p_boost__shared_ptrT_Payoff_t')
class(`Payoff_isNull`) = c("SWIGFunction", class('Payoff_isNull'))

# Start of new_Payoff

`Payoff` = function()
{
  ;ans = .Call('R_swig_new_Payoff', PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_Payoff_t";
  
  reg.finalizer(ans, delete_Payoff)
  ans
  
}

attr(`Payoff`, 'returnType') = '_p_boost__shared_ptrT_Payoff_t'
class(`Payoff`) = c("SWIGFunction", class('Payoff'))

# Start of delete_Payoff

`delete_Payoff` = function(self)
{
  ;.Call('R_swig_delete_Payoff', self, PACKAGE='QuantLib');
  
}

attr(`delete_Payoff`, 'returnType') = 'void'
attr(`delete_Payoff`, "inputTypes") = c('_p_boost__shared_ptrT_Payoff_t')
class(`delete_Payoff`) = c("SWIGFunction", class('delete_Payoff'))

# Start of Payoff___call__

`Payoff___call__` = function(self, price, .copy = FALSE)
{
  ;.Call('R_swig_Payoff___call__', self, price, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Payoff___call__`, 'returnType') = 'numeric'
attr(`Payoff___call__`, "inputTypes") = c('_p_boost__shared_ptrT_Payoff_t', 'numeric')
class(`Payoff___call__`) = c("SWIGFunction", class('Payoff___call__'))

# Start of accessor method for boost::shared_ptr<(Payoff)>
setMethod('$', '_p_boost__shared_ptrT_Payoff_t', function(x, name)

{
  accessorFuns = list('__deref__' = Payoff___deref__, 'isNull' = Payoff_isNull, '__call__' = Payoff___call__);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for boost::shared_ptr<(Payoff)>
setMethod('delete', '_p_boost__shared_ptrT_Payoff_t', function(obj) {delete_boost__shared_ptrT_Payoff_t(obj)})

setMethod("summary", "_p_VanillaOptionPtr",
function(object) {object$freeze()
ans <- c(value=object$NPV(), delta=object$delta(),
gamma=object$gamma(), vega=object$vega(),
theta=object$theta(), rho=object$rho(),
divRho=object$dividendRho())
object$unfreeze()
ans
})

setMethod("summary", "_p_DividendVanillaOptionPtr",
function(object) {object$freeze()
ans <- c(value=object$NPV(), delta=object$delta(),
gamma=object$gamma(), vega=object$vega(),
theta=object$theta(), rho=object$rho(),
divRho=object$dividendRho())
object$unfreeze()
ans
})


# Start of new_VanillaOption

`VanillaOption` = function(payoff, exercise)
{
  ;ans = .Call('R_swig_new_VanillaOption', payoff, exercise, PACKAGE='QuantLib');
  class(ans) <- "_p_VanillaOptionPtr";
  
  reg.finalizer(ans, delete_VanillaOption)
  ans
  
}

attr(`VanillaOption`, 'returnType') = '_p_VanillaOptionPtr'
attr(`VanillaOption`, "inputTypes") = c('_p_boost__shared_ptrT_Payoff_t', '_p_boost__shared_ptrT_Exercise_t')
class(`VanillaOption`) = c("SWIGFunction", class('VanillaOption'))

# Start of VanillaOption_priceCurve

`VanillaOption_priceCurve` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_VanillaOption_priceCurve', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_SampledCurve";
  
  ans
  
}

attr(`VanillaOption_priceCurve`, 'returnType') = '_p_SampledCurve'
attr(`VanillaOption_priceCurve`, "inputTypes") = c('_p_VanillaOptionPtr')
class(`VanillaOption_priceCurve`) = c("SWIGFunction", class('VanillaOption_priceCurve'))

# Start of VanillaOption_impliedVolatility

`VanillaOption_impliedVolatility__SWIG_0` = function(self, targetValue, process, accuracy, maxEvaluations, minVol, maxVol, .copy = FALSE)
{
  if(length(maxEvaluations) > 1) {
    warning("using only the first element of maxEvaluations");
  };
  
  
  
  ;.Call('R_swig_VanillaOption_impliedVolatility__SWIG_0', self, targetValue, process, accuracy, maxEvaluations, minVol, maxVol, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`VanillaOption_impliedVolatility__SWIG_0`, 'returnType') = 'numeric'
attr(`VanillaOption_impliedVolatility__SWIG_0`, "inputTypes") = c('_p_VanillaOptionPtr', 'numeric', '_p_GeneralizedBlackScholesProcessPtr', 'numeric', 'integer', 'numeric', 'numeric')
class(`VanillaOption_impliedVolatility__SWIG_0`) = c("SWIGFunction", class('VanillaOption_impliedVolatility__SWIG_0'))

# Start of VanillaOption_impliedVolatility

`VanillaOption_impliedVolatility__SWIG_1` = function(self, targetValue, process, accuracy, maxEvaluations, minVol, .copy = FALSE)
{
  if(length(maxEvaluations) > 1) {
    warning("using only the first element of maxEvaluations");
  };
  
  
  ;.Call('R_swig_VanillaOption_impliedVolatility__SWIG_1', self, targetValue, process, accuracy, maxEvaluations, minVol, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`VanillaOption_impliedVolatility__SWIG_1`, 'returnType') = 'numeric'
attr(`VanillaOption_impliedVolatility__SWIG_1`, "inputTypes") = c('_p_VanillaOptionPtr', 'numeric', '_p_GeneralizedBlackScholesProcessPtr', 'numeric', 'integer', 'numeric')
class(`VanillaOption_impliedVolatility__SWIG_1`) = c("SWIGFunction", class('VanillaOption_impliedVolatility__SWIG_1'))

# Start of VanillaOption_impliedVolatility

`VanillaOption_impliedVolatility__SWIG_2` = function(self, targetValue, process, accuracy, maxEvaluations, .copy = FALSE)
{
  if(length(maxEvaluations) > 1) {
    warning("using only the first element of maxEvaluations");
  };
  
  ;.Call('R_swig_VanillaOption_impliedVolatility__SWIG_2', self, targetValue, process, accuracy, maxEvaluations, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`VanillaOption_impliedVolatility__SWIG_2`, 'returnType') = 'numeric'
attr(`VanillaOption_impliedVolatility__SWIG_2`, "inputTypes") = c('_p_VanillaOptionPtr', 'numeric', '_p_GeneralizedBlackScholesProcessPtr', 'numeric', 'integer')
class(`VanillaOption_impliedVolatility__SWIG_2`) = c("SWIGFunction", class('VanillaOption_impliedVolatility__SWIG_2'))

# Start of VanillaOption_impliedVolatility

`VanillaOption_impliedVolatility__SWIG_3` = function(self, targetValue, process, accuracy, .copy = FALSE)
{
  ;.Call('R_swig_VanillaOption_impliedVolatility__SWIG_3', self, targetValue, process, accuracy, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`VanillaOption_impliedVolatility__SWIG_3`, 'returnType') = 'numeric'
attr(`VanillaOption_impliedVolatility__SWIG_3`, "inputTypes") = c('_p_VanillaOptionPtr', 'numeric', '_p_GeneralizedBlackScholesProcessPtr', 'numeric')
class(`VanillaOption_impliedVolatility__SWIG_3`) = c("SWIGFunction", class('VanillaOption_impliedVolatility__SWIG_3'))

# Start of VanillaOption_impliedVolatility

`VanillaOption_impliedVolatility__SWIG_4` = function(self, targetValue, process, .copy = FALSE)
{
  ;.Call('R_swig_VanillaOption_impliedVolatility__SWIG_4', self, targetValue, process, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`VanillaOption_impliedVolatility__SWIG_4`, 'returnType') = 'numeric'
attr(`VanillaOption_impliedVolatility__SWIG_4`, "inputTypes") = c('_p_VanillaOptionPtr', 'numeric', '_p_GeneralizedBlackScholesProcessPtr')
class(`VanillaOption_impliedVolatility__SWIG_4`) = c("SWIGFunction", class('VanillaOption_impliedVolatility__SWIG_4'))

`VanillaOption_impliedVolatility` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 5
  if (argc == 3) {
    if (extends(argtypes[1], '_p_VanillaOptionPtr') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_GeneralizedBlackScholesProcessPtr')) {
      f <- VanillaOption_impliedVolatility__SWIG_4; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_VanillaOptionPtr') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_GeneralizedBlackScholesProcessPtr') && is.numeric(argv[[4]])) {
      f <- VanillaOption_impliedVolatility__SWIG_3; 
    }
  } else if (argc == 5) {
    if (extends(argtypes[1], '_p_VanillaOptionPtr') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_GeneralizedBlackScholesProcessPtr') && is.numeric(argv[[4]]) && (is.integer(argv[[5]]) || is.numeric(argv[[5]]))) {
      f <- VanillaOption_impliedVolatility__SWIG_2; 
    }
  } else if (argc == 6) {
    if (extends(argtypes[1], '_p_VanillaOptionPtr') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_GeneralizedBlackScholesProcessPtr') && is.numeric(argv[[4]]) && (is.integer(argv[[5]]) || is.numeric(argv[[5]])) && is.numeric(argv[[6]])) {
      f <- VanillaOption_impliedVolatility__SWIG_1; 
    }
  } else if (argc == 7) {
    if (extends(argtypes[1], '_p_VanillaOptionPtr') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_GeneralizedBlackScholesProcessPtr') && is.numeric(argv[[4]]) && (is.integer(argv[[5]]) || is.numeric(argv[[5]])) && is.numeric(argv[[6]]) && is.numeric(argv[[7]])) {
      f <- VanillaOption_impliedVolatility__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for VanillaOption_impliedVolatility with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VanillaOption_delta

`VanillaOption_delta` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_VanillaOption_delta', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`VanillaOption_delta`, 'returnType') = 'numeric'
attr(`VanillaOption_delta`, "inputTypes") = c('_p_VanillaOptionPtr')
class(`VanillaOption_delta`) = c("SWIGFunction", class('VanillaOption_delta'))

# Start of VanillaOption_gamma

`VanillaOption_gamma` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_VanillaOption_gamma', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`VanillaOption_gamma`, 'returnType') = 'numeric'
attr(`VanillaOption_gamma`, "inputTypes") = c('_p_VanillaOptionPtr')
class(`VanillaOption_gamma`) = c("SWIGFunction", class('VanillaOption_gamma'))

# Start of VanillaOption_theta

`VanillaOption_theta` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_VanillaOption_theta', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`VanillaOption_theta`, 'returnType') = 'numeric'
attr(`VanillaOption_theta`, "inputTypes") = c('_p_VanillaOptionPtr')
class(`VanillaOption_theta`) = c("SWIGFunction", class('VanillaOption_theta'))

# Start of VanillaOption_thetaPerDay

`VanillaOption_thetaPerDay` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_VanillaOption_thetaPerDay', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`VanillaOption_thetaPerDay`, 'returnType') = 'numeric'
attr(`VanillaOption_thetaPerDay`, "inputTypes") = c('_p_VanillaOptionPtr')
class(`VanillaOption_thetaPerDay`) = c("SWIGFunction", class('VanillaOption_thetaPerDay'))

# Start of VanillaOption_vega

`VanillaOption_vega` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_VanillaOption_vega', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`VanillaOption_vega`, 'returnType') = 'numeric'
attr(`VanillaOption_vega`, "inputTypes") = c('_p_VanillaOptionPtr')
class(`VanillaOption_vega`) = c("SWIGFunction", class('VanillaOption_vega'))

# Start of VanillaOption_rho

`VanillaOption_rho` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_VanillaOption_rho', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`VanillaOption_rho`, 'returnType') = 'numeric'
attr(`VanillaOption_rho`, "inputTypes") = c('_p_VanillaOptionPtr')
class(`VanillaOption_rho`) = c("SWIGFunction", class('VanillaOption_rho'))

# Start of VanillaOption_dividendRho

`VanillaOption_dividendRho` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_VanillaOption_dividendRho', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`VanillaOption_dividendRho`, 'returnType') = 'numeric'
attr(`VanillaOption_dividendRho`, "inputTypes") = c('_p_VanillaOptionPtr')
class(`VanillaOption_dividendRho`) = c("SWIGFunction", class('VanillaOption_dividendRho'))

# Start of VanillaOption_strikeSensitivity

`VanillaOption_strikeSensitivity` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_VanillaOption_strikeSensitivity', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`VanillaOption_strikeSensitivity`, 'returnType') = 'numeric'
attr(`VanillaOption_strikeSensitivity`, "inputTypes") = c('_p_VanillaOptionPtr')
class(`VanillaOption_strikeSensitivity`) = c("SWIGFunction", class('VanillaOption_strikeSensitivity'))

# Start of delete_VanillaOption

`delete_VanillaOption` = function(self)
{
  ;.Call('R_swig_delete_VanillaOption', self, PACKAGE='QuantLib');
  
}

attr(`delete_VanillaOption`, 'returnType') = 'void'
attr(`delete_VanillaOption`, "inputTypes") = c('_p_VanillaOptionPtr')
class(`delete_VanillaOption`) = c("SWIGFunction", class('delete_VanillaOption'))

# Start of accessor method for VanillaOptionPtr
setMethod('$', '_p_VanillaOptionPtr', function(x, name)

{
  accessorFuns = list('priceCurve' = VanillaOption_priceCurve, 'impliedVolatility' = VanillaOption_impliedVolatility, 'delta' = VanillaOption_delta, 'gamma' = VanillaOption_gamma, 'theta' = VanillaOption_theta, 'thetaPerDay' = VanillaOption_thetaPerDay, 'vega' = VanillaOption_vega, 'rho' = VanillaOption_rho, 'dividendRho' = VanillaOption_dividendRho, 'strikeSensitivity' = VanillaOption_strikeSensitivity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for VanillaOptionPtr
setMethod('delete', '_p_VanillaOptionPtr', function(obj) {delete_VanillaOptionPtr(obj)})
# Start of new_EuropeanOption

`EuropeanOption` = function(payoff, exercise)
{
  ;ans = .Call('R_swig_new_EuropeanOption', payoff, exercise, PACKAGE='QuantLib');
  class(ans) <- "_p_EuropeanOptionPtr";
  
  reg.finalizer(ans, delete_EuropeanOption)
  ans
  
}

attr(`EuropeanOption`, 'returnType') = '_p_EuropeanOptionPtr'
attr(`EuropeanOption`, "inputTypes") = c('_p_boost__shared_ptrT_Payoff_t', '_p_boost__shared_ptrT_Exercise_t')
class(`EuropeanOption`) = c("SWIGFunction", class('EuropeanOption'))

# Start of delete_EuropeanOption

`delete_EuropeanOption` = function(self)
{
  ;.Call('R_swig_delete_EuropeanOption', self, PACKAGE='QuantLib');
  
}

attr(`delete_EuropeanOption`, 'returnType') = 'void'
attr(`delete_EuropeanOption`, "inputTypes") = c('_p_EuropeanOptionPtr')
class(`delete_EuropeanOption`) = c("SWIGFunction", class('delete_EuropeanOption'))

setMethod('delete', '_p_EuropeanOptionPtr', function(obj) {delete_EuropeanOptionPtr(obj)})
# Start of new_ForwardVanillaOption

`ForwardVanillaOption` = function(moneyness, resetDate, payoff, exercise)
{
  ;ans = .Call('R_swig_new_ForwardVanillaOption', moneyness, resetDate, payoff, exercise, PACKAGE='QuantLib');
  class(ans) <- "_p_ForwardVanillaOptionPtr";
  
  reg.finalizer(ans, delete_ForwardVanillaOption)
  ans
  
}

attr(`ForwardVanillaOption`, 'returnType') = '_p_ForwardVanillaOptionPtr'
attr(`ForwardVanillaOption`, "inputTypes") = c('numeric', '_p_Date', '_p_boost__shared_ptrT_Payoff_t', '_p_boost__shared_ptrT_Exercise_t')
class(`ForwardVanillaOption`) = c("SWIGFunction", class('ForwardVanillaOption'))

# Start of delete_ForwardVanillaOption

`delete_ForwardVanillaOption` = function(self)
{
  ;.Call('R_swig_delete_ForwardVanillaOption', self, PACKAGE='QuantLib');
  
}

attr(`delete_ForwardVanillaOption`, 'returnType') = 'void'
attr(`delete_ForwardVanillaOption`, "inputTypes") = c('_p_ForwardVanillaOptionPtr')
class(`delete_ForwardVanillaOption`) = c("SWIGFunction", class('delete_ForwardVanillaOption'))

setMethod('delete', '_p_ForwardVanillaOptionPtr', function(obj) {delete_ForwardVanillaOptionPtr(obj)})
# Start of new_QuantoVanillaOption

`QuantoVanillaOption` = function(payoff, exercise)
{
  ;ans = .Call('R_swig_new_QuantoVanillaOption', payoff, exercise, PACKAGE='QuantLib');
  class(ans) <- "_p_QuantoVanillaOptionPtr";
  
  reg.finalizer(ans, delete_QuantoVanillaOption)
  ans
  
}

attr(`QuantoVanillaOption`, 'returnType') = '_p_QuantoVanillaOptionPtr'
attr(`QuantoVanillaOption`, "inputTypes") = c('_p_boost__shared_ptrT_Payoff_t', '_p_boost__shared_ptrT_Exercise_t')
class(`QuantoVanillaOption`) = c("SWIGFunction", class('QuantoVanillaOption'))

# Start of QuantoVanillaOption_qvega

`QuantoVanillaOption_qvega` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_QuantoVanillaOption_qvega', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`QuantoVanillaOption_qvega`, 'returnType') = 'numeric'
attr(`QuantoVanillaOption_qvega`, "inputTypes") = c('_p_QuantoVanillaOptionPtr')
class(`QuantoVanillaOption_qvega`) = c("SWIGFunction", class('QuantoVanillaOption_qvega'))

# Start of QuantoVanillaOption_qrho

`QuantoVanillaOption_qrho` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_QuantoVanillaOption_qrho', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`QuantoVanillaOption_qrho`, 'returnType') = 'numeric'
attr(`QuantoVanillaOption_qrho`, "inputTypes") = c('_p_QuantoVanillaOptionPtr')
class(`QuantoVanillaOption_qrho`) = c("SWIGFunction", class('QuantoVanillaOption_qrho'))

# Start of QuantoVanillaOption_qlambda

`QuantoVanillaOption_qlambda` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_QuantoVanillaOption_qlambda', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`QuantoVanillaOption_qlambda`, 'returnType') = 'numeric'
attr(`QuantoVanillaOption_qlambda`, "inputTypes") = c('_p_QuantoVanillaOptionPtr')
class(`QuantoVanillaOption_qlambda`) = c("SWIGFunction", class('QuantoVanillaOption_qlambda'))

# Start of delete_QuantoVanillaOption

`delete_QuantoVanillaOption` = function(self)
{
  ;.Call('R_swig_delete_QuantoVanillaOption', self, PACKAGE='QuantLib');
  
}

attr(`delete_QuantoVanillaOption`, 'returnType') = 'void'
attr(`delete_QuantoVanillaOption`, "inputTypes") = c('_p_QuantoVanillaOptionPtr')
class(`delete_QuantoVanillaOption`) = c("SWIGFunction", class('delete_QuantoVanillaOption'))

# Start of accessor method for QuantoVanillaOptionPtr
setMethod('$', '_p_QuantoVanillaOptionPtr', function(x, name)

{
  accessorFuns = list('qvega' = QuantoVanillaOption_qvega, 'qrho' = QuantoVanillaOption_qrho, 'qlambda' = QuantoVanillaOption_qlambda);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for QuantoVanillaOptionPtr
setMethod('delete', '_p_QuantoVanillaOptionPtr', function(obj) {delete_QuantoVanillaOptionPtr(obj)})
# Start of new_QuantoForwardVanillaOption

`QuantoForwardVanillaOption` = function(moneyness, resetDate, payoff, exercise)
{
  ;ans = .Call('R_swig_new_QuantoForwardVanillaOption', moneyness, resetDate, payoff, exercise, PACKAGE='QuantLib');
  class(ans) <- "_p_QuantoForwardVanillaOptionPtr";
  
  reg.finalizer(ans, delete_QuantoForwardVanillaOption)
  ans
  
}

attr(`QuantoForwardVanillaOption`, 'returnType') = '_p_QuantoForwardVanillaOptionPtr'
attr(`QuantoForwardVanillaOption`, "inputTypes") = c('numeric', '_p_Date', '_p_boost__shared_ptrT_Payoff_t', '_p_boost__shared_ptrT_Exercise_t')
class(`QuantoForwardVanillaOption`) = c("SWIGFunction", class('QuantoForwardVanillaOption'))

# Start of delete_QuantoForwardVanillaOption

`delete_QuantoForwardVanillaOption` = function(self)
{
  ;.Call('R_swig_delete_QuantoForwardVanillaOption', self, PACKAGE='QuantLib');
  
}

attr(`delete_QuantoForwardVanillaOption`, 'returnType') = 'void'
attr(`delete_QuantoForwardVanillaOption`, "inputTypes") = c('_p_QuantoForwardVanillaOptionPtr')
class(`delete_QuantoForwardVanillaOption`) = c("SWIGFunction", class('delete_QuantoForwardVanillaOption'))

setMethod('delete', '_p_QuantoForwardVanillaOptionPtr', function(obj) {delete_QuantoForwardVanillaOptionPtr(obj)})
# Start of MultiAssetOption_delta

`MultiAssetOption_delta` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_MultiAssetOption_delta', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`MultiAssetOption_delta`, 'returnType') = 'numeric'
attr(`MultiAssetOption_delta`, "inputTypes") = c('_p_MultiAssetOptionPtr')
class(`MultiAssetOption_delta`) = c("SWIGFunction", class('MultiAssetOption_delta'))

# Start of MultiAssetOption_gamma

`MultiAssetOption_gamma` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_MultiAssetOption_gamma', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`MultiAssetOption_gamma`, 'returnType') = 'numeric'
attr(`MultiAssetOption_gamma`, "inputTypes") = c('_p_MultiAssetOptionPtr')
class(`MultiAssetOption_gamma`) = c("SWIGFunction", class('MultiAssetOption_gamma'))

# Start of MultiAssetOption_theta

`MultiAssetOption_theta` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_MultiAssetOption_theta', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`MultiAssetOption_theta`, 'returnType') = 'numeric'
attr(`MultiAssetOption_theta`, "inputTypes") = c('_p_MultiAssetOptionPtr')
class(`MultiAssetOption_theta`) = c("SWIGFunction", class('MultiAssetOption_theta'))

# Start of MultiAssetOption_vega

`MultiAssetOption_vega` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_MultiAssetOption_vega', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`MultiAssetOption_vega`, 'returnType') = 'numeric'
attr(`MultiAssetOption_vega`, "inputTypes") = c('_p_MultiAssetOptionPtr')
class(`MultiAssetOption_vega`) = c("SWIGFunction", class('MultiAssetOption_vega'))

# Start of MultiAssetOption_rho

`MultiAssetOption_rho` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_MultiAssetOption_rho', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`MultiAssetOption_rho`, 'returnType') = 'numeric'
attr(`MultiAssetOption_rho`, "inputTypes") = c('_p_MultiAssetOptionPtr')
class(`MultiAssetOption_rho`) = c("SWIGFunction", class('MultiAssetOption_rho'))

# Start of MultiAssetOption_dividendRho

`MultiAssetOption_dividendRho` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_MultiAssetOption_dividendRho', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`MultiAssetOption_dividendRho`, 'returnType') = 'numeric'
attr(`MultiAssetOption_dividendRho`, "inputTypes") = c('_p_MultiAssetOptionPtr')
class(`MultiAssetOption_dividendRho`) = c("SWIGFunction", class('MultiAssetOption_dividendRho'))

# Start of new_MultiAssetOption

`MultiAssetOption` = function()
{
  ;ans = .Call('R_swig_new_MultiAssetOption', PACKAGE='QuantLib');
  class(ans) <- "_p_MultiAssetOptionPtr";
  
  reg.finalizer(ans, delete_MultiAssetOption)
  ans
  
}

attr(`MultiAssetOption`, 'returnType') = '_p_MultiAssetOptionPtr'
class(`MultiAssetOption`) = c("SWIGFunction", class('MultiAssetOption'))

# Start of delete_MultiAssetOption

`delete_MultiAssetOption` = function(self)
{
  ;.Call('R_swig_delete_MultiAssetOption', self, PACKAGE='QuantLib');
  
}

attr(`delete_MultiAssetOption`, 'returnType') = 'void'
attr(`delete_MultiAssetOption`, "inputTypes") = c('_p_MultiAssetOptionPtr')
class(`delete_MultiAssetOption`) = c("SWIGFunction", class('delete_MultiAssetOption'))

# Start of accessor method for MultiAssetOptionPtr
setMethod('$', '_p_MultiAssetOptionPtr', function(x, name)

{
  accessorFuns = list('delta' = MultiAssetOption_delta, 'gamma' = MultiAssetOption_gamma, 'theta' = MultiAssetOption_theta, 'vega' = MultiAssetOption_vega, 'rho' = MultiAssetOption_rho, 'dividendRho' = MultiAssetOption_dividendRho);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for MultiAssetOptionPtr
setMethod('delete', '_p_MultiAssetOptionPtr', function(obj) {delete_MultiAssetOptionPtr(obj)})
# Start of new_AnalyticEuropeanEngine

`AnalyticEuropeanEngine` = function(process)
{
  ;ans = .Call('R_swig_new_AnalyticEuropeanEngine', process, PACKAGE='QuantLib');
  class(ans) <- "_p_AnalyticEuropeanEnginePtr";
  
  reg.finalizer(ans, delete_AnalyticEuropeanEngine)
  ans
  
}

attr(`AnalyticEuropeanEngine`, 'returnType') = '_p_AnalyticEuropeanEnginePtr'
attr(`AnalyticEuropeanEngine`, "inputTypes") = c('_p_GeneralizedBlackScholesProcessPtr')
class(`AnalyticEuropeanEngine`) = c("SWIGFunction", class('AnalyticEuropeanEngine'))

# Start of delete_AnalyticEuropeanEngine

`delete_AnalyticEuropeanEngine` = function(self)
{
  ;.Call('R_swig_delete_AnalyticEuropeanEngine', self, PACKAGE='QuantLib');
  
}

attr(`delete_AnalyticEuropeanEngine`, 'returnType') = 'void'
attr(`delete_AnalyticEuropeanEngine`, "inputTypes") = c('_p_AnalyticEuropeanEnginePtr')
class(`delete_AnalyticEuropeanEngine`) = c("SWIGFunction", class('delete_AnalyticEuropeanEngine'))

setMethod('delete', '_p_AnalyticEuropeanEnginePtr', function(obj) {delete_AnalyticEuropeanEnginePtr(obj)})
# Start of CalibratedModel___deref__

`CalibratedModel___deref__` = function(self)
{
  ;ans = .Call('R_swig_CalibratedModel___deref__', self, PACKAGE='QuantLib');
  class(ans) <- "_p_CalibratedModel";
  
  ans
  
}

attr(`CalibratedModel___deref__`, 'returnType') = '_p_CalibratedModel'
attr(`CalibratedModel___deref__`, "inputTypes") = c('_p_boost__shared_ptrT_CalibratedModel_t')
class(`CalibratedModel___deref__`) = c("SWIGFunction", class('CalibratedModel___deref__'))

# Start of CalibratedModel_isNull

`CalibratedModel_isNull` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_CalibratedModel_isNull', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CalibratedModel_isNull`, 'returnType') = 'logical'
attr(`CalibratedModel_isNull`, "inputTypes") = c('_p_boost__shared_ptrT_CalibratedModel_t')
class(`CalibratedModel_isNull`) = c("SWIGFunction", class('CalibratedModel_isNull'))

# Start of new_CalibratedModel

`CalibratedModel` = function()
{
  ;ans = .Call('R_swig_new_CalibratedModel', PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_CalibratedModel_t";
  
  reg.finalizer(ans, delete_CalibratedModel)
  ans
  
}

attr(`CalibratedModel`, 'returnType') = '_p_boost__shared_ptrT_CalibratedModel_t'
class(`CalibratedModel`) = c("SWIGFunction", class('CalibratedModel'))

# Start of delete_CalibratedModel

`delete_CalibratedModel` = function(self)
{
  ;.Call('R_swig_delete_CalibratedModel', self, PACKAGE='QuantLib');
  
}

attr(`delete_CalibratedModel`, 'returnType') = 'void'
attr(`delete_CalibratedModel`, "inputTypes") = c('_p_boost__shared_ptrT_CalibratedModel_t')
class(`delete_CalibratedModel`) = c("SWIGFunction", class('delete_CalibratedModel'))

# Start of accessor method for boost::shared_ptr<(CalibratedModel)>
setMethod('$', '_p_boost__shared_ptrT_CalibratedModel_t', function(x, name)

{
  accessorFuns = list('__deref__' = CalibratedModel___deref__, 'isNull' = CalibratedModel_isNull);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for boost::shared_ptr<(CalibratedModel)>
setMethod('delete', '_p_boost__shared_ptrT_CalibratedModel_t', function(obj) {delete_boost__shared_ptrT_CalibratedModel_t(obj)})
# Start of new_HestonModel

`HestonModel` = function(process)
{
  ;ans = .Call('R_swig_new_HestonModel', process, PACKAGE='QuantLib');
  class(ans) <- "_p_HestonModelPtr";
  
  reg.finalizer(ans, delete_HestonModel)
  ans
  
}

attr(`HestonModel`, 'returnType') = '_p_HestonModelPtr'
attr(`HestonModel`, "inputTypes") = c('_p_HestonProcessPtr')
class(`HestonModel`) = c("SWIGFunction", class('HestonModel'))

# Start of delete_HestonModel

`delete_HestonModel` = function(self)
{
  ;.Call('R_swig_delete_HestonModel', self, PACKAGE='QuantLib');
  
}

attr(`delete_HestonModel`, 'returnType') = 'void'
attr(`delete_HestonModel`, "inputTypes") = c('_p_HestonModelPtr')
class(`delete_HestonModel`) = c("SWIGFunction", class('delete_HestonModel'))

setMethod('delete', '_p_HestonModelPtr', function(obj) {delete_HestonModelPtr(obj)})
# Start of new_AnalyticHestonEngine

`AnalyticHestonEngine__SWIG_0` = function(model, integrationOrder)
{
  if(length(integrationOrder) > 1) {
    warning("using only the first element of integrationOrder");
  };
  
  ;ans = .Call('R_swig_new_AnalyticHestonEngine__SWIG_0', model, integrationOrder, PACKAGE='QuantLib');
  class(ans) <- "_p_AnalyticHestonEnginePtr";
  
  reg.finalizer(ans, delete_AnalyticHestonEngine)
  ans
  
}

attr(`AnalyticHestonEngine__SWIG_0`, 'returnType') = '_p_AnalyticHestonEnginePtr'
attr(`AnalyticHestonEngine__SWIG_0`, "inputTypes") = c('_p_HestonModelPtr', 'integer')
class(`AnalyticHestonEngine__SWIG_0`) = c("SWIGFunction", class('AnalyticHestonEngine__SWIG_0'))

# Start of new_AnalyticHestonEngine

`AnalyticHestonEngine__SWIG_1` = function(model)
{
  ;ans = .Call('R_swig_new_AnalyticHestonEngine__SWIG_1', model, PACKAGE='QuantLib');
  class(ans) <- "_p_AnalyticHestonEnginePtr";
  
  reg.finalizer(ans, delete_AnalyticHestonEngine)
  ans
  
}

attr(`AnalyticHestonEngine__SWIG_1`, 'returnType') = '_p_AnalyticHestonEnginePtr'
attr(`AnalyticHestonEngine__SWIG_1`, "inputTypes") = c('_p_HestonModelPtr')
class(`AnalyticHestonEngine__SWIG_1`) = c("SWIGFunction", class('AnalyticHestonEngine__SWIG_1'))

# Start of new_AnalyticHestonEngine

`AnalyticHestonEngine__SWIG_2` = function(model, relTolerance, maxEvaluations)
{
  if(length(maxEvaluations) > 1) {
    warning("using only the first element of maxEvaluations");
  };
  
  ;ans = .Call('R_swig_new_AnalyticHestonEngine__SWIG_2', model, relTolerance, maxEvaluations, PACKAGE='QuantLib');
  class(ans) <- "_p_AnalyticHestonEnginePtr";
  
  reg.finalizer(ans, delete_AnalyticHestonEngine)
  ans
  
}

attr(`AnalyticHestonEngine__SWIG_2`, 'returnType') = '_p_AnalyticHestonEnginePtr'
attr(`AnalyticHestonEngine__SWIG_2`, "inputTypes") = c('_p_HestonModelPtr', 'numeric', 'integer')
class(`AnalyticHestonEngine__SWIG_2`) = c("SWIGFunction", class('AnalyticHestonEngine__SWIG_2'))

`AnalyticHestonEngine` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 1) {
    if (extends(argtypes[1], '_p_HestonModelPtr')) {
      f <- AnalyticHestonEngine__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_HestonModelPtr') && (is.integer(argv[[2]]) || is.numeric(argv[[2]]))) {
      f <- AnalyticHestonEngine__SWIG_0; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_HestonModelPtr') && is.numeric(argv[[2]]) && (is.integer(argv[[3]]) || is.numeric(argv[[3]]))) {
      f <- AnalyticHestonEngine__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for AnalyticHestonEngine with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_AnalyticHestonEngine

`delete_AnalyticHestonEngine` = function(self)
{
  ;.Call('R_swig_delete_AnalyticHestonEngine', self, PACKAGE='QuantLib');
  
}

attr(`delete_AnalyticHestonEngine`, 'returnType') = 'void'
attr(`delete_AnalyticHestonEngine`, "inputTypes") = c('_p_AnalyticHestonEnginePtr')
class(`delete_AnalyticHestonEngine`) = c("SWIGFunction", class('delete_AnalyticHestonEngine'))

setMethod('delete', '_p_AnalyticHestonEnginePtr', function(obj) {delete_AnalyticHestonEnginePtr(obj)})
# Start of new_BatesModel

`BatesModel` = function(process)
{
  ;ans = .Call('R_swig_new_BatesModel', process, PACKAGE='QuantLib');
  class(ans) <- "_p_BatesModelPtr";
  
  reg.finalizer(ans, delete_BatesModel)
  ans
  
}

attr(`BatesModel`, 'returnType') = '_p_BatesModelPtr'
attr(`BatesModel`, "inputTypes") = c('_p_BatesProcessPtr')
class(`BatesModel`) = c("SWIGFunction", class('BatesModel'))

# Start of delete_BatesModel

`delete_BatesModel` = function(self)
{
  ;.Call('R_swig_delete_BatesModel', self, PACKAGE='QuantLib');
  
}

attr(`delete_BatesModel`, 'returnType') = 'void'
attr(`delete_BatesModel`, "inputTypes") = c('_p_BatesModelPtr')
class(`delete_BatesModel`) = c("SWIGFunction", class('delete_BatesModel'))

setMethod('delete', '_p_BatesModelPtr', function(obj) {delete_BatesModelPtr(obj)})
# Start of new_BatesEngine

`BatesEngine__SWIG_0` = function(model, integrationOrder)
{
  if(length(integrationOrder) > 1) {
    warning("using only the first element of integrationOrder");
  };
  
  ;ans = .Call('R_swig_new_BatesEngine__SWIG_0', model, integrationOrder, PACKAGE='QuantLib');
  class(ans) <- "_p_BatesEnginePtr";
  
  reg.finalizer(ans, delete_BatesEngine)
  ans
  
}

attr(`BatesEngine__SWIG_0`, 'returnType') = '_p_BatesEnginePtr'
attr(`BatesEngine__SWIG_0`, "inputTypes") = c('_p_BatesModelPtr', 'integer')
class(`BatesEngine__SWIG_0`) = c("SWIGFunction", class('BatesEngine__SWIG_0'))

# Start of new_BatesEngine

`BatesEngine__SWIG_1` = function(model)
{
  ;ans = .Call('R_swig_new_BatesEngine__SWIG_1', model, PACKAGE='QuantLib');
  class(ans) <- "_p_BatesEnginePtr";
  
  reg.finalizer(ans, delete_BatesEngine)
  ans
  
}

attr(`BatesEngine__SWIG_1`, 'returnType') = '_p_BatesEnginePtr'
attr(`BatesEngine__SWIG_1`, "inputTypes") = c('_p_BatesModelPtr')
class(`BatesEngine__SWIG_1`) = c("SWIGFunction", class('BatesEngine__SWIG_1'))

# Start of new_BatesEngine

`BatesEngine__SWIG_2` = function(model, relTolerance, maxEvaluations)
{
  if(length(maxEvaluations) > 1) {
    warning("using only the first element of maxEvaluations");
  };
  
  ;ans = .Call('R_swig_new_BatesEngine__SWIG_2', model, relTolerance, maxEvaluations, PACKAGE='QuantLib');
  class(ans) <- "_p_BatesEnginePtr";
  
  reg.finalizer(ans, delete_BatesEngine)
  ans
  
}

attr(`BatesEngine__SWIG_2`, 'returnType') = '_p_BatesEnginePtr'
attr(`BatesEngine__SWIG_2`, "inputTypes") = c('_p_BatesModelPtr', 'numeric', 'integer')
class(`BatesEngine__SWIG_2`) = c("SWIGFunction", class('BatesEngine__SWIG_2'))

`BatesEngine` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 1) {
    if (extends(argtypes[1], '_p_BatesModelPtr')) {
      f <- BatesEngine__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_BatesModelPtr') && (is.integer(argv[[2]]) || is.numeric(argv[[2]]))) {
      f <- BatesEngine__SWIG_0; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_BatesModelPtr') && is.numeric(argv[[2]]) && (is.integer(argv[[3]]) || is.numeric(argv[[3]]))) {
      f <- BatesEngine__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for BatesEngine with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_BatesEngine

`delete_BatesEngine` = function(self)
{
  ;.Call('R_swig_delete_BatesEngine', self, PACKAGE='QuantLib');
  
}

attr(`delete_BatesEngine`, 'returnType') = 'void'
attr(`delete_BatesEngine`, "inputTypes") = c('_p_BatesEnginePtr')
class(`delete_BatesEngine`) = c("SWIGFunction", class('delete_BatesEngine'))

setMethod('delete', '_p_BatesEnginePtr', function(obj) {delete_BatesEnginePtr(obj)})
# Start of new_IntegralEngine

`IntegralEngine` = function(process)
{
  ;ans = .Call('R_swig_new_IntegralEngine', process, PACKAGE='QuantLib');
  class(ans) <- "_p_IntegralEnginePtr";
  
  reg.finalizer(ans, delete_IntegralEngine)
  ans
  
}

attr(`IntegralEngine`, 'returnType') = '_p_IntegralEnginePtr'
attr(`IntegralEngine`, "inputTypes") = c('_p_GeneralizedBlackScholesProcessPtr')
class(`IntegralEngine`) = c("SWIGFunction", class('IntegralEngine'))

# Start of delete_IntegralEngine

`delete_IntegralEngine` = function(self)
{
  ;.Call('R_swig_delete_IntegralEngine', self, PACKAGE='QuantLib');
  
}

attr(`delete_IntegralEngine`, 'returnType') = 'void'
attr(`delete_IntegralEngine`, "inputTypes") = c('_p_IntegralEnginePtr')
class(`delete_IntegralEngine`) = c("SWIGFunction", class('delete_IntegralEngine'))

setMethod('delete', '_p_IntegralEnginePtr', function(obj) {delete_IntegralEnginePtr(obj)})
# Start of new_FDBermudanEngine

`FDBermudanEngine__SWIG_0` = function(process, timeSteps, gridPoints, timeDependent)
{
  if(length(timeSteps) > 1) {
    warning("using only the first element of timeSteps");
  };
  
  
  
  if(length(gridPoints) > 1) {
    warning("using only the first element of gridPoints");
  };
  
  timeDependent = as.logical(timeDependent);
  ;ans = .Call('R_swig_new_FDBermudanEngine__SWIG_0', process, timeSteps, gridPoints, timeDependent, PACKAGE='QuantLib');
  class(ans) <- "_p_FDBermudanEnginePtr";
  
  reg.finalizer(ans, delete_FDBermudanEngine)
  ans
  
}

attr(`FDBermudanEngine__SWIG_0`, 'returnType') = '_p_FDBermudanEnginePtr'
attr(`FDBermudanEngine__SWIG_0`, "inputTypes") = c('_p_GeneralizedBlackScholesProcessPtr', 'integer', 'integer', 'logical')
class(`FDBermudanEngine__SWIG_0`) = c("SWIGFunction", class('FDBermudanEngine__SWIG_0'))

# Start of new_FDBermudanEngine

`FDBermudanEngine__SWIG_1` = function(process, timeSteps, gridPoints)
{
  if(length(timeSteps) > 1) {
    warning("using only the first element of timeSteps");
  };
  
  
  
  if(length(gridPoints) > 1) {
    warning("using only the first element of gridPoints");
  };
  
  ;ans = .Call('R_swig_new_FDBermudanEngine__SWIG_1', process, timeSteps, gridPoints, PACKAGE='QuantLib');
  class(ans) <- "_p_FDBermudanEnginePtr";
  
  reg.finalizer(ans, delete_FDBermudanEngine)
  ans
  
}

attr(`FDBermudanEngine__SWIG_1`, 'returnType') = '_p_FDBermudanEnginePtr'
attr(`FDBermudanEngine__SWIG_1`, "inputTypes") = c('_p_GeneralizedBlackScholesProcessPtr', 'integer', 'integer')
class(`FDBermudanEngine__SWIG_1`) = c("SWIGFunction", class('FDBermudanEngine__SWIG_1'))

# Start of new_FDBermudanEngine

`FDBermudanEngine__SWIG_2` = function(process, timeSteps)
{
  if(length(timeSteps) > 1) {
    warning("using only the first element of timeSteps");
  };
  
  ;ans = .Call('R_swig_new_FDBermudanEngine__SWIG_2', process, timeSteps, PACKAGE='QuantLib');
  class(ans) <- "_p_FDBermudanEnginePtr";
  
  reg.finalizer(ans, delete_FDBermudanEngine)
  ans
  
}

attr(`FDBermudanEngine__SWIG_2`, 'returnType') = '_p_FDBermudanEnginePtr'
attr(`FDBermudanEngine__SWIG_2`, "inputTypes") = c('_p_GeneralizedBlackScholesProcessPtr', 'integer')
class(`FDBermudanEngine__SWIG_2`) = c("SWIGFunction", class('FDBermudanEngine__SWIG_2'))

# Start of new_FDBermudanEngine

`FDBermudanEngine__SWIG_3` = function(process)
{
  ;ans = .Call('R_swig_new_FDBermudanEngine__SWIG_3', process, PACKAGE='QuantLib');
  class(ans) <- "_p_FDBermudanEnginePtr";
  
  reg.finalizer(ans, delete_FDBermudanEngine)
  ans
  
}

attr(`FDBermudanEngine__SWIG_3`, 'returnType') = '_p_FDBermudanEnginePtr'
attr(`FDBermudanEngine__SWIG_3`, "inputTypes") = c('_p_GeneralizedBlackScholesProcessPtr')
class(`FDBermudanEngine__SWIG_3`) = c("SWIGFunction", class('FDBermudanEngine__SWIG_3'))

`FDBermudanEngine` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 1) {
    if (extends(argtypes[1], '_p_GeneralizedBlackScholesProcessPtr')) {
      f <- FDBermudanEngine__SWIG_3; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_GeneralizedBlackScholesProcessPtr') && (is.integer(argv[[2]]) || is.numeric(argv[[2]]))) {
      f <- FDBermudanEngine__SWIG_2; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_GeneralizedBlackScholesProcessPtr') && (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && (is.integer(argv[[3]]) || is.numeric(argv[[3]]))) {
      f <- FDBermudanEngine__SWIG_1; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_GeneralizedBlackScholesProcessPtr') && (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && extends(argtypes[4], 'logical')) {
      f <- FDBermudanEngine__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for FDBermudanEngine with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_FDBermudanEngine

`delete_FDBermudanEngine` = function(self)
{
  ;.Call('R_swig_delete_FDBermudanEngine', self, PACKAGE='QuantLib');
  
}

attr(`delete_FDBermudanEngine`, 'returnType') = 'void'
attr(`delete_FDBermudanEngine`, "inputTypes") = c('_p_FDBermudanEnginePtr')
class(`delete_FDBermudanEngine`) = c("SWIGFunction", class('delete_FDBermudanEngine'))

setMethod('delete', '_p_FDBermudanEnginePtr', function(obj) {delete_FDBermudanEnginePtr(obj)})
# Start of new_FDEuropeanEngine

`FDEuropeanEngine__SWIG_0` = function(process, timeSteps, gridPoints, timeDependent)
{
  if(length(timeSteps) > 1) {
    warning("using only the first element of timeSteps");
  };
  
  
  
  if(length(gridPoints) > 1) {
    warning("using only the first element of gridPoints");
  };
  
  timeDependent = as.logical(timeDependent);
  ;ans = .Call('R_swig_new_FDEuropeanEngine__SWIG_0', process, timeSteps, gridPoints, timeDependent, PACKAGE='QuantLib');
  class(ans) <- "_p_FDEuropeanEnginePtr";
  
  reg.finalizer(ans, delete_FDEuropeanEngine)
  ans
  
}

attr(`FDEuropeanEngine__SWIG_0`, 'returnType') = '_p_FDEuropeanEnginePtr'
attr(`FDEuropeanEngine__SWIG_0`, "inputTypes") = c('_p_GeneralizedBlackScholesProcessPtr', 'integer', 'integer', 'logical')
class(`FDEuropeanEngine__SWIG_0`) = c("SWIGFunction", class('FDEuropeanEngine__SWIG_0'))

# Start of new_FDEuropeanEngine

`FDEuropeanEngine__SWIG_1` = function(process, timeSteps, gridPoints)
{
  if(length(timeSteps) > 1) {
    warning("using only the first element of timeSteps");
  };
  
  
  
  if(length(gridPoints) > 1) {
    warning("using only the first element of gridPoints");
  };
  
  ;ans = .Call('R_swig_new_FDEuropeanEngine__SWIG_1', process, timeSteps, gridPoints, PACKAGE='QuantLib');
  class(ans) <- "_p_FDEuropeanEnginePtr";
  
  reg.finalizer(ans, delete_FDEuropeanEngine)
  ans
  
}

attr(`FDEuropeanEngine__SWIG_1`, 'returnType') = '_p_FDEuropeanEnginePtr'
attr(`FDEuropeanEngine__SWIG_1`, "inputTypes") = c('_p_GeneralizedBlackScholesProcessPtr', 'integer', 'integer')
class(`FDEuropeanEngine__SWIG_1`) = c("SWIGFunction", class('FDEuropeanEngine__SWIG_1'))

# Start of new_FDEuropeanEngine

`FDEuropeanEngine__SWIG_2` = function(process, timeSteps)
{
  if(length(timeSteps) > 1) {
    warning("using only the first element of timeSteps");
  };
  
  ;ans = .Call('R_swig_new_FDEuropeanEngine__SWIG_2', process, timeSteps, PACKAGE='QuantLib');
  class(ans) <- "_p_FDEuropeanEnginePtr";
  
  reg.finalizer(ans, delete_FDEuropeanEngine)
  ans
  
}

attr(`FDEuropeanEngine__SWIG_2`, 'returnType') = '_p_FDEuropeanEnginePtr'
attr(`FDEuropeanEngine__SWIG_2`, "inputTypes") = c('_p_GeneralizedBlackScholesProcessPtr', 'integer')
class(`FDEuropeanEngine__SWIG_2`) = c("SWIGFunction", class('FDEuropeanEngine__SWIG_2'))

# Start of new_FDEuropeanEngine

`FDEuropeanEngine__SWIG_3` = function(process)
{
  ;ans = .Call('R_swig_new_FDEuropeanEngine__SWIG_3', process, PACKAGE='QuantLib');
  class(ans) <- "_p_FDEuropeanEnginePtr";
  
  reg.finalizer(ans, delete_FDEuropeanEngine)
  ans
  
}

attr(`FDEuropeanEngine__SWIG_3`, 'returnType') = '_p_FDEuropeanEnginePtr'
attr(`FDEuropeanEngine__SWIG_3`, "inputTypes") = c('_p_GeneralizedBlackScholesProcessPtr')
class(`FDEuropeanEngine__SWIG_3`) = c("SWIGFunction", class('FDEuropeanEngine__SWIG_3'))

`FDEuropeanEngine` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 1) {
    if (extends(argtypes[1], '_p_GeneralizedBlackScholesProcessPtr')) {
      f <- FDEuropeanEngine__SWIG_3; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_GeneralizedBlackScholesProcessPtr') && (is.integer(argv[[2]]) || is.numeric(argv[[2]]))) {
      f <- FDEuropeanEngine__SWIG_2; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_GeneralizedBlackScholesProcessPtr') && (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && (is.integer(argv[[3]]) || is.numeric(argv[[3]]))) {
      f <- FDEuropeanEngine__SWIG_1; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_GeneralizedBlackScholesProcessPtr') && (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && extends(argtypes[4], 'logical')) {
      f <- FDEuropeanEngine__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for FDEuropeanEngine with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_FDEuropeanEngine

`delete_FDEuropeanEngine` = function(self)
{
  ;.Call('R_swig_delete_FDEuropeanEngine', self, PACKAGE='QuantLib');
  
}

attr(`delete_FDEuropeanEngine`, 'returnType') = 'void'
attr(`delete_FDEuropeanEngine`, "inputTypes") = c('_p_FDEuropeanEnginePtr')
class(`delete_FDEuropeanEngine`) = c("SWIGFunction", class('delete_FDEuropeanEngine'))

setMethod('delete', '_p_FDEuropeanEnginePtr', function(obj) {delete_FDEuropeanEnginePtr(obj)})
# Start of new_BinomialVanillaEngine

`BinomialVanillaEngine` = function(process, type, steps)
{
  type = as(type, "character"); 
  
  
  if(length(steps) > 1) {
    warning("using only the first element of steps");
  };
  
  ;ans = .Call('R_swig_new_BinomialVanillaEngine', process, type, steps, PACKAGE='QuantLib');
  class(ans) <- "_p_BinomialVanillaEnginePtr";
  
  reg.finalizer(ans, delete_BinomialVanillaEngine)
  ans
  
}

attr(`BinomialVanillaEngine`, 'returnType') = '_p_BinomialVanillaEnginePtr'
attr(`BinomialVanillaEngine`, "inputTypes") = c('_p_GeneralizedBlackScholesProcessPtr', 'character', 'integer')
class(`BinomialVanillaEngine`) = c("SWIGFunction", class('BinomialVanillaEngine'))

# Start of delete_BinomialVanillaEngine

`delete_BinomialVanillaEngine` = function(self)
{
  ;.Call('R_swig_delete_BinomialVanillaEngine', self, PACKAGE='QuantLib');
  
}

attr(`delete_BinomialVanillaEngine`, 'returnType') = 'void'
attr(`delete_BinomialVanillaEngine`, "inputTypes") = c('_p_BinomialVanillaEnginePtr')
class(`delete_BinomialVanillaEngine`) = c("SWIGFunction", class('delete_BinomialVanillaEngine'))

setMethod('delete', '_p_BinomialVanillaEnginePtr', function(obj) {delete_BinomialVanillaEnginePtr(obj)})
# Start of new_MCEuropeanEngine

`MCEuropeanEngine` = function(process, traits, timeSteps, timeStepsPerYear, brownianBridge, antitheticVariate, requiredSamples, requiredTolerance, maxSamples, seed)
{
  traits = as(traits, "character"); 
  as(input, "integer"); 
  as(input, "integer"); 
  brownianBridge = as.logical(brownianBridge);
  antitheticVariate = as.logical(antitheticVariate);
  as(input, "integer"); 
  as(input, "numeric"); 
  as(input, "integer"); 
  seed = as.integer(seed); 
  
  if(length(seed) > 1) {
    warning("using only the first element of seed");
  };
  
  ;ans = .Call('R_swig_new_MCEuropeanEngine', process, traits, timeSteps, timeStepsPerYear, brownianBridge, antitheticVariate, requiredSamples, requiredTolerance, maxSamples, seed, PACKAGE='QuantLib');
  class(ans) <- "_p_MCEuropeanEnginePtr";
  
  reg.finalizer(ans, delete_MCEuropeanEngine)
  ans
  
}

attr(`MCEuropeanEngine`, 'returnType') = '_p_MCEuropeanEnginePtr'
attr(`MCEuropeanEngine`, "inputTypes") = c('_p_GeneralizedBlackScholesProcessPtr', 'character', 'numeric', 'numeric', 'logical', 'logical', 'numeric', 'numeric', 'numeric', 'integer')
class(`MCEuropeanEngine`) = c("SWIGFunction", class('MCEuropeanEngine'))

# Start of delete_MCEuropeanEngine

`delete_MCEuropeanEngine` = function(self)
{
  ;.Call('R_swig_delete_MCEuropeanEngine', self, PACKAGE='QuantLib');
  
}

attr(`delete_MCEuropeanEngine`, 'returnType') = 'void'
attr(`delete_MCEuropeanEngine`, "inputTypes") = c('_p_MCEuropeanEnginePtr')
class(`delete_MCEuropeanEngine`) = c("SWIGFunction", class('delete_MCEuropeanEngine'))

setMethod('delete', '_p_MCEuropeanEnginePtr', function(obj) {delete_MCEuropeanEnginePtr(obj)})
# Start of new_FDAmericanEngine

`FDAmericanEngine__SWIG_0` = function(process, timeSteps, gridPoints, timeDependent)
{
  if(length(timeSteps) > 1) {
    warning("using only the first element of timeSteps");
  };
  
  
  
  if(length(gridPoints) > 1) {
    warning("using only the first element of gridPoints");
  };
  
  timeDependent = as.logical(timeDependent);
  ;ans = .Call('R_swig_new_FDAmericanEngine__SWIG_0', process, timeSteps, gridPoints, timeDependent, PACKAGE='QuantLib');
  class(ans) <- "_p_FDAmericanEnginePtr";
  
  reg.finalizer(ans, delete_FDAmericanEngine)
  ans
  
}

attr(`FDAmericanEngine__SWIG_0`, 'returnType') = '_p_FDAmericanEnginePtr'
attr(`FDAmericanEngine__SWIG_0`, "inputTypes") = c('_p_GeneralizedBlackScholesProcessPtr', 'integer', 'integer', 'logical')
class(`FDAmericanEngine__SWIG_0`) = c("SWIGFunction", class('FDAmericanEngine__SWIG_0'))

# Start of new_FDAmericanEngine

`FDAmericanEngine__SWIG_1` = function(process, timeSteps, gridPoints)
{
  if(length(timeSteps) > 1) {
    warning("using only the first element of timeSteps");
  };
  
  
  
  if(length(gridPoints) > 1) {
    warning("using only the first element of gridPoints");
  };
  
  ;ans = .Call('R_swig_new_FDAmericanEngine__SWIG_1', process, timeSteps, gridPoints, PACKAGE='QuantLib');
  class(ans) <- "_p_FDAmericanEnginePtr";
  
  reg.finalizer(ans, delete_FDAmericanEngine)
  ans
  
}

attr(`FDAmericanEngine__SWIG_1`, 'returnType') = '_p_FDAmericanEnginePtr'
attr(`FDAmericanEngine__SWIG_1`, "inputTypes") = c('_p_GeneralizedBlackScholesProcessPtr', 'integer', 'integer')
class(`FDAmericanEngine__SWIG_1`) = c("SWIGFunction", class('FDAmericanEngine__SWIG_1'))

# Start of new_FDAmericanEngine

`FDAmericanEngine__SWIG_2` = function(process, timeSteps)
{
  if(length(timeSteps) > 1) {
    warning("using only the first element of timeSteps");
  };
  
  ;ans = .Call('R_swig_new_FDAmericanEngine__SWIG_2', process, timeSteps, PACKAGE='QuantLib');
  class(ans) <- "_p_FDAmericanEnginePtr";
  
  reg.finalizer(ans, delete_FDAmericanEngine)
  ans
  
}

attr(`FDAmericanEngine__SWIG_2`, 'returnType') = '_p_FDAmericanEnginePtr'
attr(`FDAmericanEngine__SWIG_2`, "inputTypes") = c('_p_GeneralizedBlackScholesProcessPtr', 'integer')
class(`FDAmericanEngine__SWIG_2`) = c("SWIGFunction", class('FDAmericanEngine__SWIG_2'))

# Start of new_FDAmericanEngine

`FDAmericanEngine__SWIG_3` = function(process)
{
  ;ans = .Call('R_swig_new_FDAmericanEngine__SWIG_3', process, PACKAGE='QuantLib');
  class(ans) <- "_p_FDAmericanEnginePtr";
  
  reg.finalizer(ans, delete_FDAmericanEngine)
  ans
  
}

attr(`FDAmericanEngine__SWIG_3`, 'returnType') = '_p_FDAmericanEnginePtr'
attr(`FDAmericanEngine__SWIG_3`, "inputTypes") = c('_p_GeneralizedBlackScholesProcessPtr')
class(`FDAmericanEngine__SWIG_3`) = c("SWIGFunction", class('FDAmericanEngine__SWIG_3'))

`FDAmericanEngine` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 1) {
    if (extends(argtypes[1], '_p_GeneralizedBlackScholesProcessPtr')) {
      f <- FDAmericanEngine__SWIG_3; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_GeneralizedBlackScholesProcessPtr') && (is.integer(argv[[2]]) || is.numeric(argv[[2]]))) {
      f <- FDAmericanEngine__SWIG_2; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_GeneralizedBlackScholesProcessPtr') && (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && (is.integer(argv[[3]]) || is.numeric(argv[[3]]))) {
      f <- FDAmericanEngine__SWIG_1; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_GeneralizedBlackScholesProcessPtr') && (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && extends(argtypes[4], 'logical')) {
      f <- FDAmericanEngine__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for FDAmericanEngine with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_FDAmericanEngine

`delete_FDAmericanEngine` = function(self)
{
  ;.Call('R_swig_delete_FDAmericanEngine', self, PACKAGE='QuantLib');
  
}

attr(`delete_FDAmericanEngine`, 'returnType') = 'void'
attr(`delete_FDAmericanEngine`, "inputTypes") = c('_p_FDAmericanEnginePtr')
class(`delete_FDAmericanEngine`) = c("SWIGFunction", class('delete_FDAmericanEngine'))

setMethod('delete', '_p_FDAmericanEnginePtr', function(obj) {delete_FDAmericanEnginePtr(obj)})
# Start of new_FDShoutEngine

`FDShoutEngine__SWIG_0` = function(process, timeSteps, gridPoints, timeDependent)
{
  if(length(timeSteps) > 1) {
    warning("using only the first element of timeSteps");
  };
  
  
  
  if(length(gridPoints) > 1) {
    warning("using only the first element of gridPoints");
  };
  
  timeDependent = as.logical(timeDependent);
  ;ans = .Call('R_swig_new_FDShoutEngine__SWIG_0', process, timeSteps, gridPoints, timeDependent, PACKAGE='QuantLib');
  class(ans) <- "_p_FDShoutEnginePtr";
  
  reg.finalizer(ans, delete_FDShoutEngine)
  ans
  
}

attr(`FDShoutEngine__SWIG_0`, 'returnType') = '_p_FDShoutEnginePtr'
attr(`FDShoutEngine__SWIG_0`, "inputTypes") = c('_p_GeneralizedBlackScholesProcessPtr', 'integer', 'integer', 'logical')
class(`FDShoutEngine__SWIG_0`) = c("SWIGFunction", class('FDShoutEngine__SWIG_0'))

# Start of new_FDShoutEngine

`FDShoutEngine__SWIG_1` = function(process, timeSteps, gridPoints)
{
  if(length(timeSteps) > 1) {
    warning("using only the first element of timeSteps");
  };
  
  
  
  if(length(gridPoints) > 1) {
    warning("using only the first element of gridPoints");
  };
  
  ;ans = .Call('R_swig_new_FDShoutEngine__SWIG_1', process, timeSteps, gridPoints, PACKAGE='QuantLib');
  class(ans) <- "_p_FDShoutEnginePtr";
  
  reg.finalizer(ans, delete_FDShoutEngine)
  ans
  
}

attr(`FDShoutEngine__SWIG_1`, 'returnType') = '_p_FDShoutEnginePtr'
attr(`FDShoutEngine__SWIG_1`, "inputTypes") = c('_p_GeneralizedBlackScholesProcessPtr', 'integer', 'integer')
class(`FDShoutEngine__SWIG_1`) = c("SWIGFunction", class('FDShoutEngine__SWIG_1'))

# Start of new_FDShoutEngine

`FDShoutEngine__SWIG_2` = function(process, timeSteps)
{
  if(length(timeSteps) > 1) {
    warning("using only the first element of timeSteps");
  };
  
  ;ans = .Call('R_swig_new_FDShoutEngine__SWIG_2', process, timeSteps, PACKAGE='QuantLib');
  class(ans) <- "_p_FDShoutEnginePtr";
  
  reg.finalizer(ans, delete_FDShoutEngine)
  ans
  
}

attr(`FDShoutEngine__SWIG_2`, 'returnType') = '_p_FDShoutEnginePtr'
attr(`FDShoutEngine__SWIG_2`, "inputTypes") = c('_p_GeneralizedBlackScholesProcessPtr', 'integer')
class(`FDShoutEngine__SWIG_2`) = c("SWIGFunction", class('FDShoutEngine__SWIG_2'))

# Start of new_FDShoutEngine

`FDShoutEngine__SWIG_3` = function(process)
{
  ;ans = .Call('R_swig_new_FDShoutEngine__SWIG_3', process, PACKAGE='QuantLib');
  class(ans) <- "_p_FDShoutEnginePtr";
  
  reg.finalizer(ans, delete_FDShoutEngine)
  ans
  
}

attr(`FDShoutEngine__SWIG_3`, 'returnType') = '_p_FDShoutEnginePtr'
attr(`FDShoutEngine__SWIG_3`, "inputTypes") = c('_p_GeneralizedBlackScholesProcessPtr')
class(`FDShoutEngine__SWIG_3`) = c("SWIGFunction", class('FDShoutEngine__SWIG_3'))

`FDShoutEngine` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 1) {
    if (extends(argtypes[1], '_p_GeneralizedBlackScholesProcessPtr')) {
      f <- FDShoutEngine__SWIG_3; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_GeneralizedBlackScholesProcessPtr') && (is.integer(argv[[2]]) || is.numeric(argv[[2]]))) {
      f <- FDShoutEngine__SWIG_2; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_GeneralizedBlackScholesProcessPtr') && (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && (is.integer(argv[[3]]) || is.numeric(argv[[3]]))) {
      f <- FDShoutEngine__SWIG_1; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_GeneralizedBlackScholesProcessPtr') && (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && extends(argtypes[4], 'logical')) {
      f <- FDShoutEngine__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for FDShoutEngine with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_FDShoutEngine

`delete_FDShoutEngine` = function(self)
{
  ;.Call('R_swig_delete_FDShoutEngine', self, PACKAGE='QuantLib');
  
}

attr(`delete_FDShoutEngine`, 'returnType') = 'void'
attr(`delete_FDShoutEngine`, "inputTypes") = c('_p_FDShoutEnginePtr')
class(`delete_FDShoutEngine`) = c("SWIGFunction", class('delete_FDShoutEngine'))

setMethod('delete', '_p_FDShoutEnginePtr', function(obj) {delete_FDShoutEnginePtr(obj)})
# Start of new_BaroneAdesiWhaleyEngine

`BaroneAdesiWhaleyEngine` = function(process)
{
  ;ans = .Call('R_swig_new_BaroneAdesiWhaleyEngine', process, PACKAGE='QuantLib');
  class(ans) <- "_p_BaroneAdesiWhaleyApproximationEnginePtr";
  
  reg.finalizer(ans, delete_BaroneAdesiWhaleyEngine)
  ans
  
}

attr(`BaroneAdesiWhaleyEngine`, 'returnType') = '_p_BaroneAdesiWhaleyApproximationEnginePtr'
attr(`BaroneAdesiWhaleyEngine`, "inputTypes") = c('_p_GeneralizedBlackScholesProcessPtr')
class(`BaroneAdesiWhaleyEngine`) = c("SWIGFunction", class('BaroneAdesiWhaleyEngine'))

# Start of delete_BaroneAdesiWhaleyEngine

`delete_BaroneAdesiWhaleyEngine` = function(self)
{
  ;.Call('R_swig_delete_BaroneAdesiWhaleyEngine', self, PACKAGE='QuantLib');
  
}

attr(`delete_BaroneAdesiWhaleyEngine`, 'returnType') = 'void'
attr(`delete_BaroneAdesiWhaleyEngine`, "inputTypes") = c('_p_BaroneAdesiWhaleyApproximationEnginePtr')
class(`delete_BaroneAdesiWhaleyEngine`) = c("SWIGFunction", class('delete_BaroneAdesiWhaleyEngine'))

setMethod('delete', '_p_BaroneAdesiWhaleyApproximationEnginePtr', function(obj) {delete_BaroneAdesiWhaleyApproximationEnginePtr(obj)})
# Start of new_BjerksundStenslandEngine

`BjerksundStenslandEngine` = function(process)
{
  ;ans = .Call('R_swig_new_BjerksundStenslandEngine', process, PACKAGE='QuantLib');
  class(ans) <- "_p_BjerksundStenslandApproximationEnginePtr";
  
  reg.finalizer(ans, delete_BjerksundStenslandEngine)
  ans
  
}

attr(`BjerksundStenslandEngine`, 'returnType') = '_p_BjerksundStenslandApproximationEnginePtr'
attr(`BjerksundStenslandEngine`, "inputTypes") = c('_p_GeneralizedBlackScholesProcessPtr')
class(`BjerksundStenslandEngine`) = c("SWIGFunction", class('BjerksundStenslandEngine'))

# Start of delete_BjerksundStenslandEngine

`delete_BjerksundStenslandEngine` = function(self)
{
  ;.Call('R_swig_delete_BjerksundStenslandEngine', self, PACKAGE='QuantLib');
  
}

attr(`delete_BjerksundStenslandEngine`, 'returnType') = 'void'
attr(`delete_BjerksundStenslandEngine`, "inputTypes") = c('_p_BjerksundStenslandApproximationEnginePtr')
class(`delete_BjerksundStenslandEngine`) = c("SWIGFunction", class('delete_BjerksundStenslandEngine'))

setMethod('delete', '_p_BjerksundStenslandApproximationEnginePtr', function(obj) {delete_BjerksundStenslandApproximationEnginePtr(obj)})
# Start of new_AnalyticDigitalAmericanEngine

`AnalyticDigitalAmericanEngine` = function(process)
{
  ;ans = .Call('R_swig_new_AnalyticDigitalAmericanEngine', process, PACKAGE='QuantLib');
  class(ans) <- "_p_AnalyticDigitalAmericanEnginePtr";
  
  reg.finalizer(ans, delete_AnalyticDigitalAmericanEngine)
  ans
  
}

attr(`AnalyticDigitalAmericanEngine`, 'returnType') = '_p_AnalyticDigitalAmericanEnginePtr'
attr(`AnalyticDigitalAmericanEngine`, "inputTypes") = c('_p_GeneralizedBlackScholesProcessPtr')
class(`AnalyticDigitalAmericanEngine`) = c("SWIGFunction", class('AnalyticDigitalAmericanEngine'))

# Start of delete_AnalyticDigitalAmericanEngine

`delete_AnalyticDigitalAmericanEngine` = function(self)
{
  ;.Call('R_swig_delete_AnalyticDigitalAmericanEngine', self, PACKAGE='QuantLib');
  
}

attr(`delete_AnalyticDigitalAmericanEngine`, 'returnType') = 'void'
attr(`delete_AnalyticDigitalAmericanEngine`, "inputTypes") = c('_p_AnalyticDigitalAmericanEnginePtr')
class(`delete_AnalyticDigitalAmericanEngine`) = c("SWIGFunction", class('delete_AnalyticDigitalAmericanEngine'))

setMethod('delete', '_p_AnalyticDigitalAmericanEnginePtr', function(obj) {delete_AnalyticDigitalAmericanEnginePtr(obj)})
# Start of new_DividendVanillaOption

`DividendVanillaOption` = function(payoff, exercise, dividendDates, dividends)
{
  ;ans = .Call('R_swig_new_DividendVanillaOption', payoff, exercise, dividendDates, dividends, PACKAGE='QuantLib');
  class(ans) <- "_p_DividendVanillaOptionPtr";
  
  reg.finalizer(ans, delete_DividendVanillaOption)
  ans
  
}

attr(`DividendVanillaOption`, 'returnType') = '_p_DividendVanillaOptionPtr'
attr(`DividendVanillaOption`, "inputTypes") = c('_p_boost__shared_ptrT_Payoff_t', '_p_boost__shared_ptrT_Exercise_t', '_p_std__vectorT_Date_std__allocatorT_Date_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`DividendVanillaOption`) = c("SWIGFunction", class('DividendVanillaOption'))

# Start of DividendVanillaOption_priceCurve

`DividendVanillaOption_priceCurve` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_DividendVanillaOption_priceCurve', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_SampledCurve";
  
  ans
  
}

attr(`DividendVanillaOption_priceCurve`, 'returnType') = '_p_SampledCurve'
attr(`DividendVanillaOption_priceCurve`, "inputTypes") = c('_p_DividendVanillaOptionPtr')
class(`DividendVanillaOption_priceCurve`) = c("SWIGFunction", class('DividendVanillaOption_priceCurve'))

# Start of DividendVanillaOption_impliedVolatility

`DividendVanillaOption_impliedVolatility__SWIG_0` = function(self, targetValue, process, accuracy, maxEvaluations, minVol, maxVol, .copy = FALSE)
{
  if(length(maxEvaluations) > 1) {
    warning("using only the first element of maxEvaluations");
  };
  
  
  
  ;.Call('R_swig_DividendVanillaOption_impliedVolatility__SWIG_0', self, targetValue, process, accuracy, maxEvaluations, minVol, maxVol, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DividendVanillaOption_impliedVolatility__SWIG_0`, 'returnType') = 'numeric'
attr(`DividendVanillaOption_impliedVolatility__SWIG_0`, "inputTypes") = c('_p_DividendVanillaOptionPtr', 'numeric', '_p_GeneralizedBlackScholesProcessPtr', 'numeric', 'integer', 'numeric', 'numeric')
class(`DividendVanillaOption_impliedVolatility__SWIG_0`) = c("SWIGFunction", class('DividendVanillaOption_impliedVolatility__SWIG_0'))

# Start of DividendVanillaOption_impliedVolatility

`DividendVanillaOption_impliedVolatility__SWIG_1` = function(self, targetValue, process, accuracy, maxEvaluations, minVol, .copy = FALSE)
{
  if(length(maxEvaluations) > 1) {
    warning("using only the first element of maxEvaluations");
  };
  
  
  ;.Call('R_swig_DividendVanillaOption_impliedVolatility__SWIG_1', self, targetValue, process, accuracy, maxEvaluations, minVol, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DividendVanillaOption_impliedVolatility__SWIG_1`, 'returnType') = 'numeric'
attr(`DividendVanillaOption_impliedVolatility__SWIG_1`, "inputTypes") = c('_p_DividendVanillaOptionPtr', 'numeric', '_p_GeneralizedBlackScholesProcessPtr', 'numeric', 'integer', 'numeric')
class(`DividendVanillaOption_impliedVolatility__SWIG_1`) = c("SWIGFunction", class('DividendVanillaOption_impliedVolatility__SWIG_1'))

# Start of DividendVanillaOption_impliedVolatility

`DividendVanillaOption_impliedVolatility__SWIG_2` = function(self, targetValue, process, accuracy, maxEvaluations, .copy = FALSE)
{
  if(length(maxEvaluations) > 1) {
    warning("using only the first element of maxEvaluations");
  };
  
  ;.Call('R_swig_DividendVanillaOption_impliedVolatility__SWIG_2', self, targetValue, process, accuracy, maxEvaluations, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DividendVanillaOption_impliedVolatility__SWIG_2`, 'returnType') = 'numeric'
attr(`DividendVanillaOption_impliedVolatility__SWIG_2`, "inputTypes") = c('_p_DividendVanillaOptionPtr', 'numeric', '_p_GeneralizedBlackScholesProcessPtr', 'numeric', 'integer')
class(`DividendVanillaOption_impliedVolatility__SWIG_2`) = c("SWIGFunction", class('DividendVanillaOption_impliedVolatility__SWIG_2'))

# Start of DividendVanillaOption_impliedVolatility

`DividendVanillaOption_impliedVolatility__SWIG_3` = function(self, targetValue, process, accuracy, .copy = FALSE)
{
  ;.Call('R_swig_DividendVanillaOption_impliedVolatility__SWIG_3', self, targetValue, process, accuracy, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DividendVanillaOption_impliedVolatility__SWIG_3`, 'returnType') = 'numeric'
attr(`DividendVanillaOption_impliedVolatility__SWIG_3`, "inputTypes") = c('_p_DividendVanillaOptionPtr', 'numeric', '_p_GeneralizedBlackScholesProcessPtr', 'numeric')
class(`DividendVanillaOption_impliedVolatility__SWIG_3`) = c("SWIGFunction", class('DividendVanillaOption_impliedVolatility__SWIG_3'))

# Start of DividendVanillaOption_impliedVolatility

`DividendVanillaOption_impliedVolatility__SWIG_4` = function(self, targetValue, process, .copy = FALSE)
{
  ;.Call('R_swig_DividendVanillaOption_impliedVolatility__SWIG_4', self, targetValue, process, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DividendVanillaOption_impliedVolatility__SWIG_4`, 'returnType') = 'numeric'
attr(`DividendVanillaOption_impliedVolatility__SWIG_4`, "inputTypes") = c('_p_DividendVanillaOptionPtr', 'numeric', '_p_GeneralizedBlackScholesProcessPtr')
class(`DividendVanillaOption_impliedVolatility__SWIG_4`) = c("SWIGFunction", class('DividendVanillaOption_impliedVolatility__SWIG_4'))

`DividendVanillaOption_impliedVolatility` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 5
  if (argc == 3) {
    if (extends(argtypes[1], '_p_DividendVanillaOptionPtr') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_GeneralizedBlackScholesProcessPtr')) {
      f <- DividendVanillaOption_impliedVolatility__SWIG_4; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_DividendVanillaOptionPtr') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_GeneralizedBlackScholesProcessPtr') && is.numeric(argv[[4]])) {
      f <- DividendVanillaOption_impliedVolatility__SWIG_3; 
    }
  } else if (argc == 5) {
    if (extends(argtypes[1], '_p_DividendVanillaOptionPtr') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_GeneralizedBlackScholesProcessPtr') && is.numeric(argv[[4]]) && (is.integer(argv[[5]]) || is.numeric(argv[[5]]))) {
      f <- DividendVanillaOption_impliedVolatility__SWIG_2; 
    }
  } else if (argc == 6) {
    if (extends(argtypes[1], '_p_DividendVanillaOptionPtr') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_GeneralizedBlackScholesProcessPtr') && is.numeric(argv[[4]]) && (is.integer(argv[[5]]) || is.numeric(argv[[5]])) && is.numeric(argv[[6]])) {
      f <- DividendVanillaOption_impliedVolatility__SWIG_1; 
    }
  } else if (argc == 7) {
    if (extends(argtypes[1], '_p_DividendVanillaOptionPtr') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_GeneralizedBlackScholesProcessPtr') && is.numeric(argv[[4]]) && (is.integer(argv[[5]]) || is.numeric(argv[[5]])) && is.numeric(argv[[6]]) && is.numeric(argv[[7]])) {
      f <- DividendVanillaOption_impliedVolatility__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for DividendVanillaOption_impliedVolatility with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of DividendVanillaOption_delta

`DividendVanillaOption_delta` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_DividendVanillaOption_delta', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DividendVanillaOption_delta`, 'returnType') = 'numeric'
attr(`DividendVanillaOption_delta`, "inputTypes") = c('_p_DividendVanillaOptionPtr')
class(`DividendVanillaOption_delta`) = c("SWIGFunction", class('DividendVanillaOption_delta'))

# Start of DividendVanillaOption_gamma

`DividendVanillaOption_gamma` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_DividendVanillaOption_gamma', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DividendVanillaOption_gamma`, 'returnType') = 'numeric'
attr(`DividendVanillaOption_gamma`, "inputTypes") = c('_p_DividendVanillaOptionPtr')
class(`DividendVanillaOption_gamma`) = c("SWIGFunction", class('DividendVanillaOption_gamma'))

# Start of DividendVanillaOption_theta

`DividendVanillaOption_theta` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_DividendVanillaOption_theta', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DividendVanillaOption_theta`, 'returnType') = 'numeric'
attr(`DividendVanillaOption_theta`, "inputTypes") = c('_p_DividendVanillaOptionPtr')
class(`DividendVanillaOption_theta`) = c("SWIGFunction", class('DividendVanillaOption_theta'))

# Start of DividendVanillaOption_thetaPerDay

`DividendVanillaOption_thetaPerDay` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_DividendVanillaOption_thetaPerDay', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DividendVanillaOption_thetaPerDay`, 'returnType') = 'numeric'
attr(`DividendVanillaOption_thetaPerDay`, "inputTypes") = c('_p_DividendVanillaOptionPtr')
class(`DividendVanillaOption_thetaPerDay`) = c("SWIGFunction", class('DividendVanillaOption_thetaPerDay'))

# Start of DividendVanillaOption_vega

`DividendVanillaOption_vega` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_DividendVanillaOption_vega', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DividendVanillaOption_vega`, 'returnType') = 'numeric'
attr(`DividendVanillaOption_vega`, "inputTypes") = c('_p_DividendVanillaOptionPtr')
class(`DividendVanillaOption_vega`) = c("SWIGFunction", class('DividendVanillaOption_vega'))

# Start of DividendVanillaOption_rho

`DividendVanillaOption_rho` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_DividendVanillaOption_rho', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DividendVanillaOption_rho`, 'returnType') = 'numeric'
attr(`DividendVanillaOption_rho`, "inputTypes") = c('_p_DividendVanillaOptionPtr')
class(`DividendVanillaOption_rho`) = c("SWIGFunction", class('DividendVanillaOption_rho'))

# Start of DividendVanillaOption_dividendRho

`DividendVanillaOption_dividendRho` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_DividendVanillaOption_dividendRho', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DividendVanillaOption_dividendRho`, 'returnType') = 'numeric'
attr(`DividendVanillaOption_dividendRho`, "inputTypes") = c('_p_DividendVanillaOptionPtr')
class(`DividendVanillaOption_dividendRho`) = c("SWIGFunction", class('DividendVanillaOption_dividendRho'))

# Start of DividendVanillaOption_strikeSensitivity

`DividendVanillaOption_strikeSensitivity` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_DividendVanillaOption_strikeSensitivity', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DividendVanillaOption_strikeSensitivity`, 'returnType') = 'numeric'
attr(`DividendVanillaOption_strikeSensitivity`, "inputTypes") = c('_p_DividendVanillaOptionPtr')
class(`DividendVanillaOption_strikeSensitivity`) = c("SWIGFunction", class('DividendVanillaOption_strikeSensitivity'))

# Start of delete_DividendVanillaOption

`delete_DividendVanillaOption` = function(self)
{
  ;.Call('R_swig_delete_DividendVanillaOption', self, PACKAGE='QuantLib');
  
}

attr(`delete_DividendVanillaOption`, 'returnType') = 'void'
attr(`delete_DividendVanillaOption`, "inputTypes") = c('_p_DividendVanillaOptionPtr')
class(`delete_DividendVanillaOption`) = c("SWIGFunction", class('delete_DividendVanillaOption'))

# Start of accessor method for DividendVanillaOptionPtr
setMethod('$', '_p_DividendVanillaOptionPtr', function(x, name)

{
  accessorFuns = list('priceCurve' = DividendVanillaOption_priceCurve, 'impliedVolatility' = DividendVanillaOption_impliedVolatility, 'delta' = DividendVanillaOption_delta, 'gamma' = DividendVanillaOption_gamma, 'theta' = DividendVanillaOption_theta, 'thetaPerDay' = DividendVanillaOption_thetaPerDay, 'vega' = DividendVanillaOption_vega, 'rho' = DividendVanillaOption_rho, 'dividendRho' = DividendVanillaOption_dividendRho, 'strikeSensitivity' = DividendVanillaOption_strikeSensitivity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for DividendVanillaOptionPtr
setMethod('delete', '_p_DividendVanillaOptionPtr', function(obj) {delete_DividendVanillaOptionPtr(obj)})
# Start of new_AnalyticDividendEuropeanEngine

`AnalyticDividendEuropeanEngine` = function(process)
{
  ;ans = .Call('R_swig_new_AnalyticDividendEuropeanEngine', process, PACKAGE='QuantLib');
  class(ans) <- "_p_AnalyticDividendEuropeanEnginePtr";
  
  reg.finalizer(ans, delete_AnalyticDividendEuropeanEngine)
  ans
  
}

attr(`AnalyticDividendEuropeanEngine`, 'returnType') = '_p_AnalyticDividendEuropeanEnginePtr'
attr(`AnalyticDividendEuropeanEngine`, "inputTypes") = c('_p_GeneralizedBlackScholesProcessPtr')
class(`AnalyticDividendEuropeanEngine`) = c("SWIGFunction", class('AnalyticDividendEuropeanEngine'))

# Start of delete_AnalyticDividendEuropeanEngine

`delete_AnalyticDividendEuropeanEngine` = function(self)
{
  ;.Call('R_swig_delete_AnalyticDividendEuropeanEngine', self, PACKAGE='QuantLib');
  
}

attr(`delete_AnalyticDividendEuropeanEngine`, 'returnType') = 'void'
attr(`delete_AnalyticDividendEuropeanEngine`, "inputTypes") = c('_p_AnalyticDividendEuropeanEnginePtr')
class(`delete_AnalyticDividendEuropeanEngine`) = c("SWIGFunction", class('delete_AnalyticDividendEuropeanEngine'))

setMethod('delete', '_p_AnalyticDividendEuropeanEnginePtr', function(obj) {delete_AnalyticDividendEuropeanEnginePtr(obj)})
# Start of new_FDDividendEuropeanEngine

`FDDividendEuropeanEngine__SWIG_0` = function(process, timeSteps, gridPoints, timeDependent)
{
  if(length(timeSteps) > 1) {
    warning("using only the first element of timeSteps");
  };
  
  
  
  if(length(gridPoints) > 1) {
    warning("using only the first element of gridPoints");
  };
  
  timeDependent = as.logical(timeDependent);
  ;ans = .Call('R_swig_new_FDDividendEuropeanEngine__SWIG_0', process, timeSteps, gridPoints, timeDependent, PACKAGE='QuantLib');
  class(ans) <- "_p_FDDividendEuropeanEnginePtr";
  
  reg.finalizer(ans, delete_FDDividendEuropeanEngine)
  ans
  
}

attr(`FDDividendEuropeanEngine__SWIG_0`, 'returnType') = '_p_FDDividendEuropeanEnginePtr'
attr(`FDDividendEuropeanEngine__SWIG_0`, "inputTypes") = c('_p_GeneralizedBlackScholesProcessPtr', 'integer', 'integer', 'logical')
class(`FDDividendEuropeanEngine__SWIG_0`) = c("SWIGFunction", class('FDDividendEuropeanEngine__SWIG_0'))

# Start of new_FDDividendEuropeanEngine

`FDDividendEuropeanEngine__SWIG_1` = function(process, timeSteps, gridPoints)
{
  if(length(timeSteps) > 1) {
    warning("using only the first element of timeSteps");
  };
  
  
  
  if(length(gridPoints) > 1) {
    warning("using only the first element of gridPoints");
  };
  
  ;ans = .Call('R_swig_new_FDDividendEuropeanEngine__SWIG_1', process, timeSteps, gridPoints, PACKAGE='QuantLib');
  class(ans) <- "_p_FDDividendEuropeanEnginePtr";
  
  reg.finalizer(ans, delete_FDDividendEuropeanEngine)
  ans
  
}

attr(`FDDividendEuropeanEngine__SWIG_1`, 'returnType') = '_p_FDDividendEuropeanEnginePtr'
attr(`FDDividendEuropeanEngine__SWIG_1`, "inputTypes") = c('_p_GeneralizedBlackScholesProcessPtr', 'integer', 'integer')
class(`FDDividendEuropeanEngine__SWIG_1`) = c("SWIGFunction", class('FDDividendEuropeanEngine__SWIG_1'))

# Start of new_FDDividendEuropeanEngine

`FDDividendEuropeanEngine__SWIG_2` = function(process, timeSteps)
{
  if(length(timeSteps) > 1) {
    warning("using only the first element of timeSteps");
  };
  
  ;ans = .Call('R_swig_new_FDDividendEuropeanEngine__SWIG_2', process, timeSteps, PACKAGE='QuantLib');
  class(ans) <- "_p_FDDividendEuropeanEnginePtr";
  
  reg.finalizer(ans, delete_FDDividendEuropeanEngine)
  ans
  
}

attr(`FDDividendEuropeanEngine__SWIG_2`, 'returnType') = '_p_FDDividendEuropeanEnginePtr'
attr(`FDDividendEuropeanEngine__SWIG_2`, "inputTypes") = c('_p_GeneralizedBlackScholesProcessPtr', 'integer')
class(`FDDividendEuropeanEngine__SWIG_2`) = c("SWIGFunction", class('FDDividendEuropeanEngine__SWIG_2'))

# Start of new_FDDividendEuropeanEngine

`FDDividendEuropeanEngine__SWIG_3` = function(process)
{
  ;ans = .Call('R_swig_new_FDDividendEuropeanEngine__SWIG_3', process, PACKAGE='QuantLib');
  class(ans) <- "_p_FDDividendEuropeanEnginePtr";
  
  reg.finalizer(ans, delete_FDDividendEuropeanEngine)
  ans
  
}

attr(`FDDividendEuropeanEngine__SWIG_3`, 'returnType') = '_p_FDDividendEuropeanEnginePtr'
attr(`FDDividendEuropeanEngine__SWIG_3`, "inputTypes") = c('_p_GeneralizedBlackScholesProcessPtr')
class(`FDDividendEuropeanEngine__SWIG_3`) = c("SWIGFunction", class('FDDividendEuropeanEngine__SWIG_3'))

`FDDividendEuropeanEngine` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 1) {
    if (extends(argtypes[1], '_p_GeneralizedBlackScholesProcessPtr')) {
      f <- FDDividendEuropeanEngine__SWIG_3; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_GeneralizedBlackScholesProcessPtr') && (is.integer(argv[[2]]) || is.numeric(argv[[2]]))) {
      f <- FDDividendEuropeanEngine__SWIG_2; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_GeneralizedBlackScholesProcessPtr') && (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && (is.integer(argv[[3]]) || is.numeric(argv[[3]]))) {
      f <- FDDividendEuropeanEngine__SWIG_1; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_GeneralizedBlackScholesProcessPtr') && (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && extends(argtypes[4], 'logical')) {
      f <- FDDividendEuropeanEngine__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for FDDividendEuropeanEngine with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_FDDividendEuropeanEngine

`delete_FDDividendEuropeanEngine` = function(self)
{
  ;.Call('R_swig_delete_FDDividendEuropeanEngine', self, PACKAGE='QuantLib');
  
}

attr(`delete_FDDividendEuropeanEngine`, 'returnType') = 'void'
attr(`delete_FDDividendEuropeanEngine`, "inputTypes") = c('_p_FDDividendEuropeanEnginePtr')
class(`delete_FDDividendEuropeanEngine`) = c("SWIGFunction", class('delete_FDDividendEuropeanEngine'))

setMethod('delete', '_p_FDDividendEuropeanEnginePtr', function(obj) {delete_FDDividendEuropeanEnginePtr(obj)})
# Start of new_FDDividendAmericanEngine

`FDDividendAmericanEngine__SWIG_0` = function(process, timeSteps, gridPoints, timeDependent)
{
  if(length(timeSteps) > 1) {
    warning("using only the first element of timeSteps");
  };
  
  
  
  if(length(gridPoints) > 1) {
    warning("using only the first element of gridPoints");
  };
  
  timeDependent = as.logical(timeDependent);
  ;ans = .Call('R_swig_new_FDDividendAmericanEngine__SWIG_0', process, timeSteps, gridPoints, timeDependent, PACKAGE='QuantLib');
  class(ans) <- "_p_FDDividendAmericanEnginePtr";
  
  reg.finalizer(ans, delete_FDDividendAmericanEngine)
  ans
  
}

attr(`FDDividendAmericanEngine__SWIG_0`, 'returnType') = '_p_FDDividendAmericanEnginePtr'
attr(`FDDividendAmericanEngine__SWIG_0`, "inputTypes") = c('_p_GeneralizedBlackScholesProcessPtr', 'integer', 'integer', 'logical')
class(`FDDividendAmericanEngine__SWIG_0`) = c("SWIGFunction", class('FDDividendAmericanEngine__SWIG_0'))

# Start of new_FDDividendAmericanEngine

`FDDividendAmericanEngine__SWIG_1` = function(process, timeSteps, gridPoints)
{
  if(length(timeSteps) > 1) {
    warning("using only the first element of timeSteps");
  };
  
  
  
  if(length(gridPoints) > 1) {
    warning("using only the first element of gridPoints");
  };
  
  ;ans = .Call('R_swig_new_FDDividendAmericanEngine__SWIG_1', process, timeSteps, gridPoints, PACKAGE='QuantLib');
  class(ans) <- "_p_FDDividendAmericanEnginePtr";
  
  reg.finalizer(ans, delete_FDDividendAmericanEngine)
  ans
  
}

attr(`FDDividendAmericanEngine__SWIG_1`, 'returnType') = '_p_FDDividendAmericanEnginePtr'
attr(`FDDividendAmericanEngine__SWIG_1`, "inputTypes") = c('_p_GeneralizedBlackScholesProcessPtr', 'integer', 'integer')
class(`FDDividendAmericanEngine__SWIG_1`) = c("SWIGFunction", class('FDDividendAmericanEngine__SWIG_1'))

# Start of new_FDDividendAmericanEngine

`FDDividendAmericanEngine__SWIG_2` = function(process, timeSteps)
{
  if(length(timeSteps) > 1) {
    warning("using only the first element of timeSteps");
  };
  
  ;ans = .Call('R_swig_new_FDDividendAmericanEngine__SWIG_2', process, timeSteps, PACKAGE='QuantLib');
  class(ans) <- "_p_FDDividendAmericanEnginePtr";
  
  reg.finalizer(ans, delete_FDDividendAmericanEngine)
  ans
  
}

attr(`FDDividendAmericanEngine__SWIG_2`, 'returnType') = '_p_FDDividendAmericanEnginePtr'
attr(`FDDividendAmericanEngine__SWIG_2`, "inputTypes") = c('_p_GeneralizedBlackScholesProcessPtr', 'integer')
class(`FDDividendAmericanEngine__SWIG_2`) = c("SWIGFunction", class('FDDividendAmericanEngine__SWIG_2'))

# Start of new_FDDividendAmericanEngine

`FDDividendAmericanEngine__SWIG_3` = function(process)
{
  ;ans = .Call('R_swig_new_FDDividendAmericanEngine__SWIG_3', process, PACKAGE='QuantLib');
  class(ans) <- "_p_FDDividendAmericanEnginePtr";
  
  reg.finalizer(ans, delete_FDDividendAmericanEngine)
  ans
  
}

attr(`FDDividendAmericanEngine__SWIG_3`, 'returnType') = '_p_FDDividendAmericanEnginePtr'
attr(`FDDividendAmericanEngine__SWIG_3`, "inputTypes") = c('_p_GeneralizedBlackScholesProcessPtr')
class(`FDDividendAmericanEngine__SWIG_3`) = c("SWIGFunction", class('FDDividendAmericanEngine__SWIG_3'))

`FDDividendAmericanEngine` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 1) {
    if (extends(argtypes[1], '_p_GeneralizedBlackScholesProcessPtr')) {
      f <- FDDividendAmericanEngine__SWIG_3; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_GeneralizedBlackScholesProcessPtr') && (is.integer(argv[[2]]) || is.numeric(argv[[2]]))) {
      f <- FDDividendAmericanEngine__SWIG_2; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_GeneralizedBlackScholesProcessPtr') && (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && (is.integer(argv[[3]]) || is.numeric(argv[[3]]))) {
      f <- FDDividendAmericanEngine__SWIG_1; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_GeneralizedBlackScholesProcessPtr') && (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && extends(argtypes[4], 'logical')) {
      f <- FDDividendAmericanEngine__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for FDDividendAmericanEngine with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_FDDividendAmericanEngine

`delete_FDDividendAmericanEngine` = function(self)
{
  ;.Call('R_swig_delete_FDDividendAmericanEngine', self, PACKAGE='QuantLib');
  
}

attr(`delete_FDDividendAmericanEngine`, 'returnType') = 'void'
attr(`delete_FDDividendAmericanEngine`, "inputTypes") = c('_p_FDDividendAmericanEnginePtr')
class(`delete_FDDividendAmericanEngine`) = c("SWIGFunction", class('delete_FDDividendAmericanEngine'))

setMethod('delete', '_p_FDDividendAmericanEnginePtr', function(obj) {delete_FDDividendAmericanEnginePtr(obj)})
# Start of new_BarrierOption

`BarrierOption` = function(barrierType, barrier, rebate, payoff, exercise)
{
  barrierType = enumToInteger(barrierType, "_Barrier__Type"); 
  
  if(length(barrierType) > 1) {
    warning("using only the first element of barrierType");
  };
  
  
  
  
  
  ;ans = .Call('R_swig_new_BarrierOption', barrierType, barrier, rebate, payoff, exercise, PACKAGE='QuantLib');
  class(ans) <- "_p_BarrierOptionPtr";
  
  reg.finalizer(ans, delete_BarrierOption)
  ans
  
}

attr(`BarrierOption`, 'returnType') = '_p_BarrierOptionPtr'
attr(`BarrierOption`, "inputTypes") = c('character', 'numeric', 'numeric', '_p_boost__shared_ptrT_Payoff_t', '_p_boost__shared_ptrT_Exercise_t')
class(`BarrierOption`) = c("SWIGFunction", class('BarrierOption'))

# Start of BarrierOption_priceCurve

`BarrierOption_priceCurve` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_BarrierOption_priceCurve', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_SampledCurve";
  
  ans
  
}

attr(`BarrierOption_priceCurve`, 'returnType') = '_p_SampledCurve'
attr(`BarrierOption_priceCurve`, "inputTypes") = c('_p_BarrierOptionPtr')
class(`BarrierOption_priceCurve`) = c("SWIGFunction", class('BarrierOption_priceCurve'))

# Start of BarrierOption_impliedVolatility

`BarrierOption_impliedVolatility__SWIG_0` = function(self, targetValue, process, accuracy, maxEvaluations, minVol, maxVol, .copy = FALSE)
{
  if(length(maxEvaluations) > 1) {
    warning("using only the first element of maxEvaluations");
  };
  
  
  
  ;.Call('R_swig_BarrierOption_impliedVolatility__SWIG_0', self, targetValue, process, accuracy, maxEvaluations, minVol, maxVol, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BarrierOption_impliedVolatility__SWIG_0`, 'returnType') = 'numeric'
attr(`BarrierOption_impliedVolatility__SWIG_0`, "inputTypes") = c('_p_BarrierOptionPtr', 'numeric', '_p_GeneralizedBlackScholesProcessPtr', 'numeric', 'integer', 'numeric', 'numeric')
class(`BarrierOption_impliedVolatility__SWIG_0`) = c("SWIGFunction", class('BarrierOption_impliedVolatility__SWIG_0'))

# Start of BarrierOption_impliedVolatility

`BarrierOption_impliedVolatility__SWIG_1` = function(self, targetValue, process, accuracy, maxEvaluations, minVol, .copy = FALSE)
{
  if(length(maxEvaluations) > 1) {
    warning("using only the first element of maxEvaluations");
  };
  
  
  ;.Call('R_swig_BarrierOption_impliedVolatility__SWIG_1', self, targetValue, process, accuracy, maxEvaluations, minVol, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BarrierOption_impliedVolatility__SWIG_1`, 'returnType') = 'numeric'
attr(`BarrierOption_impliedVolatility__SWIG_1`, "inputTypes") = c('_p_BarrierOptionPtr', 'numeric', '_p_GeneralizedBlackScholesProcessPtr', 'numeric', 'integer', 'numeric')
class(`BarrierOption_impliedVolatility__SWIG_1`) = c("SWIGFunction", class('BarrierOption_impliedVolatility__SWIG_1'))

# Start of BarrierOption_impliedVolatility

`BarrierOption_impliedVolatility__SWIG_2` = function(self, targetValue, process, accuracy, maxEvaluations, .copy = FALSE)
{
  if(length(maxEvaluations) > 1) {
    warning("using only the first element of maxEvaluations");
  };
  
  ;.Call('R_swig_BarrierOption_impliedVolatility__SWIG_2', self, targetValue, process, accuracy, maxEvaluations, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BarrierOption_impliedVolatility__SWIG_2`, 'returnType') = 'numeric'
attr(`BarrierOption_impliedVolatility__SWIG_2`, "inputTypes") = c('_p_BarrierOptionPtr', 'numeric', '_p_GeneralizedBlackScholesProcessPtr', 'numeric', 'integer')
class(`BarrierOption_impliedVolatility__SWIG_2`) = c("SWIGFunction", class('BarrierOption_impliedVolatility__SWIG_2'))

# Start of BarrierOption_impliedVolatility

`BarrierOption_impliedVolatility__SWIG_3` = function(self, targetValue, process, accuracy, .copy = FALSE)
{
  ;.Call('R_swig_BarrierOption_impliedVolatility__SWIG_3', self, targetValue, process, accuracy, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BarrierOption_impliedVolatility__SWIG_3`, 'returnType') = 'numeric'
attr(`BarrierOption_impliedVolatility__SWIG_3`, "inputTypes") = c('_p_BarrierOptionPtr', 'numeric', '_p_GeneralizedBlackScholesProcessPtr', 'numeric')
class(`BarrierOption_impliedVolatility__SWIG_3`) = c("SWIGFunction", class('BarrierOption_impliedVolatility__SWIG_3'))

# Start of BarrierOption_impliedVolatility

`BarrierOption_impliedVolatility__SWIG_4` = function(self, targetValue, process, .copy = FALSE)
{
  ;.Call('R_swig_BarrierOption_impliedVolatility__SWIG_4', self, targetValue, process, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BarrierOption_impliedVolatility__SWIG_4`, 'returnType') = 'numeric'
attr(`BarrierOption_impliedVolatility__SWIG_4`, "inputTypes") = c('_p_BarrierOptionPtr', 'numeric', '_p_GeneralizedBlackScholesProcessPtr')
class(`BarrierOption_impliedVolatility__SWIG_4`) = c("SWIGFunction", class('BarrierOption_impliedVolatility__SWIG_4'))

`BarrierOption_impliedVolatility` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 5
  if (argc == 3) {
    if (extends(argtypes[1], '_p_BarrierOptionPtr') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_GeneralizedBlackScholesProcessPtr')) {
      f <- BarrierOption_impliedVolatility__SWIG_4; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_BarrierOptionPtr') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_GeneralizedBlackScholesProcessPtr') && is.numeric(argv[[4]])) {
      f <- BarrierOption_impliedVolatility__SWIG_3; 
    }
  } else if (argc == 5) {
    if (extends(argtypes[1], '_p_BarrierOptionPtr') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_GeneralizedBlackScholesProcessPtr') && is.numeric(argv[[4]]) && (is.integer(argv[[5]]) || is.numeric(argv[[5]]))) {
      f <- BarrierOption_impliedVolatility__SWIG_2; 
    }
  } else if (argc == 6) {
    if (extends(argtypes[1], '_p_BarrierOptionPtr') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_GeneralizedBlackScholesProcessPtr') && is.numeric(argv[[4]]) && (is.integer(argv[[5]]) || is.numeric(argv[[5]])) && is.numeric(argv[[6]])) {
      f <- BarrierOption_impliedVolatility__SWIG_1; 
    }
  } else if (argc == 7) {
    if (extends(argtypes[1], '_p_BarrierOptionPtr') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_GeneralizedBlackScholesProcessPtr') && is.numeric(argv[[4]]) && (is.integer(argv[[5]]) || is.numeric(argv[[5]])) && is.numeric(argv[[6]]) && is.numeric(argv[[7]])) {
      f <- BarrierOption_impliedVolatility__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for BarrierOption_impliedVolatility with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of BarrierOption_delta

`BarrierOption_delta` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_BarrierOption_delta', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BarrierOption_delta`, 'returnType') = 'numeric'
attr(`BarrierOption_delta`, "inputTypes") = c('_p_BarrierOptionPtr')
class(`BarrierOption_delta`) = c("SWIGFunction", class('BarrierOption_delta'))

# Start of BarrierOption_gamma

`BarrierOption_gamma` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_BarrierOption_gamma', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BarrierOption_gamma`, 'returnType') = 'numeric'
attr(`BarrierOption_gamma`, "inputTypes") = c('_p_BarrierOptionPtr')
class(`BarrierOption_gamma`) = c("SWIGFunction", class('BarrierOption_gamma'))

# Start of BarrierOption_theta

`BarrierOption_theta` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_BarrierOption_theta', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BarrierOption_theta`, 'returnType') = 'numeric'
attr(`BarrierOption_theta`, "inputTypes") = c('_p_BarrierOptionPtr')
class(`BarrierOption_theta`) = c("SWIGFunction", class('BarrierOption_theta'))

# Start of BarrierOption_thetaPerDay

`BarrierOption_thetaPerDay` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_BarrierOption_thetaPerDay', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BarrierOption_thetaPerDay`, 'returnType') = 'numeric'
attr(`BarrierOption_thetaPerDay`, "inputTypes") = c('_p_BarrierOptionPtr')
class(`BarrierOption_thetaPerDay`) = c("SWIGFunction", class('BarrierOption_thetaPerDay'))

# Start of BarrierOption_vega

`BarrierOption_vega` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_BarrierOption_vega', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BarrierOption_vega`, 'returnType') = 'numeric'
attr(`BarrierOption_vega`, "inputTypes") = c('_p_BarrierOptionPtr')
class(`BarrierOption_vega`) = c("SWIGFunction", class('BarrierOption_vega'))

# Start of BarrierOption_rho

`BarrierOption_rho` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_BarrierOption_rho', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BarrierOption_rho`, 'returnType') = 'numeric'
attr(`BarrierOption_rho`, "inputTypes") = c('_p_BarrierOptionPtr')
class(`BarrierOption_rho`) = c("SWIGFunction", class('BarrierOption_rho'))

# Start of BarrierOption_dividendRho

`BarrierOption_dividendRho` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_BarrierOption_dividendRho', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BarrierOption_dividendRho`, 'returnType') = 'numeric'
attr(`BarrierOption_dividendRho`, "inputTypes") = c('_p_BarrierOptionPtr')
class(`BarrierOption_dividendRho`) = c("SWIGFunction", class('BarrierOption_dividendRho'))

# Start of BarrierOption_strikeSensitivity

`BarrierOption_strikeSensitivity` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_BarrierOption_strikeSensitivity', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BarrierOption_strikeSensitivity`, 'returnType') = 'numeric'
attr(`BarrierOption_strikeSensitivity`, "inputTypes") = c('_p_BarrierOptionPtr')
class(`BarrierOption_strikeSensitivity`) = c("SWIGFunction", class('BarrierOption_strikeSensitivity'))

# Start of delete_BarrierOption

`delete_BarrierOption` = function(self)
{
  ;.Call('R_swig_delete_BarrierOption', self, PACKAGE='QuantLib');
  
}

attr(`delete_BarrierOption`, 'returnType') = 'void'
attr(`delete_BarrierOption`, "inputTypes") = c('_p_BarrierOptionPtr')
class(`delete_BarrierOption`) = c("SWIGFunction", class('delete_BarrierOption'))

# Start of accessor method for BarrierOptionPtr
setMethod('$', '_p_BarrierOptionPtr', function(x, name)

{
  accessorFuns = list('priceCurve' = BarrierOption_priceCurve, 'impliedVolatility' = BarrierOption_impliedVolatility, 'delta' = BarrierOption_delta, 'gamma' = BarrierOption_gamma, 'theta' = BarrierOption_theta, 'thetaPerDay' = BarrierOption_thetaPerDay, 'vega' = BarrierOption_vega, 'rho' = BarrierOption_rho, 'dividendRho' = BarrierOption_dividendRho, 'strikeSensitivity' = BarrierOption_strikeSensitivity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for BarrierOptionPtr
setMethod('delete', '_p_BarrierOptionPtr', function(obj) {delete_BarrierOptionPtr(obj)})
# Start of new_AnalyticBarrierEngine

`AnalyticBarrierEngine` = function(process)
{
  ;ans = .Call('R_swig_new_AnalyticBarrierEngine', process, PACKAGE='QuantLib');
  class(ans) <- "_p_AnalyticBarrierEnginePtr";
  
  reg.finalizer(ans, delete_AnalyticBarrierEngine)
  ans
  
}

attr(`AnalyticBarrierEngine`, 'returnType') = '_p_AnalyticBarrierEnginePtr'
attr(`AnalyticBarrierEngine`, "inputTypes") = c('_p_GeneralizedBlackScholesProcessPtr')
class(`AnalyticBarrierEngine`) = c("SWIGFunction", class('AnalyticBarrierEngine'))

# Start of delete_AnalyticBarrierEngine

`delete_AnalyticBarrierEngine` = function(self)
{
  ;.Call('R_swig_delete_AnalyticBarrierEngine', self, PACKAGE='QuantLib');
  
}

attr(`delete_AnalyticBarrierEngine`, 'returnType') = 'void'
attr(`delete_AnalyticBarrierEngine`, "inputTypes") = c('_p_AnalyticBarrierEnginePtr')
class(`delete_AnalyticBarrierEngine`) = c("SWIGFunction", class('delete_AnalyticBarrierEngine'))

setMethod('delete', '_p_AnalyticBarrierEnginePtr', function(obj) {delete_AnalyticBarrierEnginePtr(obj)})
# Start of new_MCBarrierEngine

`MCBarrierEngine` = function(process, traits, timeSteps, timeStepsPerYear, brownianBridge, antitheticVariate, requiredSamples, requiredTolerance, maxSamples, isBiased, seed)
{
  traits = as(traits, "character"); 
  
  
  if(length(timeSteps) > 1) {
    warning("using only the first element of timeSteps");
  };
  
  
  
  if(length(timeStepsPerYear) > 1) {
    warning("using only the first element of timeStepsPerYear");
  };
  
  brownianBridge = as.logical(brownianBridge);
  antitheticVariate = as.logical(antitheticVariate);
  as(input, "integer"); 
  as(input, "numeric"); 
  as(input, "integer"); 
  isBiased = as.logical(isBiased);
  seed = as.integer(seed); 
  
  if(length(seed) > 1) {
    warning("using only the first element of seed");
  };
  
  ;ans = .Call('R_swig_new_MCBarrierEngine', process, traits, timeSteps, timeStepsPerYear, brownianBridge, antitheticVariate, requiredSamples, requiredTolerance, maxSamples, isBiased, seed, PACKAGE='QuantLib');
  class(ans) <- "_p_MCBarrierEnginePtr";
  
  reg.finalizer(ans, delete_MCBarrierEngine)
  ans
  
}

attr(`MCBarrierEngine`, 'returnType') = '_p_MCBarrierEnginePtr'
attr(`MCBarrierEngine`, "inputTypes") = c('_p_GeneralizedBlackScholesProcessPtr', 'character', 'integer', 'integer', 'logical', 'logical', 'numeric', 'numeric', 'numeric', 'logical', 'integer')
class(`MCBarrierEngine`) = c("SWIGFunction", class('MCBarrierEngine'))

# Start of delete_MCBarrierEngine

`delete_MCBarrierEngine` = function(self)
{
  ;.Call('R_swig_delete_MCBarrierEngine', self, PACKAGE='QuantLib');
  
}

attr(`delete_MCBarrierEngine`, 'returnType') = 'void'
attr(`delete_MCBarrierEngine`, "inputTypes") = c('_p_MCBarrierEnginePtr')
class(`delete_MCBarrierEngine`) = c("SWIGFunction", class('delete_MCBarrierEngine'))

setMethod('delete', '_p_MCBarrierEnginePtr', function(obj) {delete_MCBarrierEnginePtr(obj)})
# Start of new_ForwardEuropeanEngine

`ForwardEuropeanEngine` = function(process)
{
  ;ans = .Call('R_swig_new_ForwardEuropeanEngine', process, PACKAGE='QuantLib');
  class(ans) <- "_p_ForwardEuropeanEnginePtr";
  
  reg.finalizer(ans, delete_ForwardEuropeanEngine)
  ans
  
}

attr(`ForwardEuropeanEngine`, 'returnType') = '_p_ForwardEuropeanEnginePtr'
attr(`ForwardEuropeanEngine`, "inputTypes") = c('_p_GeneralizedBlackScholesProcessPtr')
class(`ForwardEuropeanEngine`) = c("SWIGFunction", class('ForwardEuropeanEngine'))

# Start of delete_ForwardEuropeanEngine

`delete_ForwardEuropeanEngine` = function(self)
{
  ;.Call('R_swig_delete_ForwardEuropeanEngine', self, PACKAGE='QuantLib');
  
}

attr(`delete_ForwardEuropeanEngine`, 'returnType') = 'void'
attr(`delete_ForwardEuropeanEngine`, "inputTypes") = c('_p_ForwardEuropeanEnginePtr')
class(`delete_ForwardEuropeanEngine`) = c("SWIGFunction", class('delete_ForwardEuropeanEngine'))

setMethod('delete', '_p_ForwardEuropeanEnginePtr', function(obj) {delete_ForwardEuropeanEnginePtr(obj)})
# Start of new_QuantoEuropeanEngine

`QuantoEuropeanEngine` = function(process, foreignRiskFreeRate, exchangeRateVolatility, correlation)
{
  ;ans = .Call('R_swig_new_QuantoEuropeanEngine', process, foreignRiskFreeRate, exchangeRateVolatility, correlation, PACKAGE='QuantLib');
  class(ans) <- "_p_QuantoEuropeanEnginePtr";
  
  reg.finalizer(ans, delete_QuantoEuropeanEngine)
  ans
  
}

attr(`QuantoEuropeanEngine`, 'returnType') = '_p_QuantoEuropeanEnginePtr'
attr(`QuantoEuropeanEngine`, "inputTypes") = c('_p_GeneralizedBlackScholesProcessPtr', '_p_HandleT_YieldTermStructure_t', '_p_HandleT_BlackVolTermStructure_t', '_p_HandleT_Quote_t')
class(`QuantoEuropeanEngine`) = c("SWIGFunction", class('QuantoEuropeanEngine'))

# Start of delete_QuantoEuropeanEngine

`delete_QuantoEuropeanEngine` = function(self)
{
  ;.Call('R_swig_delete_QuantoEuropeanEngine', self, PACKAGE='QuantLib');
  
}

attr(`delete_QuantoEuropeanEngine`, 'returnType') = 'void'
attr(`delete_QuantoEuropeanEngine`, "inputTypes") = c('_p_QuantoEuropeanEnginePtr')
class(`delete_QuantoEuropeanEngine`) = c("SWIGFunction", class('delete_QuantoEuropeanEngine'))

setMethod('delete', '_p_QuantoEuropeanEnginePtr', function(obj) {delete_QuantoEuropeanEnginePtr(obj)})
# Start of new_QuantoForwardEuropeanEngine

`QuantoForwardEuropeanEngine` = function(process, foreignRiskFreeRate, exchangeRateVolatility, correlation)
{
  ;ans = .Call('R_swig_new_QuantoForwardEuropeanEngine', process, foreignRiskFreeRate, exchangeRateVolatility, correlation, PACKAGE='QuantLib');
  class(ans) <- "_p_QuantoForwardEuropeanEnginePtr";
  
  reg.finalizer(ans, delete_QuantoForwardEuropeanEngine)
  ans
  
}

attr(`QuantoForwardEuropeanEngine`, 'returnType') = '_p_QuantoForwardEuropeanEnginePtr'
attr(`QuantoForwardEuropeanEngine`, "inputTypes") = c('_p_GeneralizedBlackScholesProcessPtr', '_p_HandleT_YieldTermStructure_t', '_p_HandleT_BlackVolTermStructure_t', '_p_HandleT_Quote_t')
class(`QuantoForwardEuropeanEngine`) = c("SWIGFunction", class('QuantoForwardEuropeanEngine'))

# Start of delete_QuantoForwardEuropeanEngine

`delete_QuantoForwardEuropeanEngine` = function(self)
{
  ;.Call('R_swig_delete_QuantoForwardEuropeanEngine', self, PACKAGE='QuantLib');
  
}

attr(`delete_QuantoForwardEuropeanEngine`, 'returnType') = 'void'
attr(`delete_QuantoForwardEuropeanEngine`, "inputTypes") = c('_p_QuantoForwardEuropeanEnginePtr')
class(`delete_QuantoForwardEuropeanEngine`) = c("SWIGFunction", class('delete_QuantoForwardEuropeanEngine'))

setMethod('delete', '_p_QuantoForwardEuropeanEnginePtr', function(obj) {delete_QuantoForwardEuropeanEnginePtr(obj)})
# Start of new_BlackCalculator

`BlackCalculator__SWIG_0` = function(payoff, forward, stdDev, discount)
{
  ;ans = .Call('R_swig_new_BlackCalculator__SWIG_0', payoff, forward, stdDev, discount, PACKAGE='QuantLib');
  class(ans) <- "_p_BlackCalculator";
  
  reg.finalizer(ans, delete_BlackCalculator)
  ans
  
}

attr(`BlackCalculator__SWIG_0`, 'returnType') = '_p_BlackCalculator'
attr(`BlackCalculator__SWIG_0`, "inputTypes") = c('_p_boost__shared_ptrT_Payoff_t', 'numeric', 'numeric', 'numeric')
class(`BlackCalculator__SWIG_0`) = c("SWIGFunction", class('BlackCalculator__SWIG_0'))

# Start of new_BlackCalculator

`BlackCalculator__SWIG_1` = function(payoff, forward, stdDev)
{
  ;ans = .Call('R_swig_new_BlackCalculator__SWIG_1', payoff, forward, stdDev, PACKAGE='QuantLib');
  class(ans) <- "_p_BlackCalculator";
  
  reg.finalizer(ans, delete_BlackCalculator)
  ans
  
}

attr(`BlackCalculator__SWIG_1`, 'returnType') = '_p_BlackCalculator'
attr(`BlackCalculator__SWIG_1`, "inputTypes") = c('_p_boost__shared_ptrT_Payoff_t', 'numeric', 'numeric')
class(`BlackCalculator__SWIG_1`) = c("SWIGFunction", class('BlackCalculator__SWIG_1'))

`BlackCalculator` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 3) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_Payoff_t') && is.numeric(argv[[2]]) && is.numeric(argv[[3]])) {
      f <- BlackCalculator__SWIG_1; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_Payoff_t') && is.numeric(argv[[2]]) && is.numeric(argv[[3]]) && is.numeric(argv[[4]])) {
      f <- BlackCalculator__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for BlackCalculator with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of BlackCalculator_value

`BlackCalculator_value` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_BlackCalculator_value', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackCalculator_value`, 'returnType') = 'numeric'
attr(`BlackCalculator_value`, "inputTypes") = c('_p_BlackCalculator')
class(`BlackCalculator_value`) = c("SWIGFunction", class('BlackCalculator_value'))

# Start of BlackCalculator_deltaForward

`BlackCalculator_deltaForward` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_BlackCalculator_deltaForward', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackCalculator_deltaForward`, 'returnType') = 'numeric'
attr(`BlackCalculator_deltaForward`, "inputTypes") = c('_p_BlackCalculator')
class(`BlackCalculator_deltaForward`) = c("SWIGFunction", class('BlackCalculator_deltaForward'))

# Start of BlackCalculator_delta

`BlackCalculator_delta` = function(self, spot, .copy = FALSE)
{
  ;.Call('R_swig_BlackCalculator_delta', self, spot, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackCalculator_delta`, 'returnType') = 'numeric'
attr(`BlackCalculator_delta`, "inputTypes") = c('_p_BlackCalculator', 'numeric')
class(`BlackCalculator_delta`) = c("SWIGFunction", class('BlackCalculator_delta'))

# Start of BlackCalculator_elasticityForward

`BlackCalculator_elasticityForward` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_BlackCalculator_elasticityForward', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackCalculator_elasticityForward`, 'returnType') = 'numeric'
attr(`BlackCalculator_elasticityForward`, "inputTypes") = c('_p_BlackCalculator')
class(`BlackCalculator_elasticityForward`) = c("SWIGFunction", class('BlackCalculator_elasticityForward'))

# Start of BlackCalculator_elasticity

`BlackCalculator_elasticity` = function(self, spot, .copy = FALSE)
{
  ;.Call('R_swig_BlackCalculator_elasticity', self, spot, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackCalculator_elasticity`, 'returnType') = 'numeric'
attr(`BlackCalculator_elasticity`, "inputTypes") = c('_p_BlackCalculator', 'numeric')
class(`BlackCalculator_elasticity`) = c("SWIGFunction", class('BlackCalculator_elasticity'))

# Start of BlackCalculator_gammaForward

`BlackCalculator_gammaForward` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_BlackCalculator_gammaForward', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackCalculator_gammaForward`, 'returnType') = 'numeric'
attr(`BlackCalculator_gammaForward`, "inputTypes") = c('_p_BlackCalculator')
class(`BlackCalculator_gammaForward`) = c("SWIGFunction", class('BlackCalculator_gammaForward'))

# Start of BlackCalculator_gamma

`BlackCalculator_gamma` = function(self, spot, .copy = FALSE)
{
  ;.Call('R_swig_BlackCalculator_gamma', self, spot, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackCalculator_gamma`, 'returnType') = 'numeric'
attr(`BlackCalculator_gamma`, "inputTypes") = c('_p_BlackCalculator', 'numeric')
class(`BlackCalculator_gamma`) = c("SWIGFunction", class('BlackCalculator_gamma'))

# Start of BlackCalculator_theta

`BlackCalculator_theta` = function(self, spot, maturity, .copy = FALSE)
{
  ;.Call('R_swig_BlackCalculator_theta', self, spot, maturity, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackCalculator_theta`, 'returnType') = 'numeric'
attr(`BlackCalculator_theta`, "inputTypes") = c('_p_BlackCalculator', 'numeric', 'numeric')
class(`BlackCalculator_theta`) = c("SWIGFunction", class('BlackCalculator_theta'))

# Start of BlackCalculator_thetaPerDay

`BlackCalculator_thetaPerDay` = function(self, spot, maturity, .copy = FALSE)
{
  ;.Call('R_swig_BlackCalculator_thetaPerDay', self, spot, maturity, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackCalculator_thetaPerDay`, 'returnType') = 'numeric'
attr(`BlackCalculator_thetaPerDay`, "inputTypes") = c('_p_BlackCalculator', 'numeric', 'numeric')
class(`BlackCalculator_thetaPerDay`) = c("SWIGFunction", class('BlackCalculator_thetaPerDay'))

# Start of BlackCalculator_vega

`BlackCalculator_vega` = function(self, maturity, .copy = FALSE)
{
  ;.Call('R_swig_BlackCalculator_vega', self, maturity, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackCalculator_vega`, 'returnType') = 'numeric'
attr(`BlackCalculator_vega`, "inputTypes") = c('_p_BlackCalculator', 'numeric')
class(`BlackCalculator_vega`) = c("SWIGFunction", class('BlackCalculator_vega'))

# Start of BlackCalculator_rho

`BlackCalculator_rho` = function(self, maturity, .copy = FALSE)
{
  ;.Call('R_swig_BlackCalculator_rho', self, maturity, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackCalculator_rho`, 'returnType') = 'numeric'
attr(`BlackCalculator_rho`, "inputTypes") = c('_p_BlackCalculator', 'numeric')
class(`BlackCalculator_rho`) = c("SWIGFunction", class('BlackCalculator_rho'))

# Start of BlackCalculator_dividendRho

`BlackCalculator_dividendRho` = function(self, maturity, .copy = FALSE)
{
  ;.Call('R_swig_BlackCalculator_dividendRho', self, maturity, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackCalculator_dividendRho`, 'returnType') = 'numeric'
attr(`BlackCalculator_dividendRho`, "inputTypes") = c('_p_BlackCalculator', 'numeric')
class(`BlackCalculator_dividendRho`) = c("SWIGFunction", class('BlackCalculator_dividendRho'))

# Start of BlackCalculator_itmCashProbability

`BlackCalculator_itmCashProbability` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_BlackCalculator_itmCashProbability', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackCalculator_itmCashProbability`, 'returnType') = 'numeric'
attr(`BlackCalculator_itmCashProbability`, "inputTypes") = c('_p_BlackCalculator')
class(`BlackCalculator_itmCashProbability`) = c("SWIGFunction", class('BlackCalculator_itmCashProbability'))

# Start of BlackCalculator_itmAssetProbability

`BlackCalculator_itmAssetProbability` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_BlackCalculator_itmAssetProbability', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackCalculator_itmAssetProbability`, 'returnType') = 'numeric'
attr(`BlackCalculator_itmAssetProbability`, "inputTypes") = c('_p_BlackCalculator')
class(`BlackCalculator_itmAssetProbability`) = c("SWIGFunction", class('BlackCalculator_itmAssetProbability'))

# Start of BlackCalculator_strikeSensitivity

`BlackCalculator_strikeSensitivity` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_BlackCalculator_strikeSensitivity', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackCalculator_strikeSensitivity`, 'returnType') = 'numeric'
attr(`BlackCalculator_strikeSensitivity`, "inputTypes") = c('_p_BlackCalculator')
class(`BlackCalculator_strikeSensitivity`) = c("SWIGFunction", class('BlackCalculator_strikeSensitivity'))

# Start of BlackCalculator_alpha

`BlackCalculator_alpha` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_BlackCalculator_alpha', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackCalculator_alpha`, 'returnType') = 'numeric'
attr(`BlackCalculator_alpha`, "inputTypes") = c('_p_BlackCalculator')
class(`BlackCalculator_alpha`) = c("SWIGFunction", class('BlackCalculator_alpha'))

# Start of BlackCalculator_beta

`BlackCalculator_beta` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_BlackCalculator_beta', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BlackCalculator_beta`, 'returnType') = 'numeric'
attr(`BlackCalculator_beta`, "inputTypes") = c('_p_BlackCalculator')
class(`BlackCalculator_beta`) = c("SWIGFunction", class('BlackCalculator_beta'))

# Start of delete_BlackCalculator

`delete_BlackCalculator` = function(self)
{
  ;.Call('R_swig_delete_BlackCalculator', self, PACKAGE='QuantLib');
  
}

attr(`delete_BlackCalculator`, 'returnType') = 'void'
attr(`delete_BlackCalculator`, "inputTypes") = c('_p_BlackCalculator')
class(`delete_BlackCalculator`) = c("SWIGFunction", class('delete_BlackCalculator'))

# Start of accessor method for BlackCalculator
setMethod('$', '_p_BlackCalculator', function(x, name)

{
  accessorFuns = list('value' = BlackCalculator_value, 'deltaForward' = BlackCalculator_deltaForward, 'delta' = BlackCalculator_delta, 'elasticityForward' = BlackCalculator_elasticityForward, 'elasticity' = BlackCalculator_elasticity, 'gammaForward' = BlackCalculator_gammaForward, 'gamma' = BlackCalculator_gamma, 'theta' = BlackCalculator_theta, 'thetaPerDay' = BlackCalculator_thetaPerDay, 'vega' = BlackCalculator_vega, 'rho' = BlackCalculator_rho, 'dividendRho' = BlackCalculator_dividendRho, 'itmCashProbability' = BlackCalculator_itmCashProbability, 'itmAssetProbability' = BlackCalculator_itmAssetProbability, 'strikeSensitivity' = BlackCalculator_strikeSensitivity, 'alpha' = BlackCalculator_alpha, 'beta' = BlackCalculator_beta);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for BlackCalculator
setMethod('delete', '_p_BlackCalculator', function(obj) {delete_BlackCalculator(obj)})
defineEnumeration('_Average__Type',
                    .values = c(
                        'Arithmetic' = 0, 
                        'Geometric' = 1
))
# Start of new_Average

`Average` = function()
{
  ;ans = .Call('R_swig_new_Average', PACKAGE='QuantLib');
  class(ans) <- "_p_Average";
  
  reg.finalizer(ans, delete_Average)
  ans
  
}

attr(`Average`, 'returnType') = '_p_Average'
class(`Average`) = c("SWIGFunction", class('Average'))

# Start of delete_Average

`delete_Average` = function(self)
{
  ;.Call('R_swig_delete_Average', self, PACKAGE='QuantLib');
  
}

attr(`delete_Average`, 'returnType') = 'void'
attr(`delete_Average`, "inputTypes") = c('_p_Average')
class(`delete_Average`) = c("SWIGFunction", class('delete_Average'))

setMethod('delete', '_p_Average', function(obj) {delete_Average(obj)})
# Start definition of copy functions & methods for Average
CopyToR_Average = function(value, obj = new("Average"))
{
  obj;
}



CopyToC_Average = function(value, obj)
{
  obj
}



# Start definition of copy methods for Average
setMethod('copyToR', '_p_Average', CopyToR_Average);
setMethod('copyToC', 'Average', CopyToC_Average);

# End definition of copy methods for Average
# End definition of copy functions & methods for Average
# Start of new_ContinuousAveragingAsianOption

`ContinuousAveragingAsianOption` = function(averageType, payoff, exercise)
{
  averageType = enumToInteger(averageType, "_Average__Type"); 
  
  if(length(averageType) > 1) {
    warning("using only the first element of averageType");
  };
  
  
  
  ;ans = .Call('R_swig_new_ContinuousAveragingAsianOption', averageType, payoff, exercise, PACKAGE='QuantLib');
  class(ans) <- "_p_ContinuousAveragingAsianOptionPtr";
  
  reg.finalizer(ans, delete_ContinuousAveragingAsianOption)
  ans
  
}

attr(`ContinuousAveragingAsianOption`, 'returnType') = '_p_ContinuousAveragingAsianOptionPtr'
attr(`ContinuousAveragingAsianOption`, "inputTypes") = c('character', '_p_boost__shared_ptrT_Payoff_t', '_p_boost__shared_ptrT_Exercise_t')
class(`ContinuousAveragingAsianOption`) = c("SWIGFunction", class('ContinuousAveragingAsianOption'))

# Start of ContinuousAveragingAsianOption_delta

`ContinuousAveragingAsianOption_delta` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_ContinuousAveragingAsianOption_delta', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`ContinuousAveragingAsianOption_delta`, 'returnType') = 'numeric'
attr(`ContinuousAveragingAsianOption_delta`, "inputTypes") = c('_p_ContinuousAveragingAsianOptionPtr')
class(`ContinuousAveragingAsianOption_delta`) = c("SWIGFunction", class('ContinuousAveragingAsianOption_delta'))

# Start of ContinuousAveragingAsianOption_gamma

`ContinuousAveragingAsianOption_gamma` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_ContinuousAveragingAsianOption_gamma', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`ContinuousAveragingAsianOption_gamma`, 'returnType') = 'numeric'
attr(`ContinuousAveragingAsianOption_gamma`, "inputTypes") = c('_p_ContinuousAveragingAsianOptionPtr')
class(`ContinuousAveragingAsianOption_gamma`) = c("SWIGFunction", class('ContinuousAveragingAsianOption_gamma'))

# Start of ContinuousAveragingAsianOption_theta

`ContinuousAveragingAsianOption_theta` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_ContinuousAveragingAsianOption_theta', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`ContinuousAveragingAsianOption_theta`, 'returnType') = 'numeric'
attr(`ContinuousAveragingAsianOption_theta`, "inputTypes") = c('_p_ContinuousAveragingAsianOptionPtr')
class(`ContinuousAveragingAsianOption_theta`) = c("SWIGFunction", class('ContinuousAveragingAsianOption_theta'))

# Start of ContinuousAveragingAsianOption_thetaPerDay

`ContinuousAveragingAsianOption_thetaPerDay` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_ContinuousAveragingAsianOption_thetaPerDay', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`ContinuousAveragingAsianOption_thetaPerDay`, 'returnType') = 'numeric'
attr(`ContinuousAveragingAsianOption_thetaPerDay`, "inputTypes") = c('_p_ContinuousAveragingAsianOptionPtr')
class(`ContinuousAveragingAsianOption_thetaPerDay`) = c("SWIGFunction", class('ContinuousAveragingAsianOption_thetaPerDay'))

# Start of ContinuousAveragingAsianOption_vega

`ContinuousAveragingAsianOption_vega` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_ContinuousAveragingAsianOption_vega', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`ContinuousAveragingAsianOption_vega`, 'returnType') = 'numeric'
attr(`ContinuousAveragingAsianOption_vega`, "inputTypes") = c('_p_ContinuousAveragingAsianOptionPtr')
class(`ContinuousAveragingAsianOption_vega`) = c("SWIGFunction", class('ContinuousAveragingAsianOption_vega'))

# Start of ContinuousAveragingAsianOption_rho

`ContinuousAveragingAsianOption_rho` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_ContinuousAveragingAsianOption_rho', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`ContinuousAveragingAsianOption_rho`, 'returnType') = 'numeric'
attr(`ContinuousAveragingAsianOption_rho`, "inputTypes") = c('_p_ContinuousAveragingAsianOptionPtr')
class(`ContinuousAveragingAsianOption_rho`) = c("SWIGFunction", class('ContinuousAveragingAsianOption_rho'))

# Start of ContinuousAveragingAsianOption_dividendRho

`ContinuousAveragingAsianOption_dividendRho` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_ContinuousAveragingAsianOption_dividendRho', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`ContinuousAveragingAsianOption_dividendRho`, 'returnType') = 'numeric'
attr(`ContinuousAveragingAsianOption_dividendRho`, "inputTypes") = c('_p_ContinuousAveragingAsianOptionPtr')
class(`ContinuousAveragingAsianOption_dividendRho`) = c("SWIGFunction", class('ContinuousAveragingAsianOption_dividendRho'))

# Start of ContinuousAveragingAsianOption_strikeSensitivity

`ContinuousAveragingAsianOption_strikeSensitivity` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_ContinuousAveragingAsianOption_strikeSensitivity', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`ContinuousAveragingAsianOption_strikeSensitivity`, 'returnType') = 'numeric'
attr(`ContinuousAveragingAsianOption_strikeSensitivity`, "inputTypes") = c('_p_ContinuousAveragingAsianOptionPtr')
class(`ContinuousAveragingAsianOption_strikeSensitivity`) = c("SWIGFunction", class('ContinuousAveragingAsianOption_strikeSensitivity'))

# Start of delete_ContinuousAveragingAsianOption

`delete_ContinuousAveragingAsianOption` = function(self)
{
  ;.Call('R_swig_delete_ContinuousAveragingAsianOption', self, PACKAGE='QuantLib');
  
}

attr(`delete_ContinuousAveragingAsianOption`, 'returnType') = 'void'
attr(`delete_ContinuousAveragingAsianOption`, "inputTypes") = c('_p_ContinuousAveragingAsianOptionPtr')
class(`delete_ContinuousAveragingAsianOption`) = c("SWIGFunction", class('delete_ContinuousAveragingAsianOption'))

# Start of accessor method for ContinuousAveragingAsianOptionPtr
setMethod('$', '_p_ContinuousAveragingAsianOptionPtr', function(x, name)

{
  accessorFuns = list('delta' = ContinuousAveragingAsianOption_delta, 'gamma' = ContinuousAveragingAsianOption_gamma, 'theta' = ContinuousAveragingAsianOption_theta, 'thetaPerDay' = ContinuousAveragingAsianOption_thetaPerDay, 'vega' = ContinuousAveragingAsianOption_vega, 'rho' = ContinuousAveragingAsianOption_rho, 'dividendRho' = ContinuousAveragingAsianOption_dividendRho, 'strikeSensitivity' = ContinuousAveragingAsianOption_strikeSensitivity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for ContinuousAveragingAsianOptionPtr
setMethod('delete', '_p_ContinuousAveragingAsianOptionPtr', function(obj) {delete_ContinuousAveragingAsianOptionPtr(obj)})
# Start of new_DiscreteAveragingAsianOption

`DiscreteAveragingAsianOption` = function(averageType, runningAccumulator, pastFixings, fixingDates, payoff, exercise)
{
  averageType = enumToInteger(averageType, "_Average__Type"); 
  
  if(length(averageType) > 1) {
    warning("using only the first element of averageType");
  };
  
  
  
  
  if(length(pastFixings) > 1) {
    warning("using only the first element of pastFixings");
  };
  
  
  
  
  ;ans = .Call('R_swig_new_DiscreteAveragingAsianOption', averageType, runningAccumulator, pastFixings, fixingDates, payoff, exercise, PACKAGE='QuantLib');
  class(ans) <- "_p_DiscreteAveragingAsianOptionPtr";
  
  reg.finalizer(ans, delete_DiscreteAveragingAsianOption)
  ans
  
}

attr(`DiscreteAveragingAsianOption`, 'returnType') = '_p_DiscreteAveragingAsianOptionPtr'
attr(`DiscreteAveragingAsianOption`, "inputTypes") = c('character', 'numeric', 'integer', '_p_std__vectorT_Date_std__allocatorT_Date_t_t', '_p_boost__shared_ptrT_Payoff_t', '_p_boost__shared_ptrT_Exercise_t')
class(`DiscreteAveragingAsianOption`) = c("SWIGFunction", class('DiscreteAveragingAsianOption'))

# Start of DiscreteAveragingAsianOption_delta

`DiscreteAveragingAsianOption_delta` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_DiscreteAveragingAsianOption_delta', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DiscreteAveragingAsianOption_delta`, 'returnType') = 'numeric'
attr(`DiscreteAveragingAsianOption_delta`, "inputTypes") = c('_p_DiscreteAveragingAsianOptionPtr')
class(`DiscreteAveragingAsianOption_delta`) = c("SWIGFunction", class('DiscreteAveragingAsianOption_delta'))

# Start of DiscreteAveragingAsianOption_gamma

`DiscreteAveragingAsianOption_gamma` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_DiscreteAveragingAsianOption_gamma', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DiscreteAveragingAsianOption_gamma`, 'returnType') = 'numeric'
attr(`DiscreteAveragingAsianOption_gamma`, "inputTypes") = c('_p_DiscreteAveragingAsianOptionPtr')
class(`DiscreteAveragingAsianOption_gamma`) = c("SWIGFunction", class('DiscreteAveragingAsianOption_gamma'))

# Start of DiscreteAveragingAsianOption_theta

`DiscreteAveragingAsianOption_theta` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_DiscreteAveragingAsianOption_theta', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DiscreteAveragingAsianOption_theta`, 'returnType') = 'numeric'
attr(`DiscreteAveragingAsianOption_theta`, "inputTypes") = c('_p_DiscreteAveragingAsianOptionPtr')
class(`DiscreteAveragingAsianOption_theta`) = c("SWIGFunction", class('DiscreteAveragingAsianOption_theta'))

# Start of DiscreteAveragingAsianOption_thetaPerDay

`DiscreteAveragingAsianOption_thetaPerDay` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_DiscreteAveragingAsianOption_thetaPerDay', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DiscreteAveragingAsianOption_thetaPerDay`, 'returnType') = 'numeric'
attr(`DiscreteAveragingAsianOption_thetaPerDay`, "inputTypes") = c('_p_DiscreteAveragingAsianOptionPtr')
class(`DiscreteAveragingAsianOption_thetaPerDay`) = c("SWIGFunction", class('DiscreteAveragingAsianOption_thetaPerDay'))

# Start of DiscreteAveragingAsianOption_vega

`DiscreteAveragingAsianOption_vega` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_DiscreteAveragingAsianOption_vega', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DiscreteAveragingAsianOption_vega`, 'returnType') = 'numeric'
attr(`DiscreteAveragingAsianOption_vega`, "inputTypes") = c('_p_DiscreteAveragingAsianOptionPtr')
class(`DiscreteAveragingAsianOption_vega`) = c("SWIGFunction", class('DiscreteAveragingAsianOption_vega'))

# Start of DiscreteAveragingAsianOption_rho

`DiscreteAveragingAsianOption_rho` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_DiscreteAveragingAsianOption_rho', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DiscreteAveragingAsianOption_rho`, 'returnType') = 'numeric'
attr(`DiscreteAveragingAsianOption_rho`, "inputTypes") = c('_p_DiscreteAveragingAsianOptionPtr')
class(`DiscreteAveragingAsianOption_rho`) = c("SWIGFunction", class('DiscreteAveragingAsianOption_rho'))

# Start of DiscreteAveragingAsianOption_dividendRho

`DiscreteAveragingAsianOption_dividendRho` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_DiscreteAveragingAsianOption_dividendRho', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DiscreteAveragingAsianOption_dividendRho`, 'returnType') = 'numeric'
attr(`DiscreteAveragingAsianOption_dividendRho`, "inputTypes") = c('_p_DiscreteAveragingAsianOptionPtr')
class(`DiscreteAveragingAsianOption_dividendRho`) = c("SWIGFunction", class('DiscreteAveragingAsianOption_dividendRho'))

# Start of DiscreteAveragingAsianOption_strikeSensitivity

`DiscreteAveragingAsianOption_strikeSensitivity` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_DiscreteAveragingAsianOption_strikeSensitivity', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DiscreteAveragingAsianOption_strikeSensitivity`, 'returnType') = 'numeric'
attr(`DiscreteAveragingAsianOption_strikeSensitivity`, "inputTypes") = c('_p_DiscreteAveragingAsianOptionPtr')
class(`DiscreteAveragingAsianOption_strikeSensitivity`) = c("SWIGFunction", class('DiscreteAveragingAsianOption_strikeSensitivity'))

# Start of delete_DiscreteAveragingAsianOption

`delete_DiscreteAveragingAsianOption` = function(self)
{
  ;.Call('R_swig_delete_DiscreteAveragingAsianOption', self, PACKAGE='QuantLib');
  
}

attr(`delete_DiscreteAveragingAsianOption`, 'returnType') = 'void'
attr(`delete_DiscreteAveragingAsianOption`, "inputTypes") = c('_p_DiscreteAveragingAsianOptionPtr')
class(`delete_DiscreteAveragingAsianOption`) = c("SWIGFunction", class('delete_DiscreteAveragingAsianOption'))

# Start of accessor method for DiscreteAveragingAsianOptionPtr
setMethod('$', '_p_DiscreteAveragingAsianOptionPtr', function(x, name)

{
  accessorFuns = list('delta' = DiscreteAveragingAsianOption_delta, 'gamma' = DiscreteAveragingAsianOption_gamma, 'theta' = DiscreteAveragingAsianOption_theta, 'thetaPerDay' = DiscreteAveragingAsianOption_thetaPerDay, 'vega' = DiscreteAveragingAsianOption_vega, 'rho' = DiscreteAveragingAsianOption_rho, 'dividendRho' = DiscreteAveragingAsianOption_dividendRho, 'strikeSensitivity' = DiscreteAveragingAsianOption_strikeSensitivity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for DiscreteAveragingAsianOptionPtr
setMethod('delete', '_p_DiscreteAveragingAsianOptionPtr', function(obj) {delete_DiscreteAveragingAsianOptionPtr(obj)})
# Start of new_AnalyticContinuousGeometricAveragePriceAsianEngine

`AnalyticContinuousGeometricAveragePriceAsianEngine` = function(process)
{
  ;ans = .Call('R_swig_new_AnalyticContinuousGeometricAveragePriceAsianEngine', process, PACKAGE='QuantLib');
  class(ans) <- "_p_AnalyticContinuousGeometricAveragePriceAsianEnginePtr";
  
  reg.finalizer(ans, delete_AnalyticContinuousGeometricAveragePriceAsianEngine)
  ans
  
}

attr(`AnalyticContinuousGeometricAveragePriceAsianEngine`, 'returnType') = '_p_AnalyticContinuousGeometricAveragePriceAsianEnginePtr'
attr(`AnalyticContinuousGeometricAveragePriceAsianEngine`, "inputTypes") = c('_p_GeneralizedBlackScholesProcessPtr')
class(`AnalyticContinuousGeometricAveragePriceAsianEngine`) = c("SWIGFunction", class('AnalyticContinuousGeometricAveragePriceAsianEngine'))

# Start of delete_AnalyticContinuousGeometricAveragePriceAsianEngine

`delete_AnalyticContinuousGeometricAveragePriceAsianEngine` = function(self)
{
  ;.Call('R_swig_delete_AnalyticContinuousGeometricAveragePriceAsianEngine', self, PACKAGE='QuantLib');
  
}

attr(`delete_AnalyticContinuousGeometricAveragePriceAsianEngine`, 'returnType') = 'void'
attr(`delete_AnalyticContinuousGeometricAveragePriceAsianEngine`, "inputTypes") = c('_p_AnalyticContinuousGeometricAveragePriceAsianEnginePtr')
class(`delete_AnalyticContinuousGeometricAveragePriceAsianEngine`) = c("SWIGFunction", class('delete_AnalyticContinuousGeometricAveragePriceAsianEngine'))

setMethod('delete', '_p_AnalyticContinuousGeometricAveragePriceAsianEnginePtr', function(obj) {delete_AnalyticContinuousGeometricAveragePriceAsianEnginePtr(obj)})
# Start of new_AnalyticDiscreteGeometricAveragePriceAsianEngine

`AnalyticDiscreteGeometricAveragePriceAsianEngine` = function(process)
{
  ;ans = .Call('R_swig_new_AnalyticDiscreteGeometricAveragePriceAsianEngine', process, PACKAGE='QuantLib');
  class(ans) <- "_p_AnalyticDiscreteGeometricAveragePriceAsianEnginePtr";
  
  reg.finalizer(ans, delete_AnalyticDiscreteGeometricAveragePriceAsianEngine)
  ans
  
}

attr(`AnalyticDiscreteGeometricAveragePriceAsianEngine`, 'returnType') = '_p_AnalyticDiscreteGeometricAveragePriceAsianEnginePtr'
attr(`AnalyticDiscreteGeometricAveragePriceAsianEngine`, "inputTypes") = c('_p_GeneralizedBlackScholesProcessPtr')
class(`AnalyticDiscreteGeometricAveragePriceAsianEngine`) = c("SWIGFunction", class('AnalyticDiscreteGeometricAveragePriceAsianEngine'))

# Start of delete_AnalyticDiscreteGeometricAveragePriceAsianEngine

`delete_AnalyticDiscreteGeometricAveragePriceAsianEngine` = function(self)
{
  ;.Call('R_swig_delete_AnalyticDiscreteGeometricAveragePriceAsianEngine', self, PACKAGE='QuantLib');
  
}

attr(`delete_AnalyticDiscreteGeometricAveragePriceAsianEngine`, 'returnType') = 'void'
attr(`delete_AnalyticDiscreteGeometricAveragePriceAsianEngine`, "inputTypes") = c('_p_AnalyticDiscreteGeometricAveragePriceAsianEnginePtr')
class(`delete_AnalyticDiscreteGeometricAveragePriceAsianEngine`) = c("SWIGFunction", class('delete_AnalyticDiscreteGeometricAveragePriceAsianEngine'))

setMethod('delete', '_p_AnalyticDiscreteGeometricAveragePriceAsianEnginePtr', function(obj) {delete_AnalyticDiscreteGeometricAveragePriceAsianEnginePtr(obj)})
# Start of new_AnalyticDiscreteGeometricAverageStrikeAsianEngine

`AnalyticDiscreteGeometricAverageStrikeAsianEngine` = function(process)
{
  ;ans = .Call('R_swig_new_AnalyticDiscreteGeometricAverageStrikeAsianEngine', process, PACKAGE='QuantLib');
  class(ans) <- "_p_AnalyticDiscreteGeometricAverageStrikeAsianEnginePtr";
  
  reg.finalizer(ans, delete_AnalyticDiscreteGeometricAverageStrikeAsianEngine)
  ans
  
}

attr(`AnalyticDiscreteGeometricAverageStrikeAsianEngine`, 'returnType') = '_p_AnalyticDiscreteGeometricAverageStrikeAsianEnginePtr'
attr(`AnalyticDiscreteGeometricAverageStrikeAsianEngine`, "inputTypes") = c('_p_GeneralizedBlackScholesProcessPtr')
class(`AnalyticDiscreteGeometricAverageStrikeAsianEngine`) = c("SWIGFunction", class('AnalyticDiscreteGeometricAverageStrikeAsianEngine'))

# Start of delete_AnalyticDiscreteGeometricAverageStrikeAsianEngine

`delete_AnalyticDiscreteGeometricAverageStrikeAsianEngine` = function(self)
{
  ;.Call('R_swig_delete_AnalyticDiscreteGeometricAverageStrikeAsianEngine', self, PACKAGE='QuantLib');
  
}

attr(`delete_AnalyticDiscreteGeometricAverageStrikeAsianEngine`, 'returnType') = 'void'
attr(`delete_AnalyticDiscreteGeometricAverageStrikeAsianEngine`, "inputTypes") = c('_p_AnalyticDiscreteGeometricAverageStrikeAsianEnginePtr')
class(`delete_AnalyticDiscreteGeometricAverageStrikeAsianEngine`) = c("SWIGFunction", class('delete_AnalyticDiscreteGeometricAverageStrikeAsianEngine'))

setMethod('delete', '_p_AnalyticDiscreteGeometricAverageStrikeAsianEnginePtr', function(obj) {delete_AnalyticDiscreteGeometricAverageStrikeAsianEnginePtr(obj)})
# Start of new_MCDiscreteArithmeticAPEngine

`MCDiscreteArithmeticAPEngine` = function(process, traits, brownianBridge, antitheticVariate, controlVariate, requiredSamples, requiredTolerance, maxSamples, seed)
{
  traits = as(traits, "character"); 
  brownianBridge = as.logical(brownianBridge);
  antitheticVariate = as.logical(antitheticVariate);
  controlVariate = as.logical(controlVariate);
  as(input, "integer"); 
  as(input, "numeric"); 
  as(input, "integer"); 
  seed = as.integer(seed); 
  
  if(length(seed) > 1) {
    warning("using only the first element of seed");
  };
  
  ;ans = .Call('R_swig_new_MCDiscreteArithmeticAPEngine', process, traits, brownianBridge, antitheticVariate, controlVariate, requiredSamples, requiredTolerance, maxSamples, seed, PACKAGE='QuantLib');
  class(ans) <- "_p_MCDiscreteArithmeticAPEnginePtr";
  
  reg.finalizer(ans, delete_MCDiscreteArithmeticAPEngine)
  ans
  
}

attr(`MCDiscreteArithmeticAPEngine`, 'returnType') = '_p_MCDiscreteArithmeticAPEnginePtr'
attr(`MCDiscreteArithmeticAPEngine`, "inputTypes") = c('_p_GeneralizedBlackScholesProcessPtr', 'character', 'logical', 'logical', 'logical', 'numeric', 'numeric', 'numeric', 'integer')
class(`MCDiscreteArithmeticAPEngine`) = c("SWIGFunction", class('MCDiscreteArithmeticAPEngine'))

# Start of delete_MCDiscreteArithmeticAPEngine

`delete_MCDiscreteArithmeticAPEngine` = function(self)
{
  ;.Call('R_swig_delete_MCDiscreteArithmeticAPEngine', self, PACKAGE='QuantLib');
  
}

attr(`delete_MCDiscreteArithmeticAPEngine`, 'returnType') = 'void'
attr(`delete_MCDiscreteArithmeticAPEngine`, "inputTypes") = c('_p_MCDiscreteArithmeticAPEnginePtr')
class(`delete_MCDiscreteArithmeticAPEngine`) = c("SWIGFunction", class('delete_MCDiscreteArithmeticAPEngine'))

setMethod('delete', '_p_MCDiscreteArithmeticAPEnginePtr', function(obj) {delete_MCDiscreteArithmeticAPEnginePtr(obj)})
# Start of new_MCDiscreteArithmeticASEngine

`MCDiscreteArithmeticASEngine` = function(process, traits, brownianBridge, antitheticVariate, requiredSamples, requiredTolerance, maxSamples, seed)
{
  traits = as(traits, "character"); 
  brownianBridge = as.logical(brownianBridge);
  antitheticVariate = as.logical(antitheticVariate);
  as(input, "integer"); 
  as(input, "numeric"); 
  as(input, "integer"); 
  seed = as.integer(seed); 
  
  if(length(seed) > 1) {
    warning("using only the first element of seed");
  };
  
  ;ans = .Call('R_swig_new_MCDiscreteArithmeticASEngine', process, traits, brownianBridge, antitheticVariate, requiredSamples, requiredTolerance, maxSamples, seed, PACKAGE='QuantLib');
  class(ans) <- "_p_MCDiscreteArithmeticASEnginePtr";
  
  reg.finalizer(ans, delete_MCDiscreteArithmeticASEngine)
  ans
  
}

attr(`MCDiscreteArithmeticASEngine`, 'returnType') = '_p_MCDiscreteArithmeticASEnginePtr'
attr(`MCDiscreteArithmeticASEngine`, "inputTypes") = c('_p_GeneralizedBlackScholesProcessPtr', 'character', 'logical', 'logical', 'numeric', 'numeric', 'numeric', 'integer')
class(`MCDiscreteArithmeticASEngine`) = c("SWIGFunction", class('MCDiscreteArithmeticASEngine'))

# Start of delete_MCDiscreteArithmeticASEngine

`delete_MCDiscreteArithmeticASEngine` = function(self)
{
  ;.Call('R_swig_delete_MCDiscreteArithmeticASEngine', self, PACKAGE='QuantLib');
  
}

attr(`delete_MCDiscreteArithmeticASEngine`, 'returnType') = 'void'
attr(`delete_MCDiscreteArithmeticASEngine`, "inputTypes") = c('_p_MCDiscreteArithmeticASEnginePtr')
class(`delete_MCDiscreteArithmeticASEngine`) = c("SWIGFunction", class('delete_MCDiscreteArithmeticASEngine'))

setMethod('delete', '_p_MCDiscreteArithmeticASEnginePtr', function(obj) {delete_MCDiscreteArithmeticASEnginePtr(obj)})
# Start of new_MCDiscreteGeometricAPEngine

`MCDiscreteGeometricAPEngine` = function(process, traits, brownianBridge, antitheticVariate, requiredSamples, requiredTolerance, maxSamples, seed)
{
  traits = as(traits, "character"); 
  brownianBridge = as.logical(brownianBridge);
  antitheticVariate = as.logical(antitheticVariate);
  as(input, "integer"); 
  as(input, "numeric"); 
  as(input, "integer"); 
  seed = as.integer(seed); 
  
  if(length(seed) > 1) {
    warning("using only the first element of seed");
  };
  
  ;ans = .Call('R_swig_new_MCDiscreteGeometricAPEngine', process, traits, brownianBridge, antitheticVariate, requiredSamples, requiredTolerance, maxSamples, seed, PACKAGE='QuantLib');
  class(ans) <- "_p_MCDiscreteGeometricAPEnginePtr";
  
  reg.finalizer(ans, delete_MCDiscreteGeometricAPEngine)
  ans
  
}

attr(`MCDiscreteGeometricAPEngine`, 'returnType') = '_p_MCDiscreteGeometricAPEnginePtr'
attr(`MCDiscreteGeometricAPEngine`, "inputTypes") = c('_p_GeneralizedBlackScholesProcessPtr', 'character', 'logical', 'logical', 'numeric', 'numeric', 'numeric', 'integer')
class(`MCDiscreteGeometricAPEngine`) = c("SWIGFunction", class('MCDiscreteGeometricAPEngine'))

# Start of delete_MCDiscreteGeometricAPEngine

`delete_MCDiscreteGeometricAPEngine` = function(self)
{
  ;.Call('R_swig_delete_MCDiscreteGeometricAPEngine', self, PACKAGE='QuantLib');
  
}

attr(`delete_MCDiscreteGeometricAPEngine`, 'returnType') = 'void'
attr(`delete_MCDiscreteGeometricAPEngine`, "inputTypes") = c('_p_MCDiscreteGeometricAPEnginePtr')
class(`delete_MCDiscreteGeometricAPEngine`) = c("SWIGFunction", class('delete_MCDiscreteGeometricAPEngine'))

setMethod('delete', '_p_MCDiscreteGeometricAPEnginePtr', function(obj) {delete_MCDiscreteGeometricAPEnginePtr(obj)})
# Start of new_VarianceGammaEngine

`VarianceGammaEngine` = function(process)
{
  ;ans = .Call('R_swig_new_VarianceGammaEngine', process, PACKAGE='QuantLib');
  class(ans) <- "_p_VarianceGammaEnginePtr";
  
  reg.finalizer(ans, delete_VarianceGammaEngine)
  ans
  
}

attr(`VarianceGammaEngine`, 'returnType') = '_p_VarianceGammaEnginePtr'
attr(`VarianceGammaEngine`, "inputTypes") = c('_p_VarianceGammaProcessPtr')
class(`VarianceGammaEngine`) = c("SWIGFunction", class('VarianceGammaEngine'))

# Start of delete_VarianceGammaEngine

`delete_VarianceGammaEngine` = function(self)
{
  ;.Call('R_swig_delete_VarianceGammaEngine', self, PACKAGE='QuantLib');
  
}

attr(`delete_VarianceGammaEngine`, 'returnType') = 'void'
attr(`delete_VarianceGammaEngine`, "inputTypes") = c('_p_VarianceGammaEnginePtr')
class(`delete_VarianceGammaEngine`) = c("SWIGFunction", class('delete_VarianceGammaEngine'))

setMethod('delete', '_p_VarianceGammaEnginePtr', function(obj) {delete_VarianceGammaEnginePtr(obj)})
# Start of OptionList___nonzero__

`OptionList___nonzero__` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_OptionList___nonzero__', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`OptionList___nonzero__`, 'returnType') = 'logical'
attr(`OptionList___nonzero__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Instrument_t_std__allocatorT_boost__shared_ptrT_Instrument_t_t_t')
class(`OptionList___nonzero__`) = c("SWIGFunction", class('OptionList___nonzero__'))

# Start of OptionList___len__

`OptionList___len__` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_OptionList___len__', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`OptionList___len__`, 'returnType') = 'integer'
attr(`OptionList___len__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Instrument_t_std__allocatorT_boost__shared_ptrT_Instrument_t_t_t')
class(`OptionList___len__`) = c("SWIGFunction", class('OptionList___len__'))

# Start of OptionList_pop

`OptionList_pop` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_OptionList_pop', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_Instrument_t";
  
  ans
  
}

attr(`OptionList_pop`, 'returnType') = '_p_boost__shared_ptrT_Instrument_t'
attr(`OptionList_pop`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Instrument_t_std__allocatorT_boost__shared_ptrT_Instrument_t_t_t')
class(`OptionList_pop`) = c("SWIGFunction", class('OptionList_pop'))

# Start of OptionList___getslice__

`OptionList___getslice__` = function(self, i, j)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;ans = .Call('R_swig_OptionList___getslice__', self, i, j, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_Instrument_t_std__allocatorT_boost__shared_ptrT_Instrument_t_t_t";
  
  ans
  
}

attr(`OptionList___getslice__`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_Instrument_t_std__allocatorT_boost__shared_ptrT_Instrument_t_t_t'
attr(`OptionList___getslice__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Instrument_t_std__allocatorT_boost__shared_ptrT_Instrument_t_t_t', 'integer', 'integer')
class(`OptionList___getslice__`) = c("SWIGFunction", class('OptionList___getslice__'))

# Start of OptionList___setslice__

`OptionList___setslice__` = function(self, i, j, v)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  
  ;.Call('R_swig_OptionList___setslice__', self, i, j, v, PACKAGE='QuantLib');
  
}

attr(`OptionList___setslice__`, 'returnType') = 'void'
attr(`OptionList___setslice__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Instrument_t_std__allocatorT_boost__shared_ptrT_Instrument_t_t_t', 'integer', 'integer', '_p_std__vectorT_boost__shared_ptrT_Instrument_t_std__allocatorT_boost__shared_ptrT_Instrument_t_t_t')
class(`OptionList___setslice__`) = c("SWIGFunction", class('OptionList___setslice__'))

# Start of OptionList___delslice__

`OptionList___delslice__` = function(self, i, j)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_OptionList___delslice__', self, i, j, PACKAGE='QuantLib');
  
}

attr(`OptionList___delslice__`, 'returnType') = 'void'
attr(`OptionList___delslice__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Instrument_t_std__allocatorT_boost__shared_ptrT_Instrument_t_t_t', 'integer', 'integer')
class(`OptionList___delslice__`) = c("SWIGFunction", class('OptionList___delslice__'))

# Start of OptionList___delitem__

`OptionList___delitem__` = function(self, i)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_OptionList___delitem__', self, i, PACKAGE='QuantLib');
  
}

attr(`OptionList___delitem__`, 'returnType') = 'void'
attr(`OptionList___delitem__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Instrument_t_std__allocatorT_boost__shared_ptrT_Instrument_t_t_t', 'integer')
class(`OptionList___delitem__`) = c("SWIGFunction", class('OptionList___delitem__'))

# Start of OptionList___getitem__

`OptionList___getitem__` = function(self, i, .copy = FALSE)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;ans = .Call('R_swig_OptionList___getitem__', self, i, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_Instrument_t";
  
  ans
  
}

attr(`OptionList___getitem__`, 'returnType') = '_p_boost__shared_ptrT_Instrument_t'
attr(`OptionList___getitem__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Instrument_t_std__allocatorT_boost__shared_ptrT_Instrument_t_t_t', 'integer')
class(`OptionList___getitem__`) = c("SWIGFunction", class('OptionList___getitem__'))

# Start of OptionList___setitem__

`OptionList___setitem__` = function(self, i, x)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  ;.Call('R_swig_OptionList___setitem__', self, i, x, PACKAGE='QuantLib');
  
}

attr(`OptionList___setitem__`, 'returnType') = 'void'
attr(`OptionList___setitem__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Instrument_t_std__allocatorT_boost__shared_ptrT_Instrument_t_t_t', 'integer', '_p_boost__shared_ptrT_Instrument_t')
class(`OptionList___setitem__`) = c("SWIGFunction", class('OptionList___setitem__'))

# Start of OptionList_append

`OptionList_append` = function(self, x)
{
  ;.Call('R_swig_OptionList_append', self, x, PACKAGE='QuantLib');
  
}

attr(`OptionList_append`, 'returnType') = 'void'
attr(`OptionList_append`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Instrument_t_std__allocatorT_boost__shared_ptrT_Instrument_t_t_t', '_p_boost__shared_ptrT_Instrument_t')
class(`OptionList_append`) = c("SWIGFunction", class('OptionList_append'))

# Start of new_OptionList

`OptionList__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_OptionList__SWIG_0', PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_Instrument_t_std__allocatorT_boost__shared_ptrT_Instrument_t_t_t";
  
  reg.finalizer(ans, delete_OptionList)
  ans
  
}

attr(`OptionList__SWIG_0`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_Instrument_t_std__allocatorT_boost__shared_ptrT_Instrument_t_t_t'
class(`OptionList__SWIG_0`) = c("SWIGFunction", class('OptionList__SWIG_0'))

# Start of new_OptionList

`OptionList__SWIG_1` = function(s_arg1)
{
  ;ans = .Call('R_swig_new_OptionList__SWIG_1', s_arg1, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_Instrument_t_std__allocatorT_boost__shared_ptrT_Instrument_t_t_t";
  
  reg.finalizer(ans, delete_OptionList)
  ans
  
}

attr(`OptionList__SWIG_1`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_Instrument_t_std__allocatorT_boost__shared_ptrT_Instrument_t_t_t'
attr(`OptionList__SWIG_1`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Instrument_t_std__allocatorT_boost__shared_ptrT_Instrument_t_t_t')
class(`OptionList__SWIG_1`) = c("SWIGFunction", class('OptionList__SWIG_1'))

# Start of OptionList_empty

`OptionList_empty` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_OptionList_empty', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`OptionList_empty`, 'returnType') = 'logical'
attr(`OptionList_empty`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Instrument_t_std__allocatorT_boost__shared_ptrT_Instrument_t_t_t')
class(`OptionList_empty`) = c("SWIGFunction", class('OptionList_empty'))

# Start of OptionList_size

`OptionList_size` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_OptionList_size', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`OptionList_size`, 'returnType') = 'integer'
attr(`OptionList_size`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Instrument_t_std__allocatorT_boost__shared_ptrT_Instrument_t_t_t')
class(`OptionList_size`) = c("SWIGFunction", class('OptionList_size'))

# Start of OptionList_clear

`OptionList_clear` = function(self)
{
  ;.Call('R_swig_OptionList_clear', self, PACKAGE='QuantLib');
  
}

attr(`OptionList_clear`, 'returnType') = 'void'
attr(`OptionList_clear`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Instrument_t_std__allocatorT_boost__shared_ptrT_Instrument_t_t_t')
class(`OptionList_clear`) = c("SWIGFunction", class('OptionList_clear'))

# Start of OptionList_swap

`OptionList_swap` = function(self, v)
{
  ;.Call('R_swig_OptionList_swap', self, v, PACKAGE='QuantLib');
  
}

attr(`OptionList_swap`, 'returnType') = 'void'
attr(`OptionList_swap`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Instrument_t_std__allocatorT_boost__shared_ptrT_Instrument_t_t_t', '_p_std__vectorT_boost__shared_ptrT_Instrument_t_std__allocatorT_boost__shared_ptrT_Instrument_t_t_t')
class(`OptionList_swap`) = c("SWIGFunction", class('OptionList_swap'))

# Start of OptionList_get_allocator

`OptionList_get_allocator` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_OptionList_get_allocator', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__allocatorT_boost__shared_ptrT_Instrument_t_t";
  
  ans
  
}

attr(`OptionList_get_allocator`, 'returnType') = '_p_std__allocatorT_boost__shared_ptrT_Instrument_t_t'
attr(`OptionList_get_allocator`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Instrument_t_std__allocatorT_boost__shared_ptrT_Instrument_t_t_t')
class(`OptionList_get_allocator`) = c("SWIGFunction", class('OptionList_get_allocator'))

# Start of new_OptionList

`OptionList__SWIG_2` = function(size)
{
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_new_OptionList__SWIG_2', size, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_Instrument_t_std__allocatorT_boost__shared_ptrT_Instrument_t_t_t";
  
  reg.finalizer(ans, delete_OptionList)
  ans
  
}

attr(`OptionList__SWIG_2`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_Instrument_t_std__allocatorT_boost__shared_ptrT_Instrument_t_t_t'
attr(`OptionList__SWIG_2`, "inputTypes") = c('integer')
class(`OptionList__SWIG_2`) = c("SWIGFunction", class('OptionList__SWIG_2'))

# Start of OptionList_pop_back

`OptionList_pop_back` = function(self)
{
  ;.Call('R_swig_OptionList_pop_back', self, PACKAGE='QuantLib');
  
}

attr(`OptionList_pop_back`, 'returnType') = 'void'
attr(`OptionList_pop_back`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Instrument_t_std__allocatorT_boost__shared_ptrT_Instrument_t_t_t')
class(`OptionList_pop_back`) = c("SWIGFunction", class('OptionList_pop_back'))

# Start of OptionList_resize

`OptionList_resize__SWIG_0` = function(self, new_size)
{
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_OptionList_resize__SWIG_0', self, new_size, PACKAGE='QuantLib');
  
}

attr(`OptionList_resize__SWIG_0`, 'returnType') = 'void'
attr(`OptionList_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Instrument_t_std__allocatorT_boost__shared_ptrT_Instrument_t_t_t', 'integer')
class(`OptionList_resize__SWIG_0`) = c("SWIGFunction", class('OptionList_resize__SWIG_0'))

# Start of new_OptionList

`OptionList__SWIG_3` = function(size, value)
{
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  
  ;ans = .Call('R_swig_new_OptionList__SWIG_3', size, value, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_Instrument_t_std__allocatorT_boost__shared_ptrT_Instrument_t_t_t";
  
  reg.finalizer(ans, delete_OptionList)
  ans
  
}

attr(`OptionList__SWIG_3`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_Instrument_t_std__allocatorT_boost__shared_ptrT_Instrument_t_t_t'
attr(`OptionList__SWIG_3`, "inputTypes") = c('integer', '_p_boost__shared_ptrT_Instrument_t')
class(`OptionList__SWIG_3`) = c("SWIGFunction", class('OptionList__SWIG_3'))

`OptionList` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- OptionList__SWIG_0; 
  } else if (argc == 1) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]]))) {
      f <- OptionList__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_Instrument_t_std__allocatorT_boost__shared_ptrT_Instrument_t_t_t')) {
      f <- OptionList__SWIG_1; 
    }
  } else if (argc == 2) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && extends(argtypes[2], '_p_boost__shared_ptrT_Instrument_t')) {
      f <- OptionList__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for OptionList with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of OptionList_push_back

`OptionList_push_back` = function(self, x)
{
  ;.Call('R_swig_OptionList_push_back', self, x, PACKAGE='QuantLib');
  
}

attr(`OptionList_push_back`, 'returnType') = 'void'
attr(`OptionList_push_back`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Instrument_t_std__allocatorT_boost__shared_ptrT_Instrument_t_t_t', '_p_boost__shared_ptrT_Instrument_t')
class(`OptionList_push_back`) = c("SWIGFunction", class('OptionList_push_back'))

# Start of OptionList_front

`OptionList_front` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_OptionList_front', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_Instrument_t";
  
  ans
  
}

attr(`OptionList_front`, 'returnType') = '_p_boost__shared_ptrT_Instrument_t'
attr(`OptionList_front`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Instrument_t_std__allocatorT_boost__shared_ptrT_Instrument_t_t_t')
class(`OptionList_front`) = c("SWIGFunction", class('OptionList_front'))

# Start of OptionList_back

`OptionList_back` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_OptionList_back', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_Instrument_t";
  
  ans
  
}

attr(`OptionList_back`, 'returnType') = '_p_boost__shared_ptrT_Instrument_t'
attr(`OptionList_back`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Instrument_t_std__allocatorT_boost__shared_ptrT_Instrument_t_t_t')
class(`OptionList_back`) = c("SWIGFunction", class('OptionList_back'))

# Start of OptionList_assign

`OptionList_assign` = function(self, n, x)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  
  ;.Call('R_swig_OptionList_assign', self, n, x, PACKAGE='QuantLib');
  
}

attr(`OptionList_assign`, 'returnType') = 'void'
attr(`OptionList_assign`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Instrument_t_std__allocatorT_boost__shared_ptrT_Instrument_t_t_t', 'integer', '_p_boost__shared_ptrT_Instrument_t')
class(`OptionList_assign`) = c("SWIGFunction", class('OptionList_assign'))

# Start of OptionList_resize

`OptionList_resize__SWIG_1` = function(self, new_size, x)
{
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  
  ;.Call('R_swig_OptionList_resize__SWIG_1', self, new_size, x, PACKAGE='QuantLib');
  
}

attr(`OptionList_resize__SWIG_1`, 'returnType') = 'void'
attr(`OptionList_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Instrument_t_std__allocatorT_boost__shared_ptrT_Instrument_t_t_t', 'integer', '_p_boost__shared_ptrT_Instrument_t')
class(`OptionList_resize__SWIG_1`) = c("SWIGFunction", class('OptionList_resize__SWIG_1'))

`OptionList_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_Instrument_t_std__allocatorT_boost__shared_ptrT_Instrument_t_t_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]]))) {
      f <- OptionList_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_Instrument_t_std__allocatorT_boost__shared_ptrT_Instrument_t_t_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && extends(argtypes[3], '_p_boost__shared_ptrT_Instrument_t')) {
      f <- OptionList_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for OptionList_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of OptionList_reserve

`OptionList_reserve` = function(self, n)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_OptionList_reserve', self, n, PACKAGE='QuantLib');
  
}

attr(`OptionList_reserve`, 'returnType') = 'void'
attr(`OptionList_reserve`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Instrument_t_std__allocatorT_boost__shared_ptrT_Instrument_t_t_t', 'integer')
class(`OptionList_reserve`) = c("SWIGFunction", class('OptionList_reserve'))

# Start of OptionList_capacity

`OptionList_capacity` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_OptionList_capacity', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`OptionList_capacity`, 'returnType') = 'integer'
attr(`OptionList_capacity`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Instrument_t_std__allocatorT_boost__shared_ptrT_Instrument_t_t_t')
class(`OptionList_capacity`) = c("SWIGFunction", class('OptionList_capacity'))

# Start of delete_OptionList

`delete_OptionList` = function(self)
{
  ;.Call('R_swig_delete_OptionList', self, PACKAGE='QuantLib');
  
}

attr(`delete_OptionList`, 'returnType') = 'void'
attr(`delete_OptionList`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Instrument_t_std__allocatorT_boost__shared_ptrT_Instrument_t_t_t')
class(`delete_OptionList`) = c("SWIGFunction", class('delete_OptionList'))

# Start of accessor method for std::vector<(boost::shared_ptr<(Instrument)>)>
setMethod('$', '_p_std__vectorT_boost__shared_ptrT_Instrument_t_std__allocatorT_boost__shared_ptrT_Instrument_t_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = OptionList___nonzero__, '__len__' = OptionList___len__, 'pop' = OptionList_pop, '__getslice__' = OptionList___getslice__, '__setslice__' = OptionList___setslice__, '__delslice__' = OptionList___delslice__, '__delitem__' = OptionList___delitem__, '__getitem__' = OptionList___getitem__, '__setitem__' = OptionList___setitem__, 'append' = OptionList_append, 'empty' = OptionList_empty, 'size' = OptionList_size, 'clear' = OptionList_clear, 'swap' = OptionList_swap, 'get_allocator' = OptionList_get_allocator, 'pop_back' = OptionList_pop_back, 'resize' = OptionList_resize, 'push_back' = OptionList_push_back, 'front' = OptionList_front, 'back' = OptionList_back, 'assign' = OptionList_assign, 'reserve' = OptionList_reserve, 'capacity' = OptionList_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for std::vector<(boost::shared_ptr<(Instrument)>)>
setMethod('delete', '_p_std__vectorT_boost__shared_ptrT_Instrument_t_std__allocatorT_boost__shared_ptrT_Instrument_t_t_t', function(obj) {delete_std__vectorT_boost__shared_ptrT_Instrument_t_std__allocatorT_boost__shared_ptrT_Instrument_t_t_t(obj)})
# Start of new_FFTVarianceGammaEngine

`FFTVarianceGammaEngine__SWIG_0` = function(process, logStrikeSpacing)
{
  ;ans = .Call('R_swig_new_FFTVarianceGammaEngine__SWIG_0', process, logStrikeSpacing, PACKAGE='QuantLib');
  class(ans) <- "_p_FFTVarianceGammaEnginePtr";
  
  reg.finalizer(ans, delete_FFTVarianceGammaEngine)
  ans
  
}

attr(`FFTVarianceGammaEngine__SWIG_0`, 'returnType') = '_p_FFTVarianceGammaEnginePtr'
attr(`FFTVarianceGammaEngine__SWIG_0`, "inputTypes") = c('_p_VarianceGammaProcessPtr', 'numeric')
class(`FFTVarianceGammaEngine__SWIG_0`) = c("SWIGFunction", class('FFTVarianceGammaEngine__SWIG_0'))

# Start of new_FFTVarianceGammaEngine

`FFTVarianceGammaEngine__SWIG_1` = function(process)
{
  ;ans = .Call('R_swig_new_FFTVarianceGammaEngine__SWIG_1', process, PACKAGE='QuantLib');
  class(ans) <- "_p_FFTVarianceGammaEnginePtr";
  
  reg.finalizer(ans, delete_FFTVarianceGammaEngine)
  ans
  
}

attr(`FFTVarianceGammaEngine__SWIG_1`, 'returnType') = '_p_FFTVarianceGammaEnginePtr'
attr(`FFTVarianceGammaEngine__SWIG_1`, "inputTypes") = c('_p_VarianceGammaProcessPtr')
class(`FFTVarianceGammaEngine__SWIG_1`) = c("SWIGFunction", class('FFTVarianceGammaEngine__SWIG_1'))

`FFTVarianceGammaEngine` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_VarianceGammaProcessPtr')) {
      f <- FFTVarianceGammaEngine__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_VarianceGammaProcessPtr') && is.numeric(argv[[2]])) {
      f <- FFTVarianceGammaEngine__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for FFTVarianceGammaEngine with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of FFTVarianceGammaEngine_precalculate

`FFTVarianceGammaEngine_precalculate` = function(self, optionList)
{
  ;.Call('R_swig_FFTVarianceGammaEngine_precalculate', self, optionList, PACKAGE='QuantLib');
  
}

attr(`FFTVarianceGammaEngine_precalculate`, 'returnType') = 'void'
attr(`FFTVarianceGammaEngine_precalculate`, "inputTypes") = c('_p_FFTVarianceGammaEnginePtr', '_p_std__vectorT_boost__shared_ptrT_Instrument_t_std__allocatorT_boost__shared_ptrT_Instrument_t_t_t')
class(`FFTVarianceGammaEngine_precalculate`) = c("SWIGFunction", class('FFTVarianceGammaEngine_precalculate'))

# Start of delete_FFTVarianceGammaEngine

`delete_FFTVarianceGammaEngine` = function(self)
{
  ;.Call('R_swig_delete_FFTVarianceGammaEngine', self, PACKAGE='QuantLib');
  
}

attr(`delete_FFTVarianceGammaEngine`, 'returnType') = 'void'
attr(`delete_FFTVarianceGammaEngine`, "inputTypes") = c('_p_FFTVarianceGammaEnginePtr')
class(`delete_FFTVarianceGammaEngine`) = c("SWIGFunction", class('delete_FFTVarianceGammaEngine'))

# Start of accessor method for FFTVarianceGammaEnginePtr
setMethod('$', '_p_FFTVarianceGammaEnginePtr', function(x, name)

{
  accessorFuns = list('precalculate' = FFTVarianceGammaEngine_precalculate);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for FFTVarianceGammaEnginePtr
setMethod('delete', '_p_FFTVarianceGammaEnginePtr', function(obj) {delete_FFTVarianceGammaEnginePtr(obj)})
# Start of new_PlainVanillaPayoff

`PlainVanillaPayoff` = function(type, strike)
{
  type = enumToInteger(type, "_Option__Type"); 
  
  if(length(type) > 1) {
    warning("using only the first element of type");
  };
  
  
  ;ans = .Call('R_swig_new_PlainVanillaPayoff', type, strike, PACKAGE='QuantLib');
  class(ans) <- "_p_PlainVanillaPayoffPtr";
  
  reg.finalizer(ans, delete_PlainVanillaPayoff)
  ans
  
}

attr(`PlainVanillaPayoff`, 'returnType') = '_p_PlainVanillaPayoffPtr'
attr(`PlainVanillaPayoff`, "inputTypes") = c('character', 'numeric')
class(`PlainVanillaPayoff`) = c("SWIGFunction", class('PlainVanillaPayoff'))

# Start of PlainVanillaPayoff_optionType

`PlainVanillaPayoff_optionType` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_PlainVanillaPayoff_optionType', self, as.logical(.copy), PACKAGE='QuantLib');
  ans = enumFromInteger(ans, "_Option__Type");
  
  ans
  
}

attr(`PlainVanillaPayoff_optionType`, 'returnType') = 'character'
attr(`PlainVanillaPayoff_optionType`, "inputTypes") = c('_p_PlainVanillaPayoffPtr')
class(`PlainVanillaPayoff_optionType`) = c("SWIGFunction", class('PlainVanillaPayoff_optionType'))

# Start of PlainVanillaPayoff_strike

`PlainVanillaPayoff_strike` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_PlainVanillaPayoff_strike', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`PlainVanillaPayoff_strike`, 'returnType') = 'numeric'
attr(`PlainVanillaPayoff_strike`, "inputTypes") = c('_p_PlainVanillaPayoffPtr')
class(`PlainVanillaPayoff_strike`) = c("SWIGFunction", class('PlainVanillaPayoff_strike'))

# Start of delete_PlainVanillaPayoff

`delete_PlainVanillaPayoff` = function(self)
{
  ;.Call('R_swig_delete_PlainVanillaPayoff', self, PACKAGE='QuantLib');
  
}

attr(`delete_PlainVanillaPayoff`, 'returnType') = 'void'
attr(`delete_PlainVanillaPayoff`, "inputTypes") = c('_p_PlainVanillaPayoffPtr')
class(`delete_PlainVanillaPayoff`) = c("SWIGFunction", class('delete_PlainVanillaPayoff'))

# Start of accessor method for PlainVanillaPayoffPtr
setMethod('$', '_p_PlainVanillaPayoffPtr', function(x, name)

{
  accessorFuns = list('optionType' = PlainVanillaPayoff_optionType, 'strike' = PlainVanillaPayoff_strike);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for PlainVanillaPayoffPtr
setMethod('delete', '_p_PlainVanillaPayoffPtr', function(obj) {delete_PlainVanillaPayoffPtr(obj)})
# Start of new_PercentageStrikePayoff

`PercentageStrikePayoff` = function(type, moneyness)
{
  type = enumToInteger(type, "_Option__Type"); 
  
  if(length(type) > 1) {
    warning("using only the first element of type");
  };
  
  
  ;ans = .Call('R_swig_new_PercentageStrikePayoff', type, moneyness, PACKAGE='QuantLib');
  class(ans) <- "_p_PercentageStrikePayoffPtr";
  
  reg.finalizer(ans, delete_PercentageStrikePayoff)
  ans
  
}

attr(`PercentageStrikePayoff`, 'returnType') = '_p_PercentageStrikePayoffPtr'
attr(`PercentageStrikePayoff`, "inputTypes") = c('character', 'numeric')
class(`PercentageStrikePayoff`) = c("SWIGFunction", class('PercentageStrikePayoff'))

# Start of delete_PercentageStrikePayoff

`delete_PercentageStrikePayoff` = function(self)
{
  ;.Call('R_swig_delete_PercentageStrikePayoff', self, PACKAGE='QuantLib');
  
}

attr(`delete_PercentageStrikePayoff`, 'returnType') = 'void'
attr(`delete_PercentageStrikePayoff`, "inputTypes") = c('_p_PercentageStrikePayoffPtr')
class(`delete_PercentageStrikePayoff`) = c("SWIGFunction", class('delete_PercentageStrikePayoff'))

setMethod('delete', '_p_PercentageStrikePayoffPtr', function(obj) {delete_PercentageStrikePayoffPtr(obj)})
# Start of new_CashOrNothingPayoff

`CashOrNothingPayoff` = function(type, strike, payoff)
{
  type = enumToInteger(type, "_Option__Type"); 
  
  if(length(type) > 1) {
    warning("using only the first element of type");
  };
  
  
  
  ;ans = .Call('R_swig_new_CashOrNothingPayoff', type, strike, payoff, PACKAGE='QuantLib');
  class(ans) <- "_p_CashOrNothingPayoffPtr";
  
  reg.finalizer(ans, delete_CashOrNothingPayoff)
  ans
  
}

attr(`CashOrNothingPayoff`, 'returnType') = '_p_CashOrNothingPayoffPtr'
attr(`CashOrNothingPayoff`, "inputTypes") = c('character', 'numeric', 'numeric')
class(`CashOrNothingPayoff`) = c("SWIGFunction", class('CashOrNothingPayoff'))

# Start of delete_CashOrNothingPayoff

`delete_CashOrNothingPayoff` = function(self)
{
  ;.Call('R_swig_delete_CashOrNothingPayoff', self, PACKAGE='QuantLib');
  
}

attr(`delete_CashOrNothingPayoff`, 'returnType') = 'void'
attr(`delete_CashOrNothingPayoff`, "inputTypes") = c('_p_CashOrNothingPayoffPtr')
class(`delete_CashOrNothingPayoff`) = c("SWIGFunction", class('delete_CashOrNothingPayoff'))

setMethod('delete', '_p_CashOrNothingPayoffPtr', function(obj) {delete_CashOrNothingPayoffPtr(obj)})
# Start of new_AssetOrNothingPayoff

`AssetOrNothingPayoff` = function(type, strike)
{
  type = enumToInteger(type, "_Option__Type"); 
  
  if(length(type) > 1) {
    warning("using only the first element of type");
  };
  
  
  ;ans = .Call('R_swig_new_AssetOrNothingPayoff', type, strike, PACKAGE='QuantLib');
  class(ans) <- "_p_AssetOrNothingPayoffPtr";
  
  reg.finalizer(ans, delete_AssetOrNothingPayoff)
  ans
  
}

attr(`AssetOrNothingPayoff`, 'returnType') = '_p_AssetOrNothingPayoffPtr'
attr(`AssetOrNothingPayoff`, "inputTypes") = c('character', 'numeric')
class(`AssetOrNothingPayoff`) = c("SWIGFunction", class('AssetOrNothingPayoff'))

# Start of delete_AssetOrNothingPayoff

`delete_AssetOrNothingPayoff` = function(self)
{
  ;.Call('R_swig_delete_AssetOrNothingPayoff', self, PACKAGE='QuantLib');
  
}

attr(`delete_AssetOrNothingPayoff`, 'returnType') = 'void'
attr(`delete_AssetOrNothingPayoff`, "inputTypes") = c('_p_AssetOrNothingPayoffPtr')
class(`delete_AssetOrNothingPayoff`) = c("SWIGFunction", class('delete_AssetOrNothingPayoff'))

setMethod('delete', '_p_AssetOrNothingPayoffPtr', function(obj) {delete_AssetOrNothingPayoffPtr(obj)})
# Start of new_SuperSharePayoff

`SuperSharePayoff` = function(type, strike, increment)
{
  type = enumToInteger(type, "_Option__Type"); 
  
  if(length(type) > 1) {
    warning("using only the first element of type");
  };
  
  
  
  ;ans = .Call('R_swig_new_SuperSharePayoff', type, strike, increment, PACKAGE='QuantLib');
  class(ans) <- "_p_SuperSharePayoffPtr";
  
  reg.finalizer(ans, delete_SuperSharePayoff)
  ans
  
}

attr(`SuperSharePayoff`, 'returnType') = '_p_SuperSharePayoffPtr'
attr(`SuperSharePayoff`, "inputTypes") = c('character', 'numeric', 'numeric')
class(`SuperSharePayoff`) = c("SWIGFunction", class('SuperSharePayoff'))

# Start of delete_SuperSharePayoff

`delete_SuperSharePayoff` = function(self)
{
  ;.Call('R_swig_delete_SuperSharePayoff', self, PACKAGE='QuantLib');
  
}

attr(`delete_SuperSharePayoff`, 'returnType') = 'void'
attr(`delete_SuperSharePayoff`, "inputTypes") = c('_p_SuperSharePayoffPtr')
class(`delete_SuperSharePayoff`) = c("SWIGFunction", class('delete_SuperSharePayoff'))

setMethod('delete', '_p_SuperSharePayoffPtr', function(obj) {delete_SuperSharePayoffPtr(obj)})
# Start of new_GapPayoff

`GapPayoff` = function(type, strike, strikePayoff)
{
  type = enumToInteger(type, "_Option__Type"); 
  
  if(length(type) > 1) {
    warning("using only the first element of type");
  };
  
  
  
  ;ans = .Call('R_swig_new_GapPayoff', type, strike, strikePayoff, PACKAGE='QuantLib');
  class(ans) <- "_p_GapPayoffPtr";
  
  reg.finalizer(ans, delete_GapPayoff)
  ans
  
}

attr(`GapPayoff`, 'returnType') = '_p_GapPayoffPtr'
attr(`GapPayoff`, "inputTypes") = c('character', 'numeric', 'numeric')
class(`GapPayoff`) = c("SWIGFunction", class('GapPayoff'))

# Start of delete_GapPayoff

`delete_GapPayoff` = function(self)
{
  ;.Call('R_swig_delete_GapPayoff', self, PACKAGE='QuantLib');
  
}

attr(`delete_GapPayoff`, 'returnType') = 'void'
attr(`delete_GapPayoff`, "inputTypes") = c('_p_GapPayoffPtr')
class(`delete_GapPayoff`) = c("SWIGFunction", class('delete_GapPayoff'))

setMethod('delete', '_p_GapPayoffPtr', function(obj) {delete_GapPayoffPtr(obj)})
# Start of new_BasketPayoff

`BasketPayoff` = function()
{
  ;ans = .Call('R_swig_new_BasketPayoff', PACKAGE='QuantLib');
  class(ans) <- "_p_BasketPayoffPtr";
  
  reg.finalizer(ans, delete_BasketPayoff)
  ans
  
}

attr(`BasketPayoff`, 'returnType') = '_p_BasketPayoffPtr'
class(`BasketPayoff`) = c("SWIGFunction", class('BasketPayoff'))

# Start of delete_BasketPayoff

`delete_BasketPayoff` = function(self)
{
  ;.Call('R_swig_delete_BasketPayoff', self, PACKAGE='QuantLib');
  
}

attr(`delete_BasketPayoff`, 'returnType') = 'void'
attr(`delete_BasketPayoff`, "inputTypes") = c('_p_BasketPayoffPtr')
class(`delete_BasketPayoff`) = c("SWIGFunction", class('delete_BasketPayoff'))

setMethod('delete', '_p_BasketPayoffPtr', function(obj) {delete_BasketPayoffPtr(obj)})
# Start of new_MinBasketPayoff

`MinBasketPayoff` = function(p)
{
  ;ans = .Call('R_swig_new_MinBasketPayoff', p, PACKAGE='QuantLib');
  class(ans) <- "_p_MinBasketPayoffPtr";
  
  reg.finalizer(ans, delete_MinBasketPayoff)
  ans
  
}

attr(`MinBasketPayoff`, 'returnType') = '_p_MinBasketPayoffPtr'
attr(`MinBasketPayoff`, "inputTypes") = c('_p_boost__shared_ptrT_Payoff_t')
class(`MinBasketPayoff`) = c("SWIGFunction", class('MinBasketPayoff'))

# Start of delete_MinBasketPayoff

`delete_MinBasketPayoff` = function(self)
{
  ;.Call('R_swig_delete_MinBasketPayoff', self, PACKAGE='QuantLib');
  
}

attr(`delete_MinBasketPayoff`, 'returnType') = 'void'
attr(`delete_MinBasketPayoff`, "inputTypes") = c('_p_MinBasketPayoffPtr')
class(`delete_MinBasketPayoff`) = c("SWIGFunction", class('delete_MinBasketPayoff'))

setMethod('delete', '_p_MinBasketPayoffPtr', function(obj) {delete_MinBasketPayoffPtr(obj)})
# Start of new_MaxBasketPayoff

`MaxBasketPayoff` = function(p)
{
  ;ans = .Call('R_swig_new_MaxBasketPayoff', p, PACKAGE='QuantLib');
  class(ans) <- "_p_MaxBasketPayoffPtr";
  
  reg.finalizer(ans, delete_MaxBasketPayoff)
  ans
  
}

attr(`MaxBasketPayoff`, 'returnType') = '_p_MaxBasketPayoffPtr'
attr(`MaxBasketPayoff`, "inputTypes") = c('_p_boost__shared_ptrT_Payoff_t')
class(`MaxBasketPayoff`) = c("SWIGFunction", class('MaxBasketPayoff'))

# Start of delete_MaxBasketPayoff

`delete_MaxBasketPayoff` = function(self)
{
  ;.Call('R_swig_delete_MaxBasketPayoff', self, PACKAGE='QuantLib');
  
}

attr(`delete_MaxBasketPayoff`, 'returnType') = 'void'
attr(`delete_MaxBasketPayoff`, "inputTypes") = c('_p_MaxBasketPayoffPtr')
class(`delete_MaxBasketPayoff`) = c("SWIGFunction", class('delete_MaxBasketPayoff'))

setMethod('delete', '_p_MaxBasketPayoffPtr', function(obj) {delete_MaxBasketPayoffPtr(obj)})
# Start of new_AverageBasketPayoff

`AverageBasketPayoff__SWIG_0` = function(p, a)
{
  ;ans = .Call('R_swig_new_AverageBasketPayoff__SWIG_0', p, a, PACKAGE='QuantLib');
  class(ans) <- "_p_AverageBasketPayoffPtr";
  
  reg.finalizer(ans, delete_AverageBasketPayoff)
  ans
  
}

attr(`AverageBasketPayoff__SWIG_0`, 'returnType') = '_p_AverageBasketPayoffPtr'
attr(`AverageBasketPayoff__SWIG_0`, "inputTypes") = c('_p_boost__shared_ptrT_Payoff_t', '_p_Array')
class(`AverageBasketPayoff__SWIG_0`) = c("SWIGFunction", class('AverageBasketPayoff__SWIG_0'))

# Start of new_AverageBasketPayoff

`AverageBasketPayoff__SWIG_1` = function(p, n)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;ans = .Call('R_swig_new_AverageBasketPayoff__SWIG_1', p, n, PACKAGE='QuantLib');
  class(ans) <- "_p_AverageBasketPayoffPtr";
  
  reg.finalizer(ans, delete_AverageBasketPayoff)
  ans
  
}

attr(`AverageBasketPayoff__SWIG_1`, 'returnType') = '_p_AverageBasketPayoffPtr'
attr(`AverageBasketPayoff__SWIG_1`, "inputTypes") = c('_p_boost__shared_ptrT_Payoff_t', 'integer')
class(`AverageBasketPayoff__SWIG_1`) = c("SWIGFunction", class('AverageBasketPayoff__SWIG_1'))

`AverageBasketPayoff` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_Payoff_t') && extends(argtypes[2], '_p_Array')) {
      f <- AverageBasketPayoff__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_boost__shared_ptrT_Payoff_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]]))) {
      f <- AverageBasketPayoff__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for AverageBasketPayoff with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_AverageBasketPayoff

`delete_AverageBasketPayoff` = function(self)
{
  ;.Call('R_swig_delete_AverageBasketPayoff', self, PACKAGE='QuantLib');
  
}

attr(`delete_AverageBasketPayoff`, 'returnType') = 'void'
attr(`delete_AverageBasketPayoff`, "inputTypes") = c('_p_AverageBasketPayoffPtr')
class(`delete_AverageBasketPayoff`) = c("SWIGFunction", class('delete_AverageBasketPayoff'))

setMethod('delete', '_p_AverageBasketPayoffPtr', function(obj) {delete_AverageBasketPayoffPtr(obj)})
# Start of new_BasketOption

`BasketOption` = function(payoff, exercise)
{
  ;ans = .Call('R_swig_new_BasketOption', payoff, exercise, PACKAGE='QuantLib');
  class(ans) <- "_p_BasketOptionPtr";
  
  reg.finalizer(ans, delete_BasketOption)
  ans
  
}

attr(`BasketOption`, 'returnType') = '_p_BasketOptionPtr'
attr(`BasketOption`, "inputTypes") = c('_p_boost__shared_ptrT_Payoff_t', '_p_boost__shared_ptrT_Exercise_t')
class(`BasketOption`) = c("SWIGFunction", class('BasketOption'))

# Start of delete_BasketOption

`delete_BasketOption` = function(self)
{
  ;.Call('R_swig_delete_BasketOption', self, PACKAGE='QuantLib');
  
}

attr(`delete_BasketOption`, 'returnType') = 'void'
attr(`delete_BasketOption`, "inputTypes") = c('_p_BasketOptionPtr')
class(`delete_BasketOption`) = c("SWIGFunction", class('delete_BasketOption'))

setMethod('delete', '_p_BasketOptionPtr', function(obj) {delete_BasketOptionPtr(obj)})
# Start of new_MCEuropeanBasketEngine

`MCEuropeanBasketEngine` = function(process, traits, timeSteps, timeStepsPerYear, brownianBridge, antitheticVariate, requiredSamples, requiredTolerance, maxSamples, seed)
{
  traits = as(traits, "character"); 
  
  
  if(length(timeSteps) > 1) {
    warning("using only the first element of timeSteps");
  };
  
  
  
  if(length(timeStepsPerYear) > 1) {
    warning("using only the first element of timeStepsPerYear");
  };
  
  brownianBridge = as.logical(brownianBridge);
  antitheticVariate = as.logical(antitheticVariate);
  as(input, "integer"); 
  as(input, "numeric"); 
  as(input, "integer"); 
  seed = as.integer(seed); 
  
  if(length(seed) > 1) {
    warning("using only the first element of seed");
  };
  
  ;ans = .Call('R_swig_new_MCEuropeanBasketEngine', process, traits, timeSteps, timeStepsPerYear, brownianBridge, antitheticVariate, requiredSamples, requiredTolerance, maxSamples, seed, PACKAGE='QuantLib');
  class(ans) <- "_p_MCEuropeanBasketEnginePtr";
  
  reg.finalizer(ans, delete_MCEuropeanBasketEngine)
  ans
  
}

attr(`MCEuropeanBasketEngine`, 'returnType') = '_p_MCEuropeanBasketEnginePtr'
attr(`MCEuropeanBasketEngine`, "inputTypes") = c('_p_StochasticProcessArrayPtr', 'character', 'integer', 'integer', 'logical', 'logical', 'numeric', 'numeric', 'numeric', 'integer')
class(`MCEuropeanBasketEngine`) = c("SWIGFunction", class('MCEuropeanBasketEngine'))

# Start of delete_MCEuropeanBasketEngine

`delete_MCEuropeanBasketEngine` = function(self)
{
  ;.Call('R_swig_delete_MCEuropeanBasketEngine', self, PACKAGE='QuantLib');
  
}

attr(`delete_MCEuropeanBasketEngine`, 'returnType') = 'void'
attr(`delete_MCEuropeanBasketEngine`, "inputTypes") = c('_p_MCEuropeanBasketEnginePtr')
class(`delete_MCEuropeanBasketEngine`) = c("SWIGFunction", class('delete_MCEuropeanBasketEngine'))

setMethod('delete', '_p_MCEuropeanBasketEnginePtr', function(obj) {delete_MCEuropeanBasketEnginePtr(obj)})
# Start of new_MCAmericanBasketEngine

`MCAmericanBasketEngine` = function(process, traits, timeSteps, timeStepsPerYear, brownianBridge, antitheticVariate, requiredSamples, requiredTolerance, maxSamples, seed)
{
  traits = as(traits, "character"); 
  
  
  if(length(timeSteps) > 1) {
    warning("using only the first element of timeSteps");
  };
  
  
  
  if(length(timeStepsPerYear) > 1) {
    warning("using only the first element of timeStepsPerYear");
  };
  
  brownianBridge = as.logical(brownianBridge);
  antitheticVariate = as.logical(antitheticVariate);
  as(input, "integer"); 
  as(input, "numeric"); 
  as(input, "integer"); 
  seed = as.integer(seed); 
  
  if(length(seed) > 1) {
    warning("using only the first element of seed");
  };
  
  ;ans = .Call('R_swig_new_MCAmericanBasketEngine', process, traits, timeSteps, timeStepsPerYear, brownianBridge, antitheticVariate, requiredSamples, requiredTolerance, maxSamples, seed, PACKAGE='QuantLib');
  class(ans) <- "_p_MCAmericanBasketEnginePtr";
  
  reg.finalizer(ans, delete_MCAmericanBasketEngine)
  ans
  
}

attr(`MCAmericanBasketEngine`, 'returnType') = '_p_MCAmericanBasketEnginePtr'
attr(`MCAmericanBasketEngine`, "inputTypes") = c('_p_StochasticProcessArrayPtr', 'character', 'integer', 'integer', 'logical', 'logical', 'numeric', 'numeric', 'numeric', 'integer')
class(`MCAmericanBasketEngine`) = c("SWIGFunction", class('MCAmericanBasketEngine'))

# Start of delete_MCAmericanBasketEngine

`delete_MCAmericanBasketEngine` = function(self)
{
  ;.Call('R_swig_delete_MCAmericanBasketEngine', self, PACKAGE='QuantLib');
  
}

attr(`delete_MCAmericanBasketEngine`, 'returnType') = 'void'
attr(`delete_MCAmericanBasketEngine`, "inputTypes") = c('_p_MCAmericanBasketEnginePtr')
class(`delete_MCAmericanBasketEngine`) = c("SWIGFunction", class('delete_MCAmericanBasketEngine'))

setMethod('delete', '_p_MCAmericanBasketEnginePtr', function(obj) {delete_MCAmericanBasketEnginePtr(obj)})
# Start of new_StulzEngine

`StulzEngine` = function(process1, process2, correlation)
{
  ;ans = .Call('R_swig_new_StulzEngine', process1, process2, correlation, PACKAGE='QuantLib');
  class(ans) <- "_p_StulzEnginePtr";
  
  reg.finalizer(ans, delete_StulzEngine)
  ans
  
}

attr(`StulzEngine`, 'returnType') = '_p_StulzEnginePtr'
attr(`StulzEngine`, "inputTypes") = c('_p_GeneralizedBlackScholesProcessPtr', '_p_GeneralizedBlackScholesProcessPtr', 'numeric')
class(`StulzEngine`) = c("SWIGFunction", class('StulzEngine'))

# Start of delete_StulzEngine

`delete_StulzEngine` = function(self)
{
  ;.Call('R_swig_delete_StulzEngine', self, PACKAGE='QuantLib');
  
}

attr(`delete_StulzEngine`, 'returnType') = 'void'
attr(`delete_StulzEngine`, "inputTypes") = c('_p_StulzEnginePtr')
class(`delete_StulzEngine`) = c("SWIGFunction", class('delete_StulzEngine'))

setMethod('delete', '_p_StulzEnginePtr', function(obj) {delete_StulzEnginePtr(obj)})
# Start of new_EverestOption

`EverestOption` = function(notional, guarantee, exercise)
{
  ;ans = .Call('R_swig_new_EverestOption', notional, guarantee, exercise, PACKAGE='QuantLib');
  class(ans) <- "_p_EverestOptionPtr";
  
  reg.finalizer(ans, delete_EverestOption)
  ans
  
}

attr(`EverestOption`, 'returnType') = '_p_EverestOptionPtr'
attr(`EverestOption`, "inputTypes") = c('numeric', 'numeric', '_p_boost__shared_ptrT_Exercise_t')
class(`EverestOption`) = c("SWIGFunction", class('EverestOption'))

# Start of delete_EverestOption

`delete_EverestOption` = function(self)
{
  ;.Call('R_swig_delete_EverestOption', self, PACKAGE='QuantLib');
  
}

attr(`delete_EverestOption`, 'returnType') = 'void'
attr(`delete_EverestOption`, "inputTypes") = c('_p_EverestOptionPtr')
class(`delete_EverestOption`) = c("SWIGFunction", class('delete_EverestOption'))

setMethod('delete', '_p_EverestOptionPtr', function(obj) {delete_EverestOptionPtr(obj)})
# Start of new_MCEverestEngine

`MCEverestEngine` = function(process, traits, timeSteps, timeStepsPerYear, brownianBridge, antitheticVariate, requiredSamples, requiredTolerance, maxSamples, seed)
{
  traits = as(traits, "character"); 
  
  
  if(length(timeSteps) > 1) {
    warning("using only the first element of timeSteps");
  };
  
  
  
  if(length(timeStepsPerYear) > 1) {
    warning("using only the first element of timeStepsPerYear");
  };
  
  brownianBridge = as.logical(brownianBridge);
  antitheticVariate = as.logical(antitheticVariate);
  as(input, "integer"); 
  as(input, "numeric"); 
  as(input, "integer"); 
  seed = as.integer(seed); 
  
  if(length(seed) > 1) {
    warning("using only the first element of seed");
  };
  
  ;ans = .Call('R_swig_new_MCEverestEngine', process, traits, timeSteps, timeStepsPerYear, brownianBridge, antitheticVariate, requiredSamples, requiredTolerance, maxSamples, seed, PACKAGE='QuantLib');
  class(ans) <- "_p_MCEverestEnginePtr";
  
  reg.finalizer(ans, delete_MCEverestEngine)
  ans
  
}

attr(`MCEverestEngine`, 'returnType') = '_p_MCEverestEnginePtr'
attr(`MCEverestEngine`, "inputTypes") = c('_p_StochasticProcessArrayPtr', 'character', 'integer', 'integer', 'logical', 'logical', 'numeric', 'numeric', 'numeric', 'integer')
class(`MCEverestEngine`) = c("SWIGFunction", class('MCEverestEngine'))

# Start of delete_MCEverestEngine

`delete_MCEverestEngine` = function(self)
{
  ;.Call('R_swig_delete_MCEverestEngine', self, PACKAGE='QuantLib');
  
}

attr(`delete_MCEverestEngine`, 'returnType') = 'void'
attr(`delete_MCEverestEngine`, "inputTypes") = c('_p_MCEverestEnginePtr')
class(`delete_MCEverestEngine`) = c("SWIGFunction", class('delete_MCEverestEngine'))

setMethod('delete', '_p_MCEverestEnginePtr', function(obj) {delete_MCEverestEnginePtr(obj)})
# Start of new_HimalayaOption

`HimalayaOption` = function(fixingDates, strike)
{
  ;ans = .Call('R_swig_new_HimalayaOption', fixingDates, strike, PACKAGE='QuantLib');
  class(ans) <- "_p_HimalayaOptionPtr";
  
  reg.finalizer(ans, delete_HimalayaOption)
  ans
  
}

attr(`HimalayaOption`, 'returnType') = '_p_HimalayaOptionPtr'
attr(`HimalayaOption`, "inputTypes") = c('_p_std__vectorT_Date_std__allocatorT_Date_t_t', 'numeric')
class(`HimalayaOption`) = c("SWIGFunction", class('HimalayaOption'))

# Start of delete_HimalayaOption

`delete_HimalayaOption` = function(self)
{
  ;.Call('R_swig_delete_HimalayaOption', self, PACKAGE='QuantLib');
  
}

attr(`delete_HimalayaOption`, 'returnType') = 'void'
attr(`delete_HimalayaOption`, "inputTypes") = c('_p_HimalayaOptionPtr')
class(`delete_HimalayaOption`) = c("SWIGFunction", class('delete_HimalayaOption'))

setMethod('delete', '_p_HimalayaOptionPtr', function(obj) {delete_HimalayaOptionPtr(obj)})
# Start of new_MCHimalayaEngine

`MCHimalayaEngine` = function(process, traits, brownianBridge, antitheticVariate, requiredSamples, requiredTolerance, maxSamples, seed)
{
  traits = as(traits, "character"); 
  brownianBridge = as.logical(brownianBridge);
  antitheticVariate = as.logical(antitheticVariate);
  as(input, "integer"); 
  as(input, "numeric"); 
  as(input, "integer"); 
  seed = as.integer(seed); 
  
  if(length(seed) > 1) {
    warning("using only the first element of seed");
  };
  
  ;ans = .Call('R_swig_new_MCHimalayaEngine', process, traits, brownianBridge, antitheticVariate, requiredSamples, requiredTolerance, maxSamples, seed, PACKAGE='QuantLib');
  class(ans) <- "_p_MCHimalayaEnginePtr";
  
  reg.finalizer(ans, delete_MCHimalayaEngine)
  ans
  
}

attr(`MCHimalayaEngine`, 'returnType') = '_p_MCHimalayaEnginePtr'
attr(`MCHimalayaEngine`, "inputTypes") = c('_p_StochasticProcessArrayPtr', 'character', 'logical', 'logical', 'numeric', 'numeric', 'numeric', 'integer')
class(`MCHimalayaEngine`) = c("SWIGFunction", class('MCHimalayaEngine'))

# Start of delete_MCHimalayaEngine

`delete_MCHimalayaEngine` = function(self)
{
  ;.Call('R_swig_delete_MCHimalayaEngine', self, PACKAGE='QuantLib');
  
}

attr(`delete_MCHimalayaEngine`, 'returnType') = 'void'
attr(`delete_MCHimalayaEngine`, "inputTypes") = c('_p_MCHimalayaEnginePtr')
class(`delete_MCHimalayaEngine`) = c("SWIGFunction", class('delete_MCHimalayaEngine'))

setMethod('delete', '_p_MCHimalayaEnginePtr', function(obj) {delete_MCHimalayaEnginePtr(obj)})
defineEnumeration('_DateGeneration__Rule',
                    .values = c(
                        'Backward' = 0, 
                        'Forward' = 1, 
                        'Zero' = 2, 
                        'ThirdWednesday' = 3, 
                        'Twentieth' = 4, 
                        'TwentiethIMM' = 5, 
                        'OldCDS' = 6
))
# Start of new_DateGeneration

`DateGeneration` = function()
{
  ;ans = .Call('R_swig_new_DateGeneration', PACKAGE='QuantLib');
  class(ans) <- "_p_DateGeneration";
  
  reg.finalizer(ans, delete_DateGeneration)
  ans
  
}

attr(`DateGeneration`, 'returnType') = '_p_DateGeneration'
class(`DateGeneration`) = c("SWIGFunction", class('DateGeneration'))

# Start of delete_DateGeneration

`delete_DateGeneration` = function(self)
{
  ;.Call('R_swig_delete_DateGeneration', self, PACKAGE='QuantLib');
  
}

attr(`delete_DateGeneration`, 'returnType') = 'void'
attr(`delete_DateGeneration`, "inputTypes") = c('_p_DateGeneration')
class(`delete_DateGeneration`) = c("SWIGFunction", class('delete_DateGeneration'))

setMethod('delete', '_p_DateGeneration', function(obj) {delete_DateGeneration(obj)})
# Start definition of copy functions & methods for DateGeneration
CopyToR_DateGeneration = function(value, obj = new("DateGeneration"))
{
  obj;
}



CopyToC_DateGeneration = function(value, obj)
{
  obj
}



# Start definition of copy methods for DateGeneration
setMethod('copyToR', '_p_DateGeneration', CopyToR_DateGeneration);
setMethod('copyToC', 'DateGeneration', CopyToC_DateGeneration);

# End definition of copy methods for DateGeneration
# End definition of copy functions & methods for DateGeneration
# Start of new_Schedule

`Schedule__SWIG_0` = function(s_arg1, calendar, rollingConvention)
{
  rollingConvention = enumToInteger(rollingConvention, "_BusinessDayConvention"); 
  
  if(length(rollingConvention) > 1) {
    warning("using only the first element of rollingConvention");
  };
  
  ;ans = .Call('R_swig_new_Schedule__SWIG_0', s_arg1, calendar, rollingConvention, PACKAGE='QuantLib');
  class(ans) <- "_p_Schedule";
  
  reg.finalizer(ans, delete_Schedule)
  ans
  
}

attr(`Schedule__SWIG_0`, 'returnType') = '_p_Schedule'
attr(`Schedule__SWIG_0`, "inputTypes") = c('_p_std__vectorT_Date_std__allocatorT_Date_t_t', '_p_Calendar', 'character')
class(`Schedule__SWIG_0`) = c("SWIGFunction", class('Schedule__SWIG_0'))

# Start of new_Schedule

`Schedule__SWIG_1` = function(effectiveDate, terminationDate, tenor, calendar, convention, terminationDateConvention, rule, endOfMonth, firstDate, nextToLastDate)
{
  convention = enumToInteger(convention, "_BusinessDayConvention"); 
  
  if(length(convention) > 1) {
    warning("using only the first element of convention");
  };
  
  terminationDateConvention = enumToInteger(terminationDateConvention, "_BusinessDayConvention"); 
  
  if(length(terminationDateConvention) > 1) {
    warning("using only the first element of terminationDateConvention");
  };
  
  rule = enumToInteger(rule, "_DateGeneration__Rule"); 
  
  if(length(rule) > 1) {
    warning("using only the first element of rule");
  };
  
  endOfMonth = as.logical(endOfMonth);
  
  
  ;ans = .Call('R_swig_new_Schedule__SWIG_1', effectiveDate, terminationDate, tenor, calendar, convention, terminationDateConvention, rule, endOfMonth, firstDate, nextToLastDate, PACKAGE='QuantLib');
  class(ans) <- "_p_Schedule";
  
  reg.finalizer(ans, delete_Schedule)
  ans
  
}

attr(`Schedule__SWIG_1`, 'returnType') = '_p_Schedule'
attr(`Schedule__SWIG_1`, "inputTypes") = c('_p_Date', '_p_Date', '_p_Period', '_p_Calendar', 'character', 'character', 'character', 'logical', '_p_Date', '_p_Date')
class(`Schedule__SWIG_1`) = c("SWIGFunction", class('Schedule__SWIG_1'))

# Start of new_Schedule

`Schedule__SWIG_2` = function(effectiveDate, terminationDate, tenor, calendar, convention, terminationDateConvention, rule, endOfMonth, firstDate)
{
  convention = enumToInteger(convention, "_BusinessDayConvention"); 
  
  if(length(convention) > 1) {
    warning("using only the first element of convention");
  };
  
  terminationDateConvention = enumToInteger(terminationDateConvention, "_BusinessDayConvention"); 
  
  if(length(terminationDateConvention) > 1) {
    warning("using only the first element of terminationDateConvention");
  };
  
  rule = enumToInteger(rule, "_DateGeneration__Rule"); 
  
  if(length(rule) > 1) {
    warning("using only the first element of rule");
  };
  
  endOfMonth = as.logical(endOfMonth);
  
  ;ans = .Call('R_swig_new_Schedule__SWIG_2', effectiveDate, terminationDate, tenor, calendar, convention, terminationDateConvention, rule, endOfMonth, firstDate, PACKAGE='QuantLib');
  class(ans) <- "_p_Schedule";
  
  reg.finalizer(ans, delete_Schedule)
  ans
  
}

attr(`Schedule__SWIG_2`, 'returnType') = '_p_Schedule'
attr(`Schedule__SWIG_2`, "inputTypes") = c('_p_Date', '_p_Date', '_p_Period', '_p_Calendar', 'character', 'character', 'character', 'logical', '_p_Date')
class(`Schedule__SWIG_2`) = c("SWIGFunction", class('Schedule__SWIG_2'))

# Start of new_Schedule

`Schedule__SWIG_3` = function(effectiveDate, terminationDate, tenor, calendar, convention, terminationDateConvention, rule, endOfMonth)
{
  convention = enumToInteger(convention, "_BusinessDayConvention"); 
  
  if(length(convention) > 1) {
    warning("using only the first element of convention");
  };
  
  terminationDateConvention = enumToInteger(terminationDateConvention, "_BusinessDayConvention"); 
  
  if(length(terminationDateConvention) > 1) {
    warning("using only the first element of terminationDateConvention");
  };
  
  rule = enumToInteger(rule, "_DateGeneration__Rule"); 
  
  if(length(rule) > 1) {
    warning("using only the first element of rule");
  };
  
  endOfMonth = as.logical(endOfMonth);
  ;ans = .Call('R_swig_new_Schedule__SWIG_3', effectiveDate, terminationDate, tenor, calendar, convention, terminationDateConvention, rule, endOfMonth, PACKAGE='QuantLib');
  class(ans) <- "_p_Schedule";
  
  reg.finalizer(ans, delete_Schedule)
  ans
  
}

attr(`Schedule__SWIG_3`, 'returnType') = '_p_Schedule'
attr(`Schedule__SWIG_3`, "inputTypes") = c('_p_Date', '_p_Date', '_p_Period', '_p_Calendar', 'character', 'character', 'character', 'logical')
class(`Schedule__SWIG_3`) = c("SWIGFunction", class('Schedule__SWIG_3'))

# Start of new_Schedule

`Schedule__SWIG_4` = function()
{
  ;ans = .Call('R_swig_new_Schedule__SWIG_4', PACKAGE='QuantLib');
  class(ans) <- "_p_Schedule";
  
  reg.finalizer(ans, delete_Schedule)
  ans
  
}

attr(`Schedule__SWIG_4`, 'returnType') = '_p_Schedule'
class(`Schedule__SWIG_4`) = c("SWIGFunction", class('Schedule__SWIG_4'))

`Schedule` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 5
  if (argc == 0) {
    f <- Schedule__SWIG_4; 
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_std__vectorT_Date_std__allocatorT_Date_t_t') && extends(argtypes[2], '_p_Calendar') && is.character(argv[[3]])) {
      f <- Schedule__SWIG_0; 
    }
  } else if (argc == 8) {
    if (extends(argtypes[1], '_p_Date') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_Period') && extends(argtypes[4], '_p_Calendar') && is.character(argv[[5]]) && is.character(argv[[6]]) && is.character(argv[[7]]) && extends(argtypes[8], 'logical')) {
      f <- Schedule__SWIG_3; 
    }
  } else if (argc == 9) {
    if (extends(argtypes[1], '_p_Date') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_Period') && extends(argtypes[4], '_p_Calendar') && is.character(argv[[5]]) && is.character(argv[[6]]) && is.character(argv[[7]]) && extends(argtypes[8], 'logical') && extends(argtypes[9], '_p_Date')) {
      f <- Schedule__SWIG_2; 
    }
  } else if (argc == 10) {
    if (extends(argtypes[1], '_p_Date') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_Period') && extends(argtypes[4], '_p_Calendar') && is.character(argv[[5]]) && is.character(argv[[6]]) && is.character(argv[[7]]) && extends(argtypes[8], 'logical') && extends(argtypes[9], '_p_Date') && extends(argtypes[10], '_p_Date')) {
      f <- Schedule__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for Schedule with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of Schedule_size

`Schedule_size` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_Schedule_size', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__size_t";
  
  ans
  
}

attr(`Schedule_size`, 'returnType') = 'integer'
attr(`Schedule_size`, "inputTypes") = c('_p_Schedule')
class(`Schedule_size`) = c("SWIGFunction", class('Schedule_size'))

# Start of Schedule_date

`Schedule_date` = function(self, i, .copy = FALSE)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;ans = .Call('R_swig_Schedule_date', self, i, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`Schedule_date`, 'returnType') = '_p_Date'
attr(`Schedule_date`, "inputTypes") = c('_p_Schedule', 'integer')
class(`Schedule_date`) = c("SWIGFunction", class('Schedule_date'))

# Start of Schedule_isRegular

`Schedule_isRegular` = function(self, i, .copy = FALSE)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_Schedule_isRegular', self, i, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Schedule_isRegular`, 'returnType') = 'logical'
attr(`Schedule_isRegular`, "inputTypes") = c('_p_Schedule', 'integer')
class(`Schedule_isRegular`) = c("SWIGFunction", class('Schedule_isRegular'))

# Start of delete_Schedule

`delete_Schedule` = function(self)
{
  ;.Call('R_swig_delete_Schedule', self, PACKAGE='QuantLib');
  
}

attr(`delete_Schedule`, 'returnType') = 'void'
attr(`delete_Schedule`, "inputTypes") = c('_p_Schedule')
class(`delete_Schedule`) = c("SWIGFunction", class('delete_Schedule'))

# Start of accessor method for Schedule
setMethod('$', '_p_Schedule', function(x, name)

{
  accessorFuns = list('size' = Schedule_size, 'date' = Schedule_date, 'isRegular' = Schedule_isRegular);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for Schedule
setMethod('delete', '_p_Schedule', function(obj) {delete_Schedule(obj)})
# Start of CashFlow___deref__

`CashFlow___deref__` = function(self)
{
  ;ans = .Call('R_swig_CashFlow___deref__', self, PACKAGE='QuantLib');
  class(ans) <- "_p_CashFlow";
  
  ans
  
}

attr(`CashFlow___deref__`, 'returnType') = '_p_CashFlow'
attr(`CashFlow___deref__`, "inputTypes") = c('_p_boost__shared_ptrT_CashFlow_t')
class(`CashFlow___deref__`) = c("SWIGFunction", class('CashFlow___deref__'))

# Start of CashFlow_isNull

`CashFlow_isNull` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_CashFlow_isNull', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CashFlow_isNull`, 'returnType') = 'logical'
attr(`CashFlow_isNull`, "inputTypes") = c('_p_boost__shared_ptrT_CashFlow_t')
class(`CashFlow_isNull`) = c("SWIGFunction", class('CashFlow_isNull'))

# Start of CashFlow_asObservable

`CashFlow_asObservable` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_CashFlow_asObservable', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_Observable_t";
  
  ans
  
}

attr(`CashFlow_asObservable`, 'returnType') = '_p_boost__shared_ptrT_Observable_t'
attr(`CashFlow_asObservable`, "inputTypes") = c('_p_boost__shared_ptrT_CashFlow_t')
class(`CashFlow_asObservable`) = c("SWIGFunction", class('CashFlow_asObservable'))

# Start of new_CashFlow

`CashFlow` = function()
{
  ;ans = .Call('R_swig_new_CashFlow', PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_CashFlow_t";
  
  reg.finalizer(ans, delete_CashFlow)
  ans
  
}

attr(`CashFlow`, 'returnType') = '_p_boost__shared_ptrT_CashFlow_t'
class(`CashFlow`) = c("SWIGFunction", class('CashFlow'))

# Start of delete_CashFlow

`delete_CashFlow` = function(self)
{
  ;.Call('R_swig_delete_CashFlow', self, PACKAGE='QuantLib');
  
}

attr(`delete_CashFlow`, 'returnType') = 'void'
attr(`delete_CashFlow`, "inputTypes") = c('_p_boost__shared_ptrT_CashFlow_t')
class(`delete_CashFlow`) = c("SWIGFunction", class('delete_CashFlow'))

# Start of CashFlow_amount

`CashFlow_amount` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_CashFlow_amount', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CashFlow_amount`, 'returnType') = 'numeric'
attr(`CashFlow_amount`, "inputTypes") = c('_p_boost__shared_ptrT_CashFlow_t')
class(`CashFlow_amount`) = c("SWIGFunction", class('CashFlow_amount'))

# Start of CashFlow_date

`CashFlow_date` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_CashFlow_date', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`CashFlow_date`, 'returnType') = '_p_Date'
attr(`CashFlow_date`, "inputTypes") = c('_p_boost__shared_ptrT_CashFlow_t')
class(`CashFlow_date`) = c("SWIGFunction", class('CashFlow_date'))

# Start of accessor method for boost::shared_ptr<(CashFlow)>
setMethod('$', '_p_boost__shared_ptrT_CashFlow_t', function(x, name)

{
  accessorFuns = list('__deref__' = CashFlow___deref__, 'isNull' = CashFlow_isNull, 'asObservable' = CashFlow_asObservable, 'amount' = CashFlow_amount, 'date' = CashFlow_date);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for boost::shared_ptr<(CashFlow)>
setMethod('delete', '_p_boost__shared_ptrT_CashFlow_t', function(obj) {delete_boost__shared_ptrT_CashFlow_t(obj)})
# Start of Leg___nonzero__

`Leg___nonzero__` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Leg___nonzero__', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Leg___nonzero__`, 'returnType') = 'logical'
attr(`Leg___nonzero__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t')
class(`Leg___nonzero__`) = c("SWIGFunction", class('Leg___nonzero__'))

# Start of Leg___len__

`Leg___len__` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_Leg___len__', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`Leg___len__`, 'returnType') = 'integer'
attr(`Leg___len__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t')
class(`Leg___len__`) = c("SWIGFunction", class('Leg___len__'))

# Start of Leg_pop

`Leg_pop` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_Leg_pop', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_CashFlow_t";
  
  ans
  
}

attr(`Leg_pop`, 'returnType') = '_p_boost__shared_ptrT_CashFlow_t'
attr(`Leg_pop`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t')
class(`Leg_pop`) = c("SWIGFunction", class('Leg_pop'))

# Start of Leg___getslice__

`Leg___getslice__` = function(self, i, j)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;ans = .Call('R_swig_Leg___getslice__', self, i, j, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t";
  
  ans
  
}

attr(`Leg___getslice__`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t'
attr(`Leg___getslice__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', 'integer', 'integer')
class(`Leg___getslice__`) = c("SWIGFunction", class('Leg___getslice__'))

# Start of Leg___setslice__

`Leg___setslice__` = function(self, i, j, v)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  
  ;.Call('R_swig_Leg___setslice__', self, i, j, v, PACKAGE='QuantLib');
  
}

attr(`Leg___setslice__`, 'returnType') = 'void'
attr(`Leg___setslice__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', 'integer', 'integer', '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t')
class(`Leg___setslice__`) = c("SWIGFunction", class('Leg___setslice__'))

# Start of Leg___delslice__

`Leg___delslice__` = function(self, i, j)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_Leg___delslice__', self, i, j, PACKAGE='QuantLib');
  
}

attr(`Leg___delslice__`, 'returnType') = 'void'
attr(`Leg___delslice__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', 'integer', 'integer')
class(`Leg___delslice__`) = c("SWIGFunction", class('Leg___delslice__'))

# Start of Leg___delitem__

`Leg___delitem__` = function(self, i)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_Leg___delitem__', self, i, PACKAGE='QuantLib');
  
}

attr(`Leg___delitem__`, 'returnType') = 'void'
attr(`Leg___delitem__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', 'integer')
class(`Leg___delitem__`) = c("SWIGFunction", class('Leg___delitem__'))

# Start of Leg___getitem__

`Leg___getitem__` = function(self, i, .copy = FALSE)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;ans = .Call('R_swig_Leg___getitem__', self, i, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_CashFlow_t";
  
  ans
  
}

attr(`Leg___getitem__`, 'returnType') = '_p_boost__shared_ptrT_CashFlow_t'
attr(`Leg___getitem__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', 'integer')
class(`Leg___getitem__`) = c("SWIGFunction", class('Leg___getitem__'))

# Start of Leg___setitem__

`Leg___setitem__` = function(self, i, x)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  ;.Call('R_swig_Leg___setitem__', self, i, x, PACKAGE='QuantLib');
  
}

attr(`Leg___setitem__`, 'returnType') = 'void'
attr(`Leg___setitem__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', 'integer', '_p_boost__shared_ptrT_CashFlow_t')
class(`Leg___setitem__`) = c("SWIGFunction", class('Leg___setitem__'))

# Start of Leg_append

`Leg_append` = function(self, x)
{
  ;.Call('R_swig_Leg_append', self, x, PACKAGE='QuantLib');
  
}

attr(`Leg_append`, 'returnType') = 'void'
attr(`Leg_append`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', '_p_boost__shared_ptrT_CashFlow_t')
class(`Leg_append`) = c("SWIGFunction", class('Leg_append'))

# Start of new_Leg

`Leg__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_Leg__SWIG_0', PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t";
  
  reg.finalizer(ans, delete_Leg)
  ans
  
}

attr(`Leg__SWIG_0`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t'
class(`Leg__SWIG_0`) = c("SWIGFunction", class('Leg__SWIG_0'))

# Start of new_Leg

`Leg__SWIG_1` = function(s_arg1)
{
  ;ans = .Call('R_swig_new_Leg__SWIG_1', s_arg1, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t";
  
  reg.finalizer(ans, delete_Leg)
  ans
  
}

attr(`Leg__SWIG_1`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t'
attr(`Leg__SWIG_1`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t')
class(`Leg__SWIG_1`) = c("SWIGFunction", class('Leg__SWIG_1'))

# Start of Leg_empty

`Leg_empty` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Leg_empty', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Leg_empty`, 'returnType') = 'logical'
attr(`Leg_empty`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t')
class(`Leg_empty`) = c("SWIGFunction", class('Leg_empty'))

# Start of Leg_size

`Leg_size` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_Leg_size', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`Leg_size`, 'returnType') = 'integer'
attr(`Leg_size`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t')
class(`Leg_size`) = c("SWIGFunction", class('Leg_size'))

# Start of Leg_clear

`Leg_clear` = function(self)
{
  ;.Call('R_swig_Leg_clear', self, PACKAGE='QuantLib');
  
}

attr(`Leg_clear`, 'returnType') = 'void'
attr(`Leg_clear`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t')
class(`Leg_clear`) = c("SWIGFunction", class('Leg_clear'))

# Start of Leg_swap

`Leg_swap` = function(self, v)
{
  ;.Call('R_swig_Leg_swap', self, v, PACKAGE='QuantLib');
  
}

attr(`Leg_swap`, 'returnType') = 'void'
attr(`Leg_swap`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t')
class(`Leg_swap`) = c("SWIGFunction", class('Leg_swap'))

# Start of Leg_get_allocator

`Leg_get_allocator` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_Leg_get_allocator', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__allocatorT_boost__shared_ptrT_CashFlow_t_t";
  
  ans
  
}

attr(`Leg_get_allocator`, 'returnType') = '_p_std__allocatorT_boost__shared_ptrT_CashFlow_t_t'
attr(`Leg_get_allocator`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t')
class(`Leg_get_allocator`) = c("SWIGFunction", class('Leg_get_allocator'))

# Start of new_Leg

`Leg__SWIG_2` = function(size)
{
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_new_Leg__SWIG_2', size, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t";
  
  reg.finalizer(ans, delete_Leg)
  ans
  
}

attr(`Leg__SWIG_2`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t'
attr(`Leg__SWIG_2`, "inputTypes") = c('integer')
class(`Leg__SWIG_2`) = c("SWIGFunction", class('Leg__SWIG_2'))

# Start of Leg_pop_back

`Leg_pop_back` = function(self)
{
  ;.Call('R_swig_Leg_pop_back', self, PACKAGE='QuantLib');
  
}

attr(`Leg_pop_back`, 'returnType') = 'void'
attr(`Leg_pop_back`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t')
class(`Leg_pop_back`) = c("SWIGFunction", class('Leg_pop_back'))

# Start of Leg_resize

`Leg_resize__SWIG_0` = function(self, new_size)
{
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_Leg_resize__SWIG_0', self, new_size, PACKAGE='QuantLib');
  
}

attr(`Leg_resize__SWIG_0`, 'returnType') = 'void'
attr(`Leg_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', 'integer')
class(`Leg_resize__SWIG_0`) = c("SWIGFunction", class('Leg_resize__SWIG_0'))

# Start of new_Leg

`Leg__SWIG_3` = function(size, value)
{
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  
  ;ans = .Call('R_swig_new_Leg__SWIG_3', size, value, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t";
  
  reg.finalizer(ans, delete_Leg)
  ans
  
}

attr(`Leg__SWIG_3`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t'
attr(`Leg__SWIG_3`, "inputTypes") = c('integer', '_p_boost__shared_ptrT_CashFlow_t')
class(`Leg__SWIG_3`) = c("SWIGFunction", class('Leg__SWIG_3'))

`Leg` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- Leg__SWIG_0; 
  } else if (argc == 1) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]]))) {
      f <- Leg__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t')) {
      f <- Leg__SWIG_1; 
    }
  } else if (argc == 2) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && extends(argtypes[2], '_p_boost__shared_ptrT_CashFlow_t')) {
      f <- Leg__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for Leg with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of Leg_push_back

`Leg_push_back` = function(self, x)
{
  ;.Call('R_swig_Leg_push_back', self, x, PACKAGE='QuantLib');
  
}

attr(`Leg_push_back`, 'returnType') = 'void'
attr(`Leg_push_back`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', '_p_boost__shared_ptrT_CashFlow_t')
class(`Leg_push_back`) = c("SWIGFunction", class('Leg_push_back'))

# Start of Leg_front

`Leg_front` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_Leg_front', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_CashFlow_t";
  
  ans
  
}

attr(`Leg_front`, 'returnType') = '_p_boost__shared_ptrT_CashFlow_t'
attr(`Leg_front`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t')
class(`Leg_front`) = c("SWIGFunction", class('Leg_front'))

# Start of Leg_back

`Leg_back` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_Leg_back', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_CashFlow_t";
  
  ans
  
}

attr(`Leg_back`, 'returnType') = '_p_boost__shared_ptrT_CashFlow_t'
attr(`Leg_back`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t')
class(`Leg_back`) = c("SWIGFunction", class('Leg_back'))

# Start of Leg_assign

`Leg_assign` = function(self, n, x)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  
  ;.Call('R_swig_Leg_assign', self, n, x, PACKAGE='QuantLib');
  
}

attr(`Leg_assign`, 'returnType') = 'void'
attr(`Leg_assign`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', 'integer', '_p_boost__shared_ptrT_CashFlow_t')
class(`Leg_assign`) = c("SWIGFunction", class('Leg_assign'))

# Start of Leg_resize

`Leg_resize__SWIG_1` = function(self, new_size, x)
{
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  
  ;.Call('R_swig_Leg_resize__SWIG_1', self, new_size, x, PACKAGE='QuantLib');
  
}

attr(`Leg_resize__SWIG_1`, 'returnType') = 'void'
attr(`Leg_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', 'integer', '_p_boost__shared_ptrT_CashFlow_t')
class(`Leg_resize__SWIG_1`) = c("SWIGFunction", class('Leg_resize__SWIG_1'))

`Leg_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]]))) {
      f <- Leg_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && extends(argtypes[3], '_p_boost__shared_ptrT_CashFlow_t')) {
      f <- Leg_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for Leg_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of Leg_reserve

`Leg_reserve` = function(self, n)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_Leg_reserve', self, n, PACKAGE='QuantLib');
  
}

attr(`Leg_reserve`, 'returnType') = 'void'
attr(`Leg_reserve`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', 'integer')
class(`Leg_reserve`) = c("SWIGFunction", class('Leg_reserve'))

# Start of Leg_capacity

`Leg_capacity` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_Leg_capacity', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`Leg_capacity`, 'returnType') = 'integer'
attr(`Leg_capacity`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t')
class(`Leg_capacity`) = c("SWIGFunction", class('Leg_capacity'))

# Start of delete_Leg

`delete_Leg` = function(self)
{
  ;.Call('R_swig_delete_Leg', self, PACKAGE='QuantLib');
  
}

attr(`delete_Leg`, 'returnType') = 'void'
attr(`delete_Leg`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t')
class(`delete_Leg`) = c("SWIGFunction", class('delete_Leg'))

# Start of accessor method for std::vector<(boost::shared_ptr<(CashFlow)>)>
setMethod('$', '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = Leg___nonzero__, '__len__' = Leg___len__, 'pop' = Leg_pop, '__getslice__' = Leg___getslice__, '__setslice__' = Leg___setslice__, '__delslice__' = Leg___delslice__, '__delitem__' = Leg___delitem__, '__getitem__' = Leg___getitem__, '__setitem__' = Leg___setitem__, 'append' = Leg_append, 'empty' = Leg_empty, 'size' = Leg_size, 'clear' = Leg_clear, 'swap' = Leg_swap, 'get_allocator' = Leg_get_allocator, 'pop_back' = Leg_pop_back, 'resize' = Leg_resize, 'push_back' = Leg_push_back, 'front' = Leg_front, 'back' = Leg_back, 'assign' = Leg_assign, 'reserve' = Leg_reserve, 'capacity' = Leg_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for std::vector<(boost::shared_ptr<(CashFlow)>)>
setMethod('delete', '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', function(obj) {delete_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t(obj)})
# Start of new_SimpleCashFlow

`SimpleCashFlow` = function(amount, date)
{
  ;ans = .Call('R_swig_new_SimpleCashFlow', amount, date, PACKAGE='QuantLib');
  class(ans) <- "_p_SimpleCashFlowPtr";
  
  reg.finalizer(ans, delete_SimpleCashFlow)
  ans
  
}

attr(`SimpleCashFlow`, 'returnType') = '_p_SimpleCashFlowPtr'
attr(`SimpleCashFlow`, "inputTypes") = c('numeric', '_p_Date')
class(`SimpleCashFlow`) = c("SWIGFunction", class('SimpleCashFlow'))

# Start of delete_SimpleCashFlow

`delete_SimpleCashFlow` = function(self)
{
  ;.Call('R_swig_delete_SimpleCashFlow', self, PACKAGE='QuantLib');
  
}

attr(`delete_SimpleCashFlow`, 'returnType') = 'void'
attr(`delete_SimpleCashFlow`, "inputTypes") = c('_p_SimpleCashFlowPtr')
class(`delete_SimpleCashFlow`) = c("SWIGFunction", class('delete_SimpleCashFlow'))

setMethod('delete', '_p_SimpleCashFlowPtr', function(obj) {delete_SimpleCashFlowPtr(obj)})
# Start of Coupon_nominal

`Coupon_nominal` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Coupon_nominal', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Coupon_nominal`, 'returnType') = 'numeric'
attr(`Coupon_nominal`, "inputTypes") = c('_p_CouponPtr')
class(`Coupon_nominal`) = c("SWIGFunction", class('Coupon_nominal'))

# Start of Coupon_accrualStartDate

`Coupon_accrualStartDate` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_Coupon_accrualStartDate', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`Coupon_accrualStartDate`, 'returnType') = '_p_Date'
attr(`Coupon_accrualStartDate`, "inputTypes") = c('_p_CouponPtr')
class(`Coupon_accrualStartDate`) = c("SWIGFunction", class('Coupon_accrualStartDate'))

# Start of Coupon_accrualEndDate

`Coupon_accrualEndDate` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_Coupon_accrualEndDate', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`Coupon_accrualEndDate`, 'returnType') = '_p_Date'
attr(`Coupon_accrualEndDate`, "inputTypes") = c('_p_CouponPtr')
class(`Coupon_accrualEndDate`) = c("SWIGFunction", class('Coupon_accrualEndDate'))

# Start of Coupon_referencePeriodStart

`Coupon_referencePeriodStart` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_Coupon_referencePeriodStart', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`Coupon_referencePeriodStart`, 'returnType') = '_p_Date'
attr(`Coupon_referencePeriodStart`, "inputTypes") = c('_p_CouponPtr')
class(`Coupon_referencePeriodStart`) = c("SWIGFunction", class('Coupon_referencePeriodStart'))

# Start of Coupon_referencePeriodEnd

`Coupon_referencePeriodEnd` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_Coupon_referencePeriodEnd', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`Coupon_referencePeriodEnd`, 'returnType') = '_p_Date'
attr(`Coupon_referencePeriodEnd`, "inputTypes") = c('_p_CouponPtr')
class(`Coupon_referencePeriodEnd`) = c("SWIGFunction", class('Coupon_referencePeriodEnd'))

# Start of Coupon_rate

`Coupon_rate` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Coupon_rate', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Coupon_rate`, 'returnType') = 'numeric'
attr(`Coupon_rate`, "inputTypes") = c('_p_CouponPtr')
class(`Coupon_rate`) = c("SWIGFunction", class('Coupon_rate'))

# Start of Coupon_accrualPeriod

`Coupon_accrualPeriod` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Coupon_accrualPeriod', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Coupon_accrualPeriod`, 'returnType') = 'numeric'
attr(`Coupon_accrualPeriod`, "inputTypes") = c('_p_CouponPtr')
class(`Coupon_accrualPeriod`) = c("SWIGFunction", class('Coupon_accrualPeriod'))

# Start of Coupon_accrualDays

`Coupon_accrualDays` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Coupon_accrualDays', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Coupon_accrualDays`, 'returnType') = 'integer'
attr(`Coupon_accrualDays`, "inputTypes") = c('_p_CouponPtr')
class(`Coupon_accrualDays`) = c("SWIGFunction", class('Coupon_accrualDays'))

# Start of Coupon_dayCounter

`Coupon_dayCounter` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_Coupon_dayCounter', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_DayCounter";
  
  ans
  
}

attr(`Coupon_dayCounter`, 'returnType') = '_p_DayCounter'
attr(`Coupon_dayCounter`, "inputTypes") = c('_p_CouponPtr')
class(`Coupon_dayCounter`) = c("SWIGFunction", class('Coupon_dayCounter'))

# Start of Coupon_accruedAmount

`Coupon_accruedAmount` = function(self, date, .copy = FALSE)
{
  ;.Call('R_swig_Coupon_accruedAmount', self, date, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Coupon_accruedAmount`, 'returnType') = 'numeric'
attr(`Coupon_accruedAmount`, "inputTypes") = c('_p_CouponPtr', '_p_Date')
class(`Coupon_accruedAmount`) = c("SWIGFunction", class('Coupon_accruedAmount'))

# Start of delete_Coupon

`delete_Coupon` = function(self)
{
  ;.Call('R_swig_delete_Coupon', self, PACKAGE='QuantLib');
  
}

attr(`delete_Coupon`, 'returnType') = 'void'
attr(`delete_Coupon`, "inputTypes") = c('_p_CouponPtr')
class(`delete_Coupon`) = c("SWIGFunction", class('delete_Coupon'))

# Start of accessor method for CouponPtr
setMethod('$', '_p_CouponPtr', function(x, name)

{
  accessorFuns = list('nominal' = Coupon_nominal, 'accrualStartDate' = Coupon_accrualStartDate, 'accrualEndDate' = Coupon_accrualEndDate, 'referencePeriodStart' = Coupon_referencePeriodStart, 'referencePeriodEnd' = Coupon_referencePeriodEnd, 'rate' = Coupon_rate, 'accrualPeriod' = Coupon_accrualPeriod, 'accrualDays' = Coupon_accrualDays, 'dayCounter' = Coupon_dayCounter, 'accruedAmount' = Coupon_accruedAmount);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for CouponPtr
setMethod('delete', '_p_CouponPtr', function(obj) {delete_CouponPtr(obj)})
# Start of as_coupon

`as_coupon` = function(cf, .copy = FALSE)
{
  ;ans = .Call('R_swig_as_coupon', cf, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_CouponPtr";
  
  ans
  
}

attr(`as_coupon`, 'returnType') = '_p_CouponPtr'
attr(`as_coupon`, "inputTypes") = c('_p_boost__shared_ptrT_CashFlow_t')
class(`as_coupon`) = c("SWIGFunction", class('as_coupon'))

# Start of new_FixedRateCoupon

`FixedRateCoupon` = function(paymentDate, nominal, rate, dayCounter, startDate, endDate, refPeriodStart, refPeriodEnd)
{
  ;ans = .Call('R_swig_new_FixedRateCoupon', paymentDate, nominal, rate, dayCounter, startDate, endDate, refPeriodStart, refPeriodEnd, PACKAGE='QuantLib');
  class(ans) <- "_p_FixedRateCouponPtr";
  
  reg.finalizer(ans, delete_FixedRateCoupon)
  ans
  
}

attr(`FixedRateCoupon`, 'returnType') = '_p_FixedRateCouponPtr'
attr(`FixedRateCoupon`, "inputTypes") = c('_p_Date', 'numeric', 'numeric', '_p_DayCounter', '_p_Date', '_p_Date', '_p_Date', '_p_Date')
class(`FixedRateCoupon`) = c("SWIGFunction", class('FixedRateCoupon'))

# Start of FixedRateCoupon_interestRate

`FixedRateCoupon_interestRate` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_FixedRateCoupon_interestRate', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_InterestRate";
  
  ans
  
}

attr(`FixedRateCoupon_interestRate`, 'returnType') = '_p_InterestRate'
attr(`FixedRateCoupon_interestRate`, "inputTypes") = c('_p_FixedRateCouponPtr')
class(`FixedRateCoupon_interestRate`) = c("SWIGFunction", class('FixedRateCoupon_interestRate'))

# Start of delete_FixedRateCoupon

`delete_FixedRateCoupon` = function(self)
{
  ;.Call('R_swig_delete_FixedRateCoupon', self, PACKAGE='QuantLib');
  
}

attr(`delete_FixedRateCoupon`, 'returnType') = 'void'
attr(`delete_FixedRateCoupon`, "inputTypes") = c('_p_FixedRateCouponPtr')
class(`delete_FixedRateCoupon`) = c("SWIGFunction", class('delete_FixedRateCoupon'))

# Start of accessor method for FixedRateCouponPtr
setMethod('$', '_p_FixedRateCouponPtr', function(x, name)

{
  accessorFuns = list('interestRate' = FixedRateCoupon_interestRate);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for FixedRateCouponPtr
setMethod('delete', '_p_FixedRateCouponPtr', function(obj) {delete_FixedRateCouponPtr(obj)})
# Start of as_fixed_rate_coupon

`as_fixed_rate_coupon` = function(cf, .copy = FALSE)
{
  ;ans = .Call('R_swig_as_fixed_rate_coupon', cf, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_FixedRateCouponPtr";
  
  ans
  
}

attr(`as_fixed_rate_coupon`, 'returnType') = '_p_FixedRateCouponPtr'
attr(`as_fixed_rate_coupon`, "inputTypes") = c('_p_boost__shared_ptrT_CashFlow_t')
class(`as_fixed_rate_coupon`) = c("SWIGFunction", class('as_fixed_rate_coupon'))

# Start of FloatingRateCouponPricer___deref__

`FloatingRateCouponPricer___deref__` = function(self)
{
  ;ans = .Call('R_swig_FloatingRateCouponPricer___deref__', self, PACKAGE='QuantLib');
  class(ans) <- "_p_FloatingRateCouponPricer";
  
  ans
  
}

attr(`FloatingRateCouponPricer___deref__`, 'returnType') = '_p_FloatingRateCouponPricer'
attr(`FloatingRateCouponPricer___deref__`, "inputTypes") = c('_p_boost__shared_ptrT_FloatingRateCouponPricer_t')
class(`FloatingRateCouponPricer___deref__`) = c("SWIGFunction", class('FloatingRateCouponPricer___deref__'))

# Start of FloatingRateCouponPricer_isNull

`FloatingRateCouponPricer_isNull` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_FloatingRateCouponPricer_isNull', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`FloatingRateCouponPricer_isNull`, 'returnType') = 'logical'
attr(`FloatingRateCouponPricer_isNull`, "inputTypes") = c('_p_boost__shared_ptrT_FloatingRateCouponPricer_t')
class(`FloatingRateCouponPricer_isNull`) = c("SWIGFunction", class('FloatingRateCouponPricer_isNull'))

# Start of new_FloatingRateCouponPricer

`FloatingRateCouponPricer` = function()
{
  ;ans = .Call('R_swig_new_FloatingRateCouponPricer', PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_FloatingRateCouponPricer_t";
  
  reg.finalizer(ans, delete_FloatingRateCouponPricer)
  ans
  
}

attr(`FloatingRateCouponPricer`, 'returnType') = '_p_boost__shared_ptrT_FloatingRateCouponPricer_t'
class(`FloatingRateCouponPricer`) = c("SWIGFunction", class('FloatingRateCouponPricer'))

# Start of delete_FloatingRateCouponPricer

`delete_FloatingRateCouponPricer` = function(self)
{
  ;.Call('R_swig_delete_FloatingRateCouponPricer', self, PACKAGE='QuantLib');
  
}

attr(`delete_FloatingRateCouponPricer`, 'returnType') = 'void'
attr(`delete_FloatingRateCouponPricer`, "inputTypes") = c('_p_boost__shared_ptrT_FloatingRateCouponPricer_t')
class(`delete_FloatingRateCouponPricer`) = c("SWIGFunction", class('delete_FloatingRateCouponPricer'))

# Start of accessor method for boost::shared_ptr<(FloatingRateCouponPricer)>
setMethod('$', '_p_boost__shared_ptrT_FloatingRateCouponPricer_t', function(x, name)

{
  accessorFuns = list('__deref__' = FloatingRateCouponPricer___deref__, 'isNull' = FloatingRateCouponPricer_isNull);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for boost::shared_ptr<(FloatingRateCouponPricer)>
setMethod('delete', '_p_boost__shared_ptrT_FloatingRateCouponPricer_t', function(obj) {delete_boost__shared_ptrT_FloatingRateCouponPricer_t(obj)})
# Start of setCouponPricer

`setCouponPricer` = function(s_arg1, s_arg2)
{
  ;.Call('R_swig_setCouponPricer', s_arg1, s_arg2, PACKAGE='QuantLib');
  
}

attr(`setCouponPricer`, 'returnType') = 'void'
attr(`setCouponPricer`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', '_p_boost__shared_ptrT_FloatingRateCouponPricer_t')
class(`setCouponPricer`) = c("SWIGFunction", class('setCouponPricer'))

# Start of FloatingRateCoupon_fixingDate

`FloatingRateCoupon_fixingDate` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_FloatingRateCoupon_fixingDate', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`FloatingRateCoupon_fixingDate`, 'returnType') = '_p_Date'
attr(`FloatingRateCoupon_fixingDate`, "inputTypes") = c('_p_FloatingRateCouponPtr')
class(`FloatingRateCoupon_fixingDate`) = c("SWIGFunction", class('FloatingRateCoupon_fixingDate'))

# Start of FloatingRateCoupon_fixingDays

`FloatingRateCoupon_fixingDays` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_FloatingRateCoupon_fixingDays', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`FloatingRateCoupon_fixingDays`, 'returnType') = 'integer'
attr(`FloatingRateCoupon_fixingDays`, "inputTypes") = c('_p_FloatingRateCouponPtr')
class(`FloatingRateCoupon_fixingDays`) = c("SWIGFunction", class('FloatingRateCoupon_fixingDays'))

# Start of FloatingRateCoupon_isInArrears

`FloatingRateCoupon_isInArrears` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_FloatingRateCoupon_isInArrears', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`FloatingRateCoupon_isInArrears`, 'returnType') = 'logical'
attr(`FloatingRateCoupon_isInArrears`, "inputTypes") = c('_p_FloatingRateCouponPtr')
class(`FloatingRateCoupon_isInArrears`) = c("SWIGFunction", class('FloatingRateCoupon_isInArrears'))

# Start of FloatingRateCoupon_gearing

`FloatingRateCoupon_gearing` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_FloatingRateCoupon_gearing', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`FloatingRateCoupon_gearing`, 'returnType') = 'numeric'
attr(`FloatingRateCoupon_gearing`, "inputTypes") = c('_p_FloatingRateCouponPtr')
class(`FloatingRateCoupon_gearing`) = c("SWIGFunction", class('FloatingRateCoupon_gearing'))

# Start of FloatingRateCoupon_spread

`FloatingRateCoupon_spread` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_FloatingRateCoupon_spread', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`FloatingRateCoupon_spread`, 'returnType') = 'numeric'
attr(`FloatingRateCoupon_spread`, "inputTypes") = c('_p_FloatingRateCouponPtr')
class(`FloatingRateCoupon_spread`) = c("SWIGFunction", class('FloatingRateCoupon_spread'))

# Start of FloatingRateCoupon_indexFixing

`FloatingRateCoupon_indexFixing` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_FloatingRateCoupon_indexFixing', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`FloatingRateCoupon_indexFixing`, 'returnType') = 'numeric'
attr(`FloatingRateCoupon_indexFixing`, "inputTypes") = c('_p_FloatingRateCouponPtr')
class(`FloatingRateCoupon_indexFixing`) = c("SWIGFunction", class('FloatingRateCoupon_indexFixing'))

# Start of FloatingRateCoupon_adjustedFixing

`FloatingRateCoupon_adjustedFixing` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_FloatingRateCoupon_adjustedFixing', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`FloatingRateCoupon_adjustedFixing`, 'returnType') = 'numeric'
attr(`FloatingRateCoupon_adjustedFixing`, "inputTypes") = c('_p_FloatingRateCouponPtr')
class(`FloatingRateCoupon_adjustedFixing`) = c("SWIGFunction", class('FloatingRateCoupon_adjustedFixing'))

# Start of FloatingRateCoupon_convexityAdjustment

`FloatingRateCoupon_convexityAdjustment` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_FloatingRateCoupon_convexityAdjustment', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`FloatingRateCoupon_convexityAdjustment`, 'returnType') = 'numeric'
attr(`FloatingRateCoupon_convexityAdjustment`, "inputTypes") = c('_p_FloatingRateCouponPtr')
class(`FloatingRateCoupon_convexityAdjustment`) = c("SWIGFunction", class('FloatingRateCoupon_convexityAdjustment'))

# Start of FloatingRateCoupon_price

`FloatingRateCoupon_price` = function(self, discountCurve, .copy = FALSE)
{
  ;.Call('R_swig_FloatingRateCoupon_price', self, discountCurve, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`FloatingRateCoupon_price`, 'returnType') = 'numeric'
attr(`FloatingRateCoupon_price`, "inputTypes") = c('_p_FloatingRateCouponPtr', '_p_HandleT_YieldTermStructure_t')
class(`FloatingRateCoupon_price`) = c("SWIGFunction", class('FloatingRateCoupon_price'))

# Start of FloatingRateCoupon_index

`FloatingRateCoupon_index` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_FloatingRateCoupon_index', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_InterestRateIndexPtr";
  
  ans
  
}

attr(`FloatingRateCoupon_index`, 'returnType') = '_p_InterestRateIndexPtr'
attr(`FloatingRateCoupon_index`, "inputTypes") = c('_p_FloatingRateCouponPtr')
class(`FloatingRateCoupon_index`) = c("SWIGFunction", class('FloatingRateCoupon_index'))

# Start of FloatingRateCoupon_setPricer

`FloatingRateCoupon_setPricer` = function(self, p)
{
  ;.Call('R_swig_FloatingRateCoupon_setPricer', self, p, PACKAGE='QuantLib');
  
}

attr(`FloatingRateCoupon_setPricer`, 'returnType') = 'void'
attr(`FloatingRateCoupon_setPricer`, "inputTypes") = c('_p_FloatingRateCouponPtr', '_p_boost__shared_ptrT_FloatingRateCouponPricer_t')
class(`FloatingRateCoupon_setPricer`) = c("SWIGFunction", class('FloatingRateCoupon_setPricer'))

# Start of delete_FloatingRateCoupon

`delete_FloatingRateCoupon` = function(self)
{
  ;.Call('R_swig_delete_FloatingRateCoupon', self, PACKAGE='QuantLib');
  
}

attr(`delete_FloatingRateCoupon`, 'returnType') = 'void'
attr(`delete_FloatingRateCoupon`, "inputTypes") = c('_p_FloatingRateCouponPtr')
class(`delete_FloatingRateCoupon`) = c("SWIGFunction", class('delete_FloatingRateCoupon'))

# Start of accessor method for FloatingRateCouponPtr
setMethod('$', '_p_FloatingRateCouponPtr', function(x, name)

{
  accessorFuns = list('fixingDate' = FloatingRateCoupon_fixingDate, 'fixingDays' = FloatingRateCoupon_fixingDays, 'isInArrears' = FloatingRateCoupon_isInArrears, 'gearing' = FloatingRateCoupon_gearing, 'spread' = FloatingRateCoupon_spread, 'indexFixing' = FloatingRateCoupon_indexFixing, 'adjustedFixing' = FloatingRateCoupon_adjustedFixing, 'convexityAdjustment' = FloatingRateCoupon_convexityAdjustment, 'price' = FloatingRateCoupon_price, 'index' = FloatingRateCoupon_index, 'setPricer' = FloatingRateCoupon_setPricer);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for FloatingRateCouponPtr
setMethod('delete', '_p_FloatingRateCouponPtr', function(obj) {delete_FloatingRateCouponPtr(obj)})
# Start of as_floating_rate_coupon

`as_floating_rate_coupon` = function(cf, .copy = FALSE)
{
  ;ans = .Call('R_swig_as_floating_rate_coupon', cf, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_FloatingRateCouponPtr";
  
  ans
  
}

attr(`as_floating_rate_coupon`, 'returnType') = '_p_FloatingRateCouponPtr'
attr(`as_floating_rate_coupon`, "inputTypes") = c('_p_boost__shared_ptrT_CashFlow_t')
class(`as_floating_rate_coupon`) = c("SWIGFunction", class('as_floating_rate_coupon'))

# Start of new_CappedFlooredCoupon

`CappedFlooredCoupon` = function(underlying, cap, floor)
{
  ;ans = .Call('R_swig_new_CappedFlooredCoupon', underlying, cap, floor, PACKAGE='QuantLib');
  class(ans) <- "_p_CappedFlooredCouponPtr";
  
  reg.finalizer(ans, delete_CappedFlooredCoupon)
  ans
  
}

attr(`CappedFlooredCoupon`, 'returnType') = '_p_CappedFlooredCouponPtr'
attr(`CappedFlooredCoupon`, "inputTypes") = c('_p_FloatingRateCouponPtr', 'numeric', 'numeric')
class(`CappedFlooredCoupon`) = c("SWIGFunction", class('CappedFlooredCoupon'))

# Start of CappedFlooredCoupon_cap

`CappedFlooredCoupon_cap` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_CappedFlooredCoupon_cap', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CappedFlooredCoupon_cap`, 'returnType') = 'numeric'
attr(`CappedFlooredCoupon_cap`, "inputTypes") = c('_p_CappedFlooredCouponPtr')
class(`CappedFlooredCoupon_cap`) = c("SWIGFunction", class('CappedFlooredCoupon_cap'))

# Start of CappedFlooredCoupon_floor

`CappedFlooredCoupon_floor` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_CappedFlooredCoupon_floor', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CappedFlooredCoupon_floor`, 'returnType') = 'numeric'
attr(`CappedFlooredCoupon_floor`, "inputTypes") = c('_p_CappedFlooredCouponPtr')
class(`CappedFlooredCoupon_floor`) = c("SWIGFunction", class('CappedFlooredCoupon_floor'))

# Start of CappedFlooredCoupon_effectiveCap

`CappedFlooredCoupon_effectiveCap` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_CappedFlooredCoupon_effectiveCap', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CappedFlooredCoupon_effectiveCap`, 'returnType') = 'numeric'
attr(`CappedFlooredCoupon_effectiveCap`, "inputTypes") = c('_p_CappedFlooredCouponPtr')
class(`CappedFlooredCoupon_effectiveCap`) = c("SWIGFunction", class('CappedFlooredCoupon_effectiveCap'))

# Start of CappedFlooredCoupon_effectiveFloor

`CappedFlooredCoupon_effectiveFloor` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_CappedFlooredCoupon_effectiveFloor', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CappedFlooredCoupon_effectiveFloor`, 'returnType') = 'numeric'
attr(`CappedFlooredCoupon_effectiveFloor`, "inputTypes") = c('_p_CappedFlooredCouponPtr')
class(`CappedFlooredCoupon_effectiveFloor`) = c("SWIGFunction", class('CappedFlooredCoupon_effectiveFloor'))

# Start of CappedFlooredCoupon_isCapped

`CappedFlooredCoupon_isCapped` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_CappedFlooredCoupon_isCapped', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CappedFlooredCoupon_isCapped`, 'returnType') = 'logical'
attr(`CappedFlooredCoupon_isCapped`, "inputTypes") = c('_p_CappedFlooredCouponPtr')
class(`CappedFlooredCoupon_isCapped`) = c("SWIGFunction", class('CappedFlooredCoupon_isCapped'))

# Start of CappedFlooredCoupon_isFloored

`CappedFlooredCoupon_isFloored` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_CappedFlooredCoupon_isFloored', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CappedFlooredCoupon_isFloored`, 'returnType') = 'logical'
attr(`CappedFlooredCoupon_isFloored`, "inputTypes") = c('_p_CappedFlooredCouponPtr')
class(`CappedFlooredCoupon_isFloored`) = c("SWIGFunction", class('CappedFlooredCoupon_isFloored'))

# Start of CappedFlooredCoupon_setPricer

`CappedFlooredCoupon_setPricer` = function(self, p)
{
  ;.Call('R_swig_CappedFlooredCoupon_setPricer', self, p, PACKAGE='QuantLib');
  
}

attr(`CappedFlooredCoupon_setPricer`, 'returnType') = 'void'
attr(`CappedFlooredCoupon_setPricer`, "inputTypes") = c('_p_CappedFlooredCouponPtr', '_p_boost__shared_ptrT_FloatingRateCouponPricer_t')
class(`CappedFlooredCoupon_setPricer`) = c("SWIGFunction", class('CappedFlooredCoupon_setPricer'))

# Start of delete_CappedFlooredCoupon

`delete_CappedFlooredCoupon` = function(self)
{
  ;.Call('R_swig_delete_CappedFlooredCoupon', self, PACKAGE='QuantLib');
  
}

attr(`delete_CappedFlooredCoupon`, 'returnType') = 'void'
attr(`delete_CappedFlooredCoupon`, "inputTypes") = c('_p_CappedFlooredCouponPtr')
class(`delete_CappedFlooredCoupon`) = c("SWIGFunction", class('delete_CappedFlooredCoupon'))

# Start of accessor method for CappedFlooredCouponPtr
setMethod('$', '_p_CappedFlooredCouponPtr', function(x, name)

{
  accessorFuns = list('cap' = CappedFlooredCoupon_cap, 'floor' = CappedFlooredCoupon_floor, 'effectiveCap' = CappedFlooredCoupon_effectiveCap, 'effectiveFloor' = CappedFlooredCoupon_effectiveFloor, 'isCapped' = CappedFlooredCoupon_isCapped, 'isFloored' = CappedFlooredCoupon_isFloored, 'setPricer' = CappedFlooredCoupon_setPricer);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for CappedFlooredCouponPtr
setMethod('delete', '_p_CappedFlooredCouponPtr', function(obj) {delete_CappedFlooredCouponPtr(obj)})
# Start of new_IborCoupon

`IborCoupon` = function(paymentDate, nominal, startDate, endDate, fixingDays, index, gearing, spread, refPeriodStart, refPeriodEnd, dayCounter)
{
  fixingDays = as.integer(fixingDays); 
  
  if(length(fixingDays) > 1) {
    warning("using only the first element of fixingDays");
  };
  
  
  
  
  
  
  
  ;ans = .Call('R_swig_new_IborCoupon', paymentDate, nominal, startDate, endDate, fixingDays, index, gearing, spread, refPeriodStart, refPeriodEnd, dayCounter, PACKAGE='QuantLib');
  class(ans) <- "_p_IborCouponPtr";
  
  reg.finalizer(ans, delete_IborCoupon)
  ans
  
}

attr(`IborCoupon`, 'returnType') = '_p_IborCouponPtr'
attr(`IborCoupon`, "inputTypes") = c('_p_Date', 'numeric', '_p_Date', '_p_Date', 'integer', '_p_InterestRateIndexPtr', 'numeric', 'numeric', '_p_Date', '_p_Date', '_p_DayCounter')
class(`IborCoupon`) = c("SWIGFunction", class('IborCoupon'))

# Start of delete_IborCoupon

`delete_IborCoupon` = function(self)
{
  ;.Call('R_swig_delete_IborCoupon', self, PACKAGE='QuantLib');
  
}

attr(`delete_IborCoupon`, 'returnType') = 'void'
attr(`delete_IborCoupon`, "inputTypes") = c('_p_IborCouponPtr')
class(`delete_IborCoupon`) = c("SWIGFunction", class('delete_IborCoupon'))

setMethod('delete', '_p_IborCouponPtr', function(obj) {delete_IborCouponPtr(obj)})
# Start of IborCouponPricer_capletVolatility

`IborCouponPricer_capletVolatility` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_IborCouponPricer_capletVolatility', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_HandleT_OptionletVolatilityStructure_t";
  
  ans
  
}

attr(`IborCouponPricer_capletVolatility`, 'returnType') = '_p_HandleT_OptionletVolatilityStructure_t'
attr(`IborCouponPricer_capletVolatility`, "inputTypes") = c('_p_IborCouponPricerPtr')
class(`IborCouponPricer_capletVolatility`) = c("SWIGFunction", class('IborCouponPricer_capletVolatility'))

# Start of IborCouponPricer_setCapletVolatility

`IborCouponPricer_setCapletVolatility__SWIG_0` = function(self, v)
{
  ;.Call('R_swig_IborCouponPricer_setCapletVolatility__SWIG_0', self, v, PACKAGE='QuantLib');
  
}

attr(`IborCouponPricer_setCapletVolatility__SWIG_0`, 'returnType') = 'void'
attr(`IborCouponPricer_setCapletVolatility__SWIG_0`, "inputTypes") = c('_p_IborCouponPricerPtr', '_p_HandleT_OptionletVolatilityStructure_t')
class(`IborCouponPricer_setCapletVolatility__SWIG_0`) = c("SWIGFunction", class('IborCouponPricer_setCapletVolatility__SWIG_0'))

# Start of IborCouponPricer_setCapletVolatility

`IborCouponPricer_setCapletVolatility__SWIG_1` = function(self)
{
  ;.Call('R_swig_IborCouponPricer_setCapletVolatility__SWIG_1', self, PACKAGE='QuantLib');
  
}

attr(`IborCouponPricer_setCapletVolatility__SWIG_1`, 'returnType') = 'void'
attr(`IborCouponPricer_setCapletVolatility__SWIG_1`, "inputTypes") = c('_p_IborCouponPricerPtr')
class(`IborCouponPricer_setCapletVolatility__SWIG_1`) = c("SWIGFunction", class('IborCouponPricer_setCapletVolatility__SWIG_1'))

`IborCouponPricer_setCapletVolatility` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_IborCouponPricerPtr')) {
      f <- IborCouponPricer_setCapletVolatility__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_IborCouponPricerPtr') && extends(argtypes[2], '_p_HandleT_OptionletVolatilityStructure_t')) {
      f <- IborCouponPricer_setCapletVolatility__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for IborCouponPricer_setCapletVolatility with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_IborCouponPricer

`delete_IborCouponPricer` = function(self)
{
  ;.Call('R_swig_delete_IborCouponPricer', self, PACKAGE='QuantLib');
  
}

attr(`delete_IborCouponPricer`, 'returnType') = 'void'
attr(`delete_IborCouponPricer`, "inputTypes") = c('_p_IborCouponPricerPtr')
class(`delete_IborCouponPricer`) = c("SWIGFunction", class('delete_IborCouponPricer'))

# Start of accessor method for IborCouponPricerPtr
setMethod('$', '_p_IborCouponPricerPtr', function(x, name)

{
  accessorFuns = list('capletVolatility' = IborCouponPricer_capletVolatility, 'setCapletVolatility' = IborCouponPricer_setCapletVolatility);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for IborCouponPricerPtr
setMethod('delete', '_p_IborCouponPricerPtr', function(obj) {delete_IborCouponPricerPtr(obj)})
# Start of new_BlackIborCouponPricer

`BlackIborCouponPricer__SWIG_0` = function(v)
{
  ;ans = .Call('R_swig_new_BlackIborCouponPricer__SWIG_0', v, PACKAGE='QuantLib');
  class(ans) <- "_p_BlackIborCouponPricerPtr";
  
  reg.finalizer(ans, delete_BlackIborCouponPricer)
  ans
  
}

attr(`BlackIborCouponPricer__SWIG_0`, 'returnType') = '_p_BlackIborCouponPricerPtr'
attr(`BlackIborCouponPricer__SWIG_0`, "inputTypes") = c('_p_HandleT_OptionletVolatilityStructure_t')
class(`BlackIborCouponPricer__SWIG_0`) = c("SWIGFunction", class('BlackIborCouponPricer__SWIG_0'))

# Start of new_BlackIborCouponPricer

`BlackIborCouponPricer__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_BlackIborCouponPricer__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_BlackIborCouponPricerPtr";
  
  reg.finalizer(ans, delete_BlackIborCouponPricer)
  ans
  
}

attr(`BlackIborCouponPricer__SWIG_1`, 'returnType') = '_p_BlackIborCouponPricerPtr'
class(`BlackIborCouponPricer__SWIG_1`) = c("SWIGFunction", class('BlackIborCouponPricer__SWIG_1'))

`BlackIborCouponPricer` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- BlackIborCouponPricer__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_HandleT_OptionletVolatilityStructure_t')) {
      f <- BlackIborCouponPricer__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for BlackIborCouponPricer with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_BlackIborCouponPricer

`delete_BlackIborCouponPricer` = function(self)
{
  ;.Call('R_swig_delete_BlackIborCouponPricer', self, PACKAGE='QuantLib');
  
}

attr(`delete_BlackIborCouponPricer`, 'returnType') = 'void'
attr(`delete_BlackIborCouponPricer`, "inputTypes") = c('_p_BlackIborCouponPricerPtr')
class(`delete_BlackIborCouponPricer`) = c("SWIGFunction", class('delete_BlackIborCouponPricer'))

setMethod('delete', '_p_BlackIborCouponPricerPtr', function(obj) {delete_BlackIborCouponPricerPtr(obj)})
# Start of new_CmsCoupon

`CmsCoupon` = function(paymentDate, nominal, startDate, endDate, fixingDays, index, gearing, spread, refPeriodStart, refPeriodEnd, dayCounter, isInArrears)
{
  fixingDays = as.integer(fixingDays); 
  
  if(length(fixingDays) > 1) {
    warning("using only the first element of fixingDays");
  };
  
  
  
  
  
  
  
  isInArrears = as.logical(isInArrears);
  ;ans = .Call('R_swig_new_CmsCoupon', paymentDate, nominal, startDate, endDate, fixingDays, index, gearing, spread, refPeriodStart, refPeriodEnd, dayCounter, isInArrears, PACKAGE='QuantLib');
  class(ans) <- "_p_CmsCouponPtr";
  
  reg.finalizer(ans, delete_CmsCoupon)
  ans
  
}

attr(`CmsCoupon`, 'returnType') = '_p_CmsCouponPtr'
attr(`CmsCoupon`, "inputTypes") = c('_p_Date', 'numeric', '_p_Date', '_p_Date', 'integer', '_p_SwapIndexPtr', 'numeric', 'numeric', '_p_Date', '_p_Date', '_p_DayCounter', 'logical')
class(`CmsCoupon`) = c("SWIGFunction", class('CmsCoupon'))

# Start of delete_CmsCoupon

`delete_CmsCoupon` = function(self)
{
  ;.Call('R_swig_delete_CmsCoupon', self, PACKAGE='QuantLib');
  
}

attr(`delete_CmsCoupon`, 'returnType') = 'void'
attr(`delete_CmsCoupon`, "inputTypes") = c('_p_CmsCouponPtr')
class(`delete_CmsCoupon`) = c("SWIGFunction", class('delete_CmsCoupon'))

setMethod('delete', '_p_CmsCouponPtr', function(obj) {delete_CmsCouponPtr(obj)})
# Start of CmsCouponPricer_swaptionVolatility

`CmsCouponPricer_swaptionVolatility` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_CmsCouponPricer_swaptionVolatility', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_HandleT_SwaptionVolatilityStructure_t";
  
  ans
  
}

attr(`CmsCouponPricer_swaptionVolatility`, 'returnType') = '_p_HandleT_SwaptionVolatilityStructure_t'
attr(`CmsCouponPricer_swaptionVolatility`, "inputTypes") = c('_p_CmsCouponPricerPtr')
class(`CmsCouponPricer_swaptionVolatility`) = c("SWIGFunction", class('CmsCouponPricer_swaptionVolatility'))

# Start of CmsCouponPricer_setSwaptionVolatility

`CmsCouponPricer_setSwaptionVolatility__SWIG_0` = function(self, v)
{
  ;.Call('R_swig_CmsCouponPricer_setSwaptionVolatility__SWIG_0', self, v, PACKAGE='QuantLib');
  
}

attr(`CmsCouponPricer_setSwaptionVolatility__SWIG_0`, 'returnType') = 'void'
attr(`CmsCouponPricer_setSwaptionVolatility__SWIG_0`, "inputTypes") = c('_p_CmsCouponPricerPtr', '_p_HandleT_SwaptionVolatilityStructure_t')
class(`CmsCouponPricer_setSwaptionVolatility__SWIG_0`) = c("SWIGFunction", class('CmsCouponPricer_setSwaptionVolatility__SWIG_0'))

# Start of CmsCouponPricer_setSwaptionVolatility

`CmsCouponPricer_setSwaptionVolatility__SWIG_1` = function(self)
{
  ;.Call('R_swig_CmsCouponPricer_setSwaptionVolatility__SWIG_1', self, PACKAGE='QuantLib');
  
}

attr(`CmsCouponPricer_setSwaptionVolatility__SWIG_1`, 'returnType') = 'void'
attr(`CmsCouponPricer_setSwaptionVolatility__SWIG_1`, "inputTypes") = c('_p_CmsCouponPricerPtr')
class(`CmsCouponPricer_setSwaptionVolatility__SWIG_1`) = c("SWIGFunction", class('CmsCouponPricer_setSwaptionVolatility__SWIG_1'))

`CmsCouponPricer_setSwaptionVolatility` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_CmsCouponPricerPtr')) {
      f <- CmsCouponPricer_setSwaptionVolatility__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_CmsCouponPricerPtr') && extends(argtypes[2], '_p_HandleT_SwaptionVolatilityStructure_t')) {
      f <- CmsCouponPricer_setSwaptionVolatility__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for CmsCouponPricer_setSwaptionVolatility with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_CmsCouponPricer

`delete_CmsCouponPricer` = function(self)
{
  ;.Call('R_swig_delete_CmsCouponPricer', self, PACKAGE='QuantLib');
  
}

attr(`delete_CmsCouponPricer`, 'returnType') = 'void'
attr(`delete_CmsCouponPricer`, "inputTypes") = c('_p_CmsCouponPricerPtr')
class(`delete_CmsCouponPricer`) = c("SWIGFunction", class('delete_CmsCouponPricer'))

# Start of accessor method for CmsCouponPricerPtr
setMethod('$', '_p_CmsCouponPricerPtr', function(x, name)

{
  accessorFuns = list('swaptionVolatility' = CmsCouponPricer_swaptionVolatility, 'setSwaptionVolatility' = CmsCouponPricer_setSwaptionVolatility);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for CmsCouponPricerPtr
setMethod('delete', '_p_CmsCouponPricerPtr', function(obj) {delete_CmsCouponPricerPtr(obj)})
defineEnumeration('_GFunctionFactory__YieldCurveModel',
                    .values = c(
                        'Standard' = 0, 
                        'ExactYield' = 1, 
                        'ParallelShifts' = 2, 
                        'NonParallelShifts' = 3
))
# Start of delete_GFunctionFactory

`delete_GFunctionFactory` = function(self)
{
  ;.Call('R_swig_delete_GFunctionFactory', self, PACKAGE='QuantLib');
  
}

attr(`delete_GFunctionFactory`, 'returnType') = 'void'
attr(`delete_GFunctionFactory`, "inputTypes") = c('_p_GFunctionFactory')
class(`delete_GFunctionFactory`) = c("SWIGFunction", class('delete_GFunctionFactory'))

setMethod('delete', '_p_GFunctionFactory', function(obj) {delete_GFunctionFactory(obj)})
# Start of new_AnalyticHaganPricer

`AnalyticHaganPricer` = function(v, model, meanReversion)
{
  model = enumToInteger(model, "_GFunctionFactory__YieldCurveModel"); 
  
  if(length(model) > 1) {
    warning("using only the first element of model");
  };
  
  
  ;ans = .Call('R_swig_new_AnalyticHaganPricer', v, model, meanReversion, PACKAGE='QuantLib');
  class(ans) <- "_p_AnalyticHaganPricerPtr";
  
  reg.finalizer(ans, delete_AnalyticHaganPricer)
  ans
  
}

attr(`AnalyticHaganPricer`, 'returnType') = '_p_AnalyticHaganPricerPtr'
attr(`AnalyticHaganPricer`, "inputTypes") = c('_p_HandleT_SwaptionVolatilityStructure_t', 'character', '_p_HandleT_Quote_t')
class(`AnalyticHaganPricer`) = c("SWIGFunction", class('AnalyticHaganPricer'))

# Start of delete_AnalyticHaganPricer

`delete_AnalyticHaganPricer` = function(self)
{
  ;.Call('R_swig_delete_AnalyticHaganPricer', self, PACKAGE='QuantLib');
  
}

attr(`delete_AnalyticHaganPricer`, 'returnType') = 'void'
attr(`delete_AnalyticHaganPricer`, "inputTypes") = c('_p_AnalyticHaganPricerPtr')
class(`delete_AnalyticHaganPricer`) = c("SWIGFunction", class('delete_AnalyticHaganPricer'))

setMethod('delete', '_p_AnalyticHaganPricerPtr', function(obj) {delete_AnalyticHaganPricerPtr(obj)})
# Start of new_NumericHaganPricer

`NumericHaganPricer__SWIG_0` = function(v, model, meanReversion, lowerLimit, upperLimit, precision)
{
  model = enumToInteger(model, "_GFunctionFactory__YieldCurveModel"); 
  
  if(length(model) > 1) {
    warning("using only the first element of model");
  };
  
  
  
  
  
  ;ans = .Call('R_swig_new_NumericHaganPricer__SWIG_0', v, model, meanReversion, lowerLimit, upperLimit, precision, PACKAGE='QuantLib');
  class(ans) <- "_p_NumericHaganPricerPtr";
  
  reg.finalizer(ans, delete_NumericHaganPricer)
  ans
  
}

attr(`NumericHaganPricer__SWIG_0`, 'returnType') = '_p_NumericHaganPricerPtr'
attr(`NumericHaganPricer__SWIG_0`, "inputTypes") = c('_p_HandleT_SwaptionVolatilityStructure_t', 'character', '_p_HandleT_Quote_t', 'numeric', 'numeric', 'numeric')
class(`NumericHaganPricer__SWIG_0`) = c("SWIGFunction", class('NumericHaganPricer__SWIG_0'))

# Start of new_NumericHaganPricer

`NumericHaganPricer__SWIG_1` = function(v, model, meanReversion, lowerLimit, upperLimit)
{
  model = enumToInteger(model, "_GFunctionFactory__YieldCurveModel"); 
  
  if(length(model) > 1) {
    warning("using only the first element of model");
  };
  
  
  
  
  ;ans = .Call('R_swig_new_NumericHaganPricer__SWIG_1', v, model, meanReversion, lowerLimit, upperLimit, PACKAGE='QuantLib');
  class(ans) <- "_p_NumericHaganPricerPtr";
  
  reg.finalizer(ans, delete_NumericHaganPricer)
  ans
  
}

attr(`NumericHaganPricer__SWIG_1`, 'returnType') = '_p_NumericHaganPricerPtr'
attr(`NumericHaganPricer__SWIG_1`, "inputTypes") = c('_p_HandleT_SwaptionVolatilityStructure_t', 'character', '_p_HandleT_Quote_t', 'numeric', 'numeric')
class(`NumericHaganPricer__SWIG_1`) = c("SWIGFunction", class('NumericHaganPricer__SWIG_1'))

# Start of new_NumericHaganPricer

`NumericHaganPricer__SWIG_2` = function(v, model, meanReversion, lowerLimit)
{
  model = enumToInteger(model, "_GFunctionFactory__YieldCurveModel"); 
  
  if(length(model) > 1) {
    warning("using only the first element of model");
  };
  
  
  
  ;ans = .Call('R_swig_new_NumericHaganPricer__SWIG_2', v, model, meanReversion, lowerLimit, PACKAGE='QuantLib');
  class(ans) <- "_p_NumericHaganPricerPtr";
  
  reg.finalizer(ans, delete_NumericHaganPricer)
  ans
  
}

attr(`NumericHaganPricer__SWIG_2`, 'returnType') = '_p_NumericHaganPricerPtr'
attr(`NumericHaganPricer__SWIG_2`, "inputTypes") = c('_p_HandleT_SwaptionVolatilityStructure_t', 'character', '_p_HandleT_Quote_t', 'numeric')
class(`NumericHaganPricer__SWIG_2`) = c("SWIGFunction", class('NumericHaganPricer__SWIG_2'))

# Start of new_NumericHaganPricer

`NumericHaganPricer__SWIG_3` = function(v, model, meanReversion)
{
  model = enumToInteger(model, "_GFunctionFactory__YieldCurveModel"); 
  
  if(length(model) > 1) {
    warning("using only the first element of model");
  };
  
  
  ;ans = .Call('R_swig_new_NumericHaganPricer__SWIG_3', v, model, meanReversion, PACKAGE='QuantLib');
  class(ans) <- "_p_NumericHaganPricerPtr";
  
  reg.finalizer(ans, delete_NumericHaganPricer)
  ans
  
}

attr(`NumericHaganPricer__SWIG_3`, 'returnType') = '_p_NumericHaganPricerPtr'
attr(`NumericHaganPricer__SWIG_3`, "inputTypes") = c('_p_HandleT_SwaptionVolatilityStructure_t', 'character', '_p_HandleT_Quote_t')
class(`NumericHaganPricer__SWIG_3`) = c("SWIGFunction", class('NumericHaganPricer__SWIG_3'))

`NumericHaganPricer` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 3) {
    if (extends(argtypes[1], '_p_HandleT_SwaptionVolatilityStructure_t') && is.character(argv[[2]]) && extends(argtypes[3], '_p_HandleT_Quote_t')) {
      f <- NumericHaganPricer__SWIG_3; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_HandleT_SwaptionVolatilityStructure_t') && is.character(argv[[2]]) && extends(argtypes[3], '_p_HandleT_Quote_t') && is.numeric(argv[[4]])) {
      f <- NumericHaganPricer__SWIG_2; 
    }
  } else if (argc == 5) {
    if (extends(argtypes[1], '_p_HandleT_SwaptionVolatilityStructure_t') && is.character(argv[[2]]) && extends(argtypes[3], '_p_HandleT_Quote_t') && is.numeric(argv[[4]]) && is.numeric(argv[[5]])) {
      f <- NumericHaganPricer__SWIG_1; 
    }
  } else if (argc == 6) {
    if (extends(argtypes[1], '_p_HandleT_SwaptionVolatilityStructure_t') && is.character(argv[[2]]) && extends(argtypes[3], '_p_HandleT_Quote_t') && is.numeric(argv[[4]]) && is.numeric(argv[[5]]) && is.numeric(argv[[6]])) {
      f <- NumericHaganPricer__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for NumericHaganPricer with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_NumericHaganPricer

`delete_NumericHaganPricer` = function(self)
{
  ;.Call('R_swig_delete_NumericHaganPricer', self, PACKAGE='QuantLib');
  
}

attr(`delete_NumericHaganPricer`, 'returnType') = 'void'
attr(`delete_NumericHaganPricer`, "inputTypes") = c('_p_NumericHaganPricerPtr')
class(`delete_NumericHaganPricer`) = c("SWIGFunction", class('delete_NumericHaganPricer'))

setMethod('delete', '_p_NumericHaganPricerPtr', function(obj) {delete_NumericHaganPricerPtr(obj)})
# Start of new_CappedFlooredCmsCoupon

`CappedFlooredCmsCoupon__SWIG_0` = function(paymentDate, nominal, startDate, endDate, fixingDays, index, gearing, spread, cap, floor, refPeriodStart, refPeriodEnd, dayCounter, isInArrears)
{
  if(length(fixingDays) > 1) {
    warning("using only the first element of fixingDays");
  };
  
  
  
  
  
  
  
  
  
  isInArrears = as.logical(isInArrears);
  ;ans = .Call('R_swig_new_CappedFlooredCmsCoupon__SWIG_0', paymentDate, nominal, startDate, endDate, fixingDays, index, gearing, spread, cap, floor, refPeriodStart, refPeriodEnd, dayCounter, isInArrears, PACKAGE='QuantLib');
  class(ans) <- "_p_CappedFlooredCmsCouponPtr";
  
  reg.finalizer(ans, delete_CappedFlooredCmsCoupon)
  ans
  
}

attr(`CappedFlooredCmsCoupon__SWIG_0`, 'returnType') = '_p_CappedFlooredCmsCouponPtr'
attr(`CappedFlooredCmsCoupon__SWIG_0`, "inputTypes") = c('_p_Date', 'numeric', '_p_Date', '_p_Date', 'integer', '_p_SwapIndexPtr', 'numeric', 'numeric', 'numeric', 'numeric', '_p_Date', '_p_Date', '_p_DayCounter', 'logical')
class(`CappedFlooredCmsCoupon__SWIG_0`) = c("SWIGFunction", class('CappedFlooredCmsCoupon__SWIG_0'))

# Start of new_CappedFlooredCmsCoupon

`CappedFlooredCmsCoupon__SWIG_1` = function(paymentDate, nominal, startDate, endDate, fixingDays, index, gearing, spread, cap, floor, refPeriodStart, refPeriodEnd, dayCounter)
{
  if(length(fixingDays) > 1) {
    warning("using only the first element of fixingDays");
  };
  
  
  
  
  
  
  
  
  
  ;ans = .Call('R_swig_new_CappedFlooredCmsCoupon__SWIG_1', paymentDate, nominal, startDate, endDate, fixingDays, index, gearing, spread, cap, floor, refPeriodStart, refPeriodEnd, dayCounter, PACKAGE='QuantLib');
  class(ans) <- "_p_CappedFlooredCmsCouponPtr";
  
  reg.finalizer(ans, delete_CappedFlooredCmsCoupon)
  ans
  
}

attr(`CappedFlooredCmsCoupon__SWIG_1`, 'returnType') = '_p_CappedFlooredCmsCouponPtr'
attr(`CappedFlooredCmsCoupon__SWIG_1`, "inputTypes") = c('_p_Date', 'numeric', '_p_Date', '_p_Date', 'integer', '_p_SwapIndexPtr', 'numeric', 'numeric', 'numeric', 'numeric', '_p_Date', '_p_Date', '_p_DayCounter')
class(`CappedFlooredCmsCoupon__SWIG_1`) = c("SWIGFunction", class('CappedFlooredCmsCoupon__SWIG_1'))

# Start of new_CappedFlooredCmsCoupon

`CappedFlooredCmsCoupon__SWIG_2` = function(paymentDate, nominal, startDate, endDate, fixingDays, index, gearing, spread, cap, floor, refPeriodStart, refPeriodEnd)
{
  if(length(fixingDays) > 1) {
    warning("using only the first element of fixingDays");
  };
  
  
  
  
  
  
  
  
  ;ans = .Call('R_swig_new_CappedFlooredCmsCoupon__SWIG_2', paymentDate, nominal, startDate, endDate, fixingDays, index, gearing, spread, cap, floor, refPeriodStart, refPeriodEnd, PACKAGE='QuantLib');
  class(ans) <- "_p_CappedFlooredCmsCouponPtr";
  
  reg.finalizer(ans, delete_CappedFlooredCmsCoupon)
  ans
  
}

attr(`CappedFlooredCmsCoupon__SWIG_2`, 'returnType') = '_p_CappedFlooredCmsCouponPtr'
attr(`CappedFlooredCmsCoupon__SWIG_2`, "inputTypes") = c('_p_Date', 'numeric', '_p_Date', '_p_Date', 'integer', '_p_SwapIndexPtr', 'numeric', 'numeric', 'numeric', 'numeric', '_p_Date', '_p_Date')
class(`CappedFlooredCmsCoupon__SWIG_2`) = c("SWIGFunction", class('CappedFlooredCmsCoupon__SWIG_2'))

# Start of new_CappedFlooredCmsCoupon

`CappedFlooredCmsCoupon__SWIG_3` = function(paymentDate, nominal, startDate, endDate, fixingDays, index, gearing, spread, cap, floor, refPeriodStart)
{
  if(length(fixingDays) > 1) {
    warning("using only the first element of fixingDays");
  };
  
  
  
  
  
  
  
  ;ans = .Call('R_swig_new_CappedFlooredCmsCoupon__SWIG_3', paymentDate, nominal, startDate, endDate, fixingDays, index, gearing, spread, cap, floor, refPeriodStart, PACKAGE='QuantLib');
  class(ans) <- "_p_CappedFlooredCmsCouponPtr";
  
  reg.finalizer(ans, delete_CappedFlooredCmsCoupon)
  ans
  
}

attr(`CappedFlooredCmsCoupon__SWIG_3`, 'returnType') = '_p_CappedFlooredCmsCouponPtr'
attr(`CappedFlooredCmsCoupon__SWIG_3`, "inputTypes") = c('_p_Date', 'numeric', '_p_Date', '_p_Date', 'integer', '_p_SwapIndexPtr', 'numeric', 'numeric', 'numeric', 'numeric', '_p_Date')
class(`CappedFlooredCmsCoupon__SWIG_3`) = c("SWIGFunction", class('CappedFlooredCmsCoupon__SWIG_3'))

# Start of new_CappedFlooredCmsCoupon

`CappedFlooredCmsCoupon__SWIG_4` = function(paymentDate, nominal, startDate, endDate, fixingDays, index, gearing, spread, cap, floor)
{
  if(length(fixingDays) > 1) {
    warning("using only the first element of fixingDays");
  };
  
  
  
  
  
  
  ;ans = .Call('R_swig_new_CappedFlooredCmsCoupon__SWIG_4', paymentDate, nominal, startDate, endDate, fixingDays, index, gearing, spread, cap, floor, PACKAGE='QuantLib');
  class(ans) <- "_p_CappedFlooredCmsCouponPtr";
  
  reg.finalizer(ans, delete_CappedFlooredCmsCoupon)
  ans
  
}

attr(`CappedFlooredCmsCoupon__SWIG_4`, 'returnType') = '_p_CappedFlooredCmsCouponPtr'
attr(`CappedFlooredCmsCoupon__SWIG_4`, "inputTypes") = c('_p_Date', 'numeric', '_p_Date', '_p_Date', 'integer', '_p_SwapIndexPtr', 'numeric', 'numeric', 'numeric', 'numeric')
class(`CappedFlooredCmsCoupon__SWIG_4`) = c("SWIGFunction", class('CappedFlooredCmsCoupon__SWIG_4'))

# Start of new_CappedFlooredCmsCoupon

`CappedFlooredCmsCoupon__SWIG_5` = function(paymentDate, nominal, startDate, endDate, fixingDays, index, gearing, spread, cap)
{
  if(length(fixingDays) > 1) {
    warning("using only the first element of fixingDays");
  };
  
  
  
  
  
  ;ans = .Call('R_swig_new_CappedFlooredCmsCoupon__SWIG_5', paymentDate, nominal, startDate, endDate, fixingDays, index, gearing, spread, cap, PACKAGE='QuantLib');
  class(ans) <- "_p_CappedFlooredCmsCouponPtr";
  
  reg.finalizer(ans, delete_CappedFlooredCmsCoupon)
  ans
  
}

attr(`CappedFlooredCmsCoupon__SWIG_5`, 'returnType') = '_p_CappedFlooredCmsCouponPtr'
attr(`CappedFlooredCmsCoupon__SWIG_5`, "inputTypes") = c('_p_Date', 'numeric', '_p_Date', '_p_Date', 'integer', '_p_SwapIndexPtr', 'numeric', 'numeric', 'numeric')
class(`CappedFlooredCmsCoupon__SWIG_5`) = c("SWIGFunction", class('CappedFlooredCmsCoupon__SWIG_5'))

# Start of new_CappedFlooredCmsCoupon

`CappedFlooredCmsCoupon__SWIG_6` = function(paymentDate, nominal, startDate, endDate, fixingDays, index, gearing, spread)
{
  if(length(fixingDays) > 1) {
    warning("using only the first element of fixingDays");
  };
  
  
  
  
  ;ans = .Call('R_swig_new_CappedFlooredCmsCoupon__SWIG_6', paymentDate, nominal, startDate, endDate, fixingDays, index, gearing, spread, PACKAGE='QuantLib');
  class(ans) <- "_p_CappedFlooredCmsCouponPtr";
  
  reg.finalizer(ans, delete_CappedFlooredCmsCoupon)
  ans
  
}

attr(`CappedFlooredCmsCoupon__SWIG_6`, 'returnType') = '_p_CappedFlooredCmsCouponPtr'
attr(`CappedFlooredCmsCoupon__SWIG_6`, "inputTypes") = c('_p_Date', 'numeric', '_p_Date', '_p_Date', 'integer', '_p_SwapIndexPtr', 'numeric', 'numeric')
class(`CappedFlooredCmsCoupon__SWIG_6`) = c("SWIGFunction", class('CappedFlooredCmsCoupon__SWIG_6'))

# Start of new_CappedFlooredCmsCoupon

`CappedFlooredCmsCoupon__SWIG_7` = function(paymentDate, nominal, startDate, endDate, fixingDays, index, gearing)
{
  if(length(fixingDays) > 1) {
    warning("using only the first element of fixingDays");
  };
  
  
  
  ;ans = .Call('R_swig_new_CappedFlooredCmsCoupon__SWIG_7', paymentDate, nominal, startDate, endDate, fixingDays, index, gearing, PACKAGE='QuantLib');
  class(ans) <- "_p_CappedFlooredCmsCouponPtr";
  
  reg.finalizer(ans, delete_CappedFlooredCmsCoupon)
  ans
  
}

attr(`CappedFlooredCmsCoupon__SWIG_7`, 'returnType') = '_p_CappedFlooredCmsCouponPtr'
attr(`CappedFlooredCmsCoupon__SWIG_7`, "inputTypes") = c('_p_Date', 'numeric', '_p_Date', '_p_Date', 'integer', '_p_SwapIndexPtr', 'numeric')
class(`CappedFlooredCmsCoupon__SWIG_7`) = c("SWIGFunction", class('CappedFlooredCmsCoupon__SWIG_7'))

# Start of new_CappedFlooredCmsCoupon

`CappedFlooredCmsCoupon__SWIG_8` = function(paymentDate, nominal, startDate, endDate, fixingDays, index)
{
  if(length(fixingDays) > 1) {
    warning("using only the first element of fixingDays");
  };
  
  
  ;ans = .Call('R_swig_new_CappedFlooredCmsCoupon__SWIG_8', paymentDate, nominal, startDate, endDate, fixingDays, index, PACKAGE='QuantLib');
  class(ans) <- "_p_CappedFlooredCmsCouponPtr";
  
  reg.finalizer(ans, delete_CappedFlooredCmsCoupon)
  ans
  
}

attr(`CappedFlooredCmsCoupon__SWIG_8`, 'returnType') = '_p_CappedFlooredCmsCouponPtr'
attr(`CappedFlooredCmsCoupon__SWIG_8`, "inputTypes") = c('_p_Date', 'numeric', '_p_Date', '_p_Date', 'integer', '_p_SwapIndexPtr')
class(`CappedFlooredCmsCoupon__SWIG_8`) = c("SWIGFunction", class('CappedFlooredCmsCoupon__SWIG_8'))

`CappedFlooredCmsCoupon` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 9
  if (argc == 6) {
    if (extends(argtypes[1], '_p_Date') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_Date') && extends(argtypes[4], '_p_Date') && (is.integer(argv[[5]]) || is.numeric(argv[[5]])) && extends(argtypes[6], '_p_SwapIndexPtr')) {
      f <- CappedFlooredCmsCoupon__SWIG_8; 
    }
  } else if (argc == 7) {
    if (extends(argtypes[1], '_p_Date') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_Date') && extends(argtypes[4], '_p_Date') && (is.integer(argv[[5]]) || is.numeric(argv[[5]])) && extends(argtypes[6], '_p_SwapIndexPtr') && is.numeric(argv[[7]])) {
      f <- CappedFlooredCmsCoupon__SWIG_7; 
    }
  } else if (argc == 8) {
    if (extends(argtypes[1], '_p_Date') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_Date') && extends(argtypes[4], '_p_Date') && (is.integer(argv[[5]]) || is.numeric(argv[[5]])) && extends(argtypes[6], '_p_SwapIndexPtr') && is.numeric(argv[[7]]) && is.numeric(argv[[8]])) {
      f <- CappedFlooredCmsCoupon__SWIG_6; 
    }
  } else if (argc == 9) {
    if (extends(argtypes[1], '_p_Date') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_Date') && extends(argtypes[4], '_p_Date') && (is.integer(argv[[5]]) || is.numeric(argv[[5]])) && extends(argtypes[6], '_p_SwapIndexPtr') && is.numeric(argv[[7]]) && is.numeric(argv[[8]]) && is.numeric(argv[[9]])) {
      f <- CappedFlooredCmsCoupon__SWIG_5; 
    }
  } else if (argc == 10) {
    if (extends(argtypes[1], '_p_Date') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_Date') && extends(argtypes[4], '_p_Date') && (is.integer(argv[[5]]) || is.numeric(argv[[5]])) && extends(argtypes[6], '_p_SwapIndexPtr') && is.numeric(argv[[7]]) && is.numeric(argv[[8]]) && is.numeric(argv[[9]]) && is.numeric(argv[[10]])) {
      f <- CappedFlooredCmsCoupon__SWIG_4; 
    }
  } else if (argc == 11) {
    if (extends(argtypes[1], '_p_Date') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_Date') && extends(argtypes[4], '_p_Date') && (is.integer(argv[[5]]) || is.numeric(argv[[5]])) && extends(argtypes[6], '_p_SwapIndexPtr') && is.numeric(argv[[7]]) && is.numeric(argv[[8]]) && is.numeric(argv[[9]]) && is.numeric(argv[[10]]) && extends(argtypes[11], '_p_Date')) {
      f <- CappedFlooredCmsCoupon__SWIG_3; 
    }
  } else if (argc == 12) {
    if (extends(argtypes[1], '_p_Date') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_Date') && extends(argtypes[4], '_p_Date') && (is.integer(argv[[5]]) || is.numeric(argv[[5]])) && extends(argtypes[6], '_p_SwapIndexPtr') && is.numeric(argv[[7]]) && is.numeric(argv[[8]]) && is.numeric(argv[[9]]) && is.numeric(argv[[10]]) && extends(argtypes[11], '_p_Date') && extends(argtypes[12], '_p_Date')) {
      f <- CappedFlooredCmsCoupon__SWIG_2; 
    }
  } else if (argc == 13) {
    if (extends(argtypes[1], '_p_Date') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_Date') && extends(argtypes[4], '_p_Date') && (is.integer(argv[[5]]) || is.numeric(argv[[5]])) && extends(argtypes[6], '_p_SwapIndexPtr') && is.numeric(argv[[7]]) && is.numeric(argv[[8]]) && is.numeric(argv[[9]]) && is.numeric(argv[[10]]) && extends(argtypes[11], '_p_Date') && extends(argtypes[12], '_p_Date') && extends(argtypes[13], '_p_DayCounter')) {
      f <- CappedFlooredCmsCoupon__SWIG_1; 
    }
  } else if (argc == 14) {
    if (extends(argtypes[1], '_p_Date') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_Date') && extends(argtypes[4], '_p_Date') && (is.integer(argv[[5]]) || is.numeric(argv[[5]])) && extends(argtypes[6], '_p_SwapIndexPtr') && is.numeric(argv[[7]]) && is.numeric(argv[[8]]) && is.numeric(argv[[9]]) && is.numeric(argv[[10]]) && extends(argtypes[11], '_p_Date') && extends(argtypes[12], '_p_Date') && extends(argtypes[13], '_p_DayCounter') && extends(argtypes[14], 'logical')) {
      f <- CappedFlooredCmsCoupon__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for CappedFlooredCmsCoupon with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_CappedFlooredCmsCoupon

`delete_CappedFlooredCmsCoupon` = function(self)
{
  ;.Call('R_swig_delete_CappedFlooredCmsCoupon', self, PACKAGE='QuantLib');
  
}

attr(`delete_CappedFlooredCmsCoupon`, 'returnType') = 'void'
attr(`delete_CappedFlooredCmsCoupon`, "inputTypes") = c('_p_CappedFlooredCmsCouponPtr')
class(`delete_CappedFlooredCmsCoupon`) = c("SWIGFunction", class('delete_CappedFlooredCmsCoupon'))

setMethod('delete', '_p_CappedFlooredCmsCouponPtr', function(obj) {delete_CappedFlooredCmsCouponPtr(obj)})
# Start of FixedRateLeg

`FixedRateLeg` = function(schedule, dayCount, nominals, couponRates, paymentAdjustment, firstPeriodDayCount, .copy = FALSE)
{
  paymentAdjustment = enumToInteger(paymentAdjustment, "_BusinessDayConvention"); 
  
  if(length(paymentAdjustment) > 1) {
    warning("using only the first element of paymentAdjustment");
  };
  
  
  ;ans = .Call('R_swig_FixedRateLeg', schedule, dayCount, nominals, couponRates, paymentAdjustment, firstPeriodDayCount, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t";
  
  ans
  
}

attr(`FixedRateLeg`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t'
attr(`FixedRateLeg`, "inputTypes") = c('_p_Schedule', '_p_DayCounter', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t', 'character', '_p_DayCounter')
class(`FixedRateLeg`) = c("SWIGFunction", class('FixedRateLeg'))

# Start of IborLeg

`IborLeg` = function(nominals, schedule, index, paymentDayCounter, paymentConvention, fixingDays, gearings, spreads, caps, floors, isInArrears, .copy = FALSE)
{
  paymentConvention = enumToInteger(paymentConvention, "_BusinessDayConvention"); 
  
  if(length(paymentConvention) > 1) {
    warning("using only the first element of paymentConvention");
  };
  
  
  
  
  
  
  isInArrears = as.logical(isInArrears);
  ;ans = .Call('R_swig_IborLeg', nominals, schedule, index, paymentDayCounter, paymentConvention, fixingDays, gearings, spreads, caps, floors, isInArrears, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t";
  
  ans
  
}

attr(`IborLeg`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t'
attr(`IborLeg`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_Schedule', '_p_IborIndexPtr', '_p_DayCounter', 'character', '_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t', 'logical')
class(`IborLeg`) = c("SWIGFunction", class('IborLeg'))

# Start of CmsLeg

`CmsLeg` = function(nominals, schedule, index, paymentDayCounter, paymentConvention, fixingDays, gearings, spreads, caps, floors, isInArrears, .copy = FALSE)
{
  paymentConvention = enumToInteger(paymentConvention, "_BusinessDayConvention"); 
  
  if(length(paymentConvention) > 1) {
    warning("using only the first element of paymentConvention");
  };
  
  
  
  
  
  
  isInArrears = as.logical(isInArrears);
  ;ans = .Call('R_swig_CmsLeg', nominals, schedule, index, paymentDayCounter, paymentConvention, fixingDays, gearings, spreads, caps, floors, isInArrears, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t";
  
  ans
  
}

attr(`CmsLeg`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t'
attr(`CmsLeg`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_Schedule', '_p_SwapIndexPtr', '_p_DayCounter', 'character', '_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t', 'logical')
class(`CmsLeg`) = c("SWIGFunction", class('CmsLeg'))

# Start of CmsZeroLeg

`CmsZeroLeg` = function(nominals, schedule, index, paymentDayCounter, paymentConvention, fixingDays, gearings, spreads, caps, floors, .copy = FALSE)
{
  paymentConvention = enumToInteger(paymentConvention, "_BusinessDayConvention"); 
  
  if(length(paymentConvention) > 1) {
    warning("using only the first element of paymentConvention");
  };
  
  
  
  
  
  
  ;ans = .Call('R_swig_CmsZeroLeg', nominals, schedule, index, paymentDayCounter, paymentConvention, fixingDays, gearings, spreads, caps, floors, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t";
  
  ans
  
}

attr(`CmsZeroLeg`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t'
attr(`CmsZeroLeg`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_Schedule', '_p_SwapIndexPtr', '_p_DayCounter', 'character', '_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`CmsZeroLeg`) = c("SWIGFunction", class('CmsZeroLeg'))

defineEnumeration('_Duration__Type',
                    .values = c(
                        'Simple' = 0, 
                        'Macaulay' = 1, 
                        'Modified' = 2
))
# Start of new_Duration

`Duration` = function()
{
  ;ans = .Call('R_swig_new_Duration', PACKAGE='QuantLib');
  class(ans) <- "_p_Duration";
  
  reg.finalizer(ans, delete_Duration)
  ans
  
}

attr(`Duration`, 'returnType') = '_p_Duration'
class(`Duration`) = c("SWIGFunction", class('Duration'))

# Start of delete_Duration

`delete_Duration` = function(self)
{
  ;.Call('R_swig_delete_Duration', self, PACKAGE='QuantLib');
  
}

attr(`delete_Duration`, 'returnType') = 'void'
attr(`delete_Duration`, "inputTypes") = c('_p_Duration')
class(`delete_Duration`) = c("SWIGFunction", class('delete_Duration'))

setMethod('delete', '_p_Duration', function(obj) {delete_Duration(obj)})
# Start definition of copy functions & methods for Duration
CopyToR_Duration = function(value, obj = new("Duration"))
{
  obj;
}



CopyToC_Duration = function(value, obj)
{
  obj
}



# Start definition of copy methods for Duration
setMethod('copyToR', '_p_Duration', CopyToR_Duration);
setMethod('copyToC', 'Duration', CopyToC_Duration);

# End definition of copy methods for Duration
# End definition of copy functions & methods for Duration
# Start of CashFlows_startDate

`CashFlows_startDate` = function(s_arg1, .copy = FALSE)
{
  ;ans = .Call('R_swig_CashFlows_startDate', s_arg1, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`CashFlows_startDate`, 'returnType') = '_p_Date'
attr(`CashFlows_startDate`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t')
class(`CashFlows_startDate`) = c("SWIGFunction", class('CashFlows_startDate'))

# Start of CashFlows_maturityDate

`CashFlows_maturityDate` = function(s_arg1, .copy = FALSE)
{
  ;ans = .Call('R_swig_CashFlows_maturityDate', s_arg1, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`CashFlows_maturityDate`, 'returnType') = '_p_Date'
attr(`CashFlows_maturityDate`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t')
class(`CashFlows_maturityDate`) = c("SWIGFunction", class('CashFlows_maturityDate'))

# Start of CashFlows_npv

`CashFlows_npv__SWIG_0` = function(leg, discountCurve, zSpread, dayCounter, compounding, frequency, includeSettlementDateFlows, settlementDate, npvDate, .copy = FALSE)
{
  compounding = enumToInteger(compounding, "_Compounding"); 
  
  if(length(compounding) > 1) {
    warning("using only the first element of compounding");
  };
  
  frequency = enumToInteger(frequency, "_Frequency"); 
  
  if(length(frequency) > 1) {
    warning("using only the first element of frequency");
  };
  
  includeSettlementDateFlows = as.logical(includeSettlementDateFlows);
  
  
  ;.Call('R_swig_CashFlows_npv__SWIG_0', leg, discountCurve, zSpread, dayCounter, compounding, frequency, includeSettlementDateFlows, settlementDate, npvDate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CashFlows_npv__SWIG_0`, 'returnType') = 'numeric'
attr(`CashFlows_npv__SWIG_0`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', '_p_boost__shared_ptrT_YieldTermStructure_t', 'numeric', '_p_DayCounter', 'character', 'character', 'logical', '_p_Date', '_p_Date')
class(`CashFlows_npv__SWIG_0`) = c("SWIGFunction", class('CashFlows_npv__SWIG_0'))

# Start of CashFlows_npv

`CashFlows_npv__SWIG_1` = function(leg, discountCurve, zSpread, dayCounter, compounding, frequency, includeSettlementDateFlows, settlementDate, .copy = FALSE)
{
  compounding = enumToInteger(compounding, "_Compounding"); 
  
  if(length(compounding) > 1) {
    warning("using only the first element of compounding");
  };
  
  frequency = enumToInteger(frequency, "_Frequency"); 
  
  if(length(frequency) > 1) {
    warning("using only the first element of frequency");
  };
  
  includeSettlementDateFlows = as.logical(includeSettlementDateFlows);
  
  ;.Call('R_swig_CashFlows_npv__SWIG_1', leg, discountCurve, zSpread, dayCounter, compounding, frequency, includeSettlementDateFlows, settlementDate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CashFlows_npv__SWIG_1`, 'returnType') = 'numeric'
attr(`CashFlows_npv__SWIG_1`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', '_p_boost__shared_ptrT_YieldTermStructure_t', 'numeric', '_p_DayCounter', 'character', 'character', 'logical', '_p_Date')
class(`CashFlows_npv__SWIG_1`) = c("SWIGFunction", class('CashFlows_npv__SWIG_1'))

# Start of CashFlows_npv

`CashFlows_npv__SWIG_2` = function(leg, discountCurve, zSpread, dayCounter, compounding, frequency, includeSettlementDateFlows, .copy = FALSE)
{
  compounding = enumToInteger(compounding, "_Compounding"); 
  
  if(length(compounding) > 1) {
    warning("using only the first element of compounding");
  };
  
  frequency = enumToInteger(frequency, "_Frequency"); 
  
  if(length(frequency) > 1) {
    warning("using only the first element of frequency");
  };
  
  includeSettlementDateFlows = as.logical(includeSettlementDateFlows);
  ;.Call('R_swig_CashFlows_npv__SWIG_2', leg, discountCurve, zSpread, dayCounter, compounding, frequency, includeSettlementDateFlows, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CashFlows_npv__SWIG_2`, 'returnType') = 'numeric'
attr(`CashFlows_npv__SWIG_2`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', '_p_boost__shared_ptrT_YieldTermStructure_t', 'numeric', '_p_DayCounter', 'character', 'character', 'logical')
class(`CashFlows_npv__SWIG_2`) = c("SWIGFunction", class('CashFlows_npv__SWIG_2'))

# Start of CashFlows_npv

`CashFlows_npv__SWIG_3` = function(leg, discountCurve, includeSettlementDateFlows, settlementDate, npvDate, .copy = FALSE)
{
  includeSettlementDateFlows = as.logical(includeSettlementDateFlows);
  
  
  ;.Call('R_swig_CashFlows_npv__SWIG_3', leg, discountCurve, includeSettlementDateFlows, settlementDate, npvDate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CashFlows_npv__SWIG_3`, 'returnType') = 'numeric'
attr(`CashFlows_npv__SWIG_3`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', '_p_HandleT_YieldTermStructure_t', 'logical', '_p_Date', '_p_Date')
class(`CashFlows_npv__SWIG_3`) = c("SWIGFunction", class('CashFlows_npv__SWIG_3'))

# Start of CashFlows_npv

`CashFlows_npv__SWIG_4` = function(leg, discountCurve, includeSettlementDateFlows, settlementDate, .copy = FALSE)
{
  includeSettlementDateFlows = as.logical(includeSettlementDateFlows);
  
  ;.Call('R_swig_CashFlows_npv__SWIG_4', leg, discountCurve, includeSettlementDateFlows, settlementDate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CashFlows_npv__SWIG_4`, 'returnType') = 'numeric'
attr(`CashFlows_npv__SWIG_4`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', '_p_HandleT_YieldTermStructure_t', 'logical', '_p_Date')
class(`CashFlows_npv__SWIG_4`) = c("SWIGFunction", class('CashFlows_npv__SWIG_4'))

# Start of CashFlows_npv

`CashFlows_npv__SWIG_5` = function(leg, discountCurve, includeSettlementDateFlows, .copy = FALSE)
{
  includeSettlementDateFlows = as.logical(includeSettlementDateFlows);
  ;.Call('R_swig_CashFlows_npv__SWIG_5', leg, discountCurve, includeSettlementDateFlows, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CashFlows_npv__SWIG_5`, 'returnType') = 'numeric'
attr(`CashFlows_npv__SWIG_5`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', '_p_HandleT_YieldTermStructure_t', 'logical')
class(`CashFlows_npv__SWIG_5`) = c("SWIGFunction", class('CashFlows_npv__SWIG_5'))

# Start of CashFlows_npv

`CashFlows_npv__SWIG_6` = function(s_arg1, s_arg2, includeSettlementDateFlows, settlementDate, npvDate, .copy = FALSE)
{
  includeSettlementDateFlows = as.logical(includeSettlementDateFlows);
  
  
  ;.Call('R_swig_CashFlows_npv__SWIG_6', s_arg1, s_arg2, includeSettlementDateFlows, settlementDate, npvDate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CashFlows_npv__SWIG_6`, 'returnType') = 'numeric'
attr(`CashFlows_npv__SWIG_6`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', '_p_InterestRate', 'logical', '_p_Date', '_p_Date')
class(`CashFlows_npv__SWIG_6`) = c("SWIGFunction", class('CashFlows_npv__SWIG_6'))

# Start of CashFlows_npv

`CashFlows_npv__SWIG_7` = function(s_arg1, s_arg2, includeSettlementDateFlows, settlementDate, .copy = FALSE)
{
  includeSettlementDateFlows = as.logical(includeSettlementDateFlows);
  
  ;.Call('R_swig_CashFlows_npv__SWIG_7', s_arg1, s_arg2, includeSettlementDateFlows, settlementDate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CashFlows_npv__SWIG_7`, 'returnType') = 'numeric'
attr(`CashFlows_npv__SWIG_7`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', '_p_InterestRate', 'logical', '_p_Date')
class(`CashFlows_npv__SWIG_7`) = c("SWIGFunction", class('CashFlows_npv__SWIG_7'))

# Start of CashFlows_npv

`CashFlows_npv__SWIG_8` = function(s_arg1, s_arg2, includeSettlementDateFlows, .copy = FALSE)
{
  includeSettlementDateFlows = as.logical(includeSettlementDateFlows);
  ;.Call('R_swig_CashFlows_npv__SWIG_8', s_arg1, s_arg2, includeSettlementDateFlows, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CashFlows_npv__SWIG_8`, 'returnType') = 'numeric'
attr(`CashFlows_npv__SWIG_8`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', '_p_InterestRate', 'logical')
class(`CashFlows_npv__SWIG_8`) = c("SWIGFunction", class('CashFlows_npv__SWIG_8'))

# Start of CashFlows_npv

`CashFlows_npv__SWIG_9` = function(s_arg1, yield, dayCounter, compounding, frequency, includeSettlementDateFlows, settlementDate, npvDate, .copy = FALSE)
{
  compounding = enumToInteger(compounding, "_Compounding"); 
  
  if(length(compounding) > 1) {
    warning("using only the first element of compounding");
  };
  
  frequency = enumToInteger(frequency, "_Frequency"); 
  
  if(length(frequency) > 1) {
    warning("using only the first element of frequency");
  };
  
  includeSettlementDateFlows = as.logical(includeSettlementDateFlows);
  
  
  ;.Call('R_swig_CashFlows_npv__SWIG_9', s_arg1, yield, dayCounter, compounding, frequency, includeSettlementDateFlows, settlementDate, npvDate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CashFlows_npv__SWIG_9`, 'returnType') = 'numeric'
attr(`CashFlows_npv__SWIG_9`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', 'numeric', '_p_DayCounter', 'character', 'character', 'logical', '_p_Date', '_p_Date')
class(`CashFlows_npv__SWIG_9`) = c("SWIGFunction", class('CashFlows_npv__SWIG_9'))

# Start of CashFlows_npv

`CashFlows_npv__SWIG_10` = function(s_arg1, yield, dayCounter, compounding, frequency, includeSettlementDateFlows, settlementDate, .copy = FALSE)
{
  compounding = enumToInteger(compounding, "_Compounding"); 
  
  if(length(compounding) > 1) {
    warning("using only the first element of compounding");
  };
  
  frequency = enumToInteger(frequency, "_Frequency"); 
  
  if(length(frequency) > 1) {
    warning("using only the first element of frequency");
  };
  
  includeSettlementDateFlows = as.logical(includeSettlementDateFlows);
  
  ;.Call('R_swig_CashFlows_npv__SWIG_10', s_arg1, yield, dayCounter, compounding, frequency, includeSettlementDateFlows, settlementDate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CashFlows_npv__SWIG_10`, 'returnType') = 'numeric'
attr(`CashFlows_npv__SWIG_10`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', 'numeric', '_p_DayCounter', 'character', 'character', 'logical', '_p_Date')
class(`CashFlows_npv__SWIG_10`) = c("SWIGFunction", class('CashFlows_npv__SWIG_10'))

# Start of CashFlows_npv

`CashFlows_npv__SWIG_11` = function(s_arg1, yield, dayCounter, compounding, frequency, includeSettlementDateFlows, .copy = FALSE)
{
  compounding = enumToInteger(compounding, "_Compounding"); 
  
  if(length(compounding) > 1) {
    warning("using only the first element of compounding");
  };
  
  frequency = enumToInteger(frequency, "_Frequency"); 
  
  if(length(frequency) > 1) {
    warning("using only the first element of frequency");
  };
  
  includeSettlementDateFlows = as.logical(includeSettlementDateFlows);
  ;.Call('R_swig_CashFlows_npv__SWIG_11', s_arg1, yield, dayCounter, compounding, frequency, includeSettlementDateFlows, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CashFlows_npv__SWIG_11`, 'returnType') = 'numeric'
attr(`CashFlows_npv__SWIG_11`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', 'numeric', '_p_DayCounter', 'character', 'character', 'logical')
class(`CashFlows_npv__SWIG_11`) = c("SWIGFunction", class('CashFlows_npv__SWIG_11'))

`CashFlows_npv` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 12
  if (argc == 3) {
    if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t') && extends(argtypes[2], '_p_HandleT_YieldTermStructure_t') && extends(argtypes[3], 'logical')) {
      f <- CashFlows_npv__SWIG_5; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t') && extends(argtypes[2], '_p_InterestRate') && extends(argtypes[3], 'logical')) {
      f <- CashFlows_npv__SWIG_8; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t') && extends(argtypes[2], '_p_InterestRate') && extends(argtypes[3], 'logical') && extends(argtypes[4], '_p_Date')) {
      f <- CashFlows_npv__SWIG_7; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t') && extends(argtypes[2], '_p_HandleT_YieldTermStructure_t') && extends(argtypes[3], 'logical') && extends(argtypes[4], '_p_Date')) {
      f <- CashFlows_npv__SWIG_4; 
    }
  } else if (argc == 5) {
    if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t') && extends(argtypes[2], '_p_HandleT_YieldTermStructure_t') && extends(argtypes[3], 'logical') && extends(argtypes[4], '_p_Date') && extends(argtypes[5], '_p_Date')) {
      f <- CashFlows_npv__SWIG_3; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t') && extends(argtypes[2], '_p_InterestRate') && extends(argtypes[3], 'logical') && extends(argtypes[4], '_p_Date') && extends(argtypes[5], '_p_Date')) {
      f <- CashFlows_npv__SWIG_6; 
    }
  } else if (argc == 6) {
    if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_DayCounter') && is.character(argv[[4]]) && is.character(argv[[5]]) && extends(argtypes[6], 'logical')) {
      f <- CashFlows_npv__SWIG_11; 
    }
  } else if (argc == 7) {
    if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t') && extends(argtypes[2], '_p_boost__shared_ptrT_YieldTermStructure_t') && is.numeric(argv[[3]]) && extends(argtypes[4], '_p_DayCounter') && is.character(argv[[5]]) && is.character(argv[[6]]) && extends(argtypes[7], 'logical')) {
      f <- CashFlows_npv__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_DayCounter') && is.character(argv[[4]]) && is.character(argv[[5]]) && extends(argtypes[6], 'logical') && extends(argtypes[7], '_p_Date')) {
      f <- CashFlows_npv__SWIG_10; 
    }
  } else if (argc == 8) {
    if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t') && extends(argtypes[2], '_p_boost__shared_ptrT_YieldTermStructure_t') && is.numeric(argv[[3]]) && extends(argtypes[4], '_p_DayCounter') && is.character(argv[[5]]) && is.character(argv[[6]]) && extends(argtypes[7], 'logical') && extends(argtypes[8], '_p_Date')) {
      f <- CashFlows_npv__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_DayCounter') && is.character(argv[[4]]) && is.character(argv[[5]]) && extends(argtypes[6], 'logical') && extends(argtypes[7], '_p_Date') && extends(argtypes[8], '_p_Date')) {
      f <- CashFlows_npv__SWIG_9; 
    }
  } else if (argc == 9) {
    if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t') && extends(argtypes[2], '_p_boost__shared_ptrT_YieldTermStructure_t') && is.numeric(argv[[3]]) && extends(argtypes[4], '_p_DayCounter') && is.character(argv[[5]]) && is.character(argv[[6]]) && extends(argtypes[7], 'logical') && extends(argtypes[8], '_p_Date') && extends(argtypes[9], '_p_Date')) {
      f <- CashFlows_npv__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for CashFlows_npv with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of CashFlows_bps

`CashFlows_bps__SWIG_0` = function(leg, discountCurve, includeSettlementDateFlows, settlementDate, npvDate, .copy = FALSE)
{
  includeSettlementDateFlows = as.logical(includeSettlementDateFlows);
  
  
  ;.Call('R_swig_CashFlows_bps__SWIG_0', leg, discountCurve, includeSettlementDateFlows, settlementDate, npvDate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CashFlows_bps__SWIG_0`, 'returnType') = 'numeric'
attr(`CashFlows_bps__SWIG_0`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', '_p_boost__shared_ptrT_YieldTermStructure_t', 'logical', '_p_Date', '_p_Date')
class(`CashFlows_bps__SWIG_0`) = c("SWIGFunction", class('CashFlows_bps__SWIG_0'))

# Start of CashFlows_bps

`CashFlows_bps__SWIG_1` = function(leg, discountCurve, includeSettlementDateFlows, settlementDate, .copy = FALSE)
{
  includeSettlementDateFlows = as.logical(includeSettlementDateFlows);
  
  ;.Call('R_swig_CashFlows_bps__SWIG_1', leg, discountCurve, includeSettlementDateFlows, settlementDate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CashFlows_bps__SWIG_1`, 'returnType') = 'numeric'
attr(`CashFlows_bps__SWIG_1`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', '_p_boost__shared_ptrT_YieldTermStructure_t', 'logical', '_p_Date')
class(`CashFlows_bps__SWIG_1`) = c("SWIGFunction", class('CashFlows_bps__SWIG_1'))

# Start of CashFlows_bps

`CashFlows_bps__SWIG_2` = function(leg, discountCurve, includeSettlementDateFlows, .copy = FALSE)
{
  includeSettlementDateFlows = as.logical(includeSettlementDateFlows);
  ;.Call('R_swig_CashFlows_bps__SWIG_2', leg, discountCurve, includeSettlementDateFlows, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CashFlows_bps__SWIG_2`, 'returnType') = 'numeric'
attr(`CashFlows_bps__SWIG_2`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', '_p_boost__shared_ptrT_YieldTermStructure_t', 'logical')
class(`CashFlows_bps__SWIG_2`) = c("SWIGFunction", class('CashFlows_bps__SWIG_2'))

# Start of CashFlows_bps

`CashFlows_bps__SWIG_3` = function(leg, discountCurve, includeSettlementDateFlows, settlementDate, npvDate, .copy = FALSE)
{
  includeSettlementDateFlows = as.logical(includeSettlementDateFlows);
  
  
  ;.Call('R_swig_CashFlows_bps__SWIG_3', leg, discountCurve, includeSettlementDateFlows, settlementDate, npvDate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CashFlows_bps__SWIG_3`, 'returnType') = 'numeric'
attr(`CashFlows_bps__SWIG_3`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', '_p_HandleT_YieldTermStructure_t', 'logical', '_p_Date', '_p_Date')
class(`CashFlows_bps__SWIG_3`) = c("SWIGFunction", class('CashFlows_bps__SWIG_3'))

# Start of CashFlows_bps

`CashFlows_bps__SWIG_4` = function(leg, discountCurve, includeSettlementDateFlows, settlementDate, .copy = FALSE)
{
  includeSettlementDateFlows = as.logical(includeSettlementDateFlows);
  
  ;.Call('R_swig_CashFlows_bps__SWIG_4', leg, discountCurve, includeSettlementDateFlows, settlementDate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CashFlows_bps__SWIG_4`, 'returnType') = 'numeric'
attr(`CashFlows_bps__SWIG_4`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', '_p_HandleT_YieldTermStructure_t', 'logical', '_p_Date')
class(`CashFlows_bps__SWIG_4`) = c("SWIGFunction", class('CashFlows_bps__SWIG_4'))

# Start of CashFlows_bps

`CashFlows_bps__SWIG_5` = function(leg, discountCurve, includeSettlementDateFlows, .copy = FALSE)
{
  includeSettlementDateFlows = as.logical(includeSettlementDateFlows);
  ;.Call('R_swig_CashFlows_bps__SWIG_5', leg, discountCurve, includeSettlementDateFlows, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CashFlows_bps__SWIG_5`, 'returnType') = 'numeric'
attr(`CashFlows_bps__SWIG_5`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', '_p_HandleT_YieldTermStructure_t', 'logical')
class(`CashFlows_bps__SWIG_5`) = c("SWIGFunction", class('CashFlows_bps__SWIG_5'))

# Start of CashFlows_bps

`CashFlows_bps__SWIG_6` = function(s_arg1, s_arg2, includeSettlementDateFlows, settlementDate, npvDate, .copy = FALSE)
{
  includeSettlementDateFlows = as.logical(includeSettlementDateFlows);
  
  
  ;.Call('R_swig_CashFlows_bps__SWIG_6', s_arg1, s_arg2, includeSettlementDateFlows, settlementDate, npvDate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CashFlows_bps__SWIG_6`, 'returnType') = 'numeric'
attr(`CashFlows_bps__SWIG_6`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', '_p_InterestRate', 'logical', '_p_Date', '_p_Date')
class(`CashFlows_bps__SWIG_6`) = c("SWIGFunction", class('CashFlows_bps__SWIG_6'))

# Start of CashFlows_bps

`CashFlows_bps__SWIG_7` = function(s_arg1, s_arg2, includeSettlementDateFlows, settlementDate, .copy = FALSE)
{
  includeSettlementDateFlows = as.logical(includeSettlementDateFlows);
  
  ;.Call('R_swig_CashFlows_bps__SWIG_7', s_arg1, s_arg2, includeSettlementDateFlows, settlementDate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CashFlows_bps__SWIG_7`, 'returnType') = 'numeric'
attr(`CashFlows_bps__SWIG_7`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', '_p_InterestRate', 'logical', '_p_Date')
class(`CashFlows_bps__SWIG_7`) = c("SWIGFunction", class('CashFlows_bps__SWIG_7'))

# Start of CashFlows_bps

`CashFlows_bps__SWIG_8` = function(s_arg1, s_arg2, includeSettlementDateFlows, .copy = FALSE)
{
  includeSettlementDateFlows = as.logical(includeSettlementDateFlows);
  ;.Call('R_swig_CashFlows_bps__SWIG_8', s_arg1, s_arg2, includeSettlementDateFlows, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CashFlows_bps__SWIG_8`, 'returnType') = 'numeric'
attr(`CashFlows_bps__SWIG_8`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', '_p_InterestRate', 'logical')
class(`CashFlows_bps__SWIG_8`) = c("SWIGFunction", class('CashFlows_bps__SWIG_8'))

# Start of CashFlows_bps

`CashFlows_bps__SWIG_9` = function(s_arg1, yield, dayCounter, compounding, frequency, includeSettlementDateFlows, settlementDate, npvDate, .copy = FALSE)
{
  compounding = enumToInteger(compounding, "_Compounding"); 
  
  if(length(compounding) > 1) {
    warning("using only the first element of compounding");
  };
  
  frequency = enumToInteger(frequency, "_Frequency"); 
  
  if(length(frequency) > 1) {
    warning("using only the first element of frequency");
  };
  
  includeSettlementDateFlows = as.logical(includeSettlementDateFlows);
  
  
  ;.Call('R_swig_CashFlows_bps__SWIG_9', s_arg1, yield, dayCounter, compounding, frequency, includeSettlementDateFlows, settlementDate, npvDate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CashFlows_bps__SWIG_9`, 'returnType') = 'numeric'
attr(`CashFlows_bps__SWIG_9`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', 'numeric', '_p_DayCounter', 'character', 'character', 'logical', '_p_Date', '_p_Date')
class(`CashFlows_bps__SWIG_9`) = c("SWIGFunction", class('CashFlows_bps__SWIG_9'))

# Start of CashFlows_bps

`CashFlows_bps__SWIG_10` = function(s_arg1, yield, dayCounter, compounding, frequency, includeSettlementDateFlows, settlementDate, .copy = FALSE)
{
  compounding = enumToInteger(compounding, "_Compounding"); 
  
  if(length(compounding) > 1) {
    warning("using only the first element of compounding");
  };
  
  frequency = enumToInteger(frequency, "_Frequency"); 
  
  if(length(frequency) > 1) {
    warning("using only the first element of frequency");
  };
  
  includeSettlementDateFlows = as.logical(includeSettlementDateFlows);
  
  ;.Call('R_swig_CashFlows_bps__SWIG_10', s_arg1, yield, dayCounter, compounding, frequency, includeSettlementDateFlows, settlementDate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CashFlows_bps__SWIG_10`, 'returnType') = 'numeric'
attr(`CashFlows_bps__SWIG_10`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', 'numeric', '_p_DayCounter', 'character', 'character', 'logical', '_p_Date')
class(`CashFlows_bps__SWIG_10`) = c("SWIGFunction", class('CashFlows_bps__SWIG_10'))

# Start of CashFlows_bps

`CashFlows_bps__SWIG_11` = function(s_arg1, yield, dayCounter, compounding, frequency, includeSettlementDateFlows, .copy = FALSE)
{
  compounding = enumToInteger(compounding, "_Compounding"); 
  
  if(length(compounding) > 1) {
    warning("using only the first element of compounding");
  };
  
  frequency = enumToInteger(frequency, "_Frequency"); 
  
  if(length(frequency) > 1) {
    warning("using only the first element of frequency");
  };
  
  includeSettlementDateFlows = as.logical(includeSettlementDateFlows);
  ;.Call('R_swig_CashFlows_bps__SWIG_11', s_arg1, yield, dayCounter, compounding, frequency, includeSettlementDateFlows, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CashFlows_bps__SWIG_11`, 'returnType') = 'numeric'
attr(`CashFlows_bps__SWIG_11`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', 'numeric', '_p_DayCounter', 'character', 'character', 'logical')
class(`CashFlows_bps__SWIG_11`) = c("SWIGFunction", class('CashFlows_bps__SWIG_11'))

`CashFlows_bps` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 12
  if (argc == 3) {
    if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t') && extends(argtypes[2], '_p_boost__shared_ptrT_YieldTermStructure_t') && extends(argtypes[3], 'logical')) {
      f <- CashFlows_bps__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t') && extends(argtypes[2], '_p_HandleT_YieldTermStructure_t') && extends(argtypes[3], 'logical')) {
      f <- CashFlows_bps__SWIG_5; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t') && extends(argtypes[2], '_p_InterestRate') && extends(argtypes[3], 'logical')) {
      f <- CashFlows_bps__SWIG_8; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t') && extends(argtypes[2], '_p_boost__shared_ptrT_YieldTermStructure_t') && extends(argtypes[3], 'logical') && extends(argtypes[4], '_p_Date')) {
      f <- CashFlows_bps__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t') && extends(argtypes[2], '_p_InterestRate') && extends(argtypes[3], 'logical') && extends(argtypes[4], '_p_Date')) {
      f <- CashFlows_bps__SWIG_7; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t') && extends(argtypes[2], '_p_HandleT_YieldTermStructure_t') && extends(argtypes[3], 'logical') && extends(argtypes[4], '_p_Date')) {
      f <- CashFlows_bps__SWIG_4; 
    }
  } else if (argc == 5) {
    if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t') && extends(argtypes[2], '_p_InterestRate') && extends(argtypes[3], 'logical') && extends(argtypes[4], '_p_Date') && extends(argtypes[5], '_p_Date')) {
      f <- CashFlows_bps__SWIG_6; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t') && extends(argtypes[2], '_p_boost__shared_ptrT_YieldTermStructure_t') && extends(argtypes[3], 'logical') && extends(argtypes[4], '_p_Date') && extends(argtypes[5], '_p_Date')) {
      f <- CashFlows_bps__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t') && extends(argtypes[2], '_p_HandleT_YieldTermStructure_t') && extends(argtypes[3], 'logical') && extends(argtypes[4], '_p_Date') && extends(argtypes[5], '_p_Date')) {
      f <- CashFlows_bps__SWIG_3; 
    }
  } else if (argc == 6) {
    if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_DayCounter') && is.character(argv[[4]]) && is.character(argv[[5]]) && extends(argtypes[6], 'logical')) {
      f <- CashFlows_bps__SWIG_11; 
    }
  } else if (argc == 7) {
    if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_DayCounter') && is.character(argv[[4]]) && is.character(argv[[5]]) && extends(argtypes[6], 'logical') && extends(argtypes[7], '_p_Date')) {
      f <- CashFlows_bps__SWIG_10; 
    }
  } else if (argc == 8) {
    if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_DayCounter') && is.character(argv[[4]]) && is.character(argv[[5]]) && extends(argtypes[6], 'logical') && extends(argtypes[7], '_p_Date') && extends(argtypes[8], '_p_Date')) {
      f <- CashFlows_bps__SWIG_9; 
    }
  } else {
    stop("cannot find overloaded function for CashFlows_bps with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of CashFlows_atmRate

`CashFlows_atmRate__SWIG_0` = function(leg, discountCurve, includeSettlementDateFlows, settlementDate, npvDate, npv, .copy = FALSE)
{
  includeSettlementDateFlows = as.logical(includeSettlementDateFlows);
  
  
  
  ;.Call('R_swig_CashFlows_atmRate__SWIG_0', leg, discountCurve, includeSettlementDateFlows, settlementDate, npvDate, npv, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CashFlows_atmRate__SWIG_0`, 'returnType') = 'numeric'
attr(`CashFlows_atmRate__SWIG_0`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', '_p_boost__shared_ptrT_YieldTermStructure_t', 'logical', '_p_Date', '_p_Date', 'numeric')
class(`CashFlows_atmRate__SWIG_0`) = c("SWIGFunction", class('CashFlows_atmRate__SWIG_0'))

# Start of CashFlows_atmRate

`CashFlows_atmRate__SWIG_1` = function(leg, discountCurve, includeSettlementDateFlows, settlementDate, npvDate, .copy = FALSE)
{
  includeSettlementDateFlows = as.logical(includeSettlementDateFlows);
  
  
  ;.Call('R_swig_CashFlows_atmRate__SWIG_1', leg, discountCurve, includeSettlementDateFlows, settlementDate, npvDate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CashFlows_atmRate__SWIG_1`, 'returnType') = 'numeric'
attr(`CashFlows_atmRate__SWIG_1`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', '_p_boost__shared_ptrT_YieldTermStructure_t', 'logical', '_p_Date', '_p_Date')
class(`CashFlows_atmRate__SWIG_1`) = c("SWIGFunction", class('CashFlows_atmRate__SWIG_1'))

# Start of CashFlows_atmRate

`CashFlows_atmRate__SWIG_2` = function(leg, discountCurve, includeSettlementDateFlows, settlementDate, .copy = FALSE)
{
  includeSettlementDateFlows = as.logical(includeSettlementDateFlows);
  
  ;.Call('R_swig_CashFlows_atmRate__SWIG_2', leg, discountCurve, includeSettlementDateFlows, settlementDate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CashFlows_atmRate__SWIG_2`, 'returnType') = 'numeric'
attr(`CashFlows_atmRate__SWIG_2`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', '_p_boost__shared_ptrT_YieldTermStructure_t', 'logical', '_p_Date')
class(`CashFlows_atmRate__SWIG_2`) = c("SWIGFunction", class('CashFlows_atmRate__SWIG_2'))

# Start of CashFlows_atmRate

`CashFlows_atmRate__SWIG_3` = function(leg, discountCurve, includeSettlementDateFlows, .copy = FALSE)
{
  includeSettlementDateFlows = as.logical(includeSettlementDateFlows);
  ;.Call('R_swig_CashFlows_atmRate__SWIG_3', leg, discountCurve, includeSettlementDateFlows, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CashFlows_atmRate__SWIG_3`, 'returnType') = 'numeric'
attr(`CashFlows_atmRate__SWIG_3`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', '_p_boost__shared_ptrT_YieldTermStructure_t', 'logical')
class(`CashFlows_atmRate__SWIG_3`) = c("SWIGFunction", class('CashFlows_atmRate__SWIG_3'))

`CashFlows_atmRate` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 3) {
    if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t') && extends(argtypes[2], '_p_boost__shared_ptrT_YieldTermStructure_t') && extends(argtypes[3], 'logical')) {
      f <- CashFlows_atmRate__SWIG_3; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t') && extends(argtypes[2], '_p_boost__shared_ptrT_YieldTermStructure_t') && extends(argtypes[3], 'logical') && extends(argtypes[4], '_p_Date')) {
      f <- CashFlows_atmRate__SWIG_2; 
    }
  } else if (argc == 5) {
    if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t') && extends(argtypes[2], '_p_boost__shared_ptrT_YieldTermStructure_t') && extends(argtypes[3], 'logical') && extends(argtypes[4], '_p_Date') && extends(argtypes[5], '_p_Date')) {
      f <- CashFlows_atmRate__SWIG_1; 
    }
  } else if (argc == 6) {
    if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t') && extends(argtypes[2], '_p_boost__shared_ptrT_YieldTermStructure_t') && extends(argtypes[3], 'logical') && extends(argtypes[4], '_p_Date') && extends(argtypes[5], '_p_Date') && is.numeric(argv[[6]])) {
      f <- CashFlows_atmRate__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for CashFlows_atmRate with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of CashFlows_yield

`CashFlows_yield__SWIG_0` = function(s_arg1, npv, dayCounter, compounding, frequency, includeSettlementDateFlows, settlementDate, npvDate, accuracy, maxIterations, guess, .copy = FALSE)
{
  compounding = enumToInteger(compounding, "_Compounding"); 
  
  if(length(compounding) > 1) {
    warning("using only the first element of compounding");
  };
  
  frequency = enumToInteger(frequency, "_Frequency"); 
  
  if(length(frequency) > 1) {
    warning("using only the first element of frequency");
  };
  
  includeSettlementDateFlows = as.logical(includeSettlementDateFlows);
  
  
  
  
  
  if(length(maxIterations) > 1) {
    warning("using only the first element of maxIterations");
  };
  
  
  ;.Call('R_swig_CashFlows_yield__SWIG_0', s_arg1, npv, dayCounter, compounding, frequency, includeSettlementDateFlows, settlementDate, npvDate, accuracy, maxIterations, guess, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CashFlows_yield__SWIG_0`, 'returnType') = 'numeric'
attr(`CashFlows_yield__SWIG_0`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', 'numeric', '_p_DayCounter', 'character', 'character', 'logical', '_p_Date', '_p_Date', 'numeric', 'integer', 'numeric')
class(`CashFlows_yield__SWIG_0`) = c("SWIGFunction", class('CashFlows_yield__SWIG_0'))

# Start of CashFlows_yield

`CashFlows_yield__SWIG_1` = function(s_arg1, npv, dayCounter, compounding, frequency, includeSettlementDateFlows, settlementDate, npvDate, accuracy, maxIterations, .copy = FALSE)
{
  compounding = enumToInteger(compounding, "_Compounding"); 
  
  if(length(compounding) > 1) {
    warning("using only the first element of compounding");
  };
  
  frequency = enumToInteger(frequency, "_Frequency"); 
  
  if(length(frequency) > 1) {
    warning("using only the first element of frequency");
  };
  
  includeSettlementDateFlows = as.logical(includeSettlementDateFlows);
  
  
  
  
  
  if(length(maxIterations) > 1) {
    warning("using only the first element of maxIterations");
  };
  
  ;.Call('R_swig_CashFlows_yield__SWIG_1', s_arg1, npv, dayCounter, compounding, frequency, includeSettlementDateFlows, settlementDate, npvDate, accuracy, maxIterations, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CashFlows_yield__SWIG_1`, 'returnType') = 'numeric'
attr(`CashFlows_yield__SWIG_1`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', 'numeric', '_p_DayCounter', 'character', 'character', 'logical', '_p_Date', '_p_Date', 'numeric', 'integer')
class(`CashFlows_yield__SWIG_1`) = c("SWIGFunction", class('CashFlows_yield__SWIG_1'))

# Start of CashFlows_yield

`CashFlows_yield__SWIG_2` = function(s_arg1, npv, dayCounter, compounding, frequency, includeSettlementDateFlows, settlementDate, npvDate, accuracy, .copy = FALSE)
{
  compounding = enumToInteger(compounding, "_Compounding"); 
  
  if(length(compounding) > 1) {
    warning("using only the first element of compounding");
  };
  
  frequency = enumToInteger(frequency, "_Frequency"); 
  
  if(length(frequency) > 1) {
    warning("using only the first element of frequency");
  };
  
  includeSettlementDateFlows = as.logical(includeSettlementDateFlows);
  
  
  
  ;.Call('R_swig_CashFlows_yield__SWIG_2', s_arg1, npv, dayCounter, compounding, frequency, includeSettlementDateFlows, settlementDate, npvDate, accuracy, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CashFlows_yield__SWIG_2`, 'returnType') = 'numeric'
attr(`CashFlows_yield__SWIG_2`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', 'numeric', '_p_DayCounter', 'character', 'character', 'logical', '_p_Date', '_p_Date', 'numeric')
class(`CashFlows_yield__SWIG_2`) = c("SWIGFunction", class('CashFlows_yield__SWIG_2'))

# Start of CashFlows_yield

`CashFlows_yield__SWIG_3` = function(s_arg1, npv, dayCounter, compounding, frequency, includeSettlementDateFlows, settlementDate, npvDate, .copy = FALSE)
{
  compounding = enumToInteger(compounding, "_Compounding"); 
  
  if(length(compounding) > 1) {
    warning("using only the first element of compounding");
  };
  
  frequency = enumToInteger(frequency, "_Frequency"); 
  
  if(length(frequency) > 1) {
    warning("using only the first element of frequency");
  };
  
  includeSettlementDateFlows = as.logical(includeSettlementDateFlows);
  
  
  ;.Call('R_swig_CashFlows_yield__SWIG_3', s_arg1, npv, dayCounter, compounding, frequency, includeSettlementDateFlows, settlementDate, npvDate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CashFlows_yield__SWIG_3`, 'returnType') = 'numeric'
attr(`CashFlows_yield__SWIG_3`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', 'numeric', '_p_DayCounter', 'character', 'character', 'logical', '_p_Date', '_p_Date')
class(`CashFlows_yield__SWIG_3`) = c("SWIGFunction", class('CashFlows_yield__SWIG_3'))

# Start of CashFlows_yield

`CashFlows_yield__SWIG_4` = function(s_arg1, npv, dayCounter, compounding, frequency, includeSettlementDateFlows, settlementDate, .copy = FALSE)
{
  compounding = enumToInteger(compounding, "_Compounding"); 
  
  if(length(compounding) > 1) {
    warning("using only the first element of compounding");
  };
  
  frequency = enumToInteger(frequency, "_Frequency"); 
  
  if(length(frequency) > 1) {
    warning("using only the first element of frequency");
  };
  
  includeSettlementDateFlows = as.logical(includeSettlementDateFlows);
  
  ;.Call('R_swig_CashFlows_yield__SWIG_4', s_arg1, npv, dayCounter, compounding, frequency, includeSettlementDateFlows, settlementDate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CashFlows_yield__SWIG_4`, 'returnType') = 'numeric'
attr(`CashFlows_yield__SWIG_4`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', 'numeric', '_p_DayCounter', 'character', 'character', 'logical', '_p_Date')
class(`CashFlows_yield__SWIG_4`) = c("SWIGFunction", class('CashFlows_yield__SWIG_4'))

# Start of CashFlows_yield

`CashFlows_yield__SWIG_5` = function(s_arg1, npv, dayCounter, compounding, frequency, includeSettlementDateFlows, .copy = FALSE)
{
  compounding = enumToInteger(compounding, "_Compounding"); 
  
  if(length(compounding) > 1) {
    warning("using only the first element of compounding");
  };
  
  frequency = enumToInteger(frequency, "_Frequency"); 
  
  if(length(frequency) > 1) {
    warning("using only the first element of frequency");
  };
  
  includeSettlementDateFlows = as.logical(includeSettlementDateFlows);
  ;.Call('R_swig_CashFlows_yield__SWIG_5', s_arg1, npv, dayCounter, compounding, frequency, includeSettlementDateFlows, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CashFlows_yield__SWIG_5`, 'returnType') = 'numeric'
attr(`CashFlows_yield__SWIG_5`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', 'numeric', '_p_DayCounter', 'character', 'character', 'logical')
class(`CashFlows_yield__SWIG_5`) = c("SWIGFunction", class('CashFlows_yield__SWIG_5'))

`CashFlows_yield` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 6
  if (argc == 6) {
    if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_DayCounter') && is.character(argv[[4]]) && is.character(argv[[5]]) && extends(argtypes[6], 'logical')) {
      f <- CashFlows_yield__SWIG_5; 
    }
  } else if (argc == 7) {
    if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_DayCounter') && is.character(argv[[4]]) && is.character(argv[[5]]) && extends(argtypes[6], 'logical') && extends(argtypes[7], '_p_Date')) {
      f <- CashFlows_yield__SWIG_4; 
    }
  } else if (argc == 8) {
    if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_DayCounter') && is.character(argv[[4]]) && is.character(argv[[5]]) && extends(argtypes[6], 'logical') && extends(argtypes[7], '_p_Date') && extends(argtypes[8], '_p_Date')) {
      f <- CashFlows_yield__SWIG_3; 
    }
  } else if (argc == 9) {
    if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_DayCounter') && is.character(argv[[4]]) && is.character(argv[[5]]) && extends(argtypes[6], 'logical') && extends(argtypes[7], '_p_Date') && extends(argtypes[8], '_p_Date') && is.numeric(argv[[9]])) {
      f <- CashFlows_yield__SWIG_2; 
    }
  } else if (argc == 10) {
    if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_DayCounter') && is.character(argv[[4]]) && is.character(argv[[5]]) && extends(argtypes[6], 'logical') && extends(argtypes[7], '_p_Date') && extends(argtypes[8], '_p_Date') && is.numeric(argv[[9]]) && (is.integer(argv[[10]]) || is.numeric(argv[[10]]))) {
      f <- CashFlows_yield__SWIG_1; 
    }
  } else if (argc == 11) {
    if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_DayCounter') && is.character(argv[[4]]) && is.character(argv[[5]]) && extends(argtypes[6], 'logical') && extends(argtypes[7], '_p_Date') && extends(argtypes[8], '_p_Date') && is.numeric(argv[[9]]) && (is.integer(argv[[10]]) || is.numeric(argv[[10]])) && is.numeric(argv[[11]])) {
      f <- CashFlows_yield__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for CashFlows_yield with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of CashFlows_duration

`CashFlows_duration__SWIG_0` = function(s_arg1, s_arg2, type, includeSettlementDateFlows, settlementDate, .copy = FALSE)
{
  type = enumToInteger(type, "_Duration__Type"); 
  
  if(length(type) > 1) {
    warning("using only the first element of type");
  };
  
  includeSettlementDateFlows = as.logical(includeSettlementDateFlows);
  
  ;.Call('R_swig_CashFlows_duration__SWIG_0', s_arg1, s_arg2, type, includeSettlementDateFlows, settlementDate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CashFlows_duration__SWIG_0`, 'returnType') = 'numeric'
attr(`CashFlows_duration__SWIG_0`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', '_p_InterestRate', 'character', 'logical', '_p_Date')
class(`CashFlows_duration__SWIG_0`) = c("SWIGFunction", class('CashFlows_duration__SWIG_0'))

# Start of CashFlows_duration

`CashFlows_duration__SWIG_1` = function(s_arg1, s_arg2, type, includeSettlementDateFlows, .copy = FALSE)
{
  type = enumToInteger(type, "_Duration__Type"); 
  
  if(length(type) > 1) {
    warning("using only the first element of type");
  };
  
  includeSettlementDateFlows = as.logical(includeSettlementDateFlows);
  ;.Call('R_swig_CashFlows_duration__SWIG_1', s_arg1, s_arg2, type, includeSettlementDateFlows, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CashFlows_duration__SWIG_1`, 'returnType') = 'numeric'
attr(`CashFlows_duration__SWIG_1`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', '_p_InterestRate', 'character', 'logical')
class(`CashFlows_duration__SWIG_1`) = c("SWIGFunction", class('CashFlows_duration__SWIG_1'))

# Start of CashFlows_duration

`CashFlows_duration__SWIG_2` = function(s_arg1, yield, dayCounter, compounding, frequency, type, includeSettlementDateFlows, settlementDate, npvDate, .copy = FALSE)
{
  compounding = enumToInteger(compounding, "_Compounding"); 
  
  if(length(compounding) > 1) {
    warning("using only the first element of compounding");
  };
  
  frequency = enumToInteger(frequency, "_Frequency"); 
  
  if(length(frequency) > 1) {
    warning("using only the first element of frequency");
  };
  
  type = enumToInteger(type, "_Duration__Type"); 
  
  if(length(type) > 1) {
    warning("using only the first element of type");
  };
  
  includeSettlementDateFlows = as.logical(includeSettlementDateFlows);
  
  
  ;.Call('R_swig_CashFlows_duration__SWIG_2', s_arg1, yield, dayCounter, compounding, frequency, type, includeSettlementDateFlows, settlementDate, npvDate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CashFlows_duration__SWIG_2`, 'returnType') = 'numeric'
attr(`CashFlows_duration__SWIG_2`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', 'numeric', '_p_DayCounter', 'character', 'character', 'character', 'logical', '_p_Date', '_p_Date')
class(`CashFlows_duration__SWIG_2`) = c("SWIGFunction", class('CashFlows_duration__SWIG_2'))

# Start of CashFlows_duration

`CashFlows_duration__SWIG_3` = function(s_arg1, yield, dayCounter, compounding, frequency, type, includeSettlementDateFlows, settlementDate, .copy = FALSE)
{
  compounding = enumToInteger(compounding, "_Compounding"); 
  
  if(length(compounding) > 1) {
    warning("using only the first element of compounding");
  };
  
  frequency = enumToInteger(frequency, "_Frequency"); 
  
  if(length(frequency) > 1) {
    warning("using only the first element of frequency");
  };
  
  type = enumToInteger(type, "_Duration__Type"); 
  
  if(length(type) > 1) {
    warning("using only the first element of type");
  };
  
  includeSettlementDateFlows = as.logical(includeSettlementDateFlows);
  
  ;.Call('R_swig_CashFlows_duration__SWIG_3', s_arg1, yield, dayCounter, compounding, frequency, type, includeSettlementDateFlows, settlementDate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CashFlows_duration__SWIG_3`, 'returnType') = 'numeric'
attr(`CashFlows_duration__SWIG_3`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', 'numeric', '_p_DayCounter', 'character', 'character', 'character', 'logical', '_p_Date')
class(`CashFlows_duration__SWIG_3`) = c("SWIGFunction", class('CashFlows_duration__SWIG_3'))

# Start of CashFlows_duration

`CashFlows_duration__SWIG_4` = function(s_arg1, yield, dayCounter, compounding, frequency, type, includeSettlementDateFlows, .copy = FALSE)
{
  compounding = enumToInteger(compounding, "_Compounding"); 
  
  if(length(compounding) > 1) {
    warning("using only the first element of compounding");
  };
  
  frequency = enumToInteger(frequency, "_Frequency"); 
  
  if(length(frequency) > 1) {
    warning("using only the first element of frequency");
  };
  
  type = enumToInteger(type, "_Duration__Type"); 
  
  if(length(type) > 1) {
    warning("using only the first element of type");
  };
  
  includeSettlementDateFlows = as.logical(includeSettlementDateFlows);
  ;.Call('R_swig_CashFlows_duration__SWIG_4', s_arg1, yield, dayCounter, compounding, frequency, type, includeSettlementDateFlows, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CashFlows_duration__SWIG_4`, 'returnType') = 'numeric'
attr(`CashFlows_duration__SWIG_4`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', 'numeric', '_p_DayCounter', 'character', 'character', 'character', 'logical')
class(`CashFlows_duration__SWIG_4`) = c("SWIGFunction", class('CashFlows_duration__SWIG_4'))

`CashFlows_duration` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 5
  if (argc == 4) {
    if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t') && extends(argtypes[2], '_p_InterestRate') && is.character(argv[[3]]) && extends(argtypes[4], 'logical')) {
      f <- CashFlows_duration__SWIG_1; 
    }
  } else if (argc == 5) {
    if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t') && extends(argtypes[2], '_p_InterestRate') && is.character(argv[[3]]) && extends(argtypes[4], 'logical') && extends(argtypes[5], '_p_Date')) {
      f <- CashFlows_duration__SWIG_0; 
    }
  } else if (argc == 7) {
    if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_DayCounter') && is.character(argv[[4]]) && is.character(argv[[5]]) && is.character(argv[[6]]) && extends(argtypes[7], 'logical')) {
      f <- CashFlows_duration__SWIG_4; 
    }
  } else if (argc == 8) {
    if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_DayCounter') && is.character(argv[[4]]) && is.character(argv[[5]]) && is.character(argv[[6]]) && extends(argtypes[7], 'logical') && extends(argtypes[8], '_p_Date')) {
      f <- CashFlows_duration__SWIG_3; 
    }
  } else if (argc == 9) {
    if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_DayCounter') && is.character(argv[[4]]) && is.character(argv[[5]]) && is.character(argv[[6]]) && extends(argtypes[7], 'logical') && extends(argtypes[8], '_p_Date') && extends(argtypes[9], '_p_Date')) {
      f <- CashFlows_duration__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for CashFlows_duration with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of CashFlows_convexity

`CashFlows_convexity__SWIG_0` = function(s_arg1, s_arg2, includeSettlementDateFlows, settlementDate, npvDate, .copy = FALSE)
{
  includeSettlementDateFlows = as.logical(includeSettlementDateFlows);
  
  
  ;.Call('R_swig_CashFlows_convexity__SWIG_0', s_arg1, s_arg2, includeSettlementDateFlows, settlementDate, npvDate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CashFlows_convexity__SWIG_0`, 'returnType') = 'numeric'
attr(`CashFlows_convexity__SWIG_0`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', '_p_InterestRate', 'logical', '_p_Date', '_p_Date')
class(`CashFlows_convexity__SWIG_0`) = c("SWIGFunction", class('CashFlows_convexity__SWIG_0'))

# Start of CashFlows_convexity

`CashFlows_convexity__SWIG_1` = function(s_arg1, s_arg2, includeSettlementDateFlows, settlementDate, .copy = FALSE)
{
  includeSettlementDateFlows = as.logical(includeSettlementDateFlows);
  
  ;.Call('R_swig_CashFlows_convexity__SWIG_1', s_arg1, s_arg2, includeSettlementDateFlows, settlementDate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CashFlows_convexity__SWIG_1`, 'returnType') = 'numeric'
attr(`CashFlows_convexity__SWIG_1`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', '_p_InterestRate', 'logical', '_p_Date')
class(`CashFlows_convexity__SWIG_1`) = c("SWIGFunction", class('CashFlows_convexity__SWIG_1'))

# Start of CashFlows_convexity

`CashFlows_convexity__SWIG_2` = function(s_arg1, s_arg2, includeSettlementDateFlows, .copy = FALSE)
{
  includeSettlementDateFlows = as.logical(includeSettlementDateFlows);
  ;.Call('R_swig_CashFlows_convexity__SWIG_2', s_arg1, s_arg2, includeSettlementDateFlows, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CashFlows_convexity__SWIG_2`, 'returnType') = 'numeric'
attr(`CashFlows_convexity__SWIG_2`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', '_p_InterestRate', 'logical')
class(`CashFlows_convexity__SWIG_2`) = c("SWIGFunction", class('CashFlows_convexity__SWIG_2'))

# Start of CashFlows_convexity

`CashFlows_convexity__SWIG_3` = function(s_arg1, yield, dayCounter, compounding, frequency, includeSettlementDateFlows, settlementDate, npvDate, .copy = FALSE)
{
  compounding = enumToInteger(compounding, "_Compounding"); 
  
  if(length(compounding) > 1) {
    warning("using only the first element of compounding");
  };
  
  frequency = enumToInteger(frequency, "_Frequency"); 
  
  if(length(frequency) > 1) {
    warning("using only the first element of frequency");
  };
  
  includeSettlementDateFlows = as.logical(includeSettlementDateFlows);
  
  
  ;.Call('R_swig_CashFlows_convexity__SWIG_3', s_arg1, yield, dayCounter, compounding, frequency, includeSettlementDateFlows, settlementDate, npvDate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CashFlows_convexity__SWIG_3`, 'returnType') = 'numeric'
attr(`CashFlows_convexity__SWIG_3`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', 'numeric', '_p_DayCounter', 'character', 'character', 'logical', '_p_Date', '_p_Date')
class(`CashFlows_convexity__SWIG_3`) = c("SWIGFunction", class('CashFlows_convexity__SWIG_3'))

# Start of CashFlows_convexity

`CashFlows_convexity__SWIG_4` = function(s_arg1, yield, dayCounter, compounding, frequency, includeSettlementDateFlows, settlementDate, .copy = FALSE)
{
  compounding = enumToInteger(compounding, "_Compounding"); 
  
  if(length(compounding) > 1) {
    warning("using only the first element of compounding");
  };
  
  frequency = enumToInteger(frequency, "_Frequency"); 
  
  if(length(frequency) > 1) {
    warning("using only the first element of frequency");
  };
  
  includeSettlementDateFlows = as.logical(includeSettlementDateFlows);
  
  ;.Call('R_swig_CashFlows_convexity__SWIG_4', s_arg1, yield, dayCounter, compounding, frequency, includeSettlementDateFlows, settlementDate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CashFlows_convexity__SWIG_4`, 'returnType') = 'numeric'
attr(`CashFlows_convexity__SWIG_4`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', 'numeric', '_p_DayCounter', 'character', 'character', 'logical', '_p_Date')
class(`CashFlows_convexity__SWIG_4`) = c("SWIGFunction", class('CashFlows_convexity__SWIG_4'))

# Start of CashFlows_convexity

`CashFlows_convexity__SWIG_5` = function(s_arg1, yield, dayCounter, compounding, frequency, includeSettlementDateFlows, .copy = FALSE)
{
  compounding = enumToInteger(compounding, "_Compounding"); 
  
  if(length(compounding) > 1) {
    warning("using only the first element of compounding");
  };
  
  frequency = enumToInteger(frequency, "_Frequency"); 
  
  if(length(frequency) > 1) {
    warning("using only the first element of frequency");
  };
  
  includeSettlementDateFlows = as.logical(includeSettlementDateFlows);
  ;.Call('R_swig_CashFlows_convexity__SWIG_5', s_arg1, yield, dayCounter, compounding, frequency, includeSettlementDateFlows, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CashFlows_convexity__SWIG_5`, 'returnType') = 'numeric'
attr(`CashFlows_convexity__SWIG_5`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', 'numeric', '_p_DayCounter', 'character', 'character', 'logical')
class(`CashFlows_convexity__SWIG_5`) = c("SWIGFunction", class('CashFlows_convexity__SWIG_5'))

`CashFlows_convexity` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 6
  if (argc == 3) {
    if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t') && extends(argtypes[2], '_p_InterestRate') && extends(argtypes[3], 'logical')) {
      f <- CashFlows_convexity__SWIG_2; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t') && extends(argtypes[2], '_p_InterestRate') && extends(argtypes[3], 'logical') && extends(argtypes[4], '_p_Date')) {
      f <- CashFlows_convexity__SWIG_1; 
    }
  } else if (argc == 5) {
    if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t') && extends(argtypes[2], '_p_InterestRate') && extends(argtypes[3], 'logical') && extends(argtypes[4], '_p_Date') && extends(argtypes[5], '_p_Date')) {
      f <- CashFlows_convexity__SWIG_0; 
    }
  } else if (argc == 6) {
    if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_DayCounter') && is.character(argv[[4]]) && is.character(argv[[5]]) && extends(argtypes[6], 'logical')) {
      f <- CashFlows_convexity__SWIG_5; 
    }
  } else if (argc == 7) {
    if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_DayCounter') && is.character(argv[[4]]) && is.character(argv[[5]]) && extends(argtypes[6], 'logical') && extends(argtypes[7], '_p_Date')) {
      f <- CashFlows_convexity__SWIG_4; 
    }
  } else if (argc == 8) {
    if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_DayCounter') && is.character(argv[[4]]) && is.character(argv[[5]]) && extends(argtypes[6], 'logical') && extends(argtypes[7], '_p_Date') && extends(argtypes[8], '_p_Date')) {
      f <- CashFlows_convexity__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for CashFlows_convexity with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_CashFlows

`delete_CashFlows` = function(self)
{
  ;.Call('R_swig_delete_CashFlows', self, PACKAGE='QuantLib');
  
}

attr(`delete_CashFlows`, 'returnType') = 'void'
attr(`delete_CashFlows`, "inputTypes") = c('_p_CashFlows')
class(`delete_CashFlows`) = c("SWIGFunction", class('delete_CashFlows'))

setMethod('delete', '_p_CashFlows', function(obj) {delete_CashFlows(obj)})
# Start of new_Bond

`Bond__SWIG_0` = function(settlementDays, calendar, faceAmount, maturityDate, issueDate, cashflows)
{
  if(length(settlementDays) > 1) {
    warning("using only the first element of settlementDays");
  };
  
  
  
  
  
  
  ;ans = .Call('R_swig_new_Bond__SWIG_0', settlementDays, calendar, faceAmount, maturityDate, issueDate, cashflows, PACKAGE='QuantLib');
  class(ans) <- "_p_BondPtr";
  
  reg.finalizer(ans, delete_Bond)
  ans
  
}

attr(`Bond__SWIG_0`, 'returnType') = '_p_BondPtr'
attr(`Bond__SWIG_0`, "inputTypes") = c('integer', '_p_Calendar', 'numeric', '_p_Date', '_p_Date', '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t')
class(`Bond__SWIG_0`) = c("SWIGFunction", class('Bond__SWIG_0'))

# Start of new_Bond

`Bond__SWIG_1` = function(settlementDays, calendar, faceAmount, maturityDate, issueDate)
{
  if(length(settlementDays) > 1) {
    warning("using only the first element of settlementDays");
  };
  
  
  
  
  
  ;ans = .Call('R_swig_new_Bond__SWIG_1', settlementDays, calendar, faceAmount, maturityDate, issueDate, PACKAGE='QuantLib');
  class(ans) <- "_p_BondPtr";
  
  reg.finalizer(ans, delete_Bond)
  ans
  
}

attr(`Bond__SWIG_1`, 'returnType') = '_p_BondPtr'
attr(`Bond__SWIG_1`, "inputTypes") = c('integer', '_p_Calendar', 'numeric', '_p_Date', '_p_Date')
class(`Bond__SWIG_1`) = c("SWIGFunction", class('Bond__SWIG_1'))

# Start of new_Bond

`Bond__SWIG_2` = function(settlementDays, calendar, faceAmount, maturityDate)
{
  if(length(settlementDays) > 1) {
    warning("using only the first element of settlementDays");
  };
  
  
  
  
  ;ans = .Call('R_swig_new_Bond__SWIG_2', settlementDays, calendar, faceAmount, maturityDate, PACKAGE='QuantLib');
  class(ans) <- "_p_BondPtr";
  
  reg.finalizer(ans, delete_Bond)
  ans
  
}

attr(`Bond__SWIG_2`, 'returnType') = '_p_BondPtr'
attr(`Bond__SWIG_2`, "inputTypes") = c('integer', '_p_Calendar', 'numeric', '_p_Date')
class(`Bond__SWIG_2`) = c("SWIGFunction", class('Bond__SWIG_2'))

`Bond` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 4) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && extends(argtypes[2], '_p_Calendar') && is.numeric(argv[[3]]) && extends(argtypes[4], '_p_Date')) {
      f <- Bond__SWIG_2; 
    }
  } else if (argc == 5) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && extends(argtypes[2], '_p_Calendar') && is.numeric(argv[[3]]) && extends(argtypes[4], '_p_Date') && extends(argtypes[5], '_p_Date')) {
      f <- Bond__SWIG_1; 
    }
  } else if (argc == 6) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && extends(argtypes[2], '_p_Calendar') && is.numeric(argv[[3]]) && extends(argtypes[4], '_p_Date') && extends(argtypes[5], '_p_Date') && extends(argtypes[6], '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t')) {
      f <- Bond__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Bond with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of Bond_nextCouponRate

`Bond_nextCouponRate__SWIG_0` = function(self, d, .copy = FALSE)
{
  ;.Call('R_swig_Bond_nextCouponRate__SWIG_0', self, d, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Bond_nextCouponRate__SWIG_0`, 'returnType') = 'numeric'
attr(`Bond_nextCouponRate__SWIG_0`, "inputTypes") = c('_p_BondPtr', '_p_Date')
class(`Bond_nextCouponRate__SWIG_0`) = c("SWIGFunction", class('Bond_nextCouponRate__SWIG_0'))

# Start of Bond_nextCouponRate

`Bond_nextCouponRate__SWIG_1` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Bond_nextCouponRate__SWIG_1', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Bond_nextCouponRate__SWIG_1`, 'returnType') = 'numeric'
attr(`Bond_nextCouponRate__SWIG_1`, "inputTypes") = c('_p_BondPtr')
class(`Bond_nextCouponRate__SWIG_1`) = c("SWIGFunction", class('Bond_nextCouponRate__SWIG_1'))

`Bond_nextCouponRate` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_BondPtr')) {
      f <- Bond_nextCouponRate__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_BondPtr') && extends(argtypes[2], '_p_Date')) {
      f <- Bond_nextCouponRate__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Bond_nextCouponRate with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of Bond_previousCouponRate

`Bond_previousCouponRate__SWIG_0` = function(self, d, .copy = FALSE)
{
  ;.Call('R_swig_Bond_previousCouponRate__SWIG_0', self, d, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Bond_previousCouponRate__SWIG_0`, 'returnType') = 'numeric'
attr(`Bond_previousCouponRate__SWIG_0`, "inputTypes") = c('_p_BondPtr', '_p_Date')
class(`Bond_previousCouponRate__SWIG_0`) = c("SWIGFunction", class('Bond_previousCouponRate__SWIG_0'))

# Start of Bond_previousCouponRate

`Bond_previousCouponRate__SWIG_1` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Bond_previousCouponRate__SWIG_1', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Bond_previousCouponRate__SWIG_1`, 'returnType') = 'numeric'
attr(`Bond_previousCouponRate__SWIG_1`, "inputTypes") = c('_p_BondPtr')
class(`Bond_previousCouponRate__SWIG_1`) = c("SWIGFunction", class('Bond_previousCouponRate__SWIG_1'))

`Bond_previousCouponRate` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_BondPtr')) {
      f <- Bond_previousCouponRate__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_BondPtr') && extends(argtypes[2], '_p_Date')) {
      f <- Bond_previousCouponRate__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Bond_previousCouponRate with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of Bond_settlementDays

`Bond_settlementDays` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Bond_settlementDays', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Bond_settlementDays`, 'returnType') = 'integer'
attr(`Bond_settlementDays`, "inputTypes") = c('_p_BondPtr')
class(`Bond_settlementDays`) = c("SWIGFunction", class('Bond_settlementDays'))

# Start of Bond_settlementDate

`Bond_settlementDate` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_Bond_settlementDate', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`Bond_settlementDate`, 'returnType') = '_p_Date'
attr(`Bond_settlementDate`, "inputTypes") = c('_p_BondPtr')
class(`Bond_settlementDate`) = c("SWIGFunction", class('Bond_settlementDate'))

# Start of Bond_startDate

`Bond_startDate` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_Bond_startDate', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`Bond_startDate`, 'returnType') = '_p_Date'
attr(`Bond_startDate`, "inputTypes") = c('_p_BondPtr')
class(`Bond_startDate`) = c("SWIGFunction", class('Bond_startDate'))

# Start of Bond_maturityDate

`Bond_maturityDate` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_Bond_maturityDate', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`Bond_maturityDate`, 'returnType') = '_p_Date'
attr(`Bond_maturityDate`, "inputTypes") = c('_p_BondPtr')
class(`Bond_maturityDate`) = c("SWIGFunction", class('Bond_maturityDate'))

# Start of Bond_issueDate

`Bond_issueDate` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_Bond_issueDate', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`Bond_issueDate`, 'returnType') = '_p_Date'
attr(`Bond_issueDate`, "inputTypes") = c('_p_BondPtr')
class(`Bond_issueDate`) = c("SWIGFunction", class('Bond_issueDate'))

# Start of Bond_cashflows

`Bond_cashflows` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_Bond_cashflows', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t";
  
  ans
  
}

attr(`Bond_cashflows`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t'
attr(`Bond_cashflows`, "inputTypes") = c('_p_BondPtr')
class(`Bond_cashflows`) = c("SWIGFunction", class('Bond_cashflows'))

# Start of Bond_redemptions

`Bond_redemptions` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_Bond_redemptions', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t";
  
  ans
  
}

attr(`Bond_redemptions`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t'
attr(`Bond_redemptions`, "inputTypes") = c('_p_BondPtr')
class(`Bond_redemptions`) = c("SWIGFunction", class('Bond_redemptions'))

# Start of Bond_redemption

`Bond_redemption` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_Bond_redemption', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_CashFlow_t";
  
  ans
  
}

attr(`Bond_redemption`, 'returnType') = '_p_boost__shared_ptrT_CashFlow_t'
attr(`Bond_redemption`, "inputTypes") = c('_p_BondPtr')
class(`Bond_redemption`) = c("SWIGFunction", class('Bond_redemption'))

# Start of Bond_calendar

`Bond_calendar` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_Bond_calendar', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Calendar";
  
  ans
  
}

attr(`Bond_calendar`, 'returnType') = '_p_Calendar'
attr(`Bond_calendar`, "inputTypes") = c('_p_BondPtr')
class(`Bond_calendar`) = c("SWIGFunction", class('Bond_calendar'))

# Start of Bond_notionals

`Bond_notionals` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_Bond_notionals', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_double_std__allocatorT_double_t_t";
  
  ans
  
}

attr(`Bond_notionals`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`Bond_notionals`, "inputTypes") = c('_p_BondPtr')
class(`Bond_notionals`) = c("SWIGFunction", class('Bond_notionals'))

# Start of Bond_notional

`Bond_notional__SWIG_0` = function(self, d, .copy = FALSE)
{
  ;.Call('R_swig_Bond_notional__SWIG_0', self, d, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Bond_notional__SWIG_0`, 'returnType') = 'numeric'
attr(`Bond_notional__SWIG_0`, "inputTypes") = c('_p_BondPtr', '_p_Date')
class(`Bond_notional__SWIG_0`) = c("SWIGFunction", class('Bond_notional__SWIG_0'))

# Start of Bond_notional

`Bond_notional__SWIG_1` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Bond_notional__SWIG_1', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Bond_notional__SWIG_1`, 'returnType') = 'numeric'
attr(`Bond_notional__SWIG_1`, "inputTypes") = c('_p_BondPtr')
class(`Bond_notional__SWIG_1`) = c("SWIGFunction", class('Bond_notional__SWIG_1'))

`Bond_notional` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_BondPtr')) {
      f <- Bond_notional__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_BondPtr') && extends(argtypes[2], '_p_Date')) {
      f <- Bond_notional__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Bond_notional with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of Bond_cleanPrice

`Bond_cleanPrice__SWIG_0` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Bond_cleanPrice__SWIG_0', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Bond_cleanPrice__SWIG_0`, 'returnType') = 'numeric'
attr(`Bond_cleanPrice__SWIG_0`, "inputTypes") = c('_p_BondPtr')
class(`Bond_cleanPrice__SWIG_0`) = c("SWIGFunction", class('Bond_cleanPrice__SWIG_0'))

# Start of Bond_cleanPrice

`Bond_cleanPrice__SWIG_1` = function(self, yield, dc, compounding, frequency, settlement, .copy = FALSE)
{
  compounding = enumToInteger(compounding, "_Compounding"); 
  
  if(length(compounding) > 1) {
    warning("using only the first element of compounding");
  };
  
  frequency = enumToInteger(frequency, "_Frequency"); 
  
  if(length(frequency) > 1) {
    warning("using only the first element of frequency");
  };
  
  
  ;.Call('R_swig_Bond_cleanPrice__SWIG_1', self, yield, dc, compounding, frequency, settlement, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Bond_cleanPrice__SWIG_1`, 'returnType') = 'numeric'
attr(`Bond_cleanPrice__SWIG_1`, "inputTypes") = c('_p_BondPtr', 'numeric', '_p_DayCounter', 'character', 'character', '_p_Date')
class(`Bond_cleanPrice__SWIG_1`) = c("SWIGFunction", class('Bond_cleanPrice__SWIG_1'))

# Start of Bond_cleanPrice

`Bond_cleanPrice__SWIG_2` = function(self, yield, dc, compounding, frequency, .copy = FALSE)
{
  compounding = enumToInteger(compounding, "_Compounding"); 
  
  if(length(compounding) > 1) {
    warning("using only the first element of compounding");
  };
  
  frequency = enumToInteger(frequency, "_Frequency"); 
  
  if(length(frequency) > 1) {
    warning("using only the first element of frequency");
  };
  
  ;.Call('R_swig_Bond_cleanPrice__SWIG_2', self, yield, dc, compounding, frequency, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Bond_cleanPrice__SWIG_2`, 'returnType') = 'numeric'
attr(`Bond_cleanPrice__SWIG_2`, "inputTypes") = c('_p_BondPtr', 'numeric', '_p_DayCounter', 'character', 'character')
class(`Bond_cleanPrice__SWIG_2`) = c("SWIGFunction", class('Bond_cleanPrice__SWIG_2'))

`Bond_cleanPrice` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 1) {
    if (extends(argtypes[1], '_p_BondPtr')) {
      f <- Bond_cleanPrice__SWIG_0; 
    }
  } else if (argc == 5) {
    if (extends(argtypes[1], '_p_BondPtr') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_DayCounter') && is.character(argv[[4]]) && is.character(argv[[5]])) {
      f <- Bond_cleanPrice__SWIG_2; 
    }
  } else if (argc == 6) {
    if (extends(argtypes[1], '_p_BondPtr') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_DayCounter') && is.character(argv[[4]]) && is.character(argv[[5]]) && extends(argtypes[6], '_p_Date')) {
      f <- Bond_cleanPrice__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for Bond_cleanPrice with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of Bond_dirtyPrice

`Bond_dirtyPrice__SWIG_0` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Bond_dirtyPrice__SWIG_0', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Bond_dirtyPrice__SWIG_0`, 'returnType') = 'numeric'
attr(`Bond_dirtyPrice__SWIG_0`, "inputTypes") = c('_p_BondPtr')
class(`Bond_dirtyPrice__SWIG_0`) = c("SWIGFunction", class('Bond_dirtyPrice__SWIG_0'))

# Start of Bond_dirtyPrice

`Bond_dirtyPrice__SWIG_1` = function(self, yield, dc, compounding, frequency, settlement, .copy = FALSE)
{
  compounding = enumToInteger(compounding, "_Compounding"); 
  
  if(length(compounding) > 1) {
    warning("using only the first element of compounding");
  };
  
  frequency = enumToInteger(frequency, "_Frequency"); 
  
  if(length(frequency) > 1) {
    warning("using only the first element of frequency");
  };
  
  
  ;.Call('R_swig_Bond_dirtyPrice__SWIG_1', self, yield, dc, compounding, frequency, settlement, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Bond_dirtyPrice__SWIG_1`, 'returnType') = 'numeric'
attr(`Bond_dirtyPrice__SWIG_1`, "inputTypes") = c('_p_BondPtr', 'numeric', '_p_DayCounter', 'character', 'character', '_p_Date')
class(`Bond_dirtyPrice__SWIG_1`) = c("SWIGFunction", class('Bond_dirtyPrice__SWIG_1'))

# Start of Bond_dirtyPrice

`Bond_dirtyPrice__SWIG_2` = function(self, yield, dc, compounding, frequency, .copy = FALSE)
{
  compounding = enumToInteger(compounding, "_Compounding"); 
  
  if(length(compounding) > 1) {
    warning("using only the first element of compounding");
  };
  
  frequency = enumToInteger(frequency, "_Frequency"); 
  
  if(length(frequency) > 1) {
    warning("using only the first element of frequency");
  };
  
  ;.Call('R_swig_Bond_dirtyPrice__SWIG_2', self, yield, dc, compounding, frequency, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Bond_dirtyPrice__SWIG_2`, 'returnType') = 'numeric'
attr(`Bond_dirtyPrice__SWIG_2`, "inputTypes") = c('_p_BondPtr', 'numeric', '_p_DayCounter', 'character', 'character')
class(`Bond_dirtyPrice__SWIG_2`) = c("SWIGFunction", class('Bond_dirtyPrice__SWIG_2'))

`Bond_dirtyPrice` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 1) {
    if (extends(argtypes[1], '_p_BondPtr')) {
      f <- Bond_dirtyPrice__SWIG_0; 
    }
  } else if (argc == 5) {
    if (extends(argtypes[1], '_p_BondPtr') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_DayCounter') && is.character(argv[[4]]) && is.character(argv[[5]])) {
      f <- Bond_dirtyPrice__SWIG_2; 
    }
  } else if (argc == 6) {
    if (extends(argtypes[1], '_p_BondPtr') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_DayCounter') && is.character(argv[[4]]) && is.character(argv[[5]]) && extends(argtypes[6], '_p_Date')) {
      f <- Bond_dirtyPrice__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for Bond_dirtyPrice with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of Bond_yield

`Bond_yield__SWIG_0` = function(self, dc, compounding, freq, accuracy, maxEvaluations, .copy = FALSE)
{
  compounding = enumToInteger(compounding, "_Compounding"); 
  
  if(length(compounding) > 1) {
    warning("using only the first element of compounding");
  };
  
  freq = enumToInteger(freq, "_Frequency"); 
  
  if(length(freq) > 1) {
    warning("using only the first element of freq");
  };
  
  
  
  
  if(length(maxEvaluations) > 1) {
    warning("using only the first element of maxEvaluations");
  };
  
  ;.Call('R_swig_Bond_yield__SWIG_0', self, dc, compounding, freq, accuracy, maxEvaluations, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Bond_yield__SWIG_0`, 'returnType') = 'numeric'
attr(`Bond_yield__SWIG_0`, "inputTypes") = c('_p_BondPtr', '_p_DayCounter', 'character', 'character', 'numeric', 'integer')
class(`Bond_yield__SWIG_0`) = c("SWIGFunction", class('Bond_yield__SWIG_0'))

# Start of Bond_yield

`Bond_yield__SWIG_1` = function(self, dc, compounding, freq, accuracy, .copy = FALSE)
{
  compounding = enumToInteger(compounding, "_Compounding"); 
  
  if(length(compounding) > 1) {
    warning("using only the first element of compounding");
  };
  
  freq = enumToInteger(freq, "_Frequency"); 
  
  if(length(freq) > 1) {
    warning("using only the first element of freq");
  };
  
  
  ;.Call('R_swig_Bond_yield__SWIG_1', self, dc, compounding, freq, accuracy, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Bond_yield__SWIG_1`, 'returnType') = 'numeric'
attr(`Bond_yield__SWIG_1`, "inputTypes") = c('_p_BondPtr', '_p_DayCounter', 'character', 'character', 'numeric')
class(`Bond_yield__SWIG_1`) = c("SWIGFunction", class('Bond_yield__SWIG_1'))

# Start of Bond_yield

`Bond_yield__SWIG_2` = function(self, dc, compounding, freq, .copy = FALSE)
{
  compounding = enumToInteger(compounding, "_Compounding"); 
  
  if(length(compounding) > 1) {
    warning("using only the first element of compounding");
  };
  
  freq = enumToInteger(freq, "_Frequency"); 
  
  if(length(freq) > 1) {
    warning("using only the first element of freq");
  };
  
  ;.Call('R_swig_Bond_yield__SWIG_2', self, dc, compounding, freq, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Bond_yield__SWIG_2`, 'returnType') = 'numeric'
attr(`Bond_yield__SWIG_2`, "inputTypes") = c('_p_BondPtr', '_p_DayCounter', 'character', 'character')
class(`Bond_yield__SWIG_2`) = c("SWIGFunction", class('Bond_yield__SWIG_2'))

# Start of Bond_yield

`Bond_yield__SWIG_3` = function(self, cleanPrice, dc, compounding, freq, settlement, accuracy, maxEvaluations, .copy = FALSE)
{
  compounding = enumToInteger(compounding, "_Compounding"); 
  
  if(length(compounding) > 1) {
    warning("using only the first element of compounding");
  };
  
  freq = enumToInteger(freq, "_Frequency"); 
  
  if(length(freq) > 1) {
    warning("using only the first element of freq");
  };
  
  
  
  
  
  if(length(maxEvaluations) > 1) {
    warning("using only the first element of maxEvaluations");
  };
  
  ;.Call('R_swig_Bond_yield__SWIG_3', self, cleanPrice, dc, compounding, freq, settlement, accuracy, maxEvaluations, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Bond_yield__SWIG_3`, 'returnType') = 'numeric'
attr(`Bond_yield__SWIG_3`, "inputTypes") = c('_p_BondPtr', 'numeric', '_p_DayCounter', 'character', 'character', '_p_Date', 'numeric', 'integer')
class(`Bond_yield__SWIG_3`) = c("SWIGFunction", class('Bond_yield__SWIG_3'))

# Start of Bond_yield

`Bond_yield__SWIG_4` = function(self, cleanPrice, dc, compounding, freq, settlement, accuracy, .copy = FALSE)
{
  compounding = enumToInteger(compounding, "_Compounding"); 
  
  if(length(compounding) > 1) {
    warning("using only the first element of compounding");
  };
  
  freq = enumToInteger(freq, "_Frequency"); 
  
  if(length(freq) > 1) {
    warning("using only the first element of freq");
  };
  
  
  
  ;.Call('R_swig_Bond_yield__SWIG_4', self, cleanPrice, dc, compounding, freq, settlement, accuracy, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Bond_yield__SWIG_4`, 'returnType') = 'numeric'
attr(`Bond_yield__SWIG_4`, "inputTypes") = c('_p_BondPtr', 'numeric', '_p_DayCounter', 'character', 'character', '_p_Date', 'numeric')
class(`Bond_yield__SWIG_4`) = c("SWIGFunction", class('Bond_yield__SWIG_4'))

# Start of Bond_yield

`Bond_yield__SWIG_5` = function(self, cleanPrice, dc, compounding, freq, settlement, .copy = FALSE)
{
  compounding = enumToInteger(compounding, "_Compounding"); 
  
  if(length(compounding) > 1) {
    warning("using only the first element of compounding");
  };
  
  freq = enumToInteger(freq, "_Frequency"); 
  
  if(length(freq) > 1) {
    warning("using only the first element of freq");
  };
  
  
  ;.Call('R_swig_Bond_yield__SWIG_5', self, cleanPrice, dc, compounding, freq, settlement, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Bond_yield__SWIG_5`, 'returnType') = 'numeric'
attr(`Bond_yield__SWIG_5`, "inputTypes") = c('_p_BondPtr', 'numeric', '_p_DayCounter', 'character', 'character', '_p_Date')
class(`Bond_yield__SWIG_5`) = c("SWIGFunction", class('Bond_yield__SWIG_5'))

# Start of Bond_yield

`Bond_yield__SWIG_6` = function(self, cleanPrice, dc, compounding, freq, .copy = FALSE)
{
  compounding = enumToInteger(compounding, "_Compounding"); 
  
  if(length(compounding) > 1) {
    warning("using only the first element of compounding");
  };
  
  freq = enumToInteger(freq, "_Frequency"); 
  
  if(length(freq) > 1) {
    warning("using only the first element of freq");
  };
  
  ;.Call('R_swig_Bond_yield__SWIG_6', self, cleanPrice, dc, compounding, freq, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Bond_yield__SWIG_6`, 'returnType') = 'numeric'
attr(`Bond_yield__SWIG_6`, "inputTypes") = c('_p_BondPtr', 'numeric', '_p_DayCounter', 'character', 'character')
class(`Bond_yield__SWIG_6`) = c("SWIGFunction", class('Bond_yield__SWIG_6'))

`Bond_yield` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 7
  if (argc == 4) {
    if (extends(argtypes[1], '_p_BondPtr') && extends(argtypes[2], '_p_DayCounter') && is.character(argv[[3]]) && is.character(argv[[4]])) {
      f <- Bond_yield__SWIG_2; 
    }
  } else if (argc == 5) {
    if (extends(argtypes[1], '_p_BondPtr') && extends(argtypes[2], '_p_DayCounter') && is.character(argv[[3]]) && is.character(argv[[4]]) && is.numeric(argv[[5]])) {
      f <- Bond_yield__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_BondPtr') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_DayCounter') && is.character(argv[[4]]) && is.character(argv[[5]])) {
      f <- Bond_yield__SWIG_6; 
    }
  } else if (argc == 6) {
    if (extends(argtypes[1], '_p_BondPtr') && extends(argtypes[2], '_p_DayCounter') && is.character(argv[[3]]) && is.character(argv[[4]]) && is.numeric(argv[[5]]) && (is.integer(argv[[6]]) || is.numeric(argv[[6]]))) {
      f <- Bond_yield__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_BondPtr') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_DayCounter') && is.character(argv[[4]]) && is.character(argv[[5]]) && extends(argtypes[6], '_p_Date')) {
      f <- Bond_yield__SWIG_5; 
    }
  } else if (argc == 7) {
    if (extends(argtypes[1], '_p_BondPtr') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_DayCounter') && is.character(argv[[4]]) && is.character(argv[[5]]) && extends(argtypes[6], '_p_Date') && is.numeric(argv[[7]])) {
      f <- Bond_yield__SWIG_4; 
    }
  } else if (argc == 8) {
    if (extends(argtypes[1], '_p_BondPtr') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_DayCounter') && is.character(argv[[4]]) && is.character(argv[[5]]) && extends(argtypes[6], '_p_Date') && is.numeric(argv[[7]]) && (is.integer(argv[[8]]) || is.numeric(argv[[8]]))) {
      f <- Bond_yield__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for Bond_yield with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of Bond_accruedAmount

`Bond_accruedAmount__SWIG_0` = function(self, settlement, .copy = FALSE)
{
  ;.Call('R_swig_Bond_accruedAmount__SWIG_0', self, settlement, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Bond_accruedAmount__SWIG_0`, 'returnType') = 'numeric'
attr(`Bond_accruedAmount__SWIG_0`, "inputTypes") = c('_p_BondPtr', '_p_Date')
class(`Bond_accruedAmount__SWIG_0`) = c("SWIGFunction", class('Bond_accruedAmount__SWIG_0'))

# Start of Bond_accruedAmount

`Bond_accruedAmount__SWIG_1` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Bond_accruedAmount__SWIG_1', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Bond_accruedAmount__SWIG_1`, 'returnType') = 'numeric'
attr(`Bond_accruedAmount__SWIG_1`, "inputTypes") = c('_p_BondPtr')
class(`Bond_accruedAmount__SWIG_1`) = c("SWIGFunction", class('Bond_accruedAmount__SWIG_1'))

`Bond_accruedAmount` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_BondPtr')) {
      f <- Bond_accruedAmount__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_BondPtr') && extends(argtypes[2], '_p_Date')) {
      f <- Bond_accruedAmount__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Bond_accruedAmount with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of Bond_settlementValue

`Bond_settlementValue__SWIG_0` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Bond_settlementValue__SWIG_0', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Bond_settlementValue__SWIG_0`, 'returnType') = 'numeric'
attr(`Bond_settlementValue__SWIG_0`, "inputTypes") = c('_p_BondPtr')
class(`Bond_settlementValue__SWIG_0`) = c("SWIGFunction", class('Bond_settlementValue__SWIG_0'))

# Start of Bond_settlementValue

`Bond_settlementValue__SWIG_1` = function(self, cleanPrice, .copy = FALSE)
{
  ;.Call('R_swig_Bond_settlementValue__SWIG_1', self, cleanPrice, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Bond_settlementValue__SWIG_1`, 'returnType') = 'numeric'
attr(`Bond_settlementValue__SWIG_1`, "inputTypes") = c('_p_BondPtr', 'numeric')
class(`Bond_settlementValue__SWIG_1`) = c("SWIGFunction", class('Bond_settlementValue__SWIG_1'))

`Bond_settlementValue` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_BondPtr')) {
      f <- Bond_settlementValue__SWIG_0; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_BondPtr') && is.numeric(argv[[2]])) {
      f <- Bond_settlementValue__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for Bond_settlementValue with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_Bond

`delete_Bond` = function(self)
{
  ;.Call('R_swig_delete_Bond', self, PACKAGE='QuantLib');
  
}

attr(`delete_Bond`, 'returnType') = 'void'
attr(`delete_Bond`, "inputTypes") = c('_p_BondPtr')
class(`delete_Bond`) = c("SWIGFunction", class('delete_Bond'))

# Start of accessor method for BondPtr
setMethod('$', '_p_BondPtr', function(x, name)

{
  accessorFuns = list('nextCouponRate' = Bond_nextCouponRate, 'previousCouponRate' = Bond_previousCouponRate, 'settlementDays' = Bond_settlementDays, 'settlementDate' = Bond_settlementDate, 'startDate' = Bond_startDate, 'maturityDate' = Bond_maturityDate, 'issueDate' = Bond_issueDate, 'cashflows' = Bond_cashflows, 'redemptions' = Bond_redemptions, 'redemption' = Bond_redemption, 'calendar' = Bond_calendar, 'notionals' = Bond_notionals, 'notional' = Bond_notional, 'cleanPrice' = Bond_cleanPrice, 'dirtyPrice' = Bond_dirtyPrice, 'yield' = Bond_yield, 'accruedAmount' = Bond_accruedAmount, 'settlementValue' = Bond_settlementValue);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for BondPtr
setMethod('delete', '_p_BondPtr', function(obj) {delete_BondPtr(obj)})
# Start of cleanPriceFromZSpread

`cleanPriceFromZSpread__SWIG_0` = function(bond, discountCurve, zSpread, dc, compounding, freq, settlementDate, .copy = FALSE)
{
  compounding = enumToInteger(compounding, "_Compounding"); 
  
  if(length(compounding) > 1) {
    warning("using only the first element of compounding");
  };
  
  freq = enumToInteger(freq, "_Frequency"); 
  
  if(length(freq) > 1) {
    warning("using only the first element of freq");
  };
  
  
  ;.Call('R_swig_cleanPriceFromZSpread__SWIG_0', bond, discountCurve, zSpread, dc, compounding, freq, settlementDate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`cleanPriceFromZSpread__SWIG_0`, 'returnType') = 'numeric'
attr(`cleanPriceFromZSpread__SWIG_0`, "inputTypes") = c('_p_BondPtr', '_p_boost__shared_ptrT_YieldTermStructure_t', 'numeric', '_p_DayCounter', 'character', 'character', '_p_Date')
class(`cleanPriceFromZSpread__SWIG_0`) = c("SWIGFunction", class('cleanPriceFromZSpread__SWIG_0'))

# Start of cleanPriceFromZSpread

`cleanPriceFromZSpread__SWIG_1` = function(bond, discountCurve, zSpread, dc, compounding, freq, .copy = FALSE)
{
  compounding = enumToInteger(compounding, "_Compounding"); 
  
  if(length(compounding) > 1) {
    warning("using only the first element of compounding");
  };
  
  freq = enumToInteger(freq, "_Frequency"); 
  
  if(length(freq) > 1) {
    warning("using only the first element of freq");
  };
  
  ;.Call('R_swig_cleanPriceFromZSpread__SWIG_1', bond, discountCurve, zSpread, dc, compounding, freq, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`cleanPriceFromZSpread__SWIG_1`, 'returnType') = 'numeric'
attr(`cleanPriceFromZSpread__SWIG_1`, "inputTypes") = c('_p_BondPtr', '_p_boost__shared_ptrT_YieldTermStructure_t', 'numeric', '_p_DayCounter', 'character', 'character')
class(`cleanPriceFromZSpread__SWIG_1`) = c("SWIGFunction", class('cleanPriceFromZSpread__SWIG_1'))

`cleanPriceFromZSpread` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 6) {
    if (extends(argtypes[1], '_p_BondPtr') && extends(argtypes[2], '_p_boost__shared_ptrT_YieldTermStructure_t') && is.numeric(argv[[3]]) && extends(argtypes[4], '_p_DayCounter') && is.character(argv[[5]]) && is.character(argv[[6]])) {
      f <- cleanPriceFromZSpread__SWIG_1; 
    }
  } else if (argc == 7) {
    if (extends(argtypes[1], '_p_BondPtr') && extends(argtypes[2], '_p_boost__shared_ptrT_YieldTermStructure_t') && is.numeric(argv[[3]]) && extends(argtypes[4], '_p_DayCounter') && is.character(argv[[5]]) && is.character(argv[[6]]) && extends(argtypes[7], '_p_Date')) {
      f <- cleanPriceFromZSpread__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for cleanPriceFromZSpread with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of new_ZeroCouponBond

`ZeroCouponBond` = function(settlementDays, calendar, faceAmount, maturityDate, paymentConvention, redemption, issueDate)
{
  if(length(settlementDays) > 1) {
    warning("using only the first element of settlementDays");
  };
  
  
  
  
  paymentConvention = enumToInteger(paymentConvention, "_BusinessDayConvention"); 
  
  if(length(paymentConvention) > 1) {
    warning("using only the first element of paymentConvention");
  };
  
  
  
  ;ans = .Call('R_swig_new_ZeroCouponBond', settlementDays, calendar, faceAmount, maturityDate, paymentConvention, redemption, issueDate, PACKAGE='QuantLib');
  class(ans) <- "_p_ZeroCouponBondPtr";
  
  reg.finalizer(ans, delete_ZeroCouponBond)
  ans
  
}

attr(`ZeroCouponBond`, 'returnType') = '_p_ZeroCouponBondPtr'
attr(`ZeroCouponBond`, "inputTypes") = c('integer', '_p_Calendar', 'numeric', '_p_Date', 'character', 'numeric', '_p_Date')
class(`ZeroCouponBond`) = c("SWIGFunction", class('ZeroCouponBond'))

# Start of delete_ZeroCouponBond

`delete_ZeroCouponBond` = function(self)
{
  ;.Call('R_swig_delete_ZeroCouponBond', self, PACKAGE='QuantLib');
  
}

attr(`delete_ZeroCouponBond`, 'returnType') = 'void'
attr(`delete_ZeroCouponBond`, "inputTypes") = c('_p_ZeroCouponBondPtr')
class(`delete_ZeroCouponBond`) = c("SWIGFunction", class('delete_ZeroCouponBond'))

setMethod('delete', '_p_ZeroCouponBondPtr', function(obj) {delete_ZeroCouponBondPtr(obj)})
# Start of new_FixedRateBond

`FixedRateBond` = function(settlementDays, faceAmount, schedule, coupons, paymentDayCounter, paymentConvention, redemption, issueDate)
{
  settlementDays = as.integer(settlementDays); 
  
  if(length(settlementDays) > 1) {
    warning("using only the first element of settlementDays");
  };
  
  
  
  
  
  paymentConvention = enumToInteger(paymentConvention, "_BusinessDayConvention"); 
  
  if(length(paymentConvention) > 1) {
    warning("using only the first element of paymentConvention");
  };
  
  
  
  ;ans = .Call('R_swig_new_FixedRateBond', settlementDays, faceAmount, schedule, coupons, paymentDayCounter, paymentConvention, redemption, issueDate, PACKAGE='QuantLib');
  class(ans) <- "_p_FixedRateBondPtr";
  
  reg.finalizer(ans, delete_FixedRateBond)
  ans
  
}

attr(`FixedRateBond`, 'returnType') = '_p_FixedRateBondPtr'
attr(`FixedRateBond`, "inputTypes") = c('integer', 'numeric', '_p_Schedule', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_DayCounter', 'character', 'numeric', '_p_Date')
class(`FixedRateBond`) = c("SWIGFunction", class('FixedRateBond'))

# Start of FixedRateBond_frequency

`FixedRateBond_frequency` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_FixedRateBond_frequency', self, as.logical(.copy), PACKAGE='QuantLib');
  ans = enumFromInteger(ans, "_Frequency");
  
  ans
  
}

attr(`FixedRateBond_frequency`, 'returnType') = 'character'
attr(`FixedRateBond_frequency`, "inputTypes") = c('_p_FixedRateBondPtr')
class(`FixedRateBond_frequency`) = c("SWIGFunction", class('FixedRateBond_frequency'))

# Start of FixedRateBond_dayCounter

`FixedRateBond_dayCounter` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_FixedRateBond_dayCounter', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_DayCounter";
  
  ans
  
}

attr(`FixedRateBond_dayCounter`, 'returnType') = '_p_DayCounter'
attr(`FixedRateBond_dayCounter`, "inputTypes") = c('_p_FixedRateBondPtr')
class(`FixedRateBond_dayCounter`) = c("SWIGFunction", class('FixedRateBond_dayCounter'))

# Start of delete_FixedRateBond

`delete_FixedRateBond` = function(self)
{
  ;.Call('R_swig_delete_FixedRateBond', self, PACKAGE='QuantLib');
  
}

attr(`delete_FixedRateBond`, 'returnType') = 'void'
attr(`delete_FixedRateBond`, "inputTypes") = c('_p_FixedRateBondPtr')
class(`delete_FixedRateBond`) = c("SWIGFunction", class('delete_FixedRateBond'))

# Start of accessor method for FixedRateBondPtr
setMethod('$', '_p_FixedRateBondPtr', function(x, name)

{
  accessorFuns = list('frequency' = FixedRateBond_frequency, 'dayCounter' = FixedRateBond_dayCounter);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for FixedRateBondPtr
setMethod('delete', '_p_FixedRateBondPtr', function(obj) {delete_FixedRateBondPtr(obj)})
# Start of new_FloatingRateBond

`FloatingRateBond` = function(settlementDays, faceAmount, schedule, index, paymentDayCounter, paymentConvention, fixingDays, gearings, spreads, caps, floors, inArrears, redemption, issueDate)
{
  if(length(settlementDays) > 1) {
    warning("using only the first element of settlementDays");
  };
  
  
  
  
  
  paymentConvention = enumToInteger(paymentConvention, "_BusinessDayConvention"); 
  
  if(length(paymentConvention) > 1) {
    warning("using only the first element of paymentConvention");
  };
  
  
  
  if(length(fixingDays) > 1) {
    warning("using only the first element of fixingDays");
  };
  
  
  
  
  
  inArrears = as.logical(inArrears);
  
  
  ;ans = .Call('R_swig_new_FloatingRateBond', settlementDays, faceAmount, schedule, index, paymentDayCounter, paymentConvention, fixingDays, gearings, spreads, caps, floors, inArrears, redemption, issueDate, PACKAGE='QuantLib');
  class(ans) <- "_p_FloatingRateBondPtr";
  
  reg.finalizer(ans, delete_FloatingRateBond)
  ans
  
}

attr(`FloatingRateBond`, 'returnType') = '_p_FloatingRateBondPtr'
attr(`FloatingRateBond`, "inputTypes") = c('integer', 'numeric', '_p_Schedule', '_p_IborIndexPtr', '_p_DayCounter', 'character', 'integer', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t', 'logical', 'numeric', '_p_Date')
class(`FloatingRateBond`) = c("SWIGFunction", class('FloatingRateBond'))

# Start of delete_FloatingRateBond

`delete_FloatingRateBond` = function(self)
{
  ;.Call('R_swig_delete_FloatingRateBond', self, PACKAGE='QuantLib');
  
}

attr(`delete_FloatingRateBond`, 'returnType') = 'void'
attr(`delete_FloatingRateBond`, "inputTypes") = c('_p_FloatingRateBondPtr')
class(`delete_FloatingRateBond`) = c("SWIGFunction", class('delete_FloatingRateBond'))

setMethod('delete', '_p_FloatingRateBondPtr', function(obj) {delete_FloatingRateBondPtr(obj)})
# Start of new_CmsRateBond

`CmsRateBond` = function(settlementDays, faceAmount, schedule, index, paymentDayCounter, paymentConvention, fixingDays, gearings, spreads, caps, floors, inArrears, redemption, issueDate)
{
  if(length(settlementDays) > 1) {
    warning("using only the first element of settlementDays");
  };
  
  
  
  
  
  paymentConvention = enumToInteger(paymentConvention, "_BusinessDayConvention"); 
  
  if(length(paymentConvention) > 1) {
    warning("using only the first element of paymentConvention");
  };
  
  
  
  if(length(fixingDays) > 1) {
    warning("using only the first element of fixingDays");
  };
  
  
  
  
  
  inArrears = as.logical(inArrears);
  
  
  ;ans = .Call('R_swig_new_CmsRateBond', settlementDays, faceAmount, schedule, index, paymentDayCounter, paymentConvention, fixingDays, gearings, spreads, caps, floors, inArrears, redemption, issueDate, PACKAGE='QuantLib');
  class(ans) <- "_p_CmsRateBondPtr";
  
  reg.finalizer(ans, delete_CmsRateBond)
  ans
  
}

attr(`CmsRateBond`, 'returnType') = '_p_CmsRateBondPtr'
attr(`CmsRateBond`, "inputTypes") = c('integer', 'numeric', '_p_Schedule', '_p_SwapIndexPtr', '_p_DayCounter', 'character', 'integer', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t', 'logical', 'numeric', '_p_Date')
class(`CmsRateBond`) = c("SWIGFunction", class('CmsRateBond'))

# Start of delete_CmsRateBond

`delete_CmsRateBond` = function(self)
{
  ;.Call('R_swig_delete_CmsRateBond', self, PACKAGE='QuantLib');
  
}

attr(`delete_CmsRateBond`, 'returnType') = 'void'
attr(`delete_CmsRateBond`, "inputTypes") = c('_p_CmsRateBondPtr')
class(`delete_CmsRateBond`) = c("SWIGFunction", class('delete_CmsRateBond'))

setMethod('delete', '_p_CmsRateBondPtr', function(obj) {delete_CmsRateBondPtr(obj)})
# Start of new_DiscountingBondEngine

`DiscountingBondEngine` = function(discountCurve)
{
  ;ans = .Call('R_swig_new_DiscountingBondEngine', discountCurve, PACKAGE='QuantLib');
  class(ans) <- "_p_DiscountingBondEnginePtr";
  
  reg.finalizer(ans, delete_DiscountingBondEngine)
  ans
  
}

attr(`DiscountingBondEngine`, 'returnType') = '_p_DiscountingBondEnginePtr'
attr(`DiscountingBondEngine`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`DiscountingBondEngine`) = c("SWIGFunction", class('DiscountingBondEngine'))

# Start of delete_DiscountingBondEngine

`delete_DiscountingBondEngine` = function(self)
{
  ;.Call('R_swig_delete_DiscountingBondEngine', self, PACKAGE='QuantLib');
  
}

attr(`delete_DiscountingBondEngine`, 'returnType') = 'void'
attr(`delete_DiscountingBondEngine`, "inputTypes") = c('_p_DiscountingBondEnginePtr')
class(`delete_DiscountingBondEngine`) = c("SWIGFunction", class('delete_DiscountingBondEngine'))

setMethod('delete', '_p_DiscountingBondEnginePtr', function(obj) {delete_DiscountingBondEnginePtr(obj)})
defineEnumeration('_CallabilityPrice__Type',
                    .values = c(
                        'Dirty' = 0, 
                        'Clean' = 1
))
# Start of new_CallabilityPrice

`CallabilityPrice` = function(amount, type)
{
  type = enumToInteger(type, "_CallabilityPrice__Type"); 
  
  if(length(type) > 1) {
    warning("using only the first element of type");
  };
  
  ;ans = .Call('R_swig_new_CallabilityPrice', amount, type, PACKAGE='QuantLib');
  class(ans) <- "_p_CallabilityPrice";
  
  reg.finalizer(ans, delete_CallabilityPrice)
  ans
  
}

attr(`CallabilityPrice`, 'returnType') = '_p_CallabilityPrice'
attr(`CallabilityPrice`, "inputTypes") = c('numeric', 'character')
class(`CallabilityPrice`) = c("SWIGFunction", class('CallabilityPrice'))

# Start of CallabilityPrice_amount

`CallabilityPrice_amount` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_CallabilityPrice_amount', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CallabilityPrice_amount`, 'returnType') = 'numeric'
attr(`CallabilityPrice_amount`, "inputTypes") = c('_p_CallabilityPrice')
class(`CallabilityPrice_amount`) = c("SWIGFunction", class('CallabilityPrice_amount'))

# Start of CallabilityPrice_type

`CallabilityPrice_type` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_CallabilityPrice_type', self, as.logical(.copy), PACKAGE='QuantLib');
  ans = enumFromInteger(ans, "_CallabilityPrice__Type");
  
  ans
  
}

attr(`CallabilityPrice_type`, 'returnType') = 'character'
attr(`CallabilityPrice_type`, "inputTypes") = c('_p_CallabilityPrice')
class(`CallabilityPrice_type`) = c("SWIGFunction", class('CallabilityPrice_type'))

# Start of delete_CallabilityPrice

`delete_CallabilityPrice` = function(self)
{
  ;.Call('R_swig_delete_CallabilityPrice', self, PACKAGE='QuantLib');
  
}

attr(`delete_CallabilityPrice`, 'returnType') = 'void'
attr(`delete_CallabilityPrice`, "inputTypes") = c('_p_CallabilityPrice')
class(`delete_CallabilityPrice`) = c("SWIGFunction", class('delete_CallabilityPrice'))

# Start of accessor method for CallabilityPrice
setMethod('$', '_p_CallabilityPrice', function(x, name)

{
  accessorFuns = list('amount' = CallabilityPrice_amount, 'type' = CallabilityPrice_type);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for CallabilityPrice
setMethod('delete', '_p_CallabilityPrice', function(obj) {delete_CallabilityPrice(obj)})
# Start of Callability___deref__

`Callability___deref__` = function(self)
{
  ;ans = .Call('R_swig_Callability___deref__', self, PACKAGE='QuantLib');
  class(ans) <- "_p_Callability";
  
  ans
  
}

attr(`Callability___deref__`, 'returnType') = '_p_Callability'
attr(`Callability___deref__`, "inputTypes") = c('_p_boost__shared_ptrT_Callability_t')
class(`Callability___deref__`) = c("SWIGFunction", class('Callability___deref__'))

# Start of Callability_isNull

`Callability_isNull` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Callability_isNull', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Callability_isNull`, 'returnType') = 'logical'
attr(`Callability_isNull`, "inputTypes") = c('_p_boost__shared_ptrT_Callability_t')
class(`Callability_isNull`) = c("SWIGFunction", class('Callability_isNull'))

# Start of new_Callability

`Callability` = function(price, type, date)
{
  type = enumToInteger(type, "_Callability__Type"); 
  
  if(length(type) > 1) {
    warning("using only the first element of type");
  };
  
  
  ;ans = .Call('R_swig_new_Callability', price, type, date, PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_Callability_t";
  
  reg.finalizer(ans, delete_Callability)
  ans
  
}

attr(`Callability`, 'returnType') = '_p_boost__shared_ptrT_Callability_t'
attr(`Callability`, "inputTypes") = c('_p_CallabilityPrice', 'character', '_p_Date')
class(`Callability`) = c("SWIGFunction", class('Callability'))

# Start of delete_Callability

`delete_Callability` = function(self)
{
  ;.Call('R_swig_delete_Callability', self, PACKAGE='QuantLib');
  
}

attr(`delete_Callability`, 'returnType') = 'void'
attr(`delete_Callability`, "inputTypes") = c('_p_boost__shared_ptrT_Callability_t')
class(`delete_Callability`) = c("SWIGFunction", class('delete_Callability'))

# Start of Callability_price

`Callability_price` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_Callability_price', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_CallabilityPrice";
  
  ans
  
}

attr(`Callability_price`, 'returnType') = '_p_CallabilityPrice'
attr(`Callability_price`, "inputTypes") = c('_p_boost__shared_ptrT_Callability_t')
class(`Callability_price`) = c("SWIGFunction", class('Callability_price'))

# Start of Callability_type

`Callability_type` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_Callability_type', self, as.logical(.copy), PACKAGE='QuantLib');
  ans = enumFromInteger(ans, "_Callability__Type");
  
  ans
  
}

attr(`Callability_type`, 'returnType') = 'character'
attr(`Callability_type`, "inputTypes") = c('_p_boost__shared_ptrT_Callability_t')
class(`Callability_type`) = c("SWIGFunction", class('Callability_type'))

# Start of Callability_date

`Callability_date` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_Callability_date', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`Callability_date`, 'returnType') = '_p_Date'
attr(`Callability_date`, "inputTypes") = c('_p_boost__shared_ptrT_Callability_t')
class(`Callability_date`) = c("SWIGFunction", class('Callability_date'))

# Start of accessor method for boost::shared_ptr<(Callability)>
setMethod('$', '_p_boost__shared_ptrT_Callability_t', function(x, name)

{
  accessorFuns = list('__deref__' = Callability___deref__, 'isNull' = Callability_isNull, 'price' = Callability_price, 'type' = Callability_type, 'date' = Callability_date);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for boost::shared_ptr<(Callability)>
setMethod('delete', '_p_boost__shared_ptrT_Callability_t', function(obj) {delete_boost__shared_ptrT_Callability_t(obj)})
# Start of new_SoftCallability

`SoftCallability` = function(price, date, trigger)
{
  ;ans = .Call('R_swig_new_SoftCallability', price, date, trigger, PACKAGE='QuantLib');
  class(ans) <- "_p_SoftCallabilityPtr";
  
  reg.finalizer(ans, delete_SoftCallability)
  ans
  
}

attr(`SoftCallability`, 'returnType') = '_p_SoftCallabilityPtr'
attr(`SoftCallability`, "inputTypes") = c('_p_CallabilityPrice', '_p_Date', 'numeric')
class(`SoftCallability`) = c("SWIGFunction", class('SoftCallability'))

# Start of delete_SoftCallability

`delete_SoftCallability` = function(self)
{
  ;.Call('R_swig_delete_SoftCallability', self, PACKAGE='QuantLib');
  
}

attr(`delete_SoftCallability`, 'returnType') = 'void'
attr(`delete_SoftCallability`, "inputTypes") = c('_p_SoftCallabilityPtr')
class(`delete_SoftCallability`) = c("SWIGFunction", class('delete_SoftCallability'))

setMethod('delete', '_p_SoftCallabilityPtr', function(obj) {delete_SoftCallabilityPtr(obj)})
# Start of CallabilitySchedule___nonzero__

`CallabilitySchedule___nonzero__` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_CallabilitySchedule___nonzero__', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CallabilitySchedule___nonzero__`, 'returnType') = 'logical'
attr(`CallabilitySchedule___nonzero__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Callability_t_std__allocatorT_boost__shared_ptrT_Callability_t_t_t')
class(`CallabilitySchedule___nonzero__`) = c("SWIGFunction", class('CallabilitySchedule___nonzero__'))

# Start of CallabilitySchedule___len__

`CallabilitySchedule___len__` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_CallabilitySchedule___len__', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`CallabilitySchedule___len__`, 'returnType') = 'integer'
attr(`CallabilitySchedule___len__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Callability_t_std__allocatorT_boost__shared_ptrT_Callability_t_t_t')
class(`CallabilitySchedule___len__`) = c("SWIGFunction", class('CallabilitySchedule___len__'))

# Start of CallabilitySchedule_pop

`CallabilitySchedule_pop` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_CallabilitySchedule_pop', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_Callability_t";
  
  ans
  
}

attr(`CallabilitySchedule_pop`, 'returnType') = '_p_boost__shared_ptrT_Callability_t'
attr(`CallabilitySchedule_pop`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Callability_t_std__allocatorT_boost__shared_ptrT_Callability_t_t_t')
class(`CallabilitySchedule_pop`) = c("SWIGFunction", class('CallabilitySchedule_pop'))

# Start of CallabilitySchedule___getslice__

`CallabilitySchedule___getslice__` = function(self, i, j)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;ans = .Call('R_swig_CallabilitySchedule___getslice__', self, i, j, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_Callability_t_std__allocatorT_boost__shared_ptrT_Callability_t_t_t";
  
  ans
  
}

attr(`CallabilitySchedule___getslice__`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_Callability_t_std__allocatorT_boost__shared_ptrT_Callability_t_t_t'
attr(`CallabilitySchedule___getslice__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Callability_t_std__allocatorT_boost__shared_ptrT_Callability_t_t_t', 'integer', 'integer')
class(`CallabilitySchedule___getslice__`) = c("SWIGFunction", class('CallabilitySchedule___getslice__'))

# Start of CallabilitySchedule___setslice__

`CallabilitySchedule___setslice__` = function(self, i, j, v)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  
  ;.Call('R_swig_CallabilitySchedule___setslice__', self, i, j, v, PACKAGE='QuantLib');
  
}

attr(`CallabilitySchedule___setslice__`, 'returnType') = 'void'
attr(`CallabilitySchedule___setslice__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Callability_t_std__allocatorT_boost__shared_ptrT_Callability_t_t_t', 'integer', 'integer', '_p_std__vectorT_boost__shared_ptrT_Callability_t_std__allocatorT_boost__shared_ptrT_Callability_t_t_t')
class(`CallabilitySchedule___setslice__`) = c("SWIGFunction", class('CallabilitySchedule___setslice__'))

# Start of CallabilitySchedule___delslice__

`CallabilitySchedule___delslice__` = function(self, i, j)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_CallabilitySchedule___delslice__', self, i, j, PACKAGE='QuantLib');
  
}

attr(`CallabilitySchedule___delslice__`, 'returnType') = 'void'
attr(`CallabilitySchedule___delslice__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Callability_t_std__allocatorT_boost__shared_ptrT_Callability_t_t_t', 'integer', 'integer')
class(`CallabilitySchedule___delslice__`) = c("SWIGFunction", class('CallabilitySchedule___delslice__'))

# Start of CallabilitySchedule___delitem__

`CallabilitySchedule___delitem__` = function(self, i)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_CallabilitySchedule___delitem__', self, i, PACKAGE='QuantLib');
  
}

attr(`CallabilitySchedule___delitem__`, 'returnType') = 'void'
attr(`CallabilitySchedule___delitem__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Callability_t_std__allocatorT_boost__shared_ptrT_Callability_t_t_t', 'integer')
class(`CallabilitySchedule___delitem__`) = c("SWIGFunction", class('CallabilitySchedule___delitem__'))

# Start of CallabilitySchedule___getitem__

`CallabilitySchedule___getitem__` = function(self, i, .copy = FALSE)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;ans = .Call('R_swig_CallabilitySchedule___getitem__', self, i, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_Callability_t";
  
  ans
  
}

attr(`CallabilitySchedule___getitem__`, 'returnType') = '_p_boost__shared_ptrT_Callability_t'
attr(`CallabilitySchedule___getitem__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Callability_t_std__allocatorT_boost__shared_ptrT_Callability_t_t_t', 'integer')
class(`CallabilitySchedule___getitem__`) = c("SWIGFunction", class('CallabilitySchedule___getitem__'))

# Start of CallabilitySchedule___setitem__

`CallabilitySchedule___setitem__` = function(self, i, x)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  ;.Call('R_swig_CallabilitySchedule___setitem__', self, i, x, PACKAGE='QuantLib');
  
}

attr(`CallabilitySchedule___setitem__`, 'returnType') = 'void'
attr(`CallabilitySchedule___setitem__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Callability_t_std__allocatorT_boost__shared_ptrT_Callability_t_t_t', 'integer', '_p_boost__shared_ptrT_Callability_t')
class(`CallabilitySchedule___setitem__`) = c("SWIGFunction", class('CallabilitySchedule___setitem__'))

# Start of CallabilitySchedule_append

`CallabilitySchedule_append` = function(self, x)
{
  ;.Call('R_swig_CallabilitySchedule_append', self, x, PACKAGE='QuantLib');
  
}

attr(`CallabilitySchedule_append`, 'returnType') = 'void'
attr(`CallabilitySchedule_append`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Callability_t_std__allocatorT_boost__shared_ptrT_Callability_t_t_t', '_p_boost__shared_ptrT_Callability_t')
class(`CallabilitySchedule_append`) = c("SWIGFunction", class('CallabilitySchedule_append'))

# Start of new_CallabilitySchedule

`CallabilitySchedule__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_CallabilitySchedule__SWIG_0', PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_Callability_t_std__allocatorT_boost__shared_ptrT_Callability_t_t_t";
  
  reg.finalizer(ans, delete_CallabilitySchedule)
  ans
  
}

attr(`CallabilitySchedule__SWIG_0`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_Callability_t_std__allocatorT_boost__shared_ptrT_Callability_t_t_t'
class(`CallabilitySchedule__SWIG_0`) = c("SWIGFunction", class('CallabilitySchedule__SWIG_0'))

# Start of new_CallabilitySchedule

`CallabilitySchedule__SWIG_1` = function(s_arg1)
{
  ;ans = .Call('R_swig_new_CallabilitySchedule__SWIG_1', s_arg1, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_Callability_t_std__allocatorT_boost__shared_ptrT_Callability_t_t_t";
  
  reg.finalizer(ans, delete_CallabilitySchedule)
  ans
  
}

attr(`CallabilitySchedule__SWIG_1`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_Callability_t_std__allocatorT_boost__shared_ptrT_Callability_t_t_t'
attr(`CallabilitySchedule__SWIG_1`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Callability_t_std__allocatorT_boost__shared_ptrT_Callability_t_t_t')
class(`CallabilitySchedule__SWIG_1`) = c("SWIGFunction", class('CallabilitySchedule__SWIG_1'))

# Start of CallabilitySchedule_empty

`CallabilitySchedule_empty` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_CallabilitySchedule_empty', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CallabilitySchedule_empty`, 'returnType') = 'logical'
attr(`CallabilitySchedule_empty`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Callability_t_std__allocatorT_boost__shared_ptrT_Callability_t_t_t')
class(`CallabilitySchedule_empty`) = c("SWIGFunction", class('CallabilitySchedule_empty'))

# Start of CallabilitySchedule_size

`CallabilitySchedule_size` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_CallabilitySchedule_size', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`CallabilitySchedule_size`, 'returnType') = 'integer'
attr(`CallabilitySchedule_size`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Callability_t_std__allocatorT_boost__shared_ptrT_Callability_t_t_t')
class(`CallabilitySchedule_size`) = c("SWIGFunction", class('CallabilitySchedule_size'))

# Start of CallabilitySchedule_clear

`CallabilitySchedule_clear` = function(self)
{
  ;.Call('R_swig_CallabilitySchedule_clear', self, PACKAGE='QuantLib');
  
}

attr(`CallabilitySchedule_clear`, 'returnType') = 'void'
attr(`CallabilitySchedule_clear`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Callability_t_std__allocatorT_boost__shared_ptrT_Callability_t_t_t')
class(`CallabilitySchedule_clear`) = c("SWIGFunction", class('CallabilitySchedule_clear'))

# Start of CallabilitySchedule_swap

`CallabilitySchedule_swap` = function(self, v)
{
  ;.Call('R_swig_CallabilitySchedule_swap', self, v, PACKAGE='QuantLib');
  
}

attr(`CallabilitySchedule_swap`, 'returnType') = 'void'
attr(`CallabilitySchedule_swap`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Callability_t_std__allocatorT_boost__shared_ptrT_Callability_t_t_t', '_p_std__vectorT_boost__shared_ptrT_Callability_t_std__allocatorT_boost__shared_ptrT_Callability_t_t_t')
class(`CallabilitySchedule_swap`) = c("SWIGFunction", class('CallabilitySchedule_swap'))

# Start of CallabilitySchedule_get_allocator

`CallabilitySchedule_get_allocator` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_CallabilitySchedule_get_allocator', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__allocatorT_boost__shared_ptrT_Callability_t_t";
  
  ans
  
}

attr(`CallabilitySchedule_get_allocator`, 'returnType') = '_p_std__allocatorT_boost__shared_ptrT_Callability_t_t'
attr(`CallabilitySchedule_get_allocator`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Callability_t_std__allocatorT_boost__shared_ptrT_Callability_t_t_t')
class(`CallabilitySchedule_get_allocator`) = c("SWIGFunction", class('CallabilitySchedule_get_allocator'))

# Start of new_CallabilitySchedule

`CallabilitySchedule__SWIG_2` = function(size)
{
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_new_CallabilitySchedule__SWIG_2', size, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_Callability_t_std__allocatorT_boost__shared_ptrT_Callability_t_t_t";
  
  reg.finalizer(ans, delete_CallabilitySchedule)
  ans
  
}

attr(`CallabilitySchedule__SWIG_2`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_Callability_t_std__allocatorT_boost__shared_ptrT_Callability_t_t_t'
attr(`CallabilitySchedule__SWIG_2`, "inputTypes") = c('integer')
class(`CallabilitySchedule__SWIG_2`) = c("SWIGFunction", class('CallabilitySchedule__SWIG_2'))

# Start of CallabilitySchedule_pop_back

`CallabilitySchedule_pop_back` = function(self)
{
  ;.Call('R_swig_CallabilitySchedule_pop_back', self, PACKAGE='QuantLib');
  
}

attr(`CallabilitySchedule_pop_back`, 'returnType') = 'void'
attr(`CallabilitySchedule_pop_back`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Callability_t_std__allocatorT_boost__shared_ptrT_Callability_t_t_t')
class(`CallabilitySchedule_pop_back`) = c("SWIGFunction", class('CallabilitySchedule_pop_back'))

# Start of CallabilitySchedule_resize

`CallabilitySchedule_resize__SWIG_0` = function(self, new_size)
{
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_CallabilitySchedule_resize__SWIG_0', self, new_size, PACKAGE='QuantLib');
  
}

attr(`CallabilitySchedule_resize__SWIG_0`, 'returnType') = 'void'
attr(`CallabilitySchedule_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Callability_t_std__allocatorT_boost__shared_ptrT_Callability_t_t_t', 'integer')
class(`CallabilitySchedule_resize__SWIG_0`) = c("SWIGFunction", class('CallabilitySchedule_resize__SWIG_0'))

# Start of new_CallabilitySchedule

`CallabilitySchedule__SWIG_3` = function(size, value)
{
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  
  ;ans = .Call('R_swig_new_CallabilitySchedule__SWIG_3', size, value, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_Callability_t_std__allocatorT_boost__shared_ptrT_Callability_t_t_t";
  
  reg.finalizer(ans, delete_CallabilitySchedule)
  ans
  
}

attr(`CallabilitySchedule__SWIG_3`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_Callability_t_std__allocatorT_boost__shared_ptrT_Callability_t_t_t'
attr(`CallabilitySchedule__SWIG_3`, "inputTypes") = c('integer', '_p_boost__shared_ptrT_Callability_t')
class(`CallabilitySchedule__SWIG_3`) = c("SWIGFunction", class('CallabilitySchedule__SWIG_3'))

`CallabilitySchedule` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- CallabilitySchedule__SWIG_0; 
  } else if (argc == 1) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]]))) {
      f <- CallabilitySchedule__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_Callability_t_std__allocatorT_boost__shared_ptrT_Callability_t_t_t')) {
      f <- CallabilitySchedule__SWIG_1; 
    }
  } else if (argc == 2) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && extends(argtypes[2], '_p_boost__shared_ptrT_Callability_t')) {
      f <- CallabilitySchedule__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for CallabilitySchedule with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of CallabilitySchedule_push_back

`CallabilitySchedule_push_back` = function(self, x)
{
  ;.Call('R_swig_CallabilitySchedule_push_back', self, x, PACKAGE='QuantLib');
  
}

attr(`CallabilitySchedule_push_back`, 'returnType') = 'void'
attr(`CallabilitySchedule_push_back`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Callability_t_std__allocatorT_boost__shared_ptrT_Callability_t_t_t', '_p_boost__shared_ptrT_Callability_t')
class(`CallabilitySchedule_push_back`) = c("SWIGFunction", class('CallabilitySchedule_push_back'))

# Start of CallabilitySchedule_front

`CallabilitySchedule_front` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_CallabilitySchedule_front', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_Callability_t";
  
  ans
  
}

attr(`CallabilitySchedule_front`, 'returnType') = '_p_boost__shared_ptrT_Callability_t'
attr(`CallabilitySchedule_front`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Callability_t_std__allocatorT_boost__shared_ptrT_Callability_t_t_t')
class(`CallabilitySchedule_front`) = c("SWIGFunction", class('CallabilitySchedule_front'))

# Start of CallabilitySchedule_back

`CallabilitySchedule_back` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_CallabilitySchedule_back', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_Callability_t";
  
  ans
  
}

attr(`CallabilitySchedule_back`, 'returnType') = '_p_boost__shared_ptrT_Callability_t'
attr(`CallabilitySchedule_back`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Callability_t_std__allocatorT_boost__shared_ptrT_Callability_t_t_t')
class(`CallabilitySchedule_back`) = c("SWIGFunction", class('CallabilitySchedule_back'))

# Start of CallabilitySchedule_assign

`CallabilitySchedule_assign` = function(self, n, x)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  
  ;.Call('R_swig_CallabilitySchedule_assign', self, n, x, PACKAGE='QuantLib');
  
}

attr(`CallabilitySchedule_assign`, 'returnType') = 'void'
attr(`CallabilitySchedule_assign`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Callability_t_std__allocatorT_boost__shared_ptrT_Callability_t_t_t', 'integer', '_p_boost__shared_ptrT_Callability_t')
class(`CallabilitySchedule_assign`) = c("SWIGFunction", class('CallabilitySchedule_assign'))

# Start of CallabilitySchedule_resize

`CallabilitySchedule_resize__SWIG_1` = function(self, new_size, x)
{
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  
  ;.Call('R_swig_CallabilitySchedule_resize__SWIG_1', self, new_size, x, PACKAGE='QuantLib');
  
}

attr(`CallabilitySchedule_resize__SWIG_1`, 'returnType') = 'void'
attr(`CallabilitySchedule_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Callability_t_std__allocatorT_boost__shared_ptrT_Callability_t_t_t', 'integer', '_p_boost__shared_ptrT_Callability_t')
class(`CallabilitySchedule_resize__SWIG_1`) = c("SWIGFunction", class('CallabilitySchedule_resize__SWIG_1'))

`CallabilitySchedule_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_Callability_t_std__allocatorT_boost__shared_ptrT_Callability_t_t_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]]))) {
      f <- CallabilitySchedule_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_Callability_t_std__allocatorT_boost__shared_ptrT_Callability_t_t_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && extends(argtypes[3], '_p_boost__shared_ptrT_Callability_t')) {
      f <- CallabilitySchedule_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for CallabilitySchedule_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of CallabilitySchedule_reserve

`CallabilitySchedule_reserve` = function(self, n)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_CallabilitySchedule_reserve', self, n, PACKAGE='QuantLib');
  
}

attr(`CallabilitySchedule_reserve`, 'returnType') = 'void'
attr(`CallabilitySchedule_reserve`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Callability_t_std__allocatorT_boost__shared_ptrT_Callability_t_t_t', 'integer')
class(`CallabilitySchedule_reserve`) = c("SWIGFunction", class('CallabilitySchedule_reserve'))

# Start of CallabilitySchedule_capacity

`CallabilitySchedule_capacity` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_CallabilitySchedule_capacity', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`CallabilitySchedule_capacity`, 'returnType') = 'integer'
attr(`CallabilitySchedule_capacity`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Callability_t_std__allocatorT_boost__shared_ptrT_Callability_t_t_t')
class(`CallabilitySchedule_capacity`) = c("SWIGFunction", class('CallabilitySchedule_capacity'))

# Start of delete_CallabilitySchedule

`delete_CallabilitySchedule` = function(self)
{
  ;.Call('R_swig_delete_CallabilitySchedule', self, PACKAGE='QuantLib');
  
}

attr(`delete_CallabilitySchedule`, 'returnType') = 'void'
attr(`delete_CallabilitySchedule`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Callability_t_std__allocatorT_boost__shared_ptrT_Callability_t_t_t')
class(`delete_CallabilitySchedule`) = c("SWIGFunction", class('delete_CallabilitySchedule'))

# Start of accessor method for std::vector<(boost::shared_ptr<(Callability)>)>
setMethod('$', '_p_std__vectorT_boost__shared_ptrT_Callability_t_std__allocatorT_boost__shared_ptrT_Callability_t_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = CallabilitySchedule___nonzero__, '__len__' = CallabilitySchedule___len__, 'pop' = CallabilitySchedule_pop, '__getslice__' = CallabilitySchedule___getslice__, '__setslice__' = CallabilitySchedule___setslice__, '__delslice__' = CallabilitySchedule___delslice__, '__delitem__' = CallabilitySchedule___delitem__, '__getitem__' = CallabilitySchedule___getitem__, '__setitem__' = CallabilitySchedule___setitem__, 'append' = CallabilitySchedule_append, 'empty' = CallabilitySchedule_empty, 'size' = CallabilitySchedule_size, 'clear' = CallabilitySchedule_clear, 'swap' = CallabilitySchedule_swap, 'get_allocator' = CallabilitySchedule_get_allocator, 'pop_back' = CallabilitySchedule_pop_back, 'resize' = CallabilitySchedule_resize, 'push_back' = CallabilitySchedule_push_back, 'front' = CallabilitySchedule_front, 'back' = CallabilitySchedule_back, 'assign' = CallabilitySchedule_assign, 'reserve' = CallabilitySchedule_reserve, 'capacity' = CallabilitySchedule_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for std::vector<(boost::shared_ptr<(Callability)>)>
setMethod('delete', '_p_std__vectorT_boost__shared_ptrT_Callability_t_std__allocatorT_boost__shared_ptrT_Callability_t_t_t', function(obj) {delete_std__vectorT_boost__shared_ptrT_Callability_t_std__allocatorT_boost__shared_ptrT_Callability_t_t_t(obj)})
# Start of CapFloor_impliedVolatility

`CapFloor_impliedVolatility__SWIG_0` = function(self, price, curve, guess, accuracy, maxEvaluations, minVol, maxVol, .copy = FALSE)
{
  if(length(maxEvaluations) > 1) {
    warning("using only the first element of maxEvaluations");
  };
  
  
  
  ;.Call('R_swig_CapFloor_impliedVolatility__SWIG_0', self, price, curve, guess, accuracy, maxEvaluations, minVol, maxVol, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CapFloor_impliedVolatility__SWIG_0`, 'returnType') = 'numeric'
attr(`CapFloor_impliedVolatility__SWIG_0`, "inputTypes") = c('_p_CapFloorPtr', 'numeric', '_p_HandleT_YieldTermStructure_t', 'numeric', 'numeric', 'integer', 'numeric', 'numeric')
class(`CapFloor_impliedVolatility__SWIG_0`) = c("SWIGFunction", class('CapFloor_impliedVolatility__SWIG_0'))

# Start of CapFloor_impliedVolatility

`CapFloor_impliedVolatility__SWIG_1` = function(self, price, curve, guess, accuracy, maxEvaluations, minVol, .copy = FALSE)
{
  if(length(maxEvaluations) > 1) {
    warning("using only the first element of maxEvaluations");
  };
  
  
  ;.Call('R_swig_CapFloor_impliedVolatility__SWIG_1', self, price, curve, guess, accuracy, maxEvaluations, minVol, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CapFloor_impliedVolatility__SWIG_1`, 'returnType') = 'numeric'
attr(`CapFloor_impliedVolatility__SWIG_1`, "inputTypes") = c('_p_CapFloorPtr', 'numeric', '_p_HandleT_YieldTermStructure_t', 'numeric', 'numeric', 'integer', 'numeric')
class(`CapFloor_impliedVolatility__SWIG_1`) = c("SWIGFunction", class('CapFloor_impliedVolatility__SWIG_1'))

# Start of CapFloor_impliedVolatility

`CapFloor_impliedVolatility__SWIG_2` = function(self, price, curve, guess, accuracy, maxEvaluations, .copy = FALSE)
{
  if(length(maxEvaluations) > 1) {
    warning("using only the first element of maxEvaluations");
  };
  
  ;.Call('R_swig_CapFloor_impliedVolatility__SWIG_2', self, price, curve, guess, accuracy, maxEvaluations, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CapFloor_impliedVolatility__SWIG_2`, 'returnType') = 'numeric'
attr(`CapFloor_impliedVolatility__SWIG_2`, "inputTypes") = c('_p_CapFloorPtr', 'numeric', '_p_HandleT_YieldTermStructure_t', 'numeric', 'numeric', 'integer')
class(`CapFloor_impliedVolatility__SWIG_2`) = c("SWIGFunction", class('CapFloor_impliedVolatility__SWIG_2'))

# Start of CapFloor_impliedVolatility

`CapFloor_impliedVolatility__SWIG_3` = function(self, price, curve, guess, accuracy, .copy = FALSE)
{
  ;.Call('R_swig_CapFloor_impliedVolatility__SWIG_3', self, price, curve, guess, accuracy, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CapFloor_impliedVolatility__SWIG_3`, 'returnType') = 'numeric'
attr(`CapFloor_impliedVolatility__SWIG_3`, "inputTypes") = c('_p_CapFloorPtr', 'numeric', '_p_HandleT_YieldTermStructure_t', 'numeric', 'numeric')
class(`CapFloor_impliedVolatility__SWIG_3`) = c("SWIGFunction", class('CapFloor_impliedVolatility__SWIG_3'))

# Start of CapFloor_impliedVolatility

`CapFloor_impliedVolatility__SWIG_4` = function(self, price, curve, guess, .copy = FALSE)
{
  ;.Call('R_swig_CapFloor_impliedVolatility__SWIG_4', self, price, curve, guess, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CapFloor_impliedVolatility__SWIG_4`, 'returnType') = 'numeric'
attr(`CapFloor_impliedVolatility__SWIG_4`, "inputTypes") = c('_p_CapFloorPtr', 'numeric', '_p_HandleT_YieldTermStructure_t', 'numeric')
class(`CapFloor_impliedVolatility__SWIG_4`) = c("SWIGFunction", class('CapFloor_impliedVolatility__SWIG_4'))

`CapFloor_impliedVolatility` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 5
  if (argc == 4) {
    if (extends(argtypes[1], '_p_CapFloorPtr') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_HandleT_YieldTermStructure_t') && is.numeric(argv[[4]])) {
      f <- CapFloor_impliedVolatility__SWIG_4; 
    }
  } else if (argc == 5) {
    if (extends(argtypes[1], '_p_CapFloorPtr') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_HandleT_YieldTermStructure_t') && is.numeric(argv[[4]]) && is.numeric(argv[[5]])) {
      f <- CapFloor_impliedVolatility__SWIG_3; 
    }
  } else if (argc == 6) {
    if (extends(argtypes[1], '_p_CapFloorPtr') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_HandleT_YieldTermStructure_t') && is.numeric(argv[[4]]) && is.numeric(argv[[5]]) && (is.integer(argv[[6]]) || is.numeric(argv[[6]]))) {
      f <- CapFloor_impliedVolatility__SWIG_2; 
    }
  } else if (argc == 7) {
    if (extends(argtypes[1], '_p_CapFloorPtr') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_HandleT_YieldTermStructure_t') && is.numeric(argv[[4]]) && is.numeric(argv[[5]]) && (is.integer(argv[[6]]) || is.numeric(argv[[6]])) && is.numeric(argv[[7]])) {
      f <- CapFloor_impliedVolatility__SWIG_1; 
    }
  } else if (argc == 8) {
    if (extends(argtypes[1], '_p_CapFloorPtr') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_HandleT_YieldTermStructure_t') && is.numeric(argv[[4]]) && is.numeric(argv[[5]]) && (is.integer(argv[[6]]) || is.numeric(argv[[6]])) && is.numeric(argv[[7]]) && is.numeric(argv[[8]])) {
      f <- CapFloor_impliedVolatility__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for CapFloor_impliedVolatility with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of new_CapFloor

`CapFloor` = function()
{
  ;ans = .Call('R_swig_new_CapFloor', PACKAGE='QuantLib');
  class(ans) <- "_p_CapFloorPtr";
  
  reg.finalizer(ans, delete_CapFloor)
  ans
  
}

attr(`CapFloor`, 'returnType') = '_p_CapFloorPtr'
class(`CapFloor`) = c("SWIGFunction", class('CapFloor'))

# Start of delete_CapFloor

`delete_CapFloor` = function(self)
{
  ;.Call('R_swig_delete_CapFloor', self, PACKAGE='QuantLib');
  
}

attr(`delete_CapFloor`, 'returnType') = 'void'
attr(`delete_CapFloor`, "inputTypes") = c('_p_CapFloorPtr')
class(`delete_CapFloor`) = c("SWIGFunction", class('delete_CapFloor'))

# Start of accessor method for CapFloorPtr
setMethod('$', '_p_CapFloorPtr', function(x, name)

{
  accessorFuns = list('impliedVolatility' = CapFloor_impliedVolatility);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for CapFloorPtr
setMethod('delete', '_p_CapFloorPtr', function(obj) {delete_CapFloorPtr(obj)})
# Start of new_Cap

`Cap` = function(leg, capRates)
{
  ;ans = .Call('R_swig_new_Cap', leg, capRates, PACKAGE='QuantLib');
  class(ans) <- "_p_CapPtr";
  
  reg.finalizer(ans, delete_Cap)
  ans
  
}

attr(`Cap`, 'returnType') = '_p_CapPtr'
attr(`Cap`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`Cap`) = c("SWIGFunction", class('Cap'))

# Start of delete_Cap

`delete_Cap` = function(self)
{
  ;.Call('R_swig_delete_Cap', self, PACKAGE='QuantLib');
  
}

attr(`delete_Cap`, 'returnType') = 'void'
attr(`delete_Cap`, "inputTypes") = c('_p_CapPtr')
class(`delete_Cap`) = c("SWIGFunction", class('delete_Cap'))

setMethod('delete', '_p_CapPtr', function(obj) {delete_CapPtr(obj)})
# Start of new_Floor

`Floor` = function(leg, floorRates)
{
  ;ans = .Call('R_swig_new_Floor', leg, floorRates, PACKAGE='QuantLib');
  class(ans) <- "_p_FloorPtr";
  
  reg.finalizer(ans, delete_Floor)
  ans
  
}

attr(`Floor`, 'returnType') = '_p_FloorPtr'
attr(`Floor`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`Floor`) = c("SWIGFunction", class('Floor'))

# Start of delete_Floor

`delete_Floor` = function(self)
{
  ;.Call('R_swig_delete_Floor', self, PACKAGE='QuantLib');
  
}

attr(`delete_Floor`, 'returnType') = 'void'
attr(`delete_Floor`, "inputTypes") = c('_p_FloorPtr')
class(`delete_Floor`) = c("SWIGFunction", class('delete_Floor'))

setMethod('delete', '_p_FloorPtr', function(obj) {delete_FloorPtr(obj)})
# Start of new_Collar

`Collar` = function(leg, capRates, floorRates)
{
  ;ans = .Call('R_swig_new_Collar', leg, capRates, floorRates, PACKAGE='QuantLib');
  class(ans) <- "_p_CollarPtr";
  
  reg.finalizer(ans, delete_Collar)
  ans
  
}

attr(`Collar`, 'returnType') = '_p_CollarPtr'
attr(`Collar`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`Collar`) = c("SWIGFunction", class('Collar'))

# Start of delete_Collar

`delete_Collar` = function(self)
{
  ;.Call('R_swig_delete_Collar', self, PACKAGE='QuantLib');
  
}

attr(`delete_Collar`, 'returnType') = 'void'
attr(`delete_Collar`, "inputTypes") = c('_p_CollarPtr')
class(`delete_Collar`) = c("SWIGFunction", class('delete_Collar'))

setMethod('delete', '_p_CollarPtr', function(obj) {delete_CollarPtr(obj)})
# Start of new_BlackCapFloorEngine

`BlackCapFloorEngine__SWIG_0` = function(termStructure, vol)
{
  ;ans = .Call('R_swig_new_BlackCapFloorEngine__SWIG_0', termStructure, vol, PACKAGE='QuantLib');
  class(ans) <- "_p_BlackCapFloorEnginePtr";
  
  reg.finalizer(ans, delete_BlackCapFloorEngine)
  ans
  
}

attr(`BlackCapFloorEngine__SWIG_0`, 'returnType') = '_p_BlackCapFloorEnginePtr'
attr(`BlackCapFloorEngine__SWIG_0`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t', '_p_HandleT_Quote_t')
class(`BlackCapFloorEngine__SWIG_0`) = c("SWIGFunction", class('BlackCapFloorEngine__SWIG_0'))

# Start of new_BlackCapFloorEngine

`BlackCapFloorEngine__SWIG_1` = function(termStructure, vol)
{
  ;ans = .Call('R_swig_new_BlackCapFloorEngine__SWIG_1', termStructure, vol, PACKAGE='QuantLib');
  class(ans) <- "_p_BlackCapFloorEnginePtr";
  
  reg.finalizer(ans, delete_BlackCapFloorEngine)
  ans
  
}

attr(`BlackCapFloorEngine__SWIG_1`, 'returnType') = '_p_BlackCapFloorEnginePtr'
attr(`BlackCapFloorEngine__SWIG_1`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t', '_p_HandleT_OptionletVolatilityStructure_t')
class(`BlackCapFloorEngine__SWIG_1`) = c("SWIGFunction", class('BlackCapFloorEngine__SWIG_1'))

`BlackCapFloorEngine` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t') && extends(argtypes[2], '_p_HandleT_Quote_t')) {
      f <- BlackCapFloorEngine__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t') && extends(argtypes[2], '_p_HandleT_OptionletVolatilityStructure_t')) {
      f <- BlackCapFloorEngine__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for BlackCapFloorEngine with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_BlackCapFloorEngine

`delete_BlackCapFloorEngine` = function(self)
{
  ;.Call('R_swig_delete_BlackCapFloorEngine', self, PACKAGE='QuantLib');
  
}

attr(`delete_BlackCapFloorEngine`, 'returnType') = 'void'
attr(`delete_BlackCapFloorEngine`, "inputTypes") = c('_p_BlackCapFloorEnginePtr')
class(`delete_BlackCapFloorEngine`) = c("SWIGFunction", class('delete_BlackCapFloorEngine'))

setMethod('delete', '_p_BlackCapFloorEnginePtr', function(obj) {delete_BlackCapFloorEnginePtr(obj)})
# Start of Dividend___deref__

`Dividend___deref__` = function(self)
{
  ;ans = .Call('R_swig_Dividend___deref__', self, PACKAGE='QuantLib');
  class(ans) <- "_p_Dividend";
  
  ans
  
}

attr(`Dividend___deref__`, 'returnType') = '_p_Dividend'
attr(`Dividend___deref__`, "inputTypes") = c('_p_boost__shared_ptrT_Dividend_t')
class(`Dividend___deref__`) = c("SWIGFunction", class('Dividend___deref__'))

# Start of Dividend_isNull

`Dividend_isNull` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Dividend_isNull', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Dividend_isNull`, 'returnType') = 'logical'
attr(`Dividend_isNull`, "inputTypes") = c('_p_boost__shared_ptrT_Dividend_t')
class(`Dividend_isNull`) = c("SWIGFunction", class('Dividend_isNull'))

# Start of new_Dividend

`Dividend` = function()
{
  ;ans = .Call('R_swig_new_Dividend', PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_Dividend_t";
  
  reg.finalizer(ans, delete_Dividend)
  ans
  
}

attr(`Dividend`, 'returnType') = '_p_boost__shared_ptrT_Dividend_t'
class(`Dividend`) = c("SWIGFunction", class('Dividend'))

# Start of delete_Dividend

`delete_Dividend` = function(self)
{
  ;.Call('R_swig_delete_Dividend', self, PACKAGE='QuantLib');
  
}

attr(`delete_Dividend`, 'returnType') = 'void'
attr(`delete_Dividend`, "inputTypes") = c('_p_boost__shared_ptrT_Dividend_t')
class(`delete_Dividend`) = c("SWIGFunction", class('delete_Dividend'))

# Start of Dividend_amount

`Dividend_amount` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Dividend_amount', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Dividend_amount`, 'returnType') = 'numeric'
attr(`Dividend_amount`, "inputTypes") = c('_p_boost__shared_ptrT_Dividend_t')
class(`Dividend_amount`) = c("SWIGFunction", class('Dividend_amount'))

# Start of Dividend_date

`Dividend_date` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_Dividend_date', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`Dividend_date`, 'returnType') = '_p_Date'
attr(`Dividend_date`, "inputTypes") = c('_p_boost__shared_ptrT_Dividend_t')
class(`Dividend_date`) = c("SWIGFunction", class('Dividend_date'))

# Start of accessor method for boost::shared_ptr<(Dividend)>
setMethod('$', '_p_boost__shared_ptrT_Dividend_t', function(x, name)

{
  accessorFuns = list('__deref__' = Dividend___deref__, 'isNull' = Dividend_isNull, 'amount' = Dividend_amount, 'date' = Dividend_date);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for boost::shared_ptr<(Dividend)>
setMethod('delete', '_p_boost__shared_ptrT_Dividend_t', function(obj) {delete_boost__shared_ptrT_Dividend_t(obj)})
# Start of new_FixedDividend

`FixedDividend` = function(amount, date)
{
  ;ans = .Call('R_swig_new_FixedDividend', amount, date, PACKAGE='QuantLib');
  class(ans) <- "_p_FixedDividendPtr";
  
  reg.finalizer(ans, delete_FixedDividend)
  ans
  
}

attr(`FixedDividend`, 'returnType') = '_p_FixedDividendPtr'
attr(`FixedDividend`, "inputTypes") = c('numeric', '_p_Date')
class(`FixedDividend`) = c("SWIGFunction", class('FixedDividend'))

# Start of delete_FixedDividend

`delete_FixedDividend` = function(self)
{
  ;.Call('R_swig_delete_FixedDividend', self, PACKAGE='QuantLib');
  
}

attr(`delete_FixedDividend`, 'returnType') = 'void'
attr(`delete_FixedDividend`, "inputTypes") = c('_p_FixedDividendPtr')
class(`delete_FixedDividend`) = c("SWIGFunction", class('delete_FixedDividend'))

setMethod('delete', '_p_FixedDividendPtr', function(obj) {delete_FixedDividendPtr(obj)})
# Start of new_FractionalDividend

`FractionalDividend` = function(rate, date)
{
  ;ans = .Call('R_swig_new_FractionalDividend', rate, date, PACKAGE='QuantLib');
  class(ans) <- "_p_FractionalDividendPtr";
  
  reg.finalizer(ans, delete_FractionalDividend)
  ans
  
}

attr(`FractionalDividend`, 'returnType') = '_p_FractionalDividendPtr'
attr(`FractionalDividend`, "inputTypes") = c('numeric', '_p_Date')
class(`FractionalDividend`) = c("SWIGFunction", class('FractionalDividend'))

# Start of delete_FractionalDividend

`delete_FractionalDividend` = function(self)
{
  ;.Call('R_swig_delete_FractionalDividend', self, PACKAGE='QuantLib');
  
}

attr(`delete_FractionalDividend`, 'returnType') = 'void'
attr(`delete_FractionalDividend`, "inputTypes") = c('_p_FractionalDividendPtr')
class(`delete_FractionalDividend`) = c("SWIGFunction", class('delete_FractionalDividend'))

setMethod('delete', '_p_FractionalDividendPtr', function(obj) {delete_FractionalDividendPtr(obj)})
# Start of DividendSchedule___nonzero__

`DividendSchedule___nonzero__` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_DividendSchedule___nonzero__', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DividendSchedule___nonzero__`, 'returnType') = 'logical'
attr(`DividendSchedule___nonzero__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Dividend_t_std__allocatorT_boost__shared_ptrT_Dividend_t_t_t')
class(`DividendSchedule___nonzero__`) = c("SWIGFunction", class('DividendSchedule___nonzero__'))

# Start of DividendSchedule___len__

`DividendSchedule___len__` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_DividendSchedule___len__', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`DividendSchedule___len__`, 'returnType') = 'integer'
attr(`DividendSchedule___len__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Dividend_t_std__allocatorT_boost__shared_ptrT_Dividend_t_t_t')
class(`DividendSchedule___len__`) = c("SWIGFunction", class('DividendSchedule___len__'))

# Start of DividendSchedule_pop

`DividendSchedule_pop` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_DividendSchedule_pop', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_Dividend_t";
  
  ans
  
}

attr(`DividendSchedule_pop`, 'returnType') = '_p_boost__shared_ptrT_Dividend_t'
attr(`DividendSchedule_pop`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Dividend_t_std__allocatorT_boost__shared_ptrT_Dividend_t_t_t')
class(`DividendSchedule_pop`) = c("SWIGFunction", class('DividendSchedule_pop'))

# Start of DividendSchedule___getslice__

`DividendSchedule___getslice__` = function(self, i, j)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;ans = .Call('R_swig_DividendSchedule___getslice__', self, i, j, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_Dividend_t_std__allocatorT_boost__shared_ptrT_Dividend_t_t_t";
  
  ans
  
}

attr(`DividendSchedule___getslice__`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_Dividend_t_std__allocatorT_boost__shared_ptrT_Dividend_t_t_t'
attr(`DividendSchedule___getslice__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Dividend_t_std__allocatorT_boost__shared_ptrT_Dividend_t_t_t', 'integer', 'integer')
class(`DividendSchedule___getslice__`) = c("SWIGFunction", class('DividendSchedule___getslice__'))

# Start of DividendSchedule___setslice__

`DividendSchedule___setslice__` = function(self, i, j, v)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  
  ;.Call('R_swig_DividendSchedule___setslice__', self, i, j, v, PACKAGE='QuantLib');
  
}

attr(`DividendSchedule___setslice__`, 'returnType') = 'void'
attr(`DividendSchedule___setslice__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Dividend_t_std__allocatorT_boost__shared_ptrT_Dividend_t_t_t', 'integer', 'integer', '_p_std__vectorT_boost__shared_ptrT_Dividend_t_std__allocatorT_boost__shared_ptrT_Dividend_t_t_t')
class(`DividendSchedule___setslice__`) = c("SWIGFunction", class('DividendSchedule___setslice__'))

# Start of DividendSchedule___delslice__

`DividendSchedule___delslice__` = function(self, i, j)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_DividendSchedule___delslice__', self, i, j, PACKAGE='QuantLib');
  
}

attr(`DividendSchedule___delslice__`, 'returnType') = 'void'
attr(`DividendSchedule___delslice__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Dividend_t_std__allocatorT_boost__shared_ptrT_Dividend_t_t_t', 'integer', 'integer')
class(`DividendSchedule___delslice__`) = c("SWIGFunction", class('DividendSchedule___delslice__'))

# Start of DividendSchedule___delitem__

`DividendSchedule___delitem__` = function(self, i)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_DividendSchedule___delitem__', self, i, PACKAGE='QuantLib');
  
}

attr(`DividendSchedule___delitem__`, 'returnType') = 'void'
attr(`DividendSchedule___delitem__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Dividend_t_std__allocatorT_boost__shared_ptrT_Dividend_t_t_t', 'integer')
class(`DividendSchedule___delitem__`) = c("SWIGFunction", class('DividendSchedule___delitem__'))

# Start of DividendSchedule___getitem__

`DividendSchedule___getitem__` = function(self, i, .copy = FALSE)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;ans = .Call('R_swig_DividendSchedule___getitem__', self, i, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_Dividend_t";
  
  ans
  
}

attr(`DividendSchedule___getitem__`, 'returnType') = '_p_boost__shared_ptrT_Dividend_t'
attr(`DividendSchedule___getitem__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Dividend_t_std__allocatorT_boost__shared_ptrT_Dividend_t_t_t', 'integer')
class(`DividendSchedule___getitem__`) = c("SWIGFunction", class('DividendSchedule___getitem__'))

# Start of DividendSchedule___setitem__

`DividendSchedule___setitem__` = function(self, i, x)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  ;.Call('R_swig_DividendSchedule___setitem__', self, i, x, PACKAGE='QuantLib');
  
}

attr(`DividendSchedule___setitem__`, 'returnType') = 'void'
attr(`DividendSchedule___setitem__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Dividend_t_std__allocatorT_boost__shared_ptrT_Dividend_t_t_t', 'integer', '_p_boost__shared_ptrT_Dividend_t')
class(`DividendSchedule___setitem__`) = c("SWIGFunction", class('DividendSchedule___setitem__'))

# Start of DividendSchedule_append

`DividendSchedule_append` = function(self, x)
{
  ;.Call('R_swig_DividendSchedule_append', self, x, PACKAGE='QuantLib');
  
}

attr(`DividendSchedule_append`, 'returnType') = 'void'
attr(`DividendSchedule_append`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Dividend_t_std__allocatorT_boost__shared_ptrT_Dividend_t_t_t', '_p_boost__shared_ptrT_Dividend_t')
class(`DividendSchedule_append`) = c("SWIGFunction", class('DividendSchedule_append'))

# Start of new_DividendSchedule

`DividendSchedule__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_DividendSchedule__SWIG_0', PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_Dividend_t_std__allocatorT_boost__shared_ptrT_Dividend_t_t_t";
  
  reg.finalizer(ans, delete_DividendSchedule)
  ans
  
}

attr(`DividendSchedule__SWIG_0`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_Dividend_t_std__allocatorT_boost__shared_ptrT_Dividend_t_t_t'
class(`DividendSchedule__SWIG_0`) = c("SWIGFunction", class('DividendSchedule__SWIG_0'))

# Start of new_DividendSchedule

`DividendSchedule__SWIG_1` = function(s_arg1)
{
  ;ans = .Call('R_swig_new_DividendSchedule__SWIG_1', s_arg1, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_Dividend_t_std__allocatorT_boost__shared_ptrT_Dividend_t_t_t";
  
  reg.finalizer(ans, delete_DividendSchedule)
  ans
  
}

attr(`DividendSchedule__SWIG_1`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_Dividend_t_std__allocatorT_boost__shared_ptrT_Dividend_t_t_t'
attr(`DividendSchedule__SWIG_1`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Dividend_t_std__allocatorT_boost__shared_ptrT_Dividend_t_t_t')
class(`DividendSchedule__SWIG_1`) = c("SWIGFunction", class('DividendSchedule__SWIG_1'))

# Start of DividendSchedule_empty

`DividendSchedule_empty` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_DividendSchedule_empty', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DividendSchedule_empty`, 'returnType') = 'logical'
attr(`DividendSchedule_empty`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Dividend_t_std__allocatorT_boost__shared_ptrT_Dividend_t_t_t')
class(`DividendSchedule_empty`) = c("SWIGFunction", class('DividendSchedule_empty'))

# Start of DividendSchedule_size

`DividendSchedule_size` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_DividendSchedule_size', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`DividendSchedule_size`, 'returnType') = 'integer'
attr(`DividendSchedule_size`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Dividend_t_std__allocatorT_boost__shared_ptrT_Dividend_t_t_t')
class(`DividendSchedule_size`) = c("SWIGFunction", class('DividendSchedule_size'))

# Start of DividendSchedule_clear

`DividendSchedule_clear` = function(self)
{
  ;.Call('R_swig_DividendSchedule_clear', self, PACKAGE='QuantLib');
  
}

attr(`DividendSchedule_clear`, 'returnType') = 'void'
attr(`DividendSchedule_clear`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Dividend_t_std__allocatorT_boost__shared_ptrT_Dividend_t_t_t')
class(`DividendSchedule_clear`) = c("SWIGFunction", class('DividendSchedule_clear'))

# Start of DividendSchedule_swap

`DividendSchedule_swap` = function(self, v)
{
  ;.Call('R_swig_DividendSchedule_swap', self, v, PACKAGE='QuantLib');
  
}

attr(`DividendSchedule_swap`, 'returnType') = 'void'
attr(`DividendSchedule_swap`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Dividend_t_std__allocatorT_boost__shared_ptrT_Dividend_t_t_t', '_p_std__vectorT_boost__shared_ptrT_Dividend_t_std__allocatorT_boost__shared_ptrT_Dividend_t_t_t')
class(`DividendSchedule_swap`) = c("SWIGFunction", class('DividendSchedule_swap'))

# Start of DividendSchedule_get_allocator

`DividendSchedule_get_allocator` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_DividendSchedule_get_allocator', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__allocatorT_boost__shared_ptrT_Dividend_t_t";
  
  ans
  
}

attr(`DividendSchedule_get_allocator`, 'returnType') = '_p_std__allocatorT_boost__shared_ptrT_Dividend_t_t'
attr(`DividendSchedule_get_allocator`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Dividend_t_std__allocatorT_boost__shared_ptrT_Dividend_t_t_t')
class(`DividendSchedule_get_allocator`) = c("SWIGFunction", class('DividendSchedule_get_allocator'))

# Start of new_DividendSchedule

`DividendSchedule__SWIG_2` = function(size)
{
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_new_DividendSchedule__SWIG_2', size, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_Dividend_t_std__allocatorT_boost__shared_ptrT_Dividend_t_t_t";
  
  reg.finalizer(ans, delete_DividendSchedule)
  ans
  
}

attr(`DividendSchedule__SWIG_2`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_Dividend_t_std__allocatorT_boost__shared_ptrT_Dividend_t_t_t'
attr(`DividendSchedule__SWIG_2`, "inputTypes") = c('integer')
class(`DividendSchedule__SWIG_2`) = c("SWIGFunction", class('DividendSchedule__SWIG_2'))

# Start of DividendSchedule_pop_back

`DividendSchedule_pop_back` = function(self)
{
  ;.Call('R_swig_DividendSchedule_pop_back', self, PACKAGE='QuantLib');
  
}

attr(`DividendSchedule_pop_back`, 'returnType') = 'void'
attr(`DividendSchedule_pop_back`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Dividend_t_std__allocatorT_boost__shared_ptrT_Dividend_t_t_t')
class(`DividendSchedule_pop_back`) = c("SWIGFunction", class('DividendSchedule_pop_back'))

# Start of DividendSchedule_resize

`DividendSchedule_resize__SWIG_0` = function(self, new_size)
{
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_DividendSchedule_resize__SWIG_0', self, new_size, PACKAGE='QuantLib');
  
}

attr(`DividendSchedule_resize__SWIG_0`, 'returnType') = 'void'
attr(`DividendSchedule_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Dividend_t_std__allocatorT_boost__shared_ptrT_Dividend_t_t_t', 'integer')
class(`DividendSchedule_resize__SWIG_0`) = c("SWIGFunction", class('DividendSchedule_resize__SWIG_0'))

# Start of new_DividendSchedule

`DividendSchedule__SWIG_3` = function(size, value)
{
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  
  ;ans = .Call('R_swig_new_DividendSchedule__SWIG_3', size, value, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_Dividend_t_std__allocatorT_boost__shared_ptrT_Dividend_t_t_t";
  
  reg.finalizer(ans, delete_DividendSchedule)
  ans
  
}

attr(`DividendSchedule__SWIG_3`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_Dividend_t_std__allocatorT_boost__shared_ptrT_Dividend_t_t_t'
attr(`DividendSchedule__SWIG_3`, "inputTypes") = c('integer', '_p_boost__shared_ptrT_Dividend_t')
class(`DividendSchedule__SWIG_3`) = c("SWIGFunction", class('DividendSchedule__SWIG_3'))

`DividendSchedule` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- DividendSchedule__SWIG_0; 
  } else if (argc == 1) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]]))) {
      f <- DividendSchedule__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_Dividend_t_std__allocatorT_boost__shared_ptrT_Dividend_t_t_t')) {
      f <- DividendSchedule__SWIG_1; 
    }
  } else if (argc == 2) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && extends(argtypes[2], '_p_boost__shared_ptrT_Dividend_t')) {
      f <- DividendSchedule__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for DividendSchedule with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of DividendSchedule_push_back

`DividendSchedule_push_back` = function(self, x)
{
  ;.Call('R_swig_DividendSchedule_push_back', self, x, PACKAGE='QuantLib');
  
}

attr(`DividendSchedule_push_back`, 'returnType') = 'void'
attr(`DividendSchedule_push_back`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Dividend_t_std__allocatorT_boost__shared_ptrT_Dividend_t_t_t', '_p_boost__shared_ptrT_Dividend_t')
class(`DividendSchedule_push_back`) = c("SWIGFunction", class('DividendSchedule_push_back'))

# Start of DividendSchedule_front

`DividendSchedule_front` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_DividendSchedule_front', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_Dividend_t";
  
  ans
  
}

attr(`DividendSchedule_front`, 'returnType') = '_p_boost__shared_ptrT_Dividend_t'
attr(`DividendSchedule_front`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Dividend_t_std__allocatorT_boost__shared_ptrT_Dividend_t_t_t')
class(`DividendSchedule_front`) = c("SWIGFunction", class('DividendSchedule_front'))

# Start of DividendSchedule_back

`DividendSchedule_back` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_DividendSchedule_back', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_Dividend_t";
  
  ans
  
}

attr(`DividendSchedule_back`, 'returnType') = '_p_boost__shared_ptrT_Dividend_t'
attr(`DividendSchedule_back`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Dividend_t_std__allocatorT_boost__shared_ptrT_Dividend_t_t_t')
class(`DividendSchedule_back`) = c("SWIGFunction", class('DividendSchedule_back'))

# Start of DividendSchedule_assign

`DividendSchedule_assign` = function(self, n, x)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  
  ;.Call('R_swig_DividendSchedule_assign', self, n, x, PACKAGE='QuantLib');
  
}

attr(`DividendSchedule_assign`, 'returnType') = 'void'
attr(`DividendSchedule_assign`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Dividend_t_std__allocatorT_boost__shared_ptrT_Dividend_t_t_t', 'integer', '_p_boost__shared_ptrT_Dividend_t')
class(`DividendSchedule_assign`) = c("SWIGFunction", class('DividendSchedule_assign'))

# Start of DividendSchedule_resize

`DividendSchedule_resize__SWIG_1` = function(self, new_size, x)
{
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  
  ;.Call('R_swig_DividendSchedule_resize__SWIG_1', self, new_size, x, PACKAGE='QuantLib');
  
}

attr(`DividendSchedule_resize__SWIG_1`, 'returnType') = 'void'
attr(`DividendSchedule_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Dividend_t_std__allocatorT_boost__shared_ptrT_Dividend_t_t_t', 'integer', '_p_boost__shared_ptrT_Dividend_t')
class(`DividendSchedule_resize__SWIG_1`) = c("SWIGFunction", class('DividendSchedule_resize__SWIG_1'))

`DividendSchedule_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_Dividend_t_std__allocatorT_boost__shared_ptrT_Dividend_t_t_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]]))) {
      f <- DividendSchedule_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_Dividend_t_std__allocatorT_boost__shared_ptrT_Dividend_t_t_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && extends(argtypes[3], '_p_boost__shared_ptrT_Dividend_t')) {
      f <- DividendSchedule_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for DividendSchedule_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of DividendSchedule_reserve

`DividendSchedule_reserve` = function(self, n)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_DividendSchedule_reserve', self, n, PACKAGE='QuantLib');
  
}

attr(`DividendSchedule_reserve`, 'returnType') = 'void'
attr(`DividendSchedule_reserve`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Dividend_t_std__allocatorT_boost__shared_ptrT_Dividend_t_t_t', 'integer')
class(`DividendSchedule_reserve`) = c("SWIGFunction", class('DividendSchedule_reserve'))

# Start of DividendSchedule_capacity

`DividendSchedule_capacity` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_DividendSchedule_capacity', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`DividendSchedule_capacity`, 'returnType') = 'integer'
attr(`DividendSchedule_capacity`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Dividend_t_std__allocatorT_boost__shared_ptrT_Dividend_t_t_t')
class(`DividendSchedule_capacity`) = c("SWIGFunction", class('DividendSchedule_capacity'))

# Start of delete_DividendSchedule

`delete_DividendSchedule` = function(self)
{
  ;.Call('R_swig_delete_DividendSchedule', self, PACKAGE='QuantLib');
  
}

attr(`delete_DividendSchedule`, 'returnType') = 'void'
attr(`delete_DividendSchedule`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_Dividend_t_std__allocatorT_boost__shared_ptrT_Dividend_t_t_t')
class(`delete_DividendSchedule`) = c("SWIGFunction", class('delete_DividendSchedule'))

# Start of accessor method for std::vector<(boost::shared_ptr<(Dividend)>)>
setMethod('$', '_p_std__vectorT_boost__shared_ptrT_Dividend_t_std__allocatorT_boost__shared_ptrT_Dividend_t_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = DividendSchedule___nonzero__, '__len__' = DividendSchedule___len__, 'pop' = DividendSchedule_pop, '__getslice__' = DividendSchedule___getslice__, '__setslice__' = DividendSchedule___setslice__, '__delslice__' = DividendSchedule___delslice__, '__delitem__' = DividendSchedule___delitem__, '__getitem__' = DividendSchedule___getitem__, '__setitem__' = DividendSchedule___setitem__, 'append' = DividendSchedule_append, 'empty' = DividendSchedule_empty, 'size' = DividendSchedule_size, 'clear' = DividendSchedule_clear, 'swap' = DividendSchedule_swap, 'get_allocator' = DividendSchedule_get_allocator, 'pop_back' = DividendSchedule_pop_back, 'resize' = DividendSchedule_resize, 'push_back' = DividendSchedule_push_back, 'front' = DividendSchedule_front, 'back' = DividendSchedule_back, 'assign' = DividendSchedule_assign, 'reserve' = DividendSchedule_reserve, 'capacity' = DividendSchedule_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for std::vector<(boost::shared_ptr<(Dividend)>)>
setMethod('delete', '_p_std__vectorT_boost__shared_ptrT_Dividend_t_std__allocatorT_boost__shared_ptrT_Dividend_t_t_t', function(obj) {delete_std__vectorT_boost__shared_ptrT_Dividend_t_std__allocatorT_boost__shared_ptrT_Dividend_t_t_t(obj)})
# Start of new_ConvertibleZeroCouponBond

`ConvertibleZeroCouponBond__SWIG_0` = function(exercise, conversionRatio, dividends, callability, creditSpread, issueDate, settlementDays, dayCounter, schedule, redemption)
{
  settlementDays = as.integer(settlementDays); 
  
  if(length(settlementDays) > 1) {
    warning("using only the first element of settlementDays");
  };
  
  
  
  
  ;ans = .Call('R_swig_new_ConvertibleZeroCouponBond__SWIG_0', exercise, conversionRatio, dividends, callability, creditSpread, issueDate, settlementDays, dayCounter, schedule, redemption, PACKAGE='QuantLib');
  class(ans) <- "_p_ConvertibleZeroCouponBondPtr";
  
  reg.finalizer(ans, delete_ConvertibleZeroCouponBond)
  ans
  
}

attr(`ConvertibleZeroCouponBond__SWIG_0`, 'returnType') = '_p_ConvertibleZeroCouponBondPtr'
attr(`ConvertibleZeroCouponBond__SWIG_0`, "inputTypes") = c('_p_boost__shared_ptrT_Exercise_t', 'numeric', '_p_std__vectorT_boost__shared_ptrT_Dividend_t_std__allocatorT_boost__shared_ptrT_Dividend_t_t_t', '_p_std__vectorT_boost__shared_ptrT_Callability_t_std__allocatorT_boost__shared_ptrT_Callability_t_t_t', '_p_HandleT_Quote_t', '_p_Date', 'integer', '_p_DayCounter', '_p_Schedule', 'numeric')
class(`ConvertibleZeroCouponBond__SWIG_0`) = c("SWIGFunction", class('ConvertibleZeroCouponBond__SWIG_0'))

# Start of new_ConvertibleZeroCouponBond

`ConvertibleZeroCouponBond__SWIG_1` = function(exercise, conversionRatio, dividends, callability, creditSpread, issueDate, settlementDays, dayCounter, schedule)
{
  settlementDays = as.integer(settlementDays); 
  
  if(length(settlementDays) > 1) {
    warning("using only the first element of settlementDays");
  };
  
  
  
  ;ans = .Call('R_swig_new_ConvertibleZeroCouponBond__SWIG_1', exercise, conversionRatio, dividends, callability, creditSpread, issueDate, settlementDays, dayCounter, schedule, PACKAGE='QuantLib');
  class(ans) <- "_p_ConvertibleZeroCouponBondPtr";
  
  reg.finalizer(ans, delete_ConvertibleZeroCouponBond)
  ans
  
}

attr(`ConvertibleZeroCouponBond__SWIG_1`, 'returnType') = '_p_ConvertibleZeroCouponBondPtr'
attr(`ConvertibleZeroCouponBond__SWIG_1`, "inputTypes") = c('_p_boost__shared_ptrT_Exercise_t', 'numeric', '_p_std__vectorT_boost__shared_ptrT_Dividend_t_std__allocatorT_boost__shared_ptrT_Dividend_t_t_t', '_p_std__vectorT_boost__shared_ptrT_Callability_t_std__allocatorT_boost__shared_ptrT_Callability_t_t_t', '_p_HandleT_Quote_t', '_p_Date', 'integer', '_p_DayCounter', '_p_Schedule')
class(`ConvertibleZeroCouponBond__SWIG_1`) = c("SWIGFunction", class('ConvertibleZeroCouponBond__SWIG_1'))

`ConvertibleZeroCouponBond` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 9) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_Exercise_t') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_std__vectorT_boost__shared_ptrT_Dividend_t_std__allocatorT_boost__shared_ptrT_Dividend_t_t_t') && extends(argtypes[4], '_p_std__vectorT_boost__shared_ptrT_Callability_t_std__allocatorT_boost__shared_ptrT_Callability_t_t_t') && extends(argtypes[5], '_p_HandleT_Quote_t') && extends(argtypes[6], '_p_Date') && (is.integer(argv[[7]]) || is.numeric(argv[[7]])) && extends(argtypes[8], '_p_DayCounter') && extends(argtypes[9], '_p_Schedule')) {
      f <- ConvertibleZeroCouponBond__SWIG_1; 
    }
  } else if (argc == 10) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_Exercise_t') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_std__vectorT_boost__shared_ptrT_Dividend_t_std__allocatorT_boost__shared_ptrT_Dividend_t_t_t') && extends(argtypes[4], '_p_std__vectorT_boost__shared_ptrT_Callability_t_std__allocatorT_boost__shared_ptrT_Callability_t_t_t') && extends(argtypes[5], '_p_HandleT_Quote_t') && extends(argtypes[6], '_p_Date') && (is.integer(argv[[7]]) || is.numeric(argv[[7]])) && extends(argtypes[8], '_p_DayCounter') && extends(argtypes[9], '_p_Schedule') && is.numeric(argv[[10]])) {
      f <- ConvertibleZeroCouponBond__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for ConvertibleZeroCouponBond with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_ConvertibleZeroCouponBond

`delete_ConvertibleZeroCouponBond` = function(self)
{
  ;.Call('R_swig_delete_ConvertibleZeroCouponBond', self, PACKAGE='QuantLib');
  
}

attr(`delete_ConvertibleZeroCouponBond`, 'returnType') = 'void'
attr(`delete_ConvertibleZeroCouponBond`, "inputTypes") = c('_p_ConvertibleZeroCouponBondPtr')
class(`delete_ConvertibleZeroCouponBond`) = c("SWIGFunction", class('delete_ConvertibleZeroCouponBond'))

setMethod('delete', '_p_ConvertibleZeroCouponBondPtr', function(obj) {delete_ConvertibleZeroCouponBondPtr(obj)})
# Start of new_ConvertibleFixedCouponBond

`ConvertibleFixedCouponBond__SWIG_0` = function(exercise, conversionRatio, dividends, callability, creditSpread, issueDate, settlementDays, coupons, dayCounter, schedule, redemption)
{
  settlementDays = as.integer(settlementDays); 
  
  if(length(settlementDays) > 1) {
    warning("using only the first element of settlementDays");
  };
  
  
  
  
  
  ;ans = .Call('R_swig_new_ConvertibleFixedCouponBond__SWIG_0', exercise, conversionRatio, dividends, callability, creditSpread, issueDate, settlementDays, coupons, dayCounter, schedule, redemption, PACKAGE='QuantLib');
  class(ans) <- "_p_ConvertibleFixedCouponBondPtr";
  
  reg.finalizer(ans, delete_ConvertibleFixedCouponBond)
  ans
  
}

attr(`ConvertibleFixedCouponBond__SWIG_0`, 'returnType') = '_p_ConvertibleFixedCouponBondPtr'
attr(`ConvertibleFixedCouponBond__SWIG_0`, "inputTypes") = c('_p_boost__shared_ptrT_Exercise_t', 'numeric', '_p_std__vectorT_boost__shared_ptrT_Dividend_t_std__allocatorT_boost__shared_ptrT_Dividend_t_t_t', '_p_std__vectorT_boost__shared_ptrT_Callability_t_std__allocatorT_boost__shared_ptrT_Callability_t_t_t', '_p_HandleT_Quote_t', '_p_Date', 'integer', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_DayCounter', '_p_Schedule', 'numeric')
class(`ConvertibleFixedCouponBond__SWIG_0`) = c("SWIGFunction", class('ConvertibleFixedCouponBond__SWIG_0'))

# Start of new_ConvertibleFixedCouponBond

`ConvertibleFixedCouponBond__SWIG_1` = function(exercise, conversionRatio, dividends, callability, creditSpread, issueDate, settlementDays, coupons, dayCounter, schedule)
{
  settlementDays = as.integer(settlementDays); 
  
  if(length(settlementDays) > 1) {
    warning("using only the first element of settlementDays");
  };
  
  
  
  
  ;ans = .Call('R_swig_new_ConvertibleFixedCouponBond__SWIG_1', exercise, conversionRatio, dividends, callability, creditSpread, issueDate, settlementDays, coupons, dayCounter, schedule, PACKAGE='QuantLib');
  class(ans) <- "_p_ConvertibleFixedCouponBondPtr";
  
  reg.finalizer(ans, delete_ConvertibleFixedCouponBond)
  ans
  
}

attr(`ConvertibleFixedCouponBond__SWIG_1`, 'returnType') = '_p_ConvertibleFixedCouponBondPtr'
attr(`ConvertibleFixedCouponBond__SWIG_1`, "inputTypes") = c('_p_boost__shared_ptrT_Exercise_t', 'numeric', '_p_std__vectorT_boost__shared_ptrT_Dividend_t_std__allocatorT_boost__shared_ptrT_Dividend_t_t_t', '_p_std__vectorT_boost__shared_ptrT_Callability_t_std__allocatorT_boost__shared_ptrT_Callability_t_t_t', '_p_HandleT_Quote_t', '_p_Date', 'integer', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_DayCounter', '_p_Schedule')
class(`ConvertibleFixedCouponBond__SWIG_1`) = c("SWIGFunction", class('ConvertibleFixedCouponBond__SWIG_1'))

`ConvertibleFixedCouponBond` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 10) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_Exercise_t') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_std__vectorT_boost__shared_ptrT_Dividend_t_std__allocatorT_boost__shared_ptrT_Dividend_t_t_t') && extends(argtypes[4], '_p_std__vectorT_boost__shared_ptrT_Callability_t_std__allocatorT_boost__shared_ptrT_Callability_t_t_t') && extends(argtypes[5], '_p_HandleT_Quote_t') && extends(argtypes[6], '_p_Date') && (is.integer(argv[[7]]) || is.numeric(argv[[7]])) && extends(argtypes[8], '_p_std__vectorT_double_std__allocatorT_double_t_t') && extends(argtypes[9], '_p_DayCounter') && extends(argtypes[10], '_p_Schedule')) {
      f <- ConvertibleFixedCouponBond__SWIG_1; 
    }
  } else if (argc == 11) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_Exercise_t') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_std__vectorT_boost__shared_ptrT_Dividend_t_std__allocatorT_boost__shared_ptrT_Dividend_t_t_t') && extends(argtypes[4], '_p_std__vectorT_boost__shared_ptrT_Callability_t_std__allocatorT_boost__shared_ptrT_Callability_t_t_t') && extends(argtypes[5], '_p_HandleT_Quote_t') && extends(argtypes[6], '_p_Date') && (is.integer(argv[[7]]) || is.numeric(argv[[7]])) && extends(argtypes[8], '_p_std__vectorT_double_std__allocatorT_double_t_t') && extends(argtypes[9], '_p_DayCounter') && extends(argtypes[10], '_p_Schedule') && is.numeric(argv[[11]])) {
      f <- ConvertibleFixedCouponBond__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for ConvertibleFixedCouponBond with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_ConvertibleFixedCouponBond

`delete_ConvertibleFixedCouponBond` = function(self)
{
  ;.Call('R_swig_delete_ConvertibleFixedCouponBond', self, PACKAGE='QuantLib');
  
}

attr(`delete_ConvertibleFixedCouponBond`, 'returnType') = 'void'
attr(`delete_ConvertibleFixedCouponBond`, "inputTypes") = c('_p_ConvertibleFixedCouponBondPtr')
class(`delete_ConvertibleFixedCouponBond`) = c("SWIGFunction", class('delete_ConvertibleFixedCouponBond'))

setMethod('delete', '_p_ConvertibleFixedCouponBondPtr', function(obj) {delete_ConvertibleFixedCouponBondPtr(obj)})
# Start of new_ConvertibleFloatingRateBond

`ConvertibleFloatingRateBond__SWIG_0` = function(exercise, conversionRatio, dividends, callability, creditSpread, issueDate, settlementDays, index, fixingDays, spreads, dayCounter, schedule, redemption)
{
  settlementDays = as.integer(settlementDays); 
  
  if(length(settlementDays) > 1) {
    warning("using only the first element of settlementDays");
  };
  
  
  fixingDays = as.integer(fixingDays); 
  
  if(length(fixingDays) > 1) {
    warning("using only the first element of fixingDays");
  };
  
  
  
  
  
  ;ans = .Call('R_swig_new_ConvertibleFloatingRateBond__SWIG_0', exercise, conversionRatio, dividends, callability, creditSpread, issueDate, settlementDays, index, fixingDays, spreads, dayCounter, schedule, redemption, PACKAGE='QuantLib');
  class(ans) <- "_p_ConvertibleFloatingRateBondPtr";
  
  reg.finalizer(ans, delete_ConvertibleFloatingRateBond)
  ans
  
}

attr(`ConvertibleFloatingRateBond__SWIG_0`, 'returnType') = '_p_ConvertibleFloatingRateBondPtr'
attr(`ConvertibleFloatingRateBond__SWIG_0`, "inputTypes") = c('_p_boost__shared_ptrT_Exercise_t', 'numeric', '_p_std__vectorT_boost__shared_ptrT_Dividend_t_std__allocatorT_boost__shared_ptrT_Dividend_t_t_t', '_p_std__vectorT_boost__shared_ptrT_Callability_t_std__allocatorT_boost__shared_ptrT_Callability_t_t_t', '_p_HandleT_Quote_t', '_p_Date', 'integer', '_p_IborIndexPtr', 'integer', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_DayCounter', '_p_Schedule', 'numeric')
class(`ConvertibleFloatingRateBond__SWIG_0`) = c("SWIGFunction", class('ConvertibleFloatingRateBond__SWIG_0'))

# Start of new_ConvertibleFloatingRateBond

`ConvertibleFloatingRateBond__SWIG_1` = function(exercise, conversionRatio, dividends, callability, creditSpread, issueDate, settlementDays, index, fixingDays, spreads, dayCounter, schedule)
{
  settlementDays = as.integer(settlementDays); 
  
  if(length(settlementDays) > 1) {
    warning("using only the first element of settlementDays");
  };
  
  
  fixingDays = as.integer(fixingDays); 
  
  if(length(fixingDays) > 1) {
    warning("using only the first element of fixingDays");
  };
  
  
  
  
  ;ans = .Call('R_swig_new_ConvertibleFloatingRateBond__SWIG_1', exercise, conversionRatio, dividends, callability, creditSpread, issueDate, settlementDays, index, fixingDays, spreads, dayCounter, schedule, PACKAGE='QuantLib');
  class(ans) <- "_p_ConvertibleFloatingRateBondPtr";
  
  reg.finalizer(ans, delete_ConvertibleFloatingRateBond)
  ans
  
}

attr(`ConvertibleFloatingRateBond__SWIG_1`, 'returnType') = '_p_ConvertibleFloatingRateBondPtr'
attr(`ConvertibleFloatingRateBond__SWIG_1`, "inputTypes") = c('_p_boost__shared_ptrT_Exercise_t', 'numeric', '_p_std__vectorT_boost__shared_ptrT_Dividend_t_std__allocatorT_boost__shared_ptrT_Dividend_t_t_t', '_p_std__vectorT_boost__shared_ptrT_Callability_t_std__allocatorT_boost__shared_ptrT_Callability_t_t_t', '_p_HandleT_Quote_t', '_p_Date', 'integer', '_p_IborIndexPtr', 'integer', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_DayCounter', '_p_Schedule')
class(`ConvertibleFloatingRateBond__SWIG_1`) = c("SWIGFunction", class('ConvertibleFloatingRateBond__SWIG_1'))

`ConvertibleFloatingRateBond` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 12) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_Exercise_t') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_std__vectorT_boost__shared_ptrT_Dividend_t_std__allocatorT_boost__shared_ptrT_Dividend_t_t_t') && extends(argtypes[4], '_p_std__vectorT_boost__shared_ptrT_Callability_t_std__allocatorT_boost__shared_ptrT_Callability_t_t_t') && extends(argtypes[5], '_p_HandleT_Quote_t') && extends(argtypes[6], '_p_Date') && (is.integer(argv[[7]]) || is.numeric(argv[[7]])) && extends(argtypes[8], '_p_IborIndexPtr') && (is.integer(argv[[9]]) || is.numeric(argv[[9]])) && extends(argtypes[10], '_p_std__vectorT_double_std__allocatorT_double_t_t') && extends(argtypes[11], '_p_DayCounter') && extends(argtypes[12], '_p_Schedule')) {
      f <- ConvertibleFloatingRateBond__SWIG_1; 
    }
  } else if (argc == 13) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_Exercise_t') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_std__vectorT_boost__shared_ptrT_Dividend_t_std__allocatorT_boost__shared_ptrT_Dividend_t_t_t') && extends(argtypes[4], '_p_std__vectorT_boost__shared_ptrT_Callability_t_std__allocatorT_boost__shared_ptrT_Callability_t_t_t') && extends(argtypes[5], '_p_HandleT_Quote_t') && extends(argtypes[6], '_p_Date') && (is.integer(argv[[7]]) || is.numeric(argv[[7]])) && extends(argtypes[8], '_p_IborIndexPtr') && (is.integer(argv[[9]]) || is.numeric(argv[[9]])) && extends(argtypes[10], '_p_std__vectorT_double_std__allocatorT_double_t_t') && extends(argtypes[11], '_p_DayCounter') && extends(argtypes[12], '_p_Schedule') && is.numeric(argv[[13]])) {
      f <- ConvertibleFloatingRateBond__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for ConvertibleFloatingRateBond with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_ConvertibleFloatingRateBond

`delete_ConvertibleFloatingRateBond` = function(self)
{
  ;.Call('R_swig_delete_ConvertibleFloatingRateBond', self, PACKAGE='QuantLib');
  
}

attr(`delete_ConvertibleFloatingRateBond`, 'returnType') = 'void'
attr(`delete_ConvertibleFloatingRateBond`, "inputTypes") = c('_p_ConvertibleFloatingRateBondPtr')
class(`delete_ConvertibleFloatingRateBond`) = c("SWIGFunction", class('delete_ConvertibleFloatingRateBond'))

setMethod('delete', '_p_ConvertibleFloatingRateBondPtr', function(obj) {delete_ConvertibleFloatingRateBondPtr(obj)})
# Start of new_BinomialConvertibleEngine

`BinomialConvertibleEngine` = function(process, type, steps)
{
  type = as(type, "character"); 
  
  
  if(length(steps) > 1) {
    warning("using only the first element of steps");
  };
  
  ;ans = .Call('R_swig_new_BinomialConvertibleEngine', process, type, steps, PACKAGE='QuantLib');
  class(ans) <- "_p_BinomialConvertibleEnginePtr";
  
  reg.finalizer(ans, delete_BinomialConvertibleEngine)
  ans
  
}

attr(`BinomialConvertibleEngine`, 'returnType') = '_p_BinomialConvertibleEnginePtr'
attr(`BinomialConvertibleEngine`, "inputTypes") = c('_p_GeneralizedBlackScholesProcessPtr', 'character', 'integer')
class(`BinomialConvertibleEngine`) = c("SWIGFunction", class('BinomialConvertibleEngine'))

# Start of delete_BinomialConvertibleEngine

`delete_BinomialConvertibleEngine` = function(self)
{
  ;.Call('R_swig_delete_BinomialConvertibleEngine', self, PACKAGE='QuantLib');
  
}

attr(`delete_BinomialConvertibleEngine`, 'returnType') = 'void'
attr(`delete_BinomialConvertibleEngine`, "inputTypes") = c('_p_BinomialConvertibleEnginePtr')
class(`delete_BinomialConvertibleEngine`) = c("SWIGFunction", class('delete_BinomialConvertibleEngine'))

setMethod('delete', '_p_BinomialConvertibleEnginePtr', function(obj) {delete_BinomialConvertibleEnginePtr(obj)})
# Start of DefaultProbabilityTermStructure___deref__

`DefaultProbabilityTermStructure___deref__` = function(self)
{
  ;ans = .Call('R_swig_DefaultProbabilityTermStructure___deref__', self, PACKAGE='QuantLib');
  class(ans) <- "_p_DefaultProbabilityTermStructure";
  
  ans
  
}

attr(`DefaultProbabilityTermStructure___deref__`, 'returnType') = '_p_DefaultProbabilityTermStructure'
attr(`DefaultProbabilityTermStructure___deref__`, "inputTypes") = c('_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t')
class(`DefaultProbabilityTermStructure___deref__`) = c("SWIGFunction", class('DefaultProbabilityTermStructure___deref__'))

# Start of DefaultProbabilityTermStructure_isNull

`DefaultProbabilityTermStructure_isNull` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_DefaultProbabilityTermStructure_isNull', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityTermStructure_isNull`, 'returnType') = 'logical'
attr(`DefaultProbabilityTermStructure_isNull`, "inputTypes") = c('_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t')
class(`DefaultProbabilityTermStructure_isNull`) = c("SWIGFunction", class('DefaultProbabilityTermStructure_isNull'))

# Start of DefaultProbabilityTermStructure_asObservable

`DefaultProbabilityTermStructure_asObservable` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_DefaultProbabilityTermStructure_asObservable', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_Observable_t";
  
  ans
  
}

attr(`DefaultProbabilityTermStructure_asObservable`, 'returnType') = '_p_boost__shared_ptrT_Observable_t'
attr(`DefaultProbabilityTermStructure_asObservable`, "inputTypes") = c('_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t')
class(`DefaultProbabilityTermStructure_asObservable`) = c("SWIGFunction", class('DefaultProbabilityTermStructure_asObservable'))

# Start of new_DefaultProbabilityTermStructure

`DefaultProbabilityTermStructure` = function()
{
  ;ans = .Call('R_swig_new_DefaultProbabilityTermStructure', PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t";
  
  reg.finalizer(ans, delete_DefaultProbabilityTermStructure)
  ans
  
}

attr(`DefaultProbabilityTermStructure`, 'returnType') = '_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t'
class(`DefaultProbabilityTermStructure`) = c("SWIGFunction", class('DefaultProbabilityTermStructure'))

# Start of delete_DefaultProbabilityTermStructure

`delete_DefaultProbabilityTermStructure` = function(self)
{
  ;.Call('R_swig_delete_DefaultProbabilityTermStructure', self, PACKAGE='QuantLib');
  
}

attr(`delete_DefaultProbabilityTermStructure`, 'returnType') = 'void'
attr(`delete_DefaultProbabilityTermStructure`, "inputTypes") = c('_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t')
class(`delete_DefaultProbabilityTermStructure`) = c("SWIGFunction", class('delete_DefaultProbabilityTermStructure'))

# Start of DefaultProbabilityTermStructure_dayCounter

`DefaultProbabilityTermStructure_dayCounter` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_DefaultProbabilityTermStructure_dayCounter', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_DayCounter";
  
  ans
  
}

attr(`DefaultProbabilityTermStructure_dayCounter`, 'returnType') = '_p_DayCounter'
attr(`DefaultProbabilityTermStructure_dayCounter`, "inputTypes") = c('_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t')
class(`DefaultProbabilityTermStructure_dayCounter`) = c("SWIGFunction", class('DefaultProbabilityTermStructure_dayCounter'))

# Start of DefaultProbabilityTermStructure_calendar

`DefaultProbabilityTermStructure_calendar` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_DefaultProbabilityTermStructure_calendar', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Calendar";
  
  ans
  
}

attr(`DefaultProbabilityTermStructure_calendar`, 'returnType') = '_p_Calendar'
attr(`DefaultProbabilityTermStructure_calendar`, "inputTypes") = c('_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t')
class(`DefaultProbabilityTermStructure_calendar`) = c("SWIGFunction", class('DefaultProbabilityTermStructure_calendar'))

# Start of DefaultProbabilityTermStructure_referenceDate

`DefaultProbabilityTermStructure_referenceDate` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_DefaultProbabilityTermStructure_referenceDate', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`DefaultProbabilityTermStructure_referenceDate`, 'returnType') = '_p_Date'
attr(`DefaultProbabilityTermStructure_referenceDate`, "inputTypes") = c('_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t')
class(`DefaultProbabilityTermStructure_referenceDate`) = c("SWIGFunction", class('DefaultProbabilityTermStructure_referenceDate'))

# Start of DefaultProbabilityTermStructure_maxDate

`DefaultProbabilityTermStructure_maxDate` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_DefaultProbabilityTermStructure_maxDate', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`DefaultProbabilityTermStructure_maxDate`, 'returnType') = '_p_Date'
attr(`DefaultProbabilityTermStructure_maxDate`, "inputTypes") = c('_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t')
class(`DefaultProbabilityTermStructure_maxDate`) = c("SWIGFunction", class('DefaultProbabilityTermStructure_maxDate'))

# Start of DefaultProbabilityTermStructure_maxTime

`DefaultProbabilityTermStructure_maxTime` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_DefaultProbabilityTermStructure_maxTime', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityTermStructure_maxTime`, 'returnType') = 'numeric'
attr(`DefaultProbabilityTermStructure_maxTime`, "inputTypes") = c('_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t')
class(`DefaultProbabilityTermStructure_maxTime`) = c("SWIGFunction", class('DefaultProbabilityTermStructure_maxTime'))

# Start of DefaultProbabilityTermStructure_defaultProbability

`DefaultProbabilityTermStructure_defaultProbability__SWIG_0` = function(self, s_arg2, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_DefaultProbabilityTermStructure_defaultProbability__SWIG_0', self, s_arg2, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityTermStructure_defaultProbability__SWIG_0`, 'returnType') = 'numeric'
attr(`DefaultProbabilityTermStructure_defaultProbability__SWIG_0`, "inputTypes") = c('_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t', '_p_Date', 'logical')
class(`DefaultProbabilityTermStructure_defaultProbability__SWIG_0`) = c("SWIGFunction", class('DefaultProbabilityTermStructure_defaultProbability__SWIG_0'))

# Start of DefaultProbabilityTermStructure_defaultProbability

`DefaultProbabilityTermStructure_defaultProbability__SWIG_1` = function(self, s_arg2, .copy = FALSE)
{
  ;.Call('R_swig_DefaultProbabilityTermStructure_defaultProbability__SWIG_1', self, s_arg2, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityTermStructure_defaultProbability__SWIG_1`, 'returnType') = 'numeric'
attr(`DefaultProbabilityTermStructure_defaultProbability__SWIG_1`, "inputTypes") = c('_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t', '_p_Date')
class(`DefaultProbabilityTermStructure_defaultProbability__SWIG_1`) = c("SWIGFunction", class('DefaultProbabilityTermStructure_defaultProbability__SWIG_1'))

# Start of DefaultProbabilityTermStructure_defaultProbability

`DefaultProbabilityTermStructure_defaultProbability__SWIG_2` = function(self, s_arg2, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_DefaultProbabilityTermStructure_defaultProbability__SWIG_2', self, s_arg2, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityTermStructure_defaultProbability__SWIG_2`, 'returnType') = 'numeric'
attr(`DefaultProbabilityTermStructure_defaultProbability__SWIG_2`, "inputTypes") = c('_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t', 'numeric', 'logical')
class(`DefaultProbabilityTermStructure_defaultProbability__SWIG_2`) = c("SWIGFunction", class('DefaultProbabilityTermStructure_defaultProbability__SWIG_2'))

# Start of DefaultProbabilityTermStructure_defaultProbability

`DefaultProbabilityTermStructure_defaultProbability__SWIG_3` = function(self, s_arg2, .copy = FALSE)
{
  ;.Call('R_swig_DefaultProbabilityTermStructure_defaultProbability__SWIG_3', self, s_arg2, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityTermStructure_defaultProbability__SWIG_3`, 'returnType') = 'numeric'
attr(`DefaultProbabilityTermStructure_defaultProbability__SWIG_3`, "inputTypes") = c('_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t', 'numeric')
class(`DefaultProbabilityTermStructure_defaultProbability__SWIG_3`) = c("SWIGFunction", class('DefaultProbabilityTermStructure_defaultProbability__SWIG_3'))

# Start of DefaultProbabilityTermStructure_defaultProbability

`DefaultProbabilityTermStructure_defaultProbability__SWIG_4` = function(self, s_arg2, s_arg3, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_DefaultProbabilityTermStructure_defaultProbability__SWIG_4', self, s_arg2, s_arg3, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityTermStructure_defaultProbability__SWIG_4`, 'returnType') = 'numeric'
attr(`DefaultProbabilityTermStructure_defaultProbability__SWIG_4`, "inputTypes") = c('_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t', '_p_Date', '_p_Date', 'logical')
class(`DefaultProbabilityTermStructure_defaultProbability__SWIG_4`) = c("SWIGFunction", class('DefaultProbabilityTermStructure_defaultProbability__SWIG_4'))

# Start of DefaultProbabilityTermStructure_defaultProbability

`DefaultProbabilityTermStructure_defaultProbability__SWIG_5` = function(self, s_arg2, s_arg3, .copy = FALSE)
{
  ;.Call('R_swig_DefaultProbabilityTermStructure_defaultProbability__SWIG_5', self, s_arg2, s_arg3, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityTermStructure_defaultProbability__SWIG_5`, 'returnType') = 'numeric'
attr(`DefaultProbabilityTermStructure_defaultProbability__SWIG_5`, "inputTypes") = c('_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t', '_p_Date', '_p_Date')
class(`DefaultProbabilityTermStructure_defaultProbability__SWIG_5`) = c("SWIGFunction", class('DefaultProbabilityTermStructure_defaultProbability__SWIG_5'))

# Start of DefaultProbabilityTermStructure_defaultProbability

`DefaultProbabilityTermStructure_defaultProbability__SWIG_6` = function(self, s_arg2, s_arg3, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_DefaultProbabilityTermStructure_defaultProbability__SWIG_6', self, s_arg2, s_arg3, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityTermStructure_defaultProbability__SWIG_6`, 'returnType') = 'numeric'
attr(`DefaultProbabilityTermStructure_defaultProbability__SWIG_6`, "inputTypes") = c('_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t', 'numeric', 'numeric', 'logical')
class(`DefaultProbabilityTermStructure_defaultProbability__SWIG_6`) = c("SWIGFunction", class('DefaultProbabilityTermStructure_defaultProbability__SWIG_6'))

# Start of DefaultProbabilityTermStructure_defaultProbability

`DefaultProbabilityTermStructure_defaultProbability__SWIG_7` = function(self, s_arg2, s_arg3, .copy = FALSE)
{
  ;.Call('R_swig_DefaultProbabilityTermStructure_defaultProbability__SWIG_7', self, s_arg2, s_arg3, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityTermStructure_defaultProbability__SWIG_7`, 'returnType') = 'numeric'
attr(`DefaultProbabilityTermStructure_defaultProbability__SWIG_7`, "inputTypes") = c('_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t', 'numeric', 'numeric')
class(`DefaultProbabilityTermStructure_defaultProbability__SWIG_7`) = c("SWIGFunction", class('DefaultProbabilityTermStructure_defaultProbability__SWIG_7'))

`DefaultProbabilityTermStructure_defaultProbability` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 8
  if (argc == 2) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t') && extends(argtypes[2], '_p_Date')) {
      f <- DefaultProbabilityTermStructure_defaultProbability__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t') && is.numeric(argv[[2]])) {
      f <- DefaultProbabilityTermStructure_defaultProbability__SWIG_3; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_Date')) {
      f <- DefaultProbabilityTermStructure_defaultProbability__SWIG_5; 
    }
    else if (extends(argtypes[1], '_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], 'logical')) {
      f <- DefaultProbabilityTermStructure_defaultProbability__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- DefaultProbabilityTermStructure_defaultProbability__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t') && is.numeric(argv[[2]]) && is.numeric(argv[[3]])) {
      f <- DefaultProbabilityTermStructure_defaultProbability__SWIG_7; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_Date') && extends(argtypes[4], 'logical')) {
      f <- DefaultProbabilityTermStructure_defaultProbability__SWIG_4; 
    }
    else if (extends(argtypes[1], '_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t') && is.numeric(argv[[2]]) && is.numeric(argv[[3]]) && extends(argtypes[4], 'logical')) {
      f <- DefaultProbabilityTermStructure_defaultProbability__SWIG_6; 
    }
  } else {
    stop("cannot find overloaded function for DefaultProbabilityTermStructure_defaultProbability with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of DefaultProbabilityTermStructure_survivalProbability

`DefaultProbabilityTermStructure_survivalProbability__SWIG_0` = function(self, s_arg2, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_DefaultProbabilityTermStructure_survivalProbability__SWIG_0', self, s_arg2, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityTermStructure_survivalProbability__SWIG_0`, 'returnType') = 'numeric'
attr(`DefaultProbabilityTermStructure_survivalProbability__SWIG_0`, "inputTypes") = c('_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t', '_p_Date', 'logical')
class(`DefaultProbabilityTermStructure_survivalProbability__SWIG_0`) = c("SWIGFunction", class('DefaultProbabilityTermStructure_survivalProbability__SWIG_0'))

# Start of DefaultProbabilityTermStructure_survivalProbability

`DefaultProbabilityTermStructure_survivalProbability__SWIG_1` = function(self, s_arg2, .copy = FALSE)
{
  ;.Call('R_swig_DefaultProbabilityTermStructure_survivalProbability__SWIG_1', self, s_arg2, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityTermStructure_survivalProbability__SWIG_1`, 'returnType') = 'numeric'
attr(`DefaultProbabilityTermStructure_survivalProbability__SWIG_1`, "inputTypes") = c('_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t', '_p_Date')
class(`DefaultProbabilityTermStructure_survivalProbability__SWIG_1`) = c("SWIGFunction", class('DefaultProbabilityTermStructure_survivalProbability__SWIG_1'))

# Start of DefaultProbabilityTermStructure_survivalProbability

`DefaultProbabilityTermStructure_survivalProbability__SWIG_2` = function(self, s_arg2, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_DefaultProbabilityTermStructure_survivalProbability__SWIG_2', self, s_arg2, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityTermStructure_survivalProbability__SWIG_2`, 'returnType') = 'numeric'
attr(`DefaultProbabilityTermStructure_survivalProbability__SWIG_2`, "inputTypes") = c('_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t', 'numeric', 'logical')
class(`DefaultProbabilityTermStructure_survivalProbability__SWIG_2`) = c("SWIGFunction", class('DefaultProbabilityTermStructure_survivalProbability__SWIG_2'))

# Start of DefaultProbabilityTermStructure_survivalProbability

`DefaultProbabilityTermStructure_survivalProbability__SWIG_3` = function(self, s_arg2, .copy = FALSE)
{
  ;.Call('R_swig_DefaultProbabilityTermStructure_survivalProbability__SWIG_3', self, s_arg2, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityTermStructure_survivalProbability__SWIG_3`, 'returnType') = 'numeric'
attr(`DefaultProbabilityTermStructure_survivalProbability__SWIG_3`, "inputTypes") = c('_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t', 'numeric')
class(`DefaultProbabilityTermStructure_survivalProbability__SWIG_3`) = c("SWIGFunction", class('DefaultProbabilityTermStructure_survivalProbability__SWIG_3'))

`DefaultProbabilityTermStructure_survivalProbability` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 2) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t') && extends(argtypes[2], '_p_Date')) {
      f <- DefaultProbabilityTermStructure_survivalProbability__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t') && is.numeric(argv[[2]])) {
      f <- DefaultProbabilityTermStructure_survivalProbability__SWIG_3; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], 'logical')) {
      f <- DefaultProbabilityTermStructure_survivalProbability__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- DefaultProbabilityTermStructure_survivalProbability__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for DefaultProbabilityTermStructure_survivalProbability with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of DefaultProbabilityTermStructure_defaultDensity

`DefaultProbabilityTermStructure_defaultDensity__SWIG_0` = function(self, s_arg2, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_DefaultProbabilityTermStructure_defaultDensity__SWIG_0', self, s_arg2, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityTermStructure_defaultDensity__SWIG_0`, 'returnType') = 'numeric'
attr(`DefaultProbabilityTermStructure_defaultDensity__SWIG_0`, "inputTypes") = c('_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t', '_p_Date', 'logical')
class(`DefaultProbabilityTermStructure_defaultDensity__SWIG_0`) = c("SWIGFunction", class('DefaultProbabilityTermStructure_defaultDensity__SWIG_0'))

# Start of DefaultProbabilityTermStructure_defaultDensity

`DefaultProbabilityTermStructure_defaultDensity__SWIG_1` = function(self, s_arg2, .copy = FALSE)
{
  ;.Call('R_swig_DefaultProbabilityTermStructure_defaultDensity__SWIG_1', self, s_arg2, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityTermStructure_defaultDensity__SWIG_1`, 'returnType') = 'numeric'
attr(`DefaultProbabilityTermStructure_defaultDensity__SWIG_1`, "inputTypes") = c('_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t', '_p_Date')
class(`DefaultProbabilityTermStructure_defaultDensity__SWIG_1`) = c("SWIGFunction", class('DefaultProbabilityTermStructure_defaultDensity__SWIG_1'))

# Start of DefaultProbabilityTermStructure_defaultDensity

`DefaultProbabilityTermStructure_defaultDensity__SWIG_2` = function(self, s_arg2, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_DefaultProbabilityTermStructure_defaultDensity__SWIG_2', self, s_arg2, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityTermStructure_defaultDensity__SWIG_2`, 'returnType') = 'numeric'
attr(`DefaultProbabilityTermStructure_defaultDensity__SWIG_2`, "inputTypes") = c('_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t', 'numeric', 'logical')
class(`DefaultProbabilityTermStructure_defaultDensity__SWIG_2`) = c("SWIGFunction", class('DefaultProbabilityTermStructure_defaultDensity__SWIG_2'))

# Start of DefaultProbabilityTermStructure_defaultDensity

`DefaultProbabilityTermStructure_defaultDensity__SWIG_3` = function(self, s_arg2, .copy = FALSE)
{
  ;.Call('R_swig_DefaultProbabilityTermStructure_defaultDensity__SWIG_3', self, s_arg2, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityTermStructure_defaultDensity__SWIG_3`, 'returnType') = 'numeric'
attr(`DefaultProbabilityTermStructure_defaultDensity__SWIG_3`, "inputTypes") = c('_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t', 'numeric')
class(`DefaultProbabilityTermStructure_defaultDensity__SWIG_3`) = c("SWIGFunction", class('DefaultProbabilityTermStructure_defaultDensity__SWIG_3'))

`DefaultProbabilityTermStructure_defaultDensity` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 2) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t') && extends(argtypes[2], '_p_Date')) {
      f <- DefaultProbabilityTermStructure_defaultDensity__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t') && is.numeric(argv[[2]])) {
      f <- DefaultProbabilityTermStructure_defaultDensity__SWIG_3; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], 'logical')) {
      f <- DefaultProbabilityTermStructure_defaultDensity__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- DefaultProbabilityTermStructure_defaultDensity__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for DefaultProbabilityTermStructure_defaultDensity with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of DefaultProbabilityTermStructure_hazardRate

`DefaultProbabilityTermStructure_hazardRate__SWIG_0` = function(self, s_arg2, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_DefaultProbabilityTermStructure_hazardRate__SWIG_0', self, s_arg2, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityTermStructure_hazardRate__SWIG_0`, 'returnType') = 'numeric'
attr(`DefaultProbabilityTermStructure_hazardRate__SWIG_0`, "inputTypes") = c('_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t', '_p_Date', 'logical')
class(`DefaultProbabilityTermStructure_hazardRate__SWIG_0`) = c("SWIGFunction", class('DefaultProbabilityTermStructure_hazardRate__SWIG_0'))

# Start of DefaultProbabilityTermStructure_hazardRate

`DefaultProbabilityTermStructure_hazardRate__SWIG_1` = function(self, s_arg2, .copy = FALSE)
{
  ;.Call('R_swig_DefaultProbabilityTermStructure_hazardRate__SWIG_1', self, s_arg2, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityTermStructure_hazardRate__SWIG_1`, 'returnType') = 'numeric'
attr(`DefaultProbabilityTermStructure_hazardRate__SWIG_1`, "inputTypes") = c('_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t', '_p_Date')
class(`DefaultProbabilityTermStructure_hazardRate__SWIG_1`) = c("SWIGFunction", class('DefaultProbabilityTermStructure_hazardRate__SWIG_1'))

# Start of DefaultProbabilityTermStructure_hazardRate

`DefaultProbabilityTermStructure_hazardRate__SWIG_2` = function(self, s_arg2, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_DefaultProbabilityTermStructure_hazardRate__SWIG_2', self, s_arg2, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityTermStructure_hazardRate__SWIG_2`, 'returnType') = 'numeric'
attr(`DefaultProbabilityTermStructure_hazardRate__SWIG_2`, "inputTypes") = c('_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t', 'numeric', 'logical')
class(`DefaultProbabilityTermStructure_hazardRate__SWIG_2`) = c("SWIGFunction", class('DefaultProbabilityTermStructure_hazardRate__SWIG_2'))

# Start of DefaultProbabilityTermStructure_hazardRate

`DefaultProbabilityTermStructure_hazardRate__SWIG_3` = function(self, s_arg2, .copy = FALSE)
{
  ;.Call('R_swig_DefaultProbabilityTermStructure_hazardRate__SWIG_3', self, s_arg2, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityTermStructure_hazardRate__SWIG_3`, 'returnType') = 'numeric'
attr(`DefaultProbabilityTermStructure_hazardRate__SWIG_3`, "inputTypes") = c('_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t', 'numeric')
class(`DefaultProbabilityTermStructure_hazardRate__SWIG_3`) = c("SWIGFunction", class('DefaultProbabilityTermStructure_hazardRate__SWIG_3'))

`DefaultProbabilityTermStructure_hazardRate` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 2) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t') && extends(argtypes[2], '_p_Date')) {
      f <- DefaultProbabilityTermStructure_hazardRate__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t') && is.numeric(argv[[2]])) {
      f <- DefaultProbabilityTermStructure_hazardRate__SWIG_3; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], 'logical')) {
      f <- DefaultProbabilityTermStructure_hazardRate__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- DefaultProbabilityTermStructure_hazardRate__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for DefaultProbabilityTermStructure_hazardRate with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of DefaultProbabilityTermStructure_enableExtrapolation

`DefaultProbabilityTermStructure_enableExtrapolation` = function(self)
{
  ;.Call('R_swig_DefaultProbabilityTermStructure_enableExtrapolation', self, PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityTermStructure_enableExtrapolation`, 'returnType') = 'void'
attr(`DefaultProbabilityTermStructure_enableExtrapolation`, "inputTypes") = c('_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t')
class(`DefaultProbabilityTermStructure_enableExtrapolation`) = c("SWIGFunction", class('DefaultProbabilityTermStructure_enableExtrapolation'))

# Start of DefaultProbabilityTermStructure_disableExtrapolation

`DefaultProbabilityTermStructure_disableExtrapolation` = function(self)
{
  ;.Call('R_swig_DefaultProbabilityTermStructure_disableExtrapolation', self, PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityTermStructure_disableExtrapolation`, 'returnType') = 'void'
attr(`DefaultProbabilityTermStructure_disableExtrapolation`, "inputTypes") = c('_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t')
class(`DefaultProbabilityTermStructure_disableExtrapolation`) = c("SWIGFunction", class('DefaultProbabilityTermStructure_disableExtrapolation'))

# Start of DefaultProbabilityTermStructure_allowsExtrapolation

`DefaultProbabilityTermStructure_allowsExtrapolation` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_DefaultProbabilityTermStructure_allowsExtrapolation', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityTermStructure_allowsExtrapolation`, 'returnType') = 'logical'
attr(`DefaultProbabilityTermStructure_allowsExtrapolation`, "inputTypes") = c('_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t')
class(`DefaultProbabilityTermStructure_allowsExtrapolation`) = c("SWIGFunction", class('DefaultProbabilityTermStructure_allowsExtrapolation'))

# Start of accessor method for boost::shared_ptr<(DefaultProbabilityTermStructure)>
setMethod('$', '_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t', function(x, name)

{
  accessorFuns = list('__deref__' = DefaultProbabilityTermStructure___deref__, 'isNull' = DefaultProbabilityTermStructure_isNull, 'asObservable' = DefaultProbabilityTermStructure_asObservable, 'dayCounter' = DefaultProbabilityTermStructure_dayCounter, 'calendar' = DefaultProbabilityTermStructure_calendar, 'referenceDate' = DefaultProbabilityTermStructure_referenceDate, 'maxDate' = DefaultProbabilityTermStructure_maxDate, 'maxTime' = DefaultProbabilityTermStructure_maxTime, 'defaultProbability' = DefaultProbabilityTermStructure_defaultProbability, 'survivalProbability' = DefaultProbabilityTermStructure_survivalProbability, 'defaultDensity' = DefaultProbabilityTermStructure_defaultDensity, 'hazardRate' = DefaultProbabilityTermStructure_hazardRate, 'enableExtrapolation' = DefaultProbabilityTermStructure_enableExtrapolation, 'disableExtrapolation' = DefaultProbabilityTermStructure_disableExtrapolation, 'allowsExtrapolation' = DefaultProbabilityTermStructure_allowsExtrapolation);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for boost::shared_ptr<(DefaultProbabilityTermStructure)>
setMethod('delete', '_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t', function(obj) {delete_boost__shared_ptrT_DefaultProbabilityTermStructure_t(obj)})
# Start of new_DefaultProbabilityTermStructureHandle

`DefaultProbabilityTermStructureHandle__SWIG_0` = function(s_arg1)
{
  ;ans = .Call('R_swig_new_DefaultProbabilityTermStructureHandle__SWIG_0', s_arg1, PACKAGE='QuantLib');
  class(ans) <- "_p_HandleT_DefaultProbabilityTermStructure_t";
  
  reg.finalizer(ans, delete_DefaultProbabilityTermStructureHandle)
  ans
  
}

attr(`DefaultProbabilityTermStructureHandle__SWIG_0`, 'returnType') = '_p_HandleT_DefaultProbabilityTermStructure_t'
attr(`DefaultProbabilityTermStructureHandle__SWIG_0`, "inputTypes") = c('_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t')
class(`DefaultProbabilityTermStructureHandle__SWIG_0`) = c("SWIGFunction", class('DefaultProbabilityTermStructureHandle__SWIG_0'))

# Start of new_DefaultProbabilityTermStructureHandle

`DefaultProbabilityTermStructureHandle__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_DefaultProbabilityTermStructureHandle__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_HandleT_DefaultProbabilityTermStructure_t";
  
  reg.finalizer(ans, delete_DefaultProbabilityTermStructureHandle)
  ans
  
}

attr(`DefaultProbabilityTermStructureHandle__SWIG_1`, 'returnType') = '_p_HandleT_DefaultProbabilityTermStructure_t'
class(`DefaultProbabilityTermStructureHandle__SWIG_1`) = c("SWIGFunction", class('DefaultProbabilityTermStructureHandle__SWIG_1'))

`DefaultProbabilityTermStructureHandle` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- DefaultProbabilityTermStructureHandle__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t')) {
      f <- DefaultProbabilityTermStructureHandle__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for DefaultProbabilityTermStructureHandle with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of DefaultProbabilityTermStructureHandle___deref__

`DefaultProbabilityTermStructureHandle___deref__` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_DefaultProbabilityTermStructureHandle___deref__', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t";
  
  ans
  
}

attr(`DefaultProbabilityTermStructureHandle___deref__`, 'returnType') = '_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t'
attr(`DefaultProbabilityTermStructureHandle___deref__`, "inputTypes") = c('_p_HandleT_DefaultProbabilityTermStructure_t')
class(`DefaultProbabilityTermStructureHandle___deref__`) = c("SWIGFunction", class('DefaultProbabilityTermStructureHandle___deref__'))

# Start of DefaultProbabilityTermStructureHandle_empty

`DefaultProbabilityTermStructureHandle_empty` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_DefaultProbabilityTermStructureHandle_empty', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityTermStructureHandle_empty`, 'returnType') = 'logical'
attr(`DefaultProbabilityTermStructureHandle_empty`, "inputTypes") = c('_p_HandleT_DefaultProbabilityTermStructure_t')
class(`DefaultProbabilityTermStructureHandle_empty`) = c("SWIGFunction", class('DefaultProbabilityTermStructureHandle_empty'))

# Start of DefaultProbabilityTermStructureHandle_asObservable

`DefaultProbabilityTermStructureHandle_asObservable` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_DefaultProbabilityTermStructureHandle_asObservable', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_Observable_t";
  
  ans
  
}

attr(`DefaultProbabilityTermStructureHandle_asObservable`, 'returnType') = '_p_boost__shared_ptrT_Observable_t'
attr(`DefaultProbabilityTermStructureHandle_asObservable`, "inputTypes") = c('_p_HandleT_DefaultProbabilityTermStructure_t')
class(`DefaultProbabilityTermStructureHandle_asObservable`) = c("SWIGFunction", class('DefaultProbabilityTermStructureHandle_asObservable'))

# Start of delete_DefaultProbabilityTermStructureHandle

`delete_DefaultProbabilityTermStructureHandle` = function(self)
{
  ;.Call('R_swig_delete_DefaultProbabilityTermStructureHandle', self, PACKAGE='QuantLib');
  
}

attr(`delete_DefaultProbabilityTermStructureHandle`, 'returnType') = 'void'
attr(`delete_DefaultProbabilityTermStructureHandle`, "inputTypes") = c('_p_HandleT_DefaultProbabilityTermStructure_t')
class(`delete_DefaultProbabilityTermStructureHandle`) = c("SWIGFunction", class('delete_DefaultProbabilityTermStructureHandle'))

# Start of DefaultProbabilityTermStructureHandle_dayCounter

`DefaultProbabilityTermStructureHandle_dayCounter` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_DefaultProbabilityTermStructureHandle_dayCounter', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_DayCounter";
  
  ans
  
}

attr(`DefaultProbabilityTermStructureHandle_dayCounter`, 'returnType') = '_p_DayCounter'
attr(`DefaultProbabilityTermStructureHandle_dayCounter`, "inputTypes") = c('_p_HandleT_DefaultProbabilityTermStructure_t')
class(`DefaultProbabilityTermStructureHandle_dayCounter`) = c("SWIGFunction", class('DefaultProbabilityTermStructureHandle_dayCounter'))

# Start of DefaultProbabilityTermStructureHandle_calendar

`DefaultProbabilityTermStructureHandle_calendar` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_DefaultProbabilityTermStructureHandle_calendar', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Calendar";
  
  ans
  
}

attr(`DefaultProbabilityTermStructureHandle_calendar`, 'returnType') = '_p_Calendar'
attr(`DefaultProbabilityTermStructureHandle_calendar`, "inputTypes") = c('_p_HandleT_DefaultProbabilityTermStructure_t')
class(`DefaultProbabilityTermStructureHandle_calendar`) = c("SWIGFunction", class('DefaultProbabilityTermStructureHandle_calendar'))

# Start of DefaultProbabilityTermStructureHandle_referenceDate

`DefaultProbabilityTermStructureHandle_referenceDate` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_DefaultProbabilityTermStructureHandle_referenceDate', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`DefaultProbabilityTermStructureHandle_referenceDate`, 'returnType') = '_p_Date'
attr(`DefaultProbabilityTermStructureHandle_referenceDate`, "inputTypes") = c('_p_HandleT_DefaultProbabilityTermStructure_t')
class(`DefaultProbabilityTermStructureHandle_referenceDate`) = c("SWIGFunction", class('DefaultProbabilityTermStructureHandle_referenceDate'))

# Start of DefaultProbabilityTermStructureHandle_maxDate

`DefaultProbabilityTermStructureHandle_maxDate` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_DefaultProbabilityTermStructureHandle_maxDate', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`DefaultProbabilityTermStructureHandle_maxDate`, 'returnType') = '_p_Date'
attr(`DefaultProbabilityTermStructureHandle_maxDate`, "inputTypes") = c('_p_HandleT_DefaultProbabilityTermStructure_t')
class(`DefaultProbabilityTermStructureHandle_maxDate`) = c("SWIGFunction", class('DefaultProbabilityTermStructureHandle_maxDate'))

# Start of DefaultProbabilityTermStructureHandle_maxTime

`DefaultProbabilityTermStructureHandle_maxTime` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_DefaultProbabilityTermStructureHandle_maxTime', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityTermStructureHandle_maxTime`, 'returnType') = 'numeric'
attr(`DefaultProbabilityTermStructureHandle_maxTime`, "inputTypes") = c('_p_HandleT_DefaultProbabilityTermStructure_t')
class(`DefaultProbabilityTermStructureHandle_maxTime`) = c("SWIGFunction", class('DefaultProbabilityTermStructureHandle_maxTime'))

# Start of DefaultProbabilityTermStructureHandle_defaultProbability

`DefaultProbabilityTermStructureHandle_defaultProbability__SWIG_0` = function(self, s_arg2, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_DefaultProbabilityTermStructureHandle_defaultProbability__SWIG_0', self, s_arg2, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityTermStructureHandle_defaultProbability__SWIG_0`, 'returnType') = 'numeric'
attr(`DefaultProbabilityTermStructureHandle_defaultProbability__SWIG_0`, "inputTypes") = c('_p_HandleT_DefaultProbabilityTermStructure_t', '_p_Date', 'logical')
class(`DefaultProbabilityTermStructureHandle_defaultProbability__SWIG_0`) = c("SWIGFunction", class('DefaultProbabilityTermStructureHandle_defaultProbability__SWIG_0'))

# Start of DefaultProbabilityTermStructureHandle_defaultProbability

`DefaultProbabilityTermStructureHandle_defaultProbability__SWIG_1` = function(self, s_arg2, .copy = FALSE)
{
  ;.Call('R_swig_DefaultProbabilityTermStructureHandle_defaultProbability__SWIG_1', self, s_arg2, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityTermStructureHandle_defaultProbability__SWIG_1`, 'returnType') = 'numeric'
attr(`DefaultProbabilityTermStructureHandle_defaultProbability__SWIG_1`, "inputTypes") = c('_p_HandleT_DefaultProbabilityTermStructure_t', '_p_Date')
class(`DefaultProbabilityTermStructureHandle_defaultProbability__SWIG_1`) = c("SWIGFunction", class('DefaultProbabilityTermStructureHandle_defaultProbability__SWIG_1'))

# Start of DefaultProbabilityTermStructureHandle_defaultProbability

`DefaultProbabilityTermStructureHandle_defaultProbability__SWIG_2` = function(self, s_arg2, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_DefaultProbabilityTermStructureHandle_defaultProbability__SWIG_2', self, s_arg2, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityTermStructureHandle_defaultProbability__SWIG_2`, 'returnType') = 'numeric'
attr(`DefaultProbabilityTermStructureHandle_defaultProbability__SWIG_2`, "inputTypes") = c('_p_HandleT_DefaultProbabilityTermStructure_t', 'numeric', 'logical')
class(`DefaultProbabilityTermStructureHandle_defaultProbability__SWIG_2`) = c("SWIGFunction", class('DefaultProbabilityTermStructureHandle_defaultProbability__SWIG_2'))

# Start of DefaultProbabilityTermStructureHandle_defaultProbability

`DefaultProbabilityTermStructureHandle_defaultProbability__SWIG_3` = function(self, s_arg2, .copy = FALSE)
{
  ;.Call('R_swig_DefaultProbabilityTermStructureHandle_defaultProbability__SWIG_3', self, s_arg2, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityTermStructureHandle_defaultProbability__SWIG_3`, 'returnType') = 'numeric'
attr(`DefaultProbabilityTermStructureHandle_defaultProbability__SWIG_3`, "inputTypes") = c('_p_HandleT_DefaultProbabilityTermStructure_t', 'numeric')
class(`DefaultProbabilityTermStructureHandle_defaultProbability__SWIG_3`) = c("SWIGFunction", class('DefaultProbabilityTermStructureHandle_defaultProbability__SWIG_3'))

# Start of DefaultProbabilityTermStructureHandle_defaultProbability

`DefaultProbabilityTermStructureHandle_defaultProbability__SWIG_4` = function(self, s_arg2, s_arg3, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_DefaultProbabilityTermStructureHandle_defaultProbability__SWIG_4', self, s_arg2, s_arg3, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityTermStructureHandle_defaultProbability__SWIG_4`, 'returnType') = 'numeric'
attr(`DefaultProbabilityTermStructureHandle_defaultProbability__SWIG_4`, "inputTypes") = c('_p_HandleT_DefaultProbabilityTermStructure_t', '_p_Date', '_p_Date', 'logical')
class(`DefaultProbabilityTermStructureHandle_defaultProbability__SWIG_4`) = c("SWIGFunction", class('DefaultProbabilityTermStructureHandle_defaultProbability__SWIG_4'))

# Start of DefaultProbabilityTermStructureHandle_defaultProbability

`DefaultProbabilityTermStructureHandle_defaultProbability__SWIG_5` = function(self, s_arg2, s_arg3, .copy = FALSE)
{
  ;.Call('R_swig_DefaultProbabilityTermStructureHandle_defaultProbability__SWIG_5', self, s_arg2, s_arg3, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityTermStructureHandle_defaultProbability__SWIG_5`, 'returnType') = 'numeric'
attr(`DefaultProbabilityTermStructureHandle_defaultProbability__SWIG_5`, "inputTypes") = c('_p_HandleT_DefaultProbabilityTermStructure_t', '_p_Date', '_p_Date')
class(`DefaultProbabilityTermStructureHandle_defaultProbability__SWIG_5`) = c("SWIGFunction", class('DefaultProbabilityTermStructureHandle_defaultProbability__SWIG_5'))

# Start of DefaultProbabilityTermStructureHandle_defaultProbability

`DefaultProbabilityTermStructureHandle_defaultProbability__SWIG_6` = function(self, s_arg2, s_arg3, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_DefaultProbabilityTermStructureHandle_defaultProbability__SWIG_6', self, s_arg2, s_arg3, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityTermStructureHandle_defaultProbability__SWIG_6`, 'returnType') = 'numeric'
attr(`DefaultProbabilityTermStructureHandle_defaultProbability__SWIG_6`, "inputTypes") = c('_p_HandleT_DefaultProbabilityTermStructure_t', 'numeric', 'numeric', 'logical')
class(`DefaultProbabilityTermStructureHandle_defaultProbability__SWIG_6`) = c("SWIGFunction", class('DefaultProbabilityTermStructureHandle_defaultProbability__SWIG_6'))

# Start of DefaultProbabilityTermStructureHandle_defaultProbability

`DefaultProbabilityTermStructureHandle_defaultProbability__SWIG_7` = function(self, s_arg2, s_arg3, .copy = FALSE)
{
  ;.Call('R_swig_DefaultProbabilityTermStructureHandle_defaultProbability__SWIG_7', self, s_arg2, s_arg3, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityTermStructureHandle_defaultProbability__SWIG_7`, 'returnType') = 'numeric'
attr(`DefaultProbabilityTermStructureHandle_defaultProbability__SWIG_7`, "inputTypes") = c('_p_HandleT_DefaultProbabilityTermStructure_t', 'numeric', 'numeric')
class(`DefaultProbabilityTermStructureHandle_defaultProbability__SWIG_7`) = c("SWIGFunction", class('DefaultProbabilityTermStructureHandle_defaultProbability__SWIG_7'))

`DefaultProbabilityTermStructureHandle_defaultProbability` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 8
  if (argc == 2) {
    if (extends(argtypes[1], '_p_HandleT_DefaultProbabilityTermStructure_t') && extends(argtypes[2], '_p_Date')) {
      f <- DefaultProbabilityTermStructureHandle_defaultProbability__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_HandleT_DefaultProbabilityTermStructure_t') && is.numeric(argv[[2]])) {
      f <- DefaultProbabilityTermStructureHandle_defaultProbability__SWIG_3; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_HandleT_DefaultProbabilityTermStructure_t') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_Date')) {
      f <- DefaultProbabilityTermStructureHandle_defaultProbability__SWIG_5; 
    }
    else if (extends(argtypes[1], '_p_HandleT_DefaultProbabilityTermStructure_t') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], 'logical')) {
      f <- DefaultProbabilityTermStructureHandle_defaultProbability__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_HandleT_DefaultProbabilityTermStructure_t') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- DefaultProbabilityTermStructureHandle_defaultProbability__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_HandleT_DefaultProbabilityTermStructure_t') && is.numeric(argv[[2]]) && is.numeric(argv[[3]])) {
      f <- DefaultProbabilityTermStructureHandle_defaultProbability__SWIG_7; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_HandleT_DefaultProbabilityTermStructure_t') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_Date') && extends(argtypes[4], 'logical')) {
      f <- DefaultProbabilityTermStructureHandle_defaultProbability__SWIG_4; 
    }
    else if (extends(argtypes[1], '_p_HandleT_DefaultProbabilityTermStructure_t') && is.numeric(argv[[2]]) && is.numeric(argv[[3]]) && extends(argtypes[4], 'logical')) {
      f <- DefaultProbabilityTermStructureHandle_defaultProbability__SWIG_6; 
    }
  } else {
    stop("cannot find overloaded function for DefaultProbabilityTermStructureHandle_defaultProbability with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of DefaultProbabilityTermStructureHandle_survivalProbability

`DefaultProbabilityTermStructureHandle_survivalProbability__SWIG_0` = function(self, s_arg2, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_DefaultProbabilityTermStructureHandle_survivalProbability__SWIG_0', self, s_arg2, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityTermStructureHandle_survivalProbability__SWIG_0`, 'returnType') = 'numeric'
attr(`DefaultProbabilityTermStructureHandle_survivalProbability__SWIG_0`, "inputTypes") = c('_p_HandleT_DefaultProbabilityTermStructure_t', '_p_Date', 'logical')
class(`DefaultProbabilityTermStructureHandle_survivalProbability__SWIG_0`) = c("SWIGFunction", class('DefaultProbabilityTermStructureHandle_survivalProbability__SWIG_0'))

# Start of DefaultProbabilityTermStructureHandle_survivalProbability

`DefaultProbabilityTermStructureHandle_survivalProbability__SWIG_1` = function(self, s_arg2, .copy = FALSE)
{
  ;.Call('R_swig_DefaultProbabilityTermStructureHandle_survivalProbability__SWIG_1', self, s_arg2, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityTermStructureHandle_survivalProbability__SWIG_1`, 'returnType') = 'numeric'
attr(`DefaultProbabilityTermStructureHandle_survivalProbability__SWIG_1`, "inputTypes") = c('_p_HandleT_DefaultProbabilityTermStructure_t', '_p_Date')
class(`DefaultProbabilityTermStructureHandle_survivalProbability__SWIG_1`) = c("SWIGFunction", class('DefaultProbabilityTermStructureHandle_survivalProbability__SWIG_1'))

# Start of DefaultProbabilityTermStructureHandle_survivalProbability

`DefaultProbabilityTermStructureHandle_survivalProbability__SWIG_2` = function(self, s_arg2, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_DefaultProbabilityTermStructureHandle_survivalProbability__SWIG_2', self, s_arg2, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityTermStructureHandle_survivalProbability__SWIG_2`, 'returnType') = 'numeric'
attr(`DefaultProbabilityTermStructureHandle_survivalProbability__SWIG_2`, "inputTypes") = c('_p_HandleT_DefaultProbabilityTermStructure_t', 'numeric', 'logical')
class(`DefaultProbabilityTermStructureHandle_survivalProbability__SWIG_2`) = c("SWIGFunction", class('DefaultProbabilityTermStructureHandle_survivalProbability__SWIG_2'))

# Start of DefaultProbabilityTermStructureHandle_survivalProbability

`DefaultProbabilityTermStructureHandle_survivalProbability__SWIG_3` = function(self, s_arg2, .copy = FALSE)
{
  ;.Call('R_swig_DefaultProbabilityTermStructureHandle_survivalProbability__SWIG_3', self, s_arg2, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityTermStructureHandle_survivalProbability__SWIG_3`, 'returnType') = 'numeric'
attr(`DefaultProbabilityTermStructureHandle_survivalProbability__SWIG_3`, "inputTypes") = c('_p_HandleT_DefaultProbabilityTermStructure_t', 'numeric')
class(`DefaultProbabilityTermStructureHandle_survivalProbability__SWIG_3`) = c("SWIGFunction", class('DefaultProbabilityTermStructureHandle_survivalProbability__SWIG_3'))

`DefaultProbabilityTermStructureHandle_survivalProbability` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 2) {
    if (extends(argtypes[1], '_p_HandleT_DefaultProbabilityTermStructure_t') && extends(argtypes[2], '_p_Date')) {
      f <- DefaultProbabilityTermStructureHandle_survivalProbability__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_HandleT_DefaultProbabilityTermStructure_t') && is.numeric(argv[[2]])) {
      f <- DefaultProbabilityTermStructureHandle_survivalProbability__SWIG_3; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_HandleT_DefaultProbabilityTermStructure_t') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], 'logical')) {
      f <- DefaultProbabilityTermStructureHandle_survivalProbability__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_HandleT_DefaultProbabilityTermStructure_t') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- DefaultProbabilityTermStructureHandle_survivalProbability__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for DefaultProbabilityTermStructureHandle_survivalProbability with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of DefaultProbabilityTermStructureHandle_defaultDensity

`DefaultProbabilityTermStructureHandle_defaultDensity__SWIG_0` = function(self, s_arg2, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_DefaultProbabilityTermStructureHandle_defaultDensity__SWIG_0', self, s_arg2, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityTermStructureHandle_defaultDensity__SWIG_0`, 'returnType') = 'numeric'
attr(`DefaultProbabilityTermStructureHandle_defaultDensity__SWIG_0`, "inputTypes") = c('_p_HandleT_DefaultProbabilityTermStructure_t', '_p_Date', 'logical')
class(`DefaultProbabilityTermStructureHandle_defaultDensity__SWIG_0`) = c("SWIGFunction", class('DefaultProbabilityTermStructureHandle_defaultDensity__SWIG_0'))

# Start of DefaultProbabilityTermStructureHandle_defaultDensity

`DefaultProbabilityTermStructureHandle_defaultDensity__SWIG_1` = function(self, s_arg2, .copy = FALSE)
{
  ;.Call('R_swig_DefaultProbabilityTermStructureHandle_defaultDensity__SWIG_1', self, s_arg2, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityTermStructureHandle_defaultDensity__SWIG_1`, 'returnType') = 'numeric'
attr(`DefaultProbabilityTermStructureHandle_defaultDensity__SWIG_1`, "inputTypes") = c('_p_HandleT_DefaultProbabilityTermStructure_t', '_p_Date')
class(`DefaultProbabilityTermStructureHandle_defaultDensity__SWIG_1`) = c("SWIGFunction", class('DefaultProbabilityTermStructureHandle_defaultDensity__SWIG_1'))

# Start of DefaultProbabilityTermStructureHandle_defaultDensity

`DefaultProbabilityTermStructureHandle_defaultDensity__SWIG_2` = function(self, s_arg2, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_DefaultProbabilityTermStructureHandle_defaultDensity__SWIG_2', self, s_arg2, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityTermStructureHandle_defaultDensity__SWIG_2`, 'returnType') = 'numeric'
attr(`DefaultProbabilityTermStructureHandle_defaultDensity__SWIG_2`, "inputTypes") = c('_p_HandleT_DefaultProbabilityTermStructure_t', 'numeric', 'logical')
class(`DefaultProbabilityTermStructureHandle_defaultDensity__SWIG_2`) = c("SWIGFunction", class('DefaultProbabilityTermStructureHandle_defaultDensity__SWIG_2'))

# Start of DefaultProbabilityTermStructureHandle_defaultDensity

`DefaultProbabilityTermStructureHandle_defaultDensity__SWIG_3` = function(self, s_arg2, .copy = FALSE)
{
  ;.Call('R_swig_DefaultProbabilityTermStructureHandle_defaultDensity__SWIG_3', self, s_arg2, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityTermStructureHandle_defaultDensity__SWIG_3`, 'returnType') = 'numeric'
attr(`DefaultProbabilityTermStructureHandle_defaultDensity__SWIG_3`, "inputTypes") = c('_p_HandleT_DefaultProbabilityTermStructure_t', 'numeric')
class(`DefaultProbabilityTermStructureHandle_defaultDensity__SWIG_3`) = c("SWIGFunction", class('DefaultProbabilityTermStructureHandle_defaultDensity__SWIG_3'))

`DefaultProbabilityTermStructureHandle_defaultDensity` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 2) {
    if (extends(argtypes[1], '_p_HandleT_DefaultProbabilityTermStructure_t') && extends(argtypes[2], '_p_Date')) {
      f <- DefaultProbabilityTermStructureHandle_defaultDensity__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_HandleT_DefaultProbabilityTermStructure_t') && is.numeric(argv[[2]])) {
      f <- DefaultProbabilityTermStructureHandle_defaultDensity__SWIG_3; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_HandleT_DefaultProbabilityTermStructure_t') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], 'logical')) {
      f <- DefaultProbabilityTermStructureHandle_defaultDensity__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_HandleT_DefaultProbabilityTermStructure_t') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- DefaultProbabilityTermStructureHandle_defaultDensity__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for DefaultProbabilityTermStructureHandle_defaultDensity with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of DefaultProbabilityTermStructureHandle_hazardRate

`DefaultProbabilityTermStructureHandle_hazardRate__SWIG_0` = function(self, s_arg2, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_DefaultProbabilityTermStructureHandle_hazardRate__SWIG_0', self, s_arg2, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityTermStructureHandle_hazardRate__SWIG_0`, 'returnType') = 'numeric'
attr(`DefaultProbabilityTermStructureHandle_hazardRate__SWIG_0`, "inputTypes") = c('_p_HandleT_DefaultProbabilityTermStructure_t', '_p_Date', 'logical')
class(`DefaultProbabilityTermStructureHandle_hazardRate__SWIG_0`) = c("SWIGFunction", class('DefaultProbabilityTermStructureHandle_hazardRate__SWIG_0'))

# Start of DefaultProbabilityTermStructureHandle_hazardRate

`DefaultProbabilityTermStructureHandle_hazardRate__SWIG_1` = function(self, s_arg2, .copy = FALSE)
{
  ;.Call('R_swig_DefaultProbabilityTermStructureHandle_hazardRate__SWIG_1', self, s_arg2, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityTermStructureHandle_hazardRate__SWIG_1`, 'returnType') = 'numeric'
attr(`DefaultProbabilityTermStructureHandle_hazardRate__SWIG_1`, "inputTypes") = c('_p_HandleT_DefaultProbabilityTermStructure_t', '_p_Date')
class(`DefaultProbabilityTermStructureHandle_hazardRate__SWIG_1`) = c("SWIGFunction", class('DefaultProbabilityTermStructureHandle_hazardRate__SWIG_1'))

# Start of DefaultProbabilityTermStructureHandle_hazardRate

`DefaultProbabilityTermStructureHandle_hazardRate__SWIG_2` = function(self, s_arg2, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_DefaultProbabilityTermStructureHandle_hazardRate__SWIG_2', self, s_arg2, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityTermStructureHandle_hazardRate__SWIG_2`, 'returnType') = 'numeric'
attr(`DefaultProbabilityTermStructureHandle_hazardRate__SWIG_2`, "inputTypes") = c('_p_HandleT_DefaultProbabilityTermStructure_t', 'numeric', 'logical')
class(`DefaultProbabilityTermStructureHandle_hazardRate__SWIG_2`) = c("SWIGFunction", class('DefaultProbabilityTermStructureHandle_hazardRate__SWIG_2'))

# Start of DefaultProbabilityTermStructureHandle_hazardRate

`DefaultProbabilityTermStructureHandle_hazardRate__SWIG_3` = function(self, s_arg2, .copy = FALSE)
{
  ;.Call('R_swig_DefaultProbabilityTermStructureHandle_hazardRate__SWIG_3', self, s_arg2, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityTermStructureHandle_hazardRate__SWIG_3`, 'returnType') = 'numeric'
attr(`DefaultProbabilityTermStructureHandle_hazardRate__SWIG_3`, "inputTypes") = c('_p_HandleT_DefaultProbabilityTermStructure_t', 'numeric')
class(`DefaultProbabilityTermStructureHandle_hazardRate__SWIG_3`) = c("SWIGFunction", class('DefaultProbabilityTermStructureHandle_hazardRate__SWIG_3'))

`DefaultProbabilityTermStructureHandle_hazardRate` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 2) {
    if (extends(argtypes[1], '_p_HandleT_DefaultProbabilityTermStructure_t') && extends(argtypes[2], '_p_Date')) {
      f <- DefaultProbabilityTermStructureHandle_hazardRate__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_HandleT_DefaultProbabilityTermStructure_t') && is.numeric(argv[[2]])) {
      f <- DefaultProbabilityTermStructureHandle_hazardRate__SWIG_3; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_HandleT_DefaultProbabilityTermStructure_t') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], 'logical')) {
      f <- DefaultProbabilityTermStructureHandle_hazardRate__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_HandleT_DefaultProbabilityTermStructure_t') && is.numeric(argv[[2]]) && extends(argtypes[3], 'logical')) {
      f <- DefaultProbabilityTermStructureHandle_hazardRate__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for DefaultProbabilityTermStructureHandle_hazardRate with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of DefaultProbabilityTermStructureHandle_enableExtrapolation

`DefaultProbabilityTermStructureHandle_enableExtrapolation` = function(self)
{
  ;.Call('R_swig_DefaultProbabilityTermStructureHandle_enableExtrapolation', self, PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityTermStructureHandle_enableExtrapolation`, 'returnType') = 'void'
attr(`DefaultProbabilityTermStructureHandle_enableExtrapolation`, "inputTypes") = c('_p_HandleT_DefaultProbabilityTermStructure_t')
class(`DefaultProbabilityTermStructureHandle_enableExtrapolation`) = c("SWIGFunction", class('DefaultProbabilityTermStructureHandle_enableExtrapolation'))

# Start of DefaultProbabilityTermStructureHandle_disableExtrapolation

`DefaultProbabilityTermStructureHandle_disableExtrapolation` = function(self)
{
  ;.Call('R_swig_DefaultProbabilityTermStructureHandle_disableExtrapolation', self, PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityTermStructureHandle_disableExtrapolation`, 'returnType') = 'void'
attr(`DefaultProbabilityTermStructureHandle_disableExtrapolation`, "inputTypes") = c('_p_HandleT_DefaultProbabilityTermStructure_t')
class(`DefaultProbabilityTermStructureHandle_disableExtrapolation`) = c("SWIGFunction", class('DefaultProbabilityTermStructureHandle_disableExtrapolation'))

# Start of DefaultProbabilityTermStructureHandle_allowsExtrapolation

`DefaultProbabilityTermStructureHandle_allowsExtrapolation` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_DefaultProbabilityTermStructureHandle_allowsExtrapolation', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityTermStructureHandle_allowsExtrapolation`, 'returnType') = 'logical'
attr(`DefaultProbabilityTermStructureHandle_allowsExtrapolation`, "inputTypes") = c('_p_HandleT_DefaultProbabilityTermStructure_t')
class(`DefaultProbabilityTermStructureHandle_allowsExtrapolation`) = c("SWIGFunction", class('DefaultProbabilityTermStructureHandle_allowsExtrapolation'))

# Start of accessor method for Handle<(DefaultProbabilityTermStructure)>
setMethod('$', '_p_HandleT_DefaultProbabilityTermStructure_t', function(x, name)

{
  accessorFuns = list('__deref__' = DefaultProbabilityTermStructureHandle___deref__, 'empty' = DefaultProbabilityTermStructureHandle_empty, 'asObservable' = DefaultProbabilityTermStructureHandle_asObservable, 'dayCounter' = DefaultProbabilityTermStructureHandle_dayCounter, 'calendar' = DefaultProbabilityTermStructureHandle_calendar, 'referenceDate' = DefaultProbabilityTermStructureHandle_referenceDate, 'maxDate' = DefaultProbabilityTermStructureHandle_maxDate, 'maxTime' = DefaultProbabilityTermStructureHandle_maxTime, 'defaultProbability' = DefaultProbabilityTermStructureHandle_defaultProbability, 'survivalProbability' = DefaultProbabilityTermStructureHandle_survivalProbability, 'defaultDensity' = DefaultProbabilityTermStructureHandle_defaultDensity, 'hazardRate' = DefaultProbabilityTermStructureHandle_hazardRate, 'enableExtrapolation' = DefaultProbabilityTermStructureHandle_enableExtrapolation, 'disableExtrapolation' = DefaultProbabilityTermStructureHandle_disableExtrapolation, 'allowsExtrapolation' = DefaultProbabilityTermStructureHandle_allowsExtrapolation);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for Handle<(DefaultProbabilityTermStructure)>
setMethod('delete', '_p_HandleT_DefaultProbabilityTermStructure_t', function(obj) {delete_HandleT_DefaultProbabilityTermStructure_t(obj)})
# Start of new_RelinkableDefaultProbabilityTermStructureHandle

`RelinkableDefaultProbabilityTermStructureHandle__SWIG_0` = function(s_arg1)
{
  ;ans = .Call('R_swig_new_RelinkableDefaultProbabilityTermStructureHandle__SWIG_0', s_arg1, PACKAGE='QuantLib');
  class(ans) <- "_p_RelinkableHandleT_DefaultProbabilityTermStructure_t";
  
  reg.finalizer(ans, delete_RelinkableDefaultProbabilityTermStructureHandle)
  ans
  
}

attr(`RelinkableDefaultProbabilityTermStructureHandle__SWIG_0`, 'returnType') = '_p_RelinkableHandleT_DefaultProbabilityTermStructure_t'
attr(`RelinkableDefaultProbabilityTermStructureHandle__SWIG_0`, "inputTypes") = c('_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t')
class(`RelinkableDefaultProbabilityTermStructureHandle__SWIG_0`) = c("SWIGFunction", class('RelinkableDefaultProbabilityTermStructureHandle__SWIG_0'))

# Start of new_RelinkableDefaultProbabilityTermStructureHandle

`RelinkableDefaultProbabilityTermStructureHandle__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_RelinkableDefaultProbabilityTermStructureHandle__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_RelinkableHandleT_DefaultProbabilityTermStructure_t";
  
  reg.finalizer(ans, delete_RelinkableDefaultProbabilityTermStructureHandle)
  ans
  
}

attr(`RelinkableDefaultProbabilityTermStructureHandle__SWIG_1`, 'returnType') = '_p_RelinkableHandleT_DefaultProbabilityTermStructure_t'
class(`RelinkableDefaultProbabilityTermStructureHandle__SWIG_1`) = c("SWIGFunction", class('RelinkableDefaultProbabilityTermStructureHandle__SWIG_1'))

`RelinkableDefaultProbabilityTermStructureHandle` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- RelinkableDefaultProbabilityTermStructureHandle__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t')) {
      f <- RelinkableDefaultProbabilityTermStructureHandle__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for RelinkableDefaultProbabilityTermStructureHandle with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of RelinkableDefaultProbabilityTermStructureHandle_linkTo

`RelinkableDefaultProbabilityTermStructureHandle_linkTo` = function(self, s_arg2)
{
  ;.Call('R_swig_RelinkableDefaultProbabilityTermStructureHandle_linkTo', self, s_arg2, PACKAGE='QuantLib');
  
}

attr(`RelinkableDefaultProbabilityTermStructureHandle_linkTo`, 'returnType') = 'void'
attr(`RelinkableDefaultProbabilityTermStructureHandle_linkTo`, "inputTypes") = c('_p_RelinkableHandleT_DefaultProbabilityTermStructure_t', '_p_boost__shared_ptrT_DefaultProbabilityTermStructure_t')
class(`RelinkableDefaultProbabilityTermStructureHandle_linkTo`) = c("SWIGFunction", class('RelinkableDefaultProbabilityTermStructureHandle_linkTo'))

# Start of delete_RelinkableDefaultProbabilityTermStructureHandle

`delete_RelinkableDefaultProbabilityTermStructureHandle` = function(self)
{
  ;.Call('R_swig_delete_RelinkableDefaultProbabilityTermStructureHandle', self, PACKAGE='QuantLib');
  
}

attr(`delete_RelinkableDefaultProbabilityTermStructureHandle`, 'returnType') = 'void'
attr(`delete_RelinkableDefaultProbabilityTermStructureHandle`, "inputTypes") = c('_p_RelinkableHandleT_DefaultProbabilityTermStructure_t')
class(`delete_RelinkableDefaultProbabilityTermStructureHandle`) = c("SWIGFunction", class('delete_RelinkableDefaultProbabilityTermStructureHandle'))

# Start of accessor method for RelinkableHandle<(DefaultProbabilityTermStructure)>
setMethod('$', '_p_RelinkableHandleT_DefaultProbabilityTermStructure_t', function(x, name)

{
  accessorFuns = list('linkTo' = RelinkableDefaultProbabilityTermStructureHandle_linkTo);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for RelinkableHandle<(DefaultProbabilityTermStructure)>
setMethod('delete', '_p_RelinkableHandleT_DefaultProbabilityTermStructure_t', function(obj) {delete_RelinkableHandleT_DefaultProbabilityTermStructure_t(obj)})
# Start of new_FlatHazardRate

`FlatHazardRate__SWIG_0` = function(settlementDays, calendar, hazardRate, dayCounter)
{
  settlementDays = as.integer(settlementDays); 
  
  if(length(settlementDays) > 1) {
    warning("using only the first element of settlementDays");
  };
  
  
  
  
  ;ans = .Call('R_swig_new_FlatHazardRate__SWIG_0', settlementDays, calendar, hazardRate, dayCounter, PACKAGE='QuantLib');
  class(ans) <- "_p_FlatHazardRatePtr";
  
  reg.finalizer(ans, delete_FlatHazardRate)
  ans
  
}

attr(`FlatHazardRate__SWIG_0`, 'returnType') = '_p_FlatHazardRatePtr'
attr(`FlatHazardRate__SWIG_0`, "inputTypes") = c('integer', '_p_Calendar', '_p_HandleT_Quote_t', '_p_DayCounter')
class(`FlatHazardRate__SWIG_0`) = c("SWIGFunction", class('FlatHazardRate__SWIG_0'))

# Start of new_FlatHazardRate

`FlatHazardRate__SWIG_1` = function(todaysDate, hazardRate, dayCounter)
{
  ;ans = .Call('R_swig_new_FlatHazardRate__SWIG_1', todaysDate, hazardRate, dayCounter, PACKAGE='QuantLib');
  class(ans) <- "_p_FlatHazardRatePtr";
  
  reg.finalizer(ans, delete_FlatHazardRate)
  ans
  
}

attr(`FlatHazardRate__SWIG_1`, 'returnType') = '_p_FlatHazardRatePtr'
attr(`FlatHazardRate__SWIG_1`, "inputTypes") = c('_p_Date', '_p_HandleT_Quote_t', '_p_DayCounter')
class(`FlatHazardRate__SWIG_1`) = c("SWIGFunction", class('FlatHazardRate__SWIG_1'))

`FlatHazardRate` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 3) {
    if (extends(argtypes[1], '_p_Date') && extends(argtypes[2], '_p_HandleT_Quote_t') && extends(argtypes[3], '_p_DayCounter')) {
      f <- FlatHazardRate__SWIG_1; 
    }
  } else if (argc == 4) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && extends(argtypes[2], '_p_Calendar') && extends(argtypes[3], '_p_HandleT_Quote_t') && extends(argtypes[4], '_p_DayCounter')) {
      f <- FlatHazardRate__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for FlatHazardRate with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_FlatHazardRate

`delete_FlatHazardRate` = function(self)
{
  ;.Call('R_swig_delete_FlatHazardRate', self, PACKAGE='QuantLib');
  
}

attr(`delete_FlatHazardRate`, 'returnType') = 'void'
attr(`delete_FlatHazardRate`, "inputTypes") = c('_p_FlatHazardRatePtr')
class(`delete_FlatHazardRate`) = c("SWIGFunction", class('delete_FlatHazardRate'))

setMethod('delete', '_p_FlatHazardRatePtr', function(obj) {delete_FlatHazardRatePtr(obj)})
# Start of new_HazardRateCurve

`HazardRateCurve__SWIG_0` = function(dates, hazardRates, dayCounter, calendar, i)
{
  ;ans = .Call('R_swig_new_HazardRateCurve__SWIG_0', dates, hazardRates, dayCounter, calendar, i, PACKAGE='QuantLib');
  class(ans) <- "_p_HazardRateCurvePtr";
  
  reg.finalizer(ans, delete_HazardRateCurve)
  ans
  
}

attr(`HazardRateCurve__SWIG_0`, 'returnType') = '_p_HazardRateCurvePtr'
attr(`HazardRateCurve__SWIG_0`, "inputTypes") = c('_p_std__vectorT_Date_std__allocatorT_Date_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_DayCounter', '_p_Calendar', '_p_BackwardFlat')
class(`HazardRateCurve__SWIG_0`) = c("SWIGFunction", class('HazardRateCurve__SWIG_0'))

# Start of new_HazardRateCurve

`HazardRateCurve__SWIG_1` = function(dates, hazardRates, dayCounter, calendar)
{
  ;ans = .Call('R_swig_new_HazardRateCurve__SWIG_1', dates, hazardRates, dayCounter, calendar, PACKAGE='QuantLib');
  class(ans) <- "_p_HazardRateCurvePtr";
  
  reg.finalizer(ans, delete_HazardRateCurve)
  ans
  
}

attr(`HazardRateCurve__SWIG_1`, 'returnType') = '_p_HazardRateCurvePtr'
attr(`HazardRateCurve__SWIG_1`, "inputTypes") = c('_p_std__vectorT_Date_std__allocatorT_Date_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_DayCounter', '_p_Calendar')
class(`HazardRateCurve__SWIG_1`) = c("SWIGFunction", class('HazardRateCurve__SWIG_1'))

# Start of new_HazardRateCurve

`HazardRateCurve__SWIG_2` = function(dates, hazardRates, dayCounter)
{
  ;ans = .Call('R_swig_new_HazardRateCurve__SWIG_2', dates, hazardRates, dayCounter, PACKAGE='QuantLib');
  class(ans) <- "_p_HazardRateCurvePtr";
  
  reg.finalizer(ans, delete_HazardRateCurve)
  ans
  
}

attr(`HazardRateCurve__SWIG_2`, 'returnType') = '_p_HazardRateCurvePtr'
attr(`HazardRateCurve__SWIG_2`, "inputTypes") = c('_p_std__vectorT_Date_std__allocatorT_Date_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_DayCounter')
class(`HazardRateCurve__SWIG_2`) = c("SWIGFunction", class('HazardRateCurve__SWIG_2'))

`HazardRateCurve` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 3) {
    if (extends(argtypes[1], '_p_std__vectorT_Date_std__allocatorT_Date_t_t') && extends(argtypes[2], '_p_std__vectorT_double_std__allocatorT_double_t_t') && extends(argtypes[3], '_p_DayCounter')) {
      f <- HazardRateCurve__SWIG_2; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_std__vectorT_Date_std__allocatorT_Date_t_t') && extends(argtypes[2], '_p_std__vectorT_double_std__allocatorT_double_t_t') && extends(argtypes[3], '_p_DayCounter') && extends(argtypes[4], '_p_Calendar')) {
      f <- HazardRateCurve__SWIG_1; 
    }
  } else if (argc == 5) {
    if (extends(argtypes[1], '_p_std__vectorT_Date_std__allocatorT_Date_t_t') && extends(argtypes[2], '_p_std__vectorT_double_std__allocatorT_double_t_t') && extends(argtypes[3], '_p_DayCounter') && extends(argtypes[4], '_p_Calendar') && extends(argtypes[5], '_p_BackwardFlat')) {
      f <- HazardRateCurve__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for HazardRateCurve with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of HazardRateCurve_dates

`HazardRateCurve_dates` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_HazardRateCurve_dates', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_Date_std__allocatorT_Date_t_t";
  
  ans
  
}

attr(`HazardRateCurve_dates`, 'returnType') = '_p_std__vectorT_Date_std__allocatorT_Date_t_t'
attr(`HazardRateCurve_dates`, "inputTypes") = c('_p_HazardRateCurvePtr')
class(`HazardRateCurve_dates`) = c("SWIGFunction", class('HazardRateCurve_dates'))

# Start of HazardRateCurve_hazardRates

`HazardRateCurve_hazardRates` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_HazardRateCurve_hazardRates', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_double_std__allocatorT_double_t_t";
  
  ans
  
}

attr(`HazardRateCurve_hazardRates`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`HazardRateCurve_hazardRates`, "inputTypes") = c('_p_HazardRateCurvePtr')
class(`HazardRateCurve_hazardRates`) = c("SWIGFunction", class('HazardRateCurve_hazardRates'))

# Start of delete_HazardRateCurve

`delete_HazardRateCurve` = function(self)
{
  ;.Call('R_swig_delete_HazardRateCurve', self, PACKAGE='QuantLib');
  
}

attr(`delete_HazardRateCurve`, 'returnType') = 'void'
attr(`delete_HazardRateCurve`, "inputTypes") = c('_p_HazardRateCurvePtr')
class(`delete_HazardRateCurve`) = c("SWIGFunction", class('delete_HazardRateCurve'))

# Start of accessor method for HazardRateCurvePtr
setMethod('$', '_p_HazardRateCurvePtr', function(x, name)

{
  accessorFuns = list('dates' = HazardRateCurve_dates, 'hazardRates' = HazardRateCurve_hazardRates);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for HazardRateCurvePtr
setMethod('delete', '_p_HazardRateCurvePtr', function(obj) {delete_HazardRateCurvePtr(obj)})
# Start of new_DefaultDensityCurve

`DefaultDensityCurve__SWIG_0` = function(dates, densities, dayCounter, calendar, i)
{
  ;ans = .Call('R_swig_new_DefaultDensityCurve__SWIG_0', dates, densities, dayCounter, calendar, i, PACKAGE='QuantLib');
  class(ans) <- "_p_DefaultDensityCurvePtr";
  
  reg.finalizer(ans, delete_DefaultDensityCurve)
  ans
  
}

attr(`DefaultDensityCurve__SWIG_0`, 'returnType') = '_p_DefaultDensityCurvePtr'
attr(`DefaultDensityCurve__SWIG_0`, "inputTypes") = c('_p_std__vectorT_Date_std__allocatorT_Date_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_DayCounter', '_p_Calendar', '_p_Linear')
class(`DefaultDensityCurve__SWIG_0`) = c("SWIGFunction", class('DefaultDensityCurve__SWIG_0'))

# Start of new_DefaultDensityCurve

`DefaultDensityCurve__SWIG_1` = function(dates, densities, dayCounter, calendar)
{
  ;ans = .Call('R_swig_new_DefaultDensityCurve__SWIG_1', dates, densities, dayCounter, calendar, PACKAGE='QuantLib');
  class(ans) <- "_p_DefaultDensityCurvePtr";
  
  reg.finalizer(ans, delete_DefaultDensityCurve)
  ans
  
}

attr(`DefaultDensityCurve__SWIG_1`, 'returnType') = '_p_DefaultDensityCurvePtr'
attr(`DefaultDensityCurve__SWIG_1`, "inputTypes") = c('_p_std__vectorT_Date_std__allocatorT_Date_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_DayCounter', '_p_Calendar')
class(`DefaultDensityCurve__SWIG_1`) = c("SWIGFunction", class('DefaultDensityCurve__SWIG_1'))

# Start of new_DefaultDensityCurve

`DefaultDensityCurve__SWIG_2` = function(dates, densities, dayCounter)
{
  ;ans = .Call('R_swig_new_DefaultDensityCurve__SWIG_2', dates, densities, dayCounter, PACKAGE='QuantLib');
  class(ans) <- "_p_DefaultDensityCurvePtr";
  
  reg.finalizer(ans, delete_DefaultDensityCurve)
  ans
  
}

attr(`DefaultDensityCurve__SWIG_2`, 'returnType') = '_p_DefaultDensityCurvePtr'
attr(`DefaultDensityCurve__SWIG_2`, "inputTypes") = c('_p_std__vectorT_Date_std__allocatorT_Date_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_DayCounter')
class(`DefaultDensityCurve__SWIG_2`) = c("SWIGFunction", class('DefaultDensityCurve__SWIG_2'))

`DefaultDensityCurve` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 3) {
    if (extends(argtypes[1], '_p_std__vectorT_Date_std__allocatorT_Date_t_t') && extends(argtypes[2], '_p_std__vectorT_double_std__allocatorT_double_t_t') && extends(argtypes[3], '_p_DayCounter')) {
      f <- DefaultDensityCurve__SWIG_2; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_std__vectorT_Date_std__allocatorT_Date_t_t') && extends(argtypes[2], '_p_std__vectorT_double_std__allocatorT_double_t_t') && extends(argtypes[3], '_p_DayCounter') && extends(argtypes[4], '_p_Calendar')) {
      f <- DefaultDensityCurve__SWIG_1; 
    }
  } else if (argc == 5) {
    if (extends(argtypes[1], '_p_std__vectorT_Date_std__allocatorT_Date_t_t') && extends(argtypes[2], '_p_std__vectorT_double_std__allocatorT_double_t_t') && extends(argtypes[3], '_p_DayCounter') && extends(argtypes[4], '_p_Calendar') && extends(argtypes[5], '_p_Linear')) {
      f <- DefaultDensityCurve__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for DefaultDensityCurve with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of DefaultDensityCurve_dates

`DefaultDensityCurve_dates` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_DefaultDensityCurve_dates', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_Date_std__allocatorT_Date_t_t";
  
  ans
  
}

attr(`DefaultDensityCurve_dates`, 'returnType') = '_p_std__vectorT_Date_std__allocatorT_Date_t_t'
attr(`DefaultDensityCurve_dates`, "inputTypes") = c('_p_DefaultDensityCurvePtr')
class(`DefaultDensityCurve_dates`) = c("SWIGFunction", class('DefaultDensityCurve_dates'))

# Start of DefaultDensityCurve_defaultDensities

`DefaultDensityCurve_defaultDensities` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_DefaultDensityCurve_defaultDensities', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_double_std__allocatorT_double_t_t";
  
  ans
  
}

attr(`DefaultDensityCurve_defaultDensities`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`DefaultDensityCurve_defaultDensities`, "inputTypes") = c('_p_DefaultDensityCurvePtr')
class(`DefaultDensityCurve_defaultDensities`) = c("SWIGFunction", class('DefaultDensityCurve_defaultDensities'))

# Start of delete_DefaultDensityCurve

`delete_DefaultDensityCurve` = function(self)
{
  ;.Call('R_swig_delete_DefaultDensityCurve', self, PACKAGE='QuantLib');
  
}

attr(`delete_DefaultDensityCurve`, 'returnType') = 'void'
attr(`delete_DefaultDensityCurve`, "inputTypes") = c('_p_DefaultDensityCurvePtr')
class(`delete_DefaultDensityCurve`) = c("SWIGFunction", class('delete_DefaultDensityCurve'))

# Start of accessor method for DefaultDensityCurvePtr
setMethod('$', '_p_DefaultDensityCurvePtr', function(x, name)

{
  accessorFuns = list('dates' = DefaultDensityCurve_dates, 'defaultDensities' = DefaultDensityCurve_defaultDensities);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for DefaultDensityCurvePtr
setMethod('delete', '_p_DefaultDensityCurvePtr', function(obj) {delete_DefaultDensityCurvePtr(obj)})
# Start of DefaultProbabilityHelper___deref__

`DefaultProbabilityHelper___deref__` = function(self)
{
  ;ans = .Call('R_swig_DefaultProbabilityHelper___deref__', self, PACKAGE='QuantLib');
  class(ans) <- "_p_DefaultProbabilityHelper";
  
  ans
  
}

attr(`DefaultProbabilityHelper___deref__`, 'returnType') = '_p_DefaultProbabilityHelper'
attr(`DefaultProbabilityHelper___deref__`, "inputTypes") = c('_p_boost__shared_ptrT_DefaultProbabilityHelper_t')
class(`DefaultProbabilityHelper___deref__`) = c("SWIGFunction", class('DefaultProbabilityHelper___deref__'))

# Start of DefaultProbabilityHelper_isNull

`DefaultProbabilityHelper_isNull` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_DefaultProbabilityHelper_isNull', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityHelper_isNull`, 'returnType') = 'logical'
attr(`DefaultProbabilityHelper_isNull`, "inputTypes") = c('_p_boost__shared_ptrT_DefaultProbabilityHelper_t')
class(`DefaultProbabilityHelper_isNull`) = c("SWIGFunction", class('DefaultProbabilityHelper_isNull'))

# Start of new_DefaultProbabilityHelper

`DefaultProbabilityHelper` = function()
{
  ;ans = .Call('R_swig_new_DefaultProbabilityHelper', PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_DefaultProbabilityHelper_t";
  
  reg.finalizer(ans, delete_DefaultProbabilityHelper)
  ans
  
}

attr(`DefaultProbabilityHelper`, 'returnType') = '_p_boost__shared_ptrT_DefaultProbabilityHelper_t'
class(`DefaultProbabilityHelper`) = c("SWIGFunction", class('DefaultProbabilityHelper'))

# Start of delete_DefaultProbabilityHelper

`delete_DefaultProbabilityHelper` = function(self)
{
  ;.Call('R_swig_delete_DefaultProbabilityHelper', self, PACKAGE='QuantLib');
  
}

attr(`delete_DefaultProbabilityHelper`, 'returnType') = 'void'
attr(`delete_DefaultProbabilityHelper`, "inputTypes") = c('_p_boost__shared_ptrT_DefaultProbabilityHelper_t')
class(`delete_DefaultProbabilityHelper`) = c("SWIGFunction", class('delete_DefaultProbabilityHelper'))

# Start of accessor method for boost::shared_ptr<(DefaultProbabilityHelper)>
setMethod('$', '_p_boost__shared_ptrT_DefaultProbabilityHelper_t', function(x, name)

{
  accessorFuns = list('__deref__' = DefaultProbabilityHelper___deref__, 'isNull' = DefaultProbabilityHelper_isNull);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for boost::shared_ptr<(DefaultProbabilityHelper)>
setMethod('delete', '_p_boost__shared_ptrT_DefaultProbabilityHelper_t', function(obj) {delete_boost__shared_ptrT_DefaultProbabilityHelper_t(obj)})
# Start of DefaultProbabilityHelperVector___nonzero__

`DefaultProbabilityHelperVector___nonzero__` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_DefaultProbabilityHelperVector___nonzero__', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityHelperVector___nonzero__`, 'returnType') = 'logical'
attr(`DefaultProbabilityHelperVector___nonzero__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_DefaultProbabilityHelper_t_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t_t')
class(`DefaultProbabilityHelperVector___nonzero__`) = c("SWIGFunction", class('DefaultProbabilityHelperVector___nonzero__'))

# Start of DefaultProbabilityHelperVector___len__

`DefaultProbabilityHelperVector___len__` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_DefaultProbabilityHelperVector___len__', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`DefaultProbabilityHelperVector___len__`, 'returnType') = 'integer'
attr(`DefaultProbabilityHelperVector___len__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_DefaultProbabilityHelper_t_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t_t')
class(`DefaultProbabilityHelperVector___len__`) = c("SWIGFunction", class('DefaultProbabilityHelperVector___len__'))

# Start of DefaultProbabilityHelperVector_pop

`DefaultProbabilityHelperVector_pop` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_DefaultProbabilityHelperVector_pop', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_DefaultProbabilityHelper_t";
  
  ans
  
}

attr(`DefaultProbabilityHelperVector_pop`, 'returnType') = '_p_boost__shared_ptrT_DefaultProbabilityHelper_t'
attr(`DefaultProbabilityHelperVector_pop`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_DefaultProbabilityHelper_t_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t_t')
class(`DefaultProbabilityHelperVector_pop`) = c("SWIGFunction", class('DefaultProbabilityHelperVector_pop'))

# Start of DefaultProbabilityHelperVector___getslice__

`DefaultProbabilityHelperVector___getslice__` = function(self, i, j)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;ans = .Call('R_swig_DefaultProbabilityHelperVector___getslice__', self, i, j, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_DefaultProbabilityHelper_t_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t_t";
  
  ans
  
}

attr(`DefaultProbabilityHelperVector___getslice__`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_DefaultProbabilityHelper_t_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t_t'
attr(`DefaultProbabilityHelperVector___getslice__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_DefaultProbabilityHelper_t_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t_t', 'integer', 'integer')
class(`DefaultProbabilityHelperVector___getslice__`) = c("SWIGFunction", class('DefaultProbabilityHelperVector___getslice__'))

# Start of DefaultProbabilityHelperVector___setslice__

`DefaultProbabilityHelperVector___setslice__` = function(self, i, j, v)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  
  ;.Call('R_swig_DefaultProbabilityHelperVector___setslice__', self, i, j, v, PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityHelperVector___setslice__`, 'returnType') = 'void'
attr(`DefaultProbabilityHelperVector___setslice__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_DefaultProbabilityHelper_t_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t_t', 'integer', 'integer', '_p_std__vectorT_boost__shared_ptrT_DefaultProbabilityHelper_t_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t_t')
class(`DefaultProbabilityHelperVector___setslice__`) = c("SWIGFunction", class('DefaultProbabilityHelperVector___setslice__'))

# Start of DefaultProbabilityHelperVector___delslice__

`DefaultProbabilityHelperVector___delslice__` = function(self, i, j)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_DefaultProbabilityHelperVector___delslice__', self, i, j, PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityHelperVector___delslice__`, 'returnType') = 'void'
attr(`DefaultProbabilityHelperVector___delslice__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_DefaultProbabilityHelper_t_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t_t', 'integer', 'integer')
class(`DefaultProbabilityHelperVector___delslice__`) = c("SWIGFunction", class('DefaultProbabilityHelperVector___delslice__'))

# Start of DefaultProbabilityHelperVector___delitem__

`DefaultProbabilityHelperVector___delitem__` = function(self, i)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_DefaultProbabilityHelperVector___delitem__', self, i, PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityHelperVector___delitem__`, 'returnType') = 'void'
attr(`DefaultProbabilityHelperVector___delitem__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_DefaultProbabilityHelper_t_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t_t', 'integer')
class(`DefaultProbabilityHelperVector___delitem__`) = c("SWIGFunction", class('DefaultProbabilityHelperVector___delitem__'))

# Start of DefaultProbabilityHelperVector___getitem__

`DefaultProbabilityHelperVector___getitem__` = function(self, i, .copy = FALSE)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;ans = .Call('R_swig_DefaultProbabilityHelperVector___getitem__', self, i, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_DefaultProbabilityHelper_t";
  
  ans
  
}

attr(`DefaultProbabilityHelperVector___getitem__`, 'returnType') = '_p_boost__shared_ptrT_DefaultProbabilityHelper_t'
attr(`DefaultProbabilityHelperVector___getitem__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_DefaultProbabilityHelper_t_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t_t', 'integer')
class(`DefaultProbabilityHelperVector___getitem__`) = c("SWIGFunction", class('DefaultProbabilityHelperVector___getitem__'))

# Start of DefaultProbabilityHelperVector___setitem__

`DefaultProbabilityHelperVector___setitem__` = function(self, i, x)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  ;.Call('R_swig_DefaultProbabilityHelperVector___setitem__', self, i, x, PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityHelperVector___setitem__`, 'returnType') = 'void'
attr(`DefaultProbabilityHelperVector___setitem__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_DefaultProbabilityHelper_t_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t_t', 'integer', '_p_boost__shared_ptrT_DefaultProbabilityHelper_t')
class(`DefaultProbabilityHelperVector___setitem__`) = c("SWIGFunction", class('DefaultProbabilityHelperVector___setitem__'))

# Start of DefaultProbabilityHelperVector_append

`DefaultProbabilityHelperVector_append` = function(self, x)
{
  ;.Call('R_swig_DefaultProbabilityHelperVector_append', self, x, PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityHelperVector_append`, 'returnType') = 'void'
attr(`DefaultProbabilityHelperVector_append`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_DefaultProbabilityHelper_t_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t_t', '_p_boost__shared_ptrT_DefaultProbabilityHelper_t')
class(`DefaultProbabilityHelperVector_append`) = c("SWIGFunction", class('DefaultProbabilityHelperVector_append'))

# Start of new_DefaultProbabilityHelperVector

`DefaultProbabilityHelperVector__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_DefaultProbabilityHelperVector__SWIG_0', PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_DefaultProbabilityHelper_t_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t_t";
  
  reg.finalizer(ans, delete_DefaultProbabilityHelperVector)
  ans
  
}

attr(`DefaultProbabilityHelperVector__SWIG_0`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_DefaultProbabilityHelper_t_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t_t'
class(`DefaultProbabilityHelperVector__SWIG_0`) = c("SWIGFunction", class('DefaultProbabilityHelperVector__SWIG_0'))

# Start of new_DefaultProbabilityHelperVector

`DefaultProbabilityHelperVector__SWIG_1` = function(s_arg1)
{
  ;ans = .Call('R_swig_new_DefaultProbabilityHelperVector__SWIG_1', s_arg1, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_DefaultProbabilityHelper_t_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t_t";
  
  reg.finalizer(ans, delete_DefaultProbabilityHelperVector)
  ans
  
}

attr(`DefaultProbabilityHelperVector__SWIG_1`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_DefaultProbabilityHelper_t_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t_t'
attr(`DefaultProbabilityHelperVector__SWIG_1`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_DefaultProbabilityHelper_t_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t_t')
class(`DefaultProbabilityHelperVector__SWIG_1`) = c("SWIGFunction", class('DefaultProbabilityHelperVector__SWIG_1'))

# Start of DefaultProbabilityHelperVector_empty

`DefaultProbabilityHelperVector_empty` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_DefaultProbabilityHelperVector_empty', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityHelperVector_empty`, 'returnType') = 'logical'
attr(`DefaultProbabilityHelperVector_empty`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_DefaultProbabilityHelper_t_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t_t')
class(`DefaultProbabilityHelperVector_empty`) = c("SWIGFunction", class('DefaultProbabilityHelperVector_empty'))

# Start of DefaultProbabilityHelperVector_size

`DefaultProbabilityHelperVector_size` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_DefaultProbabilityHelperVector_size', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`DefaultProbabilityHelperVector_size`, 'returnType') = 'integer'
attr(`DefaultProbabilityHelperVector_size`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_DefaultProbabilityHelper_t_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t_t')
class(`DefaultProbabilityHelperVector_size`) = c("SWIGFunction", class('DefaultProbabilityHelperVector_size'))

# Start of DefaultProbabilityHelperVector_clear

`DefaultProbabilityHelperVector_clear` = function(self)
{
  ;.Call('R_swig_DefaultProbabilityHelperVector_clear', self, PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityHelperVector_clear`, 'returnType') = 'void'
attr(`DefaultProbabilityHelperVector_clear`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_DefaultProbabilityHelper_t_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t_t')
class(`DefaultProbabilityHelperVector_clear`) = c("SWIGFunction", class('DefaultProbabilityHelperVector_clear'))

# Start of DefaultProbabilityHelperVector_swap

`DefaultProbabilityHelperVector_swap` = function(self, v)
{
  ;.Call('R_swig_DefaultProbabilityHelperVector_swap', self, v, PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityHelperVector_swap`, 'returnType') = 'void'
attr(`DefaultProbabilityHelperVector_swap`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_DefaultProbabilityHelper_t_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t_t', '_p_std__vectorT_boost__shared_ptrT_DefaultProbabilityHelper_t_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t_t')
class(`DefaultProbabilityHelperVector_swap`) = c("SWIGFunction", class('DefaultProbabilityHelperVector_swap'))

# Start of DefaultProbabilityHelperVector_get_allocator

`DefaultProbabilityHelperVector_get_allocator` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_DefaultProbabilityHelperVector_get_allocator', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t";
  
  ans
  
}

attr(`DefaultProbabilityHelperVector_get_allocator`, 'returnType') = '_p_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t'
attr(`DefaultProbabilityHelperVector_get_allocator`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_DefaultProbabilityHelper_t_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t_t')
class(`DefaultProbabilityHelperVector_get_allocator`) = c("SWIGFunction", class('DefaultProbabilityHelperVector_get_allocator'))

# Start of new_DefaultProbabilityHelperVector

`DefaultProbabilityHelperVector__SWIG_2` = function(size)
{
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_new_DefaultProbabilityHelperVector__SWIG_2', size, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_DefaultProbabilityHelper_t_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t_t";
  
  reg.finalizer(ans, delete_DefaultProbabilityHelperVector)
  ans
  
}

attr(`DefaultProbabilityHelperVector__SWIG_2`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_DefaultProbabilityHelper_t_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t_t'
attr(`DefaultProbabilityHelperVector__SWIG_2`, "inputTypes") = c('integer')
class(`DefaultProbabilityHelperVector__SWIG_2`) = c("SWIGFunction", class('DefaultProbabilityHelperVector__SWIG_2'))

# Start of DefaultProbabilityHelperVector_pop_back

`DefaultProbabilityHelperVector_pop_back` = function(self)
{
  ;.Call('R_swig_DefaultProbabilityHelperVector_pop_back', self, PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityHelperVector_pop_back`, 'returnType') = 'void'
attr(`DefaultProbabilityHelperVector_pop_back`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_DefaultProbabilityHelper_t_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t_t')
class(`DefaultProbabilityHelperVector_pop_back`) = c("SWIGFunction", class('DefaultProbabilityHelperVector_pop_back'))

# Start of DefaultProbabilityHelperVector_resize

`DefaultProbabilityHelperVector_resize__SWIG_0` = function(self, new_size)
{
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_DefaultProbabilityHelperVector_resize__SWIG_0', self, new_size, PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityHelperVector_resize__SWIG_0`, 'returnType') = 'void'
attr(`DefaultProbabilityHelperVector_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_DefaultProbabilityHelper_t_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t_t', 'integer')
class(`DefaultProbabilityHelperVector_resize__SWIG_0`) = c("SWIGFunction", class('DefaultProbabilityHelperVector_resize__SWIG_0'))

# Start of new_DefaultProbabilityHelperVector

`DefaultProbabilityHelperVector__SWIG_3` = function(size, value)
{
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  
  ;ans = .Call('R_swig_new_DefaultProbabilityHelperVector__SWIG_3', size, value, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_DefaultProbabilityHelper_t_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t_t";
  
  reg.finalizer(ans, delete_DefaultProbabilityHelperVector)
  ans
  
}

attr(`DefaultProbabilityHelperVector__SWIG_3`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_DefaultProbabilityHelper_t_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t_t'
attr(`DefaultProbabilityHelperVector__SWIG_3`, "inputTypes") = c('integer', '_p_boost__shared_ptrT_DefaultProbabilityHelper_t')
class(`DefaultProbabilityHelperVector__SWIG_3`) = c("SWIGFunction", class('DefaultProbabilityHelperVector__SWIG_3'))

`DefaultProbabilityHelperVector` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- DefaultProbabilityHelperVector__SWIG_0; 
  } else if (argc == 1) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]]))) {
      f <- DefaultProbabilityHelperVector__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_DefaultProbabilityHelper_t_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t_t')) {
      f <- DefaultProbabilityHelperVector__SWIG_1; 
    }
  } else if (argc == 2) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && extends(argtypes[2], '_p_boost__shared_ptrT_DefaultProbabilityHelper_t')) {
      f <- DefaultProbabilityHelperVector__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for DefaultProbabilityHelperVector with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of DefaultProbabilityHelperVector_push_back

`DefaultProbabilityHelperVector_push_back` = function(self, x)
{
  ;.Call('R_swig_DefaultProbabilityHelperVector_push_back', self, x, PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityHelperVector_push_back`, 'returnType') = 'void'
attr(`DefaultProbabilityHelperVector_push_back`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_DefaultProbabilityHelper_t_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t_t', '_p_boost__shared_ptrT_DefaultProbabilityHelper_t')
class(`DefaultProbabilityHelperVector_push_back`) = c("SWIGFunction", class('DefaultProbabilityHelperVector_push_back'))

# Start of DefaultProbabilityHelperVector_front

`DefaultProbabilityHelperVector_front` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_DefaultProbabilityHelperVector_front', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_DefaultProbabilityHelper_t";
  
  ans
  
}

attr(`DefaultProbabilityHelperVector_front`, 'returnType') = '_p_boost__shared_ptrT_DefaultProbabilityHelper_t'
attr(`DefaultProbabilityHelperVector_front`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_DefaultProbabilityHelper_t_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t_t')
class(`DefaultProbabilityHelperVector_front`) = c("SWIGFunction", class('DefaultProbabilityHelperVector_front'))

# Start of DefaultProbabilityHelperVector_back

`DefaultProbabilityHelperVector_back` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_DefaultProbabilityHelperVector_back', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_DefaultProbabilityHelper_t";
  
  ans
  
}

attr(`DefaultProbabilityHelperVector_back`, 'returnType') = '_p_boost__shared_ptrT_DefaultProbabilityHelper_t'
attr(`DefaultProbabilityHelperVector_back`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_DefaultProbabilityHelper_t_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t_t')
class(`DefaultProbabilityHelperVector_back`) = c("SWIGFunction", class('DefaultProbabilityHelperVector_back'))

# Start of DefaultProbabilityHelperVector_assign

`DefaultProbabilityHelperVector_assign` = function(self, n, x)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  
  ;.Call('R_swig_DefaultProbabilityHelperVector_assign', self, n, x, PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityHelperVector_assign`, 'returnType') = 'void'
attr(`DefaultProbabilityHelperVector_assign`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_DefaultProbabilityHelper_t_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t_t', 'integer', '_p_boost__shared_ptrT_DefaultProbabilityHelper_t')
class(`DefaultProbabilityHelperVector_assign`) = c("SWIGFunction", class('DefaultProbabilityHelperVector_assign'))

# Start of DefaultProbabilityHelperVector_resize

`DefaultProbabilityHelperVector_resize__SWIG_1` = function(self, new_size, x)
{
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  
  ;.Call('R_swig_DefaultProbabilityHelperVector_resize__SWIG_1', self, new_size, x, PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityHelperVector_resize__SWIG_1`, 'returnType') = 'void'
attr(`DefaultProbabilityHelperVector_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_DefaultProbabilityHelper_t_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t_t', 'integer', '_p_boost__shared_ptrT_DefaultProbabilityHelper_t')
class(`DefaultProbabilityHelperVector_resize__SWIG_1`) = c("SWIGFunction", class('DefaultProbabilityHelperVector_resize__SWIG_1'))

`DefaultProbabilityHelperVector_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_DefaultProbabilityHelper_t_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]]))) {
      f <- DefaultProbabilityHelperVector_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_DefaultProbabilityHelper_t_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && extends(argtypes[3], '_p_boost__shared_ptrT_DefaultProbabilityHelper_t')) {
      f <- DefaultProbabilityHelperVector_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for DefaultProbabilityHelperVector_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of DefaultProbabilityHelperVector_reserve

`DefaultProbabilityHelperVector_reserve` = function(self, n)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_DefaultProbabilityHelperVector_reserve', self, n, PACKAGE='QuantLib');
  
}

attr(`DefaultProbabilityHelperVector_reserve`, 'returnType') = 'void'
attr(`DefaultProbabilityHelperVector_reserve`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_DefaultProbabilityHelper_t_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t_t', 'integer')
class(`DefaultProbabilityHelperVector_reserve`) = c("SWIGFunction", class('DefaultProbabilityHelperVector_reserve'))

# Start of DefaultProbabilityHelperVector_capacity

`DefaultProbabilityHelperVector_capacity` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_DefaultProbabilityHelperVector_capacity', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`DefaultProbabilityHelperVector_capacity`, 'returnType') = 'integer'
attr(`DefaultProbabilityHelperVector_capacity`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_DefaultProbabilityHelper_t_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t_t')
class(`DefaultProbabilityHelperVector_capacity`) = c("SWIGFunction", class('DefaultProbabilityHelperVector_capacity'))

# Start of delete_DefaultProbabilityHelperVector

`delete_DefaultProbabilityHelperVector` = function(self)
{
  ;.Call('R_swig_delete_DefaultProbabilityHelperVector', self, PACKAGE='QuantLib');
  
}

attr(`delete_DefaultProbabilityHelperVector`, 'returnType') = 'void'
attr(`delete_DefaultProbabilityHelperVector`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_DefaultProbabilityHelper_t_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t_t')
class(`delete_DefaultProbabilityHelperVector`) = c("SWIGFunction", class('delete_DefaultProbabilityHelperVector'))

# Start of accessor method for std::vector<(boost::shared_ptr<(DefaultProbabilityHelper)>)>
setMethod('$', '_p_std__vectorT_boost__shared_ptrT_DefaultProbabilityHelper_t_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = DefaultProbabilityHelperVector___nonzero__, '__len__' = DefaultProbabilityHelperVector___len__, 'pop' = DefaultProbabilityHelperVector_pop, '__getslice__' = DefaultProbabilityHelperVector___getslice__, '__setslice__' = DefaultProbabilityHelperVector___setslice__, '__delslice__' = DefaultProbabilityHelperVector___delslice__, '__delitem__' = DefaultProbabilityHelperVector___delitem__, '__getitem__' = DefaultProbabilityHelperVector___getitem__, '__setitem__' = DefaultProbabilityHelperVector___setitem__, 'append' = DefaultProbabilityHelperVector_append, 'empty' = DefaultProbabilityHelperVector_empty, 'size' = DefaultProbabilityHelperVector_size, 'clear' = DefaultProbabilityHelperVector_clear, 'swap' = DefaultProbabilityHelperVector_swap, 'get_allocator' = DefaultProbabilityHelperVector_get_allocator, 'pop_back' = DefaultProbabilityHelperVector_pop_back, 'resize' = DefaultProbabilityHelperVector_resize, 'push_back' = DefaultProbabilityHelperVector_push_back, 'front' = DefaultProbabilityHelperVector_front, 'back' = DefaultProbabilityHelperVector_back, 'assign' = DefaultProbabilityHelperVector_assign, 'reserve' = DefaultProbabilityHelperVector_reserve, 'capacity' = DefaultProbabilityHelperVector_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for std::vector<(boost::shared_ptr<(DefaultProbabilityHelper)>)>
setMethod('delete', '_p_std__vectorT_boost__shared_ptrT_DefaultProbabilityHelper_t_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t_t', function(obj) {delete_std__vectorT_boost__shared_ptrT_DefaultProbabilityHelper_t_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t_t(obj)})
# Start of new_SpreadCdsHelper

`SpreadCdsHelper__SWIG_0` = function(spread, tenor, settlementDays, calendar, frequency, convention, rule, dayCounter, recoveryRate, discountCurve, settlesAccrual, paysAtDefaultTime)
{
  settlementDays = as.integer(settlementDays); 
  
  if(length(settlementDays) > 1) {
    warning("using only the first element of settlementDays");
  };
  
  
  frequency = enumToInteger(frequency, "_Frequency"); 
  
  if(length(frequency) > 1) {
    warning("using only the first element of frequency");
  };
  
  convention = enumToInteger(convention, "_BusinessDayConvention"); 
  
  if(length(convention) > 1) {
    warning("using only the first element of convention");
  };
  
  rule = enumToInteger(rule, "_DateGeneration__Rule"); 
  
  if(length(rule) > 1) {
    warning("using only the first element of rule");
  };
  
  
  
  
  settlesAccrual = as.logical(settlesAccrual);
  paysAtDefaultTime = as.logical(paysAtDefaultTime);
  ;ans = .Call('R_swig_new_SpreadCdsHelper__SWIG_0', spread, tenor, settlementDays, calendar, frequency, convention, rule, dayCounter, recoveryRate, discountCurve, settlesAccrual, paysAtDefaultTime, PACKAGE='QuantLib');
  class(ans) <- "_p_SpreadCdsHelperPtr";
  
  reg.finalizer(ans, delete_SpreadCdsHelper)
  ans
  
}

attr(`SpreadCdsHelper__SWIG_0`, 'returnType') = '_p_SpreadCdsHelperPtr'
attr(`SpreadCdsHelper__SWIG_0`, "inputTypes") = c('_p_HandleT_Quote_t', '_p_Period', 'integer', '_p_Calendar', 'character', 'character', 'character', '_p_DayCounter', 'numeric', '_p_HandleT_YieldTermStructure_t', 'logical', 'logical')
class(`SpreadCdsHelper__SWIG_0`) = c("SWIGFunction", class('SpreadCdsHelper__SWIG_0'))

# Start of new_SpreadCdsHelper

`SpreadCdsHelper__SWIG_1` = function(spread, tenor, settlementDays, calendar, frequency, convention, rule, dayCounter, recoveryRate, discountCurve, settlesAccrual)
{
  settlementDays = as.integer(settlementDays); 
  
  if(length(settlementDays) > 1) {
    warning("using only the first element of settlementDays");
  };
  
  
  frequency = enumToInteger(frequency, "_Frequency"); 
  
  if(length(frequency) > 1) {
    warning("using only the first element of frequency");
  };
  
  convention = enumToInteger(convention, "_BusinessDayConvention"); 
  
  if(length(convention) > 1) {
    warning("using only the first element of convention");
  };
  
  rule = enumToInteger(rule, "_DateGeneration__Rule"); 
  
  if(length(rule) > 1) {
    warning("using only the first element of rule");
  };
  
  
  
  
  settlesAccrual = as.logical(settlesAccrual);
  ;ans = .Call('R_swig_new_SpreadCdsHelper__SWIG_1', spread, tenor, settlementDays, calendar, frequency, convention, rule, dayCounter, recoveryRate, discountCurve, settlesAccrual, PACKAGE='QuantLib');
  class(ans) <- "_p_SpreadCdsHelperPtr";
  
  reg.finalizer(ans, delete_SpreadCdsHelper)
  ans
  
}

attr(`SpreadCdsHelper__SWIG_1`, 'returnType') = '_p_SpreadCdsHelperPtr'
attr(`SpreadCdsHelper__SWIG_1`, "inputTypes") = c('_p_HandleT_Quote_t', '_p_Period', 'integer', '_p_Calendar', 'character', 'character', 'character', '_p_DayCounter', 'numeric', '_p_HandleT_YieldTermStructure_t', 'logical')
class(`SpreadCdsHelper__SWIG_1`) = c("SWIGFunction", class('SpreadCdsHelper__SWIG_1'))

# Start of new_SpreadCdsHelper

`SpreadCdsHelper__SWIG_2` = function(spread, tenor, settlementDays, calendar, frequency, convention, rule, dayCounter, recoveryRate, discountCurve)
{
  settlementDays = as.integer(settlementDays); 
  
  if(length(settlementDays) > 1) {
    warning("using only the first element of settlementDays");
  };
  
  
  frequency = enumToInteger(frequency, "_Frequency"); 
  
  if(length(frequency) > 1) {
    warning("using only the first element of frequency");
  };
  
  convention = enumToInteger(convention, "_BusinessDayConvention"); 
  
  if(length(convention) > 1) {
    warning("using only the first element of convention");
  };
  
  rule = enumToInteger(rule, "_DateGeneration__Rule"); 
  
  if(length(rule) > 1) {
    warning("using only the first element of rule");
  };
  
  
  
  
  ;ans = .Call('R_swig_new_SpreadCdsHelper__SWIG_2', spread, tenor, settlementDays, calendar, frequency, convention, rule, dayCounter, recoveryRate, discountCurve, PACKAGE='QuantLib');
  class(ans) <- "_p_SpreadCdsHelperPtr";
  
  reg.finalizer(ans, delete_SpreadCdsHelper)
  ans
  
}

attr(`SpreadCdsHelper__SWIG_2`, 'returnType') = '_p_SpreadCdsHelperPtr'
attr(`SpreadCdsHelper__SWIG_2`, "inputTypes") = c('_p_HandleT_Quote_t', '_p_Period', 'integer', '_p_Calendar', 'character', 'character', 'character', '_p_DayCounter', 'numeric', '_p_HandleT_YieldTermStructure_t')
class(`SpreadCdsHelper__SWIG_2`) = c("SWIGFunction", class('SpreadCdsHelper__SWIG_2'))

# Start of new_SpreadCdsHelper

`SpreadCdsHelper__SWIG_3` = function(spread, tenor, settlementDays, calendar, frequency, convention, rule, dayCounter, recoveryRate, discountCurve, settlesAccrual, paysAtDefaultTime)
{
  settlementDays = as.integer(settlementDays); 
  
  if(length(settlementDays) > 1) {
    warning("using only the first element of settlementDays");
  };
  
  
  frequency = enumToInteger(frequency, "_Frequency"); 
  
  if(length(frequency) > 1) {
    warning("using only the first element of frequency");
  };
  
  convention = enumToInteger(convention, "_BusinessDayConvention"); 
  
  if(length(convention) > 1) {
    warning("using only the first element of convention");
  };
  
  rule = enumToInteger(rule, "_DateGeneration__Rule"); 
  
  if(length(rule) > 1) {
    warning("using only the first element of rule");
  };
  
  
  
  
  settlesAccrual = as.logical(settlesAccrual);
  paysAtDefaultTime = as.logical(paysAtDefaultTime);
  ;ans = .Call('R_swig_new_SpreadCdsHelper__SWIG_3', spread, tenor, settlementDays, calendar, frequency, convention, rule, dayCounter, recoveryRate, discountCurve, settlesAccrual, paysAtDefaultTime, PACKAGE='QuantLib');
  class(ans) <- "_p_SpreadCdsHelperPtr";
  
  reg.finalizer(ans, delete_SpreadCdsHelper)
  ans
  
}

attr(`SpreadCdsHelper__SWIG_3`, 'returnType') = '_p_SpreadCdsHelperPtr'
attr(`SpreadCdsHelper__SWIG_3`, "inputTypes") = c('numeric', '_p_Period', 'integer', '_p_Calendar', 'character', 'character', 'character', '_p_DayCounter', 'numeric', '_p_HandleT_YieldTermStructure_t', 'logical', 'logical')
class(`SpreadCdsHelper__SWIG_3`) = c("SWIGFunction", class('SpreadCdsHelper__SWIG_3'))

# Start of new_SpreadCdsHelper

`SpreadCdsHelper__SWIG_4` = function(spread, tenor, settlementDays, calendar, frequency, convention, rule, dayCounter, recoveryRate, discountCurve, settlesAccrual)
{
  settlementDays = as.integer(settlementDays); 
  
  if(length(settlementDays) > 1) {
    warning("using only the first element of settlementDays");
  };
  
  
  frequency = enumToInteger(frequency, "_Frequency"); 
  
  if(length(frequency) > 1) {
    warning("using only the first element of frequency");
  };
  
  convention = enumToInteger(convention, "_BusinessDayConvention"); 
  
  if(length(convention) > 1) {
    warning("using only the first element of convention");
  };
  
  rule = enumToInteger(rule, "_DateGeneration__Rule"); 
  
  if(length(rule) > 1) {
    warning("using only the first element of rule");
  };
  
  
  
  
  settlesAccrual = as.logical(settlesAccrual);
  ;ans = .Call('R_swig_new_SpreadCdsHelper__SWIG_4', spread, tenor, settlementDays, calendar, frequency, convention, rule, dayCounter, recoveryRate, discountCurve, settlesAccrual, PACKAGE='QuantLib');
  class(ans) <- "_p_SpreadCdsHelperPtr";
  
  reg.finalizer(ans, delete_SpreadCdsHelper)
  ans
  
}

attr(`SpreadCdsHelper__SWIG_4`, 'returnType') = '_p_SpreadCdsHelperPtr'
attr(`SpreadCdsHelper__SWIG_4`, "inputTypes") = c('numeric', '_p_Period', 'integer', '_p_Calendar', 'character', 'character', 'character', '_p_DayCounter', 'numeric', '_p_HandleT_YieldTermStructure_t', 'logical')
class(`SpreadCdsHelper__SWIG_4`) = c("SWIGFunction", class('SpreadCdsHelper__SWIG_4'))

# Start of new_SpreadCdsHelper

`SpreadCdsHelper__SWIG_5` = function(spread, tenor, settlementDays, calendar, frequency, convention, rule, dayCounter, recoveryRate, discountCurve)
{
  settlementDays = as.integer(settlementDays); 
  
  if(length(settlementDays) > 1) {
    warning("using only the first element of settlementDays");
  };
  
  
  frequency = enumToInteger(frequency, "_Frequency"); 
  
  if(length(frequency) > 1) {
    warning("using only the first element of frequency");
  };
  
  convention = enumToInteger(convention, "_BusinessDayConvention"); 
  
  if(length(convention) > 1) {
    warning("using only the first element of convention");
  };
  
  rule = enumToInteger(rule, "_DateGeneration__Rule"); 
  
  if(length(rule) > 1) {
    warning("using only the first element of rule");
  };
  
  
  
  
  ;ans = .Call('R_swig_new_SpreadCdsHelper__SWIG_5', spread, tenor, settlementDays, calendar, frequency, convention, rule, dayCounter, recoveryRate, discountCurve, PACKAGE='QuantLib');
  class(ans) <- "_p_SpreadCdsHelperPtr";
  
  reg.finalizer(ans, delete_SpreadCdsHelper)
  ans
  
}

attr(`SpreadCdsHelper__SWIG_5`, 'returnType') = '_p_SpreadCdsHelperPtr'
attr(`SpreadCdsHelper__SWIG_5`, "inputTypes") = c('numeric', '_p_Period', 'integer', '_p_Calendar', 'character', 'character', 'character', '_p_DayCounter', 'numeric', '_p_HandleT_YieldTermStructure_t')
class(`SpreadCdsHelper__SWIG_5`) = c("SWIGFunction", class('SpreadCdsHelper__SWIG_5'))

`SpreadCdsHelper` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 6
  if (argc == 10) {
    if (extends(argtypes[1], '_p_HandleT_Quote_t') && extends(argtypes[2], '_p_Period') && (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && extends(argtypes[4], '_p_Calendar') && is.character(argv[[5]]) && is.character(argv[[6]]) && is.character(argv[[7]]) && extends(argtypes[8], '_p_DayCounter') && is.numeric(argv[[9]]) && extends(argtypes[10], '_p_HandleT_YieldTermStructure_t')) {
      f <- SpreadCdsHelper__SWIG_2; 
    }
    else if (is.numeric(argv[[1]]) && extends(argtypes[2], '_p_Period') && (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && extends(argtypes[4], '_p_Calendar') && is.character(argv[[5]]) && is.character(argv[[6]]) && is.character(argv[[7]]) && extends(argtypes[8], '_p_DayCounter') && is.numeric(argv[[9]]) && extends(argtypes[10], '_p_HandleT_YieldTermStructure_t')) {
      f <- SpreadCdsHelper__SWIG_5; 
    }
  } else if (argc == 11) {
    if (extends(argtypes[1], '_p_HandleT_Quote_t') && extends(argtypes[2], '_p_Period') && (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && extends(argtypes[4], '_p_Calendar') && is.character(argv[[5]]) && is.character(argv[[6]]) && is.character(argv[[7]]) && extends(argtypes[8], '_p_DayCounter') && is.numeric(argv[[9]]) && extends(argtypes[10], '_p_HandleT_YieldTermStructure_t') && extends(argtypes[11], 'logical')) {
      f <- SpreadCdsHelper__SWIG_1; 
    }
    else if (is.numeric(argv[[1]]) && extends(argtypes[2], '_p_Period') && (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && extends(argtypes[4], '_p_Calendar') && is.character(argv[[5]]) && is.character(argv[[6]]) && is.character(argv[[7]]) && extends(argtypes[8], '_p_DayCounter') && is.numeric(argv[[9]]) && extends(argtypes[10], '_p_HandleT_YieldTermStructure_t') && extends(argtypes[11], 'logical')) {
      f <- SpreadCdsHelper__SWIG_4; 
    }
  } else if (argc == 12) {
    if (extends(argtypes[1], '_p_HandleT_Quote_t') && extends(argtypes[2], '_p_Period') && (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && extends(argtypes[4], '_p_Calendar') && is.character(argv[[5]]) && is.character(argv[[6]]) && is.character(argv[[7]]) && extends(argtypes[8], '_p_DayCounter') && is.numeric(argv[[9]]) && extends(argtypes[10], '_p_HandleT_YieldTermStructure_t') && extends(argtypes[11], 'logical') && extends(argtypes[12], 'logical')) {
      f <- SpreadCdsHelper__SWIG_0; 
    }
    else if (is.numeric(argv[[1]]) && extends(argtypes[2], '_p_Period') && (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && extends(argtypes[4], '_p_Calendar') && is.character(argv[[5]]) && is.character(argv[[6]]) && is.character(argv[[7]]) && extends(argtypes[8], '_p_DayCounter') && is.numeric(argv[[9]]) && extends(argtypes[10], '_p_HandleT_YieldTermStructure_t') && extends(argtypes[11], 'logical') && extends(argtypes[12], 'logical')) {
      f <- SpreadCdsHelper__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for SpreadCdsHelper with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_SpreadCdsHelper

`delete_SpreadCdsHelper` = function(self)
{
  ;.Call('R_swig_delete_SpreadCdsHelper', self, PACKAGE='QuantLib');
  
}

attr(`delete_SpreadCdsHelper`, 'returnType') = 'void'
attr(`delete_SpreadCdsHelper`, "inputTypes") = c('_p_SpreadCdsHelperPtr')
class(`delete_SpreadCdsHelper`) = c("SWIGFunction", class('delete_SpreadCdsHelper'))

setMethod('delete', '_p_SpreadCdsHelperPtr', function(obj) {delete_SpreadCdsHelperPtr(obj)})
# Start of new_UpfrontCdsHelper

`UpfrontCdsHelper__SWIG_0` = function(upfront, spread, tenor, settlementDays, calendar, frequency, convention, rule, dayCounter, recoveryRate, discountCurve, settlesAccrual, paysAtDefaultTime)
{
  settlementDays = as.integer(settlementDays); 
  
  if(length(settlementDays) > 1) {
    warning("using only the first element of settlementDays");
  };
  
  
  frequency = enumToInteger(frequency, "_Frequency"); 
  
  if(length(frequency) > 1) {
    warning("using only the first element of frequency");
  };
  
  convention = enumToInteger(convention, "_BusinessDayConvention"); 
  
  if(length(convention) > 1) {
    warning("using only the first element of convention");
  };
  
  rule = enumToInteger(rule, "_DateGeneration__Rule"); 
  
  if(length(rule) > 1) {
    warning("using only the first element of rule");
  };
  
  
  
  
  settlesAccrual = as.logical(settlesAccrual);
  paysAtDefaultTime = as.logical(paysAtDefaultTime);
  ;ans = .Call('R_swig_new_UpfrontCdsHelper__SWIG_0', upfront, spread, tenor, settlementDays, calendar, frequency, convention, rule, dayCounter, recoveryRate, discountCurve, settlesAccrual, paysAtDefaultTime, PACKAGE='QuantLib');
  class(ans) <- "_p_UpfrontCdsHelperPtr";
  
  reg.finalizer(ans, delete_UpfrontCdsHelper)
  ans
  
}

attr(`UpfrontCdsHelper__SWIG_0`, 'returnType') = '_p_UpfrontCdsHelperPtr'
attr(`UpfrontCdsHelper__SWIG_0`, "inputTypes") = c('_p_HandleT_Quote_t', 'numeric', '_p_Period', 'integer', '_p_Calendar', 'character', 'character', 'character', '_p_DayCounter', 'numeric', '_p_HandleT_YieldTermStructure_t', 'logical', 'logical')
class(`UpfrontCdsHelper__SWIG_0`) = c("SWIGFunction", class('UpfrontCdsHelper__SWIG_0'))

# Start of new_UpfrontCdsHelper

`UpfrontCdsHelper__SWIG_1` = function(upfront, spread, tenor, settlementDays, calendar, frequency, convention, rule, dayCounter, recoveryRate, discountCurve, settlesAccrual)
{
  settlementDays = as.integer(settlementDays); 
  
  if(length(settlementDays) > 1) {
    warning("using only the first element of settlementDays");
  };
  
  
  frequency = enumToInteger(frequency, "_Frequency"); 
  
  if(length(frequency) > 1) {
    warning("using only the first element of frequency");
  };
  
  convention = enumToInteger(convention, "_BusinessDayConvention"); 
  
  if(length(convention) > 1) {
    warning("using only the first element of convention");
  };
  
  rule = enumToInteger(rule, "_DateGeneration__Rule"); 
  
  if(length(rule) > 1) {
    warning("using only the first element of rule");
  };
  
  
  
  
  settlesAccrual = as.logical(settlesAccrual);
  ;ans = .Call('R_swig_new_UpfrontCdsHelper__SWIG_1', upfront, spread, tenor, settlementDays, calendar, frequency, convention, rule, dayCounter, recoveryRate, discountCurve, settlesAccrual, PACKAGE='QuantLib');
  class(ans) <- "_p_UpfrontCdsHelperPtr";
  
  reg.finalizer(ans, delete_UpfrontCdsHelper)
  ans
  
}

attr(`UpfrontCdsHelper__SWIG_1`, 'returnType') = '_p_UpfrontCdsHelperPtr'
attr(`UpfrontCdsHelper__SWIG_1`, "inputTypes") = c('_p_HandleT_Quote_t', 'numeric', '_p_Period', 'integer', '_p_Calendar', 'character', 'character', 'character', '_p_DayCounter', 'numeric', '_p_HandleT_YieldTermStructure_t', 'logical')
class(`UpfrontCdsHelper__SWIG_1`) = c("SWIGFunction", class('UpfrontCdsHelper__SWIG_1'))

# Start of new_UpfrontCdsHelper

`UpfrontCdsHelper__SWIG_2` = function(upfront, spread, tenor, settlementDays, calendar, frequency, convention, rule, dayCounter, recoveryRate, discountCurve)
{
  settlementDays = as.integer(settlementDays); 
  
  if(length(settlementDays) > 1) {
    warning("using only the first element of settlementDays");
  };
  
  
  frequency = enumToInteger(frequency, "_Frequency"); 
  
  if(length(frequency) > 1) {
    warning("using only the first element of frequency");
  };
  
  convention = enumToInteger(convention, "_BusinessDayConvention"); 
  
  if(length(convention) > 1) {
    warning("using only the first element of convention");
  };
  
  rule = enumToInteger(rule, "_DateGeneration__Rule"); 
  
  if(length(rule) > 1) {
    warning("using only the first element of rule");
  };
  
  
  
  
  ;ans = .Call('R_swig_new_UpfrontCdsHelper__SWIG_2', upfront, spread, tenor, settlementDays, calendar, frequency, convention, rule, dayCounter, recoveryRate, discountCurve, PACKAGE='QuantLib');
  class(ans) <- "_p_UpfrontCdsHelperPtr";
  
  reg.finalizer(ans, delete_UpfrontCdsHelper)
  ans
  
}

attr(`UpfrontCdsHelper__SWIG_2`, 'returnType') = '_p_UpfrontCdsHelperPtr'
attr(`UpfrontCdsHelper__SWIG_2`, "inputTypes") = c('_p_HandleT_Quote_t', 'numeric', '_p_Period', 'integer', '_p_Calendar', 'character', 'character', 'character', '_p_DayCounter', 'numeric', '_p_HandleT_YieldTermStructure_t')
class(`UpfrontCdsHelper__SWIG_2`) = c("SWIGFunction", class('UpfrontCdsHelper__SWIG_2'))

# Start of new_UpfrontCdsHelper

`UpfrontCdsHelper__SWIG_3` = function(upfront, spread, tenor, settlementDays, calendar, frequency, convention, rule, dayCounter, recoveryRate, discountCurve, settlesAccrual, paysAtDefaultTime)
{
  settlementDays = as.integer(settlementDays); 
  
  if(length(settlementDays) > 1) {
    warning("using only the first element of settlementDays");
  };
  
  
  frequency = enumToInteger(frequency, "_Frequency"); 
  
  if(length(frequency) > 1) {
    warning("using only the first element of frequency");
  };
  
  convention = enumToInteger(convention, "_BusinessDayConvention"); 
  
  if(length(convention) > 1) {
    warning("using only the first element of convention");
  };
  
  rule = enumToInteger(rule, "_DateGeneration__Rule"); 
  
  if(length(rule) > 1) {
    warning("using only the first element of rule");
  };
  
  
  
  
  settlesAccrual = as.logical(settlesAccrual);
  paysAtDefaultTime = as.logical(paysAtDefaultTime);
  ;ans = .Call('R_swig_new_UpfrontCdsHelper__SWIG_3', upfront, spread, tenor, settlementDays, calendar, frequency, convention, rule, dayCounter, recoveryRate, discountCurve, settlesAccrual, paysAtDefaultTime, PACKAGE='QuantLib');
  class(ans) <- "_p_UpfrontCdsHelperPtr";
  
  reg.finalizer(ans, delete_UpfrontCdsHelper)
  ans
  
}

attr(`UpfrontCdsHelper__SWIG_3`, 'returnType') = '_p_UpfrontCdsHelperPtr'
attr(`UpfrontCdsHelper__SWIG_3`, "inputTypes") = c('numeric', 'numeric', '_p_Period', 'integer', '_p_Calendar', 'character', 'character', 'character', '_p_DayCounter', 'numeric', '_p_HandleT_YieldTermStructure_t', 'logical', 'logical')
class(`UpfrontCdsHelper__SWIG_3`) = c("SWIGFunction", class('UpfrontCdsHelper__SWIG_3'))

# Start of new_UpfrontCdsHelper

`UpfrontCdsHelper__SWIG_4` = function(upfront, spread, tenor, settlementDays, calendar, frequency, convention, rule, dayCounter, recoveryRate, discountCurve, settlesAccrual)
{
  settlementDays = as.integer(settlementDays); 
  
  if(length(settlementDays) > 1) {
    warning("using only the first element of settlementDays");
  };
  
  
  frequency = enumToInteger(frequency, "_Frequency"); 
  
  if(length(frequency) > 1) {
    warning("using only the first element of frequency");
  };
  
  convention = enumToInteger(convention, "_BusinessDayConvention"); 
  
  if(length(convention) > 1) {
    warning("using only the first element of convention");
  };
  
  rule = enumToInteger(rule, "_DateGeneration__Rule"); 
  
  if(length(rule) > 1) {
    warning("using only the first element of rule");
  };
  
  
  
  
  settlesAccrual = as.logical(settlesAccrual);
  ;ans = .Call('R_swig_new_UpfrontCdsHelper__SWIG_4', upfront, spread, tenor, settlementDays, calendar, frequency, convention, rule, dayCounter, recoveryRate, discountCurve, settlesAccrual, PACKAGE='QuantLib');
  class(ans) <- "_p_UpfrontCdsHelperPtr";
  
  reg.finalizer(ans, delete_UpfrontCdsHelper)
  ans
  
}

attr(`UpfrontCdsHelper__SWIG_4`, 'returnType') = '_p_UpfrontCdsHelperPtr'
attr(`UpfrontCdsHelper__SWIG_4`, "inputTypes") = c('numeric', 'numeric', '_p_Period', 'integer', '_p_Calendar', 'character', 'character', 'character', '_p_DayCounter', 'numeric', '_p_HandleT_YieldTermStructure_t', 'logical')
class(`UpfrontCdsHelper__SWIG_4`) = c("SWIGFunction", class('UpfrontCdsHelper__SWIG_4'))

# Start of new_UpfrontCdsHelper

`UpfrontCdsHelper__SWIG_5` = function(upfront, spread, tenor, settlementDays, calendar, frequency, convention, rule, dayCounter, recoveryRate, discountCurve)
{
  settlementDays = as.integer(settlementDays); 
  
  if(length(settlementDays) > 1) {
    warning("using only the first element of settlementDays");
  };
  
  
  frequency = enumToInteger(frequency, "_Frequency"); 
  
  if(length(frequency) > 1) {
    warning("using only the first element of frequency");
  };
  
  convention = enumToInteger(convention, "_BusinessDayConvention"); 
  
  if(length(convention) > 1) {
    warning("using only the first element of convention");
  };
  
  rule = enumToInteger(rule, "_DateGeneration__Rule"); 
  
  if(length(rule) > 1) {
    warning("using only the first element of rule");
  };
  
  
  
  
  ;ans = .Call('R_swig_new_UpfrontCdsHelper__SWIG_5', upfront, spread, tenor, settlementDays, calendar, frequency, convention, rule, dayCounter, recoveryRate, discountCurve, PACKAGE='QuantLib');
  class(ans) <- "_p_UpfrontCdsHelperPtr";
  
  reg.finalizer(ans, delete_UpfrontCdsHelper)
  ans
  
}

attr(`UpfrontCdsHelper__SWIG_5`, 'returnType') = '_p_UpfrontCdsHelperPtr'
attr(`UpfrontCdsHelper__SWIG_5`, "inputTypes") = c('numeric', 'numeric', '_p_Period', 'integer', '_p_Calendar', 'character', 'character', 'character', '_p_DayCounter', 'numeric', '_p_HandleT_YieldTermStructure_t')
class(`UpfrontCdsHelper__SWIG_5`) = c("SWIGFunction", class('UpfrontCdsHelper__SWIG_5'))

`UpfrontCdsHelper` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 6
  if (argc == 11) {
    if (extends(argtypes[1], '_p_HandleT_Quote_t') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_Period') && (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && extends(argtypes[5], '_p_Calendar') && is.character(argv[[6]]) && is.character(argv[[7]]) && is.character(argv[[8]]) && extends(argtypes[9], '_p_DayCounter') && is.numeric(argv[[10]]) && extends(argtypes[11], '_p_HandleT_YieldTermStructure_t')) {
      f <- UpfrontCdsHelper__SWIG_2; 
    }
    else if (is.numeric(argv[[1]]) && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_Period') && (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && extends(argtypes[5], '_p_Calendar') && is.character(argv[[6]]) && is.character(argv[[7]]) && is.character(argv[[8]]) && extends(argtypes[9], '_p_DayCounter') && is.numeric(argv[[10]]) && extends(argtypes[11], '_p_HandleT_YieldTermStructure_t')) {
      f <- UpfrontCdsHelper__SWIG_5; 
    }
  } else if (argc == 12) {
    if (extends(argtypes[1], '_p_HandleT_Quote_t') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_Period') && (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && extends(argtypes[5], '_p_Calendar') && is.character(argv[[6]]) && is.character(argv[[7]]) && is.character(argv[[8]]) && extends(argtypes[9], '_p_DayCounter') && is.numeric(argv[[10]]) && extends(argtypes[11], '_p_HandleT_YieldTermStructure_t') && extends(argtypes[12], 'logical')) {
      f <- UpfrontCdsHelper__SWIG_1; 
    }
    else if (is.numeric(argv[[1]]) && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_Period') && (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && extends(argtypes[5], '_p_Calendar') && is.character(argv[[6]]) && is.character(argv[[7]]) && is.character(argv[[8]]) && extends(argtypes[9], '_p_DayCounter') && is.numeric(argv[[10]]) && extends(argtypes[11], '_p_HandleT_YieldTermStructure_t') && extends(argtypes[12], 'logical')) {
      f <- UpfrontCdsHelper__SWIG_4; 
    }
  } else if (argc == 13) {
    if (extends(argtypes[1], '_p_HandleT_Quote_t') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_Period') && (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && extends(argtypes[5], '_p_Calendar') && is.character(argv[[6]]) && is.character(argv[[7]]) && is.character(argv[[8]]) && extends(argtypes[9], '_p_DayCounter') && is.numeric(argv[[10]]) && extends(argtypes[11], '_p_HandleT_YieldTermStructure_t') && extends(argtypes[12], 'logical') && extends(argtypes[13], 'logical')) {
      f <- UpfrontCdsHelper__SWIG_0; 
    }
    else if (is.numeric(argv[[1]]) && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_Period') && (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && extends(argtypes[5], '_p_Calendar') && is.character(argv[[6]]) && is.character(argv[[7]]) && is.character(argv[[8]]) && extends(argtypes[9], '_p_DayCounter') && is.numeric(argv[[10]]) && extends(argtypes[11], '_p_HandleT_YieldTermStructure_t') && extends(argtypes[12], 'logical') && extends(argtypes[13], 'logical')) {
      f <- UpfrontCdsHelper__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for UpfrontCdsHelper with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_UpfrontCdsHelper

`delete_UpfrontCdsHelper` = function(self)
{
  ;.Call('R_swig_delete_UpfrontCdsHelper', self, PACKAGE='QuantLib');
  
}

attr(`delete_UpfrontCdsHelper`, 'returnType') = 'void'
attr(`delete_UpfrontCdsHelper`, "inputTypes") = c('_p_UpfrontCdsHelperPtr')
class(`delete_UpfrontCdsHelper`) = c("SWIGFunction", class('delete_UpfrontCdsHelper'))

setMethod('delete', '_p_UpfrontCdsHelperPtr', function(obj) {delete_UpfrontCdsHelperPtr(obj)})
# Start of new_HazardRate

`HazardRate` = function()
{
  ;ans = .Call('R_swig_new_HazardRate', PACKAGE='QuantLib');
  class(ans) <- "_p_HazardRate";
  
  reg.finalizer(ans, delete_HazardRate)
  ans
  
}

attr(`HazardRate`, 'returnType') = '_p_HazardRate'
class(`HazardRate`) = c("SWIGFunction", class('HazardRate'))

# Start of delete_HazardRate

`delete_HazardRate` = function(self)
{
  ;.Call('R_swig_delete_HazardRate', self, PACKAGE='QuantLib');
  
}

attr(`delete_HazardRate`, 'returnType') = 'void'
attr(`delete_HazardRate`, "inputTypes") = c('_p_HazardRate')
class(`delete_HazardRate`) = c("SWIGFunction", class('delete_HazardRate'))

setMethod('delete', '_p_HazardRate', function(obj) {delete_HazardRate(obj)})
# Start definition of copy functions & methods for HazardRate
CopyToR_HazardRate = function(value, obj = new("HazardRate"))
{
  obj;
}



CopyToC_HazardRate = function(value, obj)
{
  obj
}



# Start definition of copy methods for HazardRate
setMethod('copyToR', '_p_HazardRate', CopyToR_HazardRate);
setMethod('copyToC', 'HazardRate', CopyToC_HazardRate);

# End definition of copy methods for HazardRate
# End definition of copy functions & methods for HazardRate
# Start of new_DefaultDensity

`DefaultDensity` = function()
{
  ;ans = .Call('R_swig_new_DefaultDensity', PACKAGE='QuantLib');
  class(ans) <- "_p_DefaultDensity";
  
  reg.finalizer(ans, delete_DefaultDensity)
  ans
  
}

attr(`DefaultDensity`, 'returnType') = '_p_DefaultDensity'
class(`DefaultDensity`) = c("SWIGFunction", class('DefaultDensity'))

# Start of delete_DefaultDensity

`delete_DefaultDensity` = function(self)
{
  ;.Call('R_swig_delete_DefaultDensity', self, PACKAGE='QuantLib');
  
}

attr(`delete_DefaultDensity`, 'returnType') = 'void'
attr(`delete_DefaultDensity`, "inputTypes") = c('_p_DefaultDensity')
class(`delete_DefaultDensity`) = c("SWIGFunction", class('delete_DefaultDensity'))

setMethod('delete', '_p_DefaultDensity', function(obj) {delete_DefaultDensity(obj)})
# Start definition of copy functions & methods for DefaultDensity
CopyToR_DefaultDensity = function(value, obj = new("DefaultDensity"))
{
  obj;
}



CopyToC_DefaultDensity = function(value, obj)
{
  obj
}



# Start definition of copy methods for DefaultDensity
setMethod('copyToR', '_p_DefaultDensity', CopyToR_DefaultDensity);
setMethod('copyToC', 'DefaultDensity', CopyToC_DefaultDensity);

# End definition of copy methods for DefaultDensity
# End definition of copy functions & methods for DefaultDensity
# Start of new_PiecewiseFlatHazardRate

`PiecewiseFlatHazardRate__SWIG_0` = function(referenceDate, instruments, dayCounter, accuracy, i)
{
  ;ans = .Call('R_swig_new_PiecewiseFlatHazardRate__SWIG_0', referenceDate, instruments, dayCounter, accuracy, i, PACKAGE='QuantLib');
  class(ans) <- "_p_PiecewiseFlatHazardRatePtr";
  
  reg.finalizer(ans, delete_PiecewiseFlatHazardRate)
  ans
  
}

attr(`PiecewiseFlatHazardRate__SWIG_0`, 'returnType') = '_p_PiecewiseFlatHazardRatePtr'
attr(`PiecewiseFlatHazardRate__SWIG_0`, "inputTypes") = c('_p_Date', '_p_std__vectorT_boost__shared_ptrT_DefaultProbabilityHelper_t_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t_t', '_p_DayCounter', 'numeric', '_p_BackwardFlat')
class(`PiecewiseFlatHazardRate__SWIG_0`) = c("SWIGFunction", class('PiecewiseFlatHazardRate__SWIG_0'))

# Start of new_PiecewiseFlatHazardRate

`PiecewiseFlatHazardRate__SWIG_1` = function(referenceDate, instruments, dayCounter, accuracy)
{
  ;ans = .Call('R_swig_new_PiecewiseFlatHazardRate__SWIG_1', referenceDate, instruments, dayCounter, accuracy, PACKAGE='QuantLib');
  class(ans) <- "_p_PiecewiseFlatHazardRatePtr";
  
  reg.finalizer(ans, delete_PiecewiseFlatHazardRate)
  ans
  
}

attr(`PiecewiseFlatHazardRate__SWIG_1`, 'returnType') = '_p_PiecewiseFlatHazardRatePtr'
attr(`PiecewiseFlatHazardRate__SWIG_1`, "inputTypes") = c('_p_Date', '_p_std__vectorT_boost__shared_ptrT_DefaultProbabilityHelper_t_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t_t', '_p_DayCounter', 'numeric')
class(`PiecewiseFlatHazardRate__SWIG_1`) = c("SWIGFunction", class('PiecewiseFlatHazardRate__SWIG_1'))

# Start of new_PiecewiseFlatHazardRate

`PiecewiseFlatHazardRate__SWIG_2` = function(referenceDate, instruments, dayCounter)
{
  ;ans = .Call('R_swig_new_PiecewiseFlatHazardRate__SWIG_2', referenceDate, instruments, dayCounter, PACKAGE='QuantLib');
  class(ans) <- "_p_PiecewiseFlatHazardRatePtr";
  
  reg.finalizer(ans, delete_PiecewiseFlatHazardRate)
  ans
  
}

attr(`PiecewiseFlatHazardRate__SWIG_2`, 'returnType') = '_p_PiecewiseFlatHazardRatePtr'
attr(`PiecewiseFlatHazardRate__SWIG_2`, "inputTypes") = c('_p_Date', '_p_std__vectorT_boost__shared_ptrT_DefaultProbabilityHelper_t_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t_t', '_p_DayCounter')
class(`PiecewiseFlatHazardRate__SWIG_2`) = c("SWIGFunction", class('PiecewiseFlatHazardRate__SWIG_2'))

# Start of new_PiecewiseFlatHazardRate

`PiecewiseFlatHazardRate__SWIG_3` = function(settlementDays, calendar, instruments, dayCounter, accuracy, i)
{
  settlementDays = as.integer(settlementDays); 
  
  if(length(settlementDays) > 1) {
    warning("using only the first element of settlementDays");
  };
  
  
  
  
  
  
  ;ans = .Call('R_swig_new_PiecewiseFlatHazardRate__SWIG_3', settlementDays, calendar, instruments, dayCounter, accuracy, i, PACKAGE='QuantLib');
  class(ans) <- "_p_PiecewiseFlatHazardRatePtr";
  
  reg.finalizer(ans, delete_PiecewiseFlatHazardRate)
  ans
  
}

attr(`PiecewiseFlatHazardRate__SWIG_3`, 'returnType') = '_p_PiecewiseFlatHazardRatePtr'
attr(`PiecewiseFlatHazardRate__SWIG_3`, "inputTypes") = c('integer', '_p_Calendar', '_p_std__vectorT_boost__shared_ptrT_DefaultProbabilityHelper_t_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t_t', '_p_DayCounter', 'numeric', '_p_BackwardFlat')
class(`PiecewiseFlatHazardRate__SWIG_3`) = c("SWIGFunction", class('PiecewiseFlatHazardRate__SWIG_3'))

# Start of new_PiecewiseFlatHazardRate

`PiecewiseFlatHazardRate__SWIG_4` = function(settlementDays, calendar, instruments, dayCounter, accuracy)
{
  settlementDays = as.integer(settlementDays); 
  
  if(length(settlementDays) > 1) {
    warning("using only the first element of settlementDays");
  };
  
  
  
  
  
  ;ans = .Call('R_swig_new_PiecewiseFlatHazardRate__SWIG_4', settlementDays, calendar, instruments, dayCounter, accuracy, PACKAGE='QuantLib');
  class(ans) <- "_p_PiecewiseFlatHazardRatePtr";
  
  reg.finalizer(ans, delete_PiecewiseFlatHazardRate)
  ans
  
}

attr(`PiecewiseFlatHazardRate__SWIG_4`, 'returnType') = '_p_PiecewiseFlatHazardRatePtr'
attr(`PiecewiseFlatHazardRate__SWIG_4`, "inputTypes") = c('integer', '_p_Calendar', '_p_std__vectorT_boost__shared_ptrT_DefaultProbabilityHelper_t_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t_t', '_p_DayCounter', 'numeric')
class(`PiecewiseFlatHazardRate__SWIG_4`) = c("SWIGFunction", class('PiecewiseFlatHazardRate__SWIG_4'))

# Start of new_PiecewiseFlatHazardRate

`PiecewiseFlatHazardRate__SWIG_5` = function(settlementDays, calendar, instruments, dayCounter)
{
  settlementDays = as.integer(settlementDays); 
  
  if(length(settlementDays) > 1) {
    warning("using only the first element of settlementDays");
  };
  
  
  
  
  ;ans = .Call('R_swig_new_PiecewiseFlatHazardRate__SWIG_5', settlementDays, calendar, instruments, dayCounter, PACKAGE='QuantLib');
  class(ans) <- "_p_PiecewiseFlatHazardRatePtr";
  
  reg.finalizer(ans, delete_PiecewiseFlatHazardRate)
  ans
  
}

attr(`PiecewiseFlatHazardRate__SWIG_5`, 'returnType') = '_p_PiecewiseFlatHazardRatePtr'
attr(`PiecewiseFlatHazardRate__SWIG_5`, "inputTypes") = c('integer', '_p_Calendar', '_p_std__vectorT_boost__shared_ptrT_DefaultProbabilityHelper_t_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t_t', '_p_DayCounter')
class(`PiecewiseFlatHazardRate__SWIG_5`) = c("SWIGFunction", class('PiecewiseFlatHazardRate__SWIG_5'))

`PiecewiseFlatHazardRate` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 6
  if (argc == 3) {
    if (extends(argtypes[1], '_p_Date') && extends(argtypes[2], '_p_std__vectorT_boost__shared_ptrT_DefaultProbabilityHelper_t_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t_t') && extends(argtypes[3], '_p_DayCounter')) {
      f <- PiecewiseFlatHazardRate__SWIG_2; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_Date') && extends(argtypes[2], '_p_std__vectorT_boost__shared_ptrT_DefaultProbabilityHelper_t_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t_t') && extends(argtypes[3], '_p_DayCounter') && is.numeric(argv[[4]])) {
      f <- PiecewiseFlatHazardRate__SWIG_1; 
    }
    else if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && extends(argtypes[2], '_p_Calendar') && extends(argtypes[3], '_p_std__vectorT_boost__shared_ptrT_DefaultProbabilityHelper_t_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t_t') && extends(argtypes[4], '_p_DayCounter')) {
      f <- PiecewiseFlatHazardRate__SWIG_5; 
    }
  } else if (argc == 5) {
    if (extends(argtypes[1], '_p_Date') && extends(argtypes[2], '_p_std__vectorT_boost__shared_ptrT_DefaultProbabilityHelper_t_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t_t') && extends(argtypes[3], '_p_DayCounter') && is.numeric(argv[[4]]) && extends(argtypes[5], '_p_BackwardFlat')) {
      f <- PiecewiseFlatHazardRate__SWIG_0; 
    }
    else if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && extends(argtypes[2], '_p_Calendar') && extends(argtypes[3], '_p_std__vectorT_boost__shared_ptrT_DefaultProbabilityHelper_t_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t_t') && extends(argtypes[4], '_p_DayCounter') && is.numeric(argv[[5]])) {
      f <- PiecewiseFlatHazardRate__SWIG_4; 
    }
  } else if (argc == 6) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && extends(argtypes[2], '_p_Calendar') && extends(argtypes[3], '_p_std__vectorT_boost__shared_ptrT_DefaultProbabilityHelper_t_std__allocatorT_boost__shared_ptrT_DefaultProbabilityHelper_t_t_t') && extends(argtypes[4], '_p_DayCounter') && is.numeric(argv[[5]]) && extends(argtypes[6], '_p_BackwardFlat')) {
      f <- PiecewiseFlatHazardRate__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for PiecewiseFlatHazardRate with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of PiecewiseFlatHazardRate_dates

`PiecewiseFlatHazardRate_dates` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_PiecewiseFlatHazardRate_dates', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_Date_std__allocatorT_Date_t_t";
  
  ans
  
}

attr(`PiecewiseFlatHazardRate_dates`, 'returnType') = '_p_std__vectorT_Date_std__allocatorT_Date_t_t'
attr(`PiecewiseFlatHazardRate_dates`, "inputTypes") = c('_p_PiecewiseFlatHazardRatePtr')
class(`PiecewiseFlatHazardRate_dates`) = c("SWIGFunction", class('PiecewiseFlatHazardRate_dates'))

# Start of PiecewiseFlatHazardRate_times

`PiecewiseFlatHazardRate_times` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_PiecewiseFlatHazardRate_times', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_double_std__allocatorT_double_t_t";
  
  ans
  
}

attr(`PiecewiseFlatHazardRate_times`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`PiecewiseFlatHazardRate_times`, "inputTypes") = c('_p_PiecewiseFlatHazardRatePtr')
class(`PiecewiseFlatHazardRate_times`) = c("SWIGFunction", class('PiecewiseFlatHazardRate_times'))

# Start of delete_PiecewiseFlatHazardRate

`delete_PiecewiseFlatHazardRate` = function(self)
{
  ;.Call('R_swig_delete_PiecewiseFlatHazardRate', self, PACKAGE='QuantLib');
  
}

attr(`delete_PiecewiseFlatHazardRate`, 'returnType') = 'void'
attr(`delete_PiecewiseFlatHazardRate`, "inputTypes") = c('_p_PiecewiseFlatHazardRatePtr')
class(`delete_PiecewiseFlatHazardRate`) = c("SWIGFunction", class('delete_PiecewiseFlatHazardRate'))

# Start of accessor method for PiecewiseFlatHazardRatePtr
setMethod('$', '_p_PiecewiseFlatHazardRatePtr', function(x, name)

{
  accessorFuns = list('dates' = PiecewiseFlatHazardRate_dates, 'times' = PiecewiseFlatHazardRate_times);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for PiecewiseFlatHazardRatePtr
setMethod('delete', '_p_PiecewiseFlatHazardRatePtr', function(obj) {delete_PiecewiseFlatHazardRatePtr(obj)})
defineEnumeration('_Protection__Side',
                    .values = c(
                        'Buyer' = 0, 
                        'Seller' = 1
))
# Start of new_Protection

`Protection` = function()
{
  ;ans = .Call('R_swig_new_Protection', PACKAGE='QuantLib');
  class(ans) <- "_p_Protection";
  
  reg.finalizer(ans, delete_Protection)
  ans
  
}

attr(`Protection`, 'returnType') = '_p_Protection'
class(`Protection`) = c("SWIGFunction", class('Protection'))

# Start of delete_Protection

`delete_Protection` = function(self)
{
  ;.Call('R_swig_delete_Protection', self, PACKAGE='QuantLib');
  
}

attr(`delete_Protection`, 'returnType') = 'void'
attr(`delete_Protection`, "inputTypes") = c('_p_Protection')
class(`delete_Protection`) = c("SWIGFunction", class('delete_Protection'))

setMethod('delete', '_p_Protection', function(obj) {delete_Protection(obj)})
# Start definition of copy functions & methods for Protection
CopyToR_Protection = function(value, obj = new("Protection"))
{
  obj;
}



CopyToC_Protection = function(value, obj)
{
  obj
}



# Start definition of copy methods for Protection
setMethod('copyToR', '_p_Protection', CopyToR_Protection);
setMethod('copyToC', 'Protection', CopyToC_Protection);

# End definition of copy methods for Protection
# End definition of copy functions & methods for Protection
# Start of new_CreditDefaultSwap

`CreditDefaultSwap__SWIG_0` = function(side, notional, spread, schedule, paymentConvention, dayCounter, settlesAccrual, paysAtDefaultTime)
{
  side = enumToInteger(side, "_Protection__Side"); 
  
  if(length(side) > 1) {
    warning("using only the first element of side");
  };
  
  
  
  
  paymentConvention = enumToInteger(paymentConvention, "_BusinessDayConvention"); 
  
  if(length(paymentConvention) > 1) {
    warning("using only the first element of paymentConvention");
  };
  
  
  settlesAccrual = as.logical(settlesAccrual);
  paysAtDefaultTime = as.logical(paysAtDefaultTime);
  ;ans = .Call('R_swig_new_CreditDefaultSwap__SWIG_0', side, notional, spread, schedule, paymentConvention, dayCounter, settlesAccrual, paysAtDefaultTime, PACKAGE='QuantLib');
  class(ans) <- "_p_CreditDefaultSwapPtr";
  
  reg.finalizer(ans, delete_CreditDefaultSwap)
  ans
  
}

attr(`CreditDefaultSwap__SWIG_0`, 'returnType') = '_p_CreditDefaultSwapPtr'
attr(`CreditDefaultSwap__SWIG_0`, "inputTypes") = c('character', 'numeric', 'numeric', '_p_Schedule', 'character', '_p_DayCounter', 'logical', 'logical')
class(`CreditDefaultSwap__SWIG_0`) = c("SWIGFunction", class('CreditDefaultSwap__SWIG_0'))

# Start of new_CreditDefaultSwap

`CreditDefaultSwap__SWIG_1` = function(side, notional, spread, schedule, paymentConvention, dayCounter, settlesAccrual)
{
  side = enumToInteger(side, "_Protection__Side"); 
  
  if(length(side) > 1) {
    warning("using only the first element of side");
  };
  
  
  
  
  paymentConvention = enumToInteger(paymentConvention, "_BusinessDayConvention"); 
  
  if(length(paymentConvention) > 1) {
    warning("using only the first element of paymentConvention");
  };
  
  
  settlesAccrual = as.logical(settlesAccrual);
  ;ans = .Call('R_swig_new_CreditDefaultSwap__SWIG_1', side, notional, spread, schedule, paymentConvention, dayCounter, settlesAccrual, PACKAGE='QuantLib');
  class(ans) <- "_p_CreditDefaultSwapPtr";
  
  reg.finalizer(ans, delete_CreditDefaultSwap)
  ans
  
}

attr(`CreditDefaultSwap__SWIG_1`, 'returnType') = '_p_CreditDefaultSwapPtr'
attr(`CreditDefaultSwap__SWIG_1`, "inputTypes") = c('character', 'numeric', 'numeric', '_p_Schedule', 'character', '_p_DayCounter', 'logical')
class(`CreditDefaultSwap__SWIG_1`) = c("SWIGFunction", class('CreditDefaultSwap__SWIG_1'))

# Start of new_CreditDefaultSwap

`CreditDefaultSwap__SWIG_2` = function(side, notional, spread, schedule, paymentConvention, dayCounter)
{
  side = enumToInteger(side, "_Protection__Side"); 
  
  if(length(side) > 1) {
    warning("using only the first element of side");
  };
  
  
  
  
  paymentConvention = enumToInteger(paymentConvention, "_BusinessDayConvention"); 
  
  if(length(paymentConvention) > 1) {
    warning("using only the first element of paymentConvention");
  };
  
  
  ;ans = .Call('R_swig_new_CreditDefaultSwap__SWIG_2', side, notional, spread, schedule, paymentConvention, dayCounter, PACKAGE='QuantLib');
  class(ans) <- "_p_CreditDefaultSwapPtr";
  
  reg.finalizer(ans, delete_CreditDefaultSwap)
  ans
  
}

attr(`CreditDefaultSwap__SWIG_2`, 'returnType') = '_p_CreditDefaultSwapPtr'
attr(`CreditDefaultSwap__SWIG_2`, "inputTypes") = c('character', 'numeric', 'numeric', '_p_Schedule', 'character', '_p_DayCounter')
class(`CreditDefaultSwap__SWIG_2`) = c("SWIGFunction", class('CreditDefaultSwap__SWIG_2'))

# Start of new_CreditDefaultSwap

`CreditDefaultSwap__SWIG_3` = function(side, notional, upfront, spread, schedule, paymentConvention, dayCounter, settlesAccrual, paysAtDefaultTime)
{
  side = enumToInteger(side, "_Protection__Side"); 
  
  if(length(side) > 1) {
    warning("using only the first element of side");
  };
  
  
  
  
  
  paymentConvention = enumToInteger(paymentConvention, "_BusinessDayConvention"); 
  
  if(length(paymentConvention) > 1) {
    warning("using only the first element of paymentConvention");
  };
  
  
  settlesAccrual = as.logical(settlesAccrual);
  paysAtDefaultTime = as.logical(paysAtDefaultTime);
  ;ans = .Call('R_swig_new_CreditDefaultSwap__SWIG_3', side, notional, upfront, spread, schedule, paymentConvention, dayCounter, settlesAccrual, paysAtDefaultTime, PACKAGE='QuantLib');
  class(ans) <- "_p_CreditDefaultSwapPtr";
  
  reg.finalizer(ans, delete_CreditDefaultSwap)
  ans
  
}

attr(`CreditDefaultSwap__SWIG_3`, 'returnType') = '_p_CreditDefaultSwapPtr'
attr(`CreditDefaultSwap__SWIG_3`, "inputTypes") = c('character', 'numeric', 'numeric', 'numeric', '_p_Schedule', 'character', '_p_DayCounter', 'logical', 'logical')
class(`CreditDefaultSwap__SWIG_3`) = c("SWIGFunction", class('CreditDefaultSwap__SWIG_3'))

# Start of new_CreditDefaultSwap

`CreditDefaultSwap__SWIG_4` = function(side, notional, upfront, spread, schedule, paymentConvention, dayCounter, settlesAccrual)
{
  side = enumToInteger(side, "_Protection__Side"); 
  
  if(length(side) > 1) {
    warning("using only the first element of side");
  };
  
  
  
  
  
  paymentConvention = enumToInteger(paymentConvention, "_BusinessDayConvention"); 
  
  if(length(paymentConvention) > 1) {
    warning("using only the first element of paymentConvention");
  };
  
  
  settlesAccrual = as.logical(settlesAccrual);
  ;ans = .Call('R_swig_new_CreditDefaultSwap__SWIG_4', side, notional, upfront, spread, schedule, paymentConvention, dayCounter, settlesAccrual, PACKAGE='QuantLib');
  class(ans) <- "_p_CreditDefaultSwapPtr";
  
  reg.finalizer(ans, delete_CreditDefaultSwap)
  ans
  
}

attr(`CreditDefaultSwap__SWIG_4`, 'returnType') = '_p_CreditDefaultSwapPtr'
attr(`CreditDefaultSwap__SWIG_4`, "inputTypes") = c('character', 'numeric', 'numeric', 'numeric', '_p_Schedule', 'character', '_p_DayCounter', 'logical')
class(`CreditDefaultSwap__SWIG_4`) = c("SWIGFunction", class('CreditDefaultSwap__SWIG_4'))

# Start of new_CreditDefaultSwap

`CreditDefaultSwap__SWIG_5` = function(side, notional, upfront, spread, schedule, paymentConvention, dayCounter)
{
  side = enumToInteger(side, "_Protection__Side"); 
  
  if(length(side) > 1) {
    warning("using only the first element of side");
  };
  
  
  
  
  
  paymentConvention = enumToInteger(paymentConvention, "_BusinessDayConvention"); 
  
  if(length(paymentConvention) > 1) {
    warning("using only the first element of paymentConvention");
  };
  
  
  ;ans = .Call('R_swig_new_CreditDefaultSwap__SWIG_5', side, notional, upfront, spread, schedule, paymentConvention, dayCounter, PACKAGE='QuantLib');
  class(ans) <- "_p_CreditDefaultSwapPtr";
  
  reg.finalizer(ans, delete_CreditDefaultSwap)
  ans
  
}

attr(`CreditDefaultSwap__SWIG_5`, 'returnType') = '_p_CreditDefaultSwapPtr'
attr(`CreditDefaultSwap__SWIG_5`, "inputTypes") = c('character', 'numeric', 'numeric', 'numeric', '_p_Schedule', 'character', '_p_DayCounter')
class(`CreditDefaultSwap__SWIG_5`) = c("SWIGFunction", class('CreditDefaultSwap__SWIG_5'))

`CreditDefaultSwap` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 6
  if (argc == 6) {
    if (is.character(argv[[1]]) && is.numeric(argv[[2]]) && is.numeric(argv[[3]]) && extends(argtypes[4], '_p_Schedule') && is.character(argv[[5]]) && extends(argtypes[6], '_p_DayCounter')) {
      f <- CreditDefaultSwap__SWIG_2; 
    }
  } else if (argc == 7) {
    if (is.character(argv[[1]]) && is.numeric(argv[[2]]) && is.numeric(argv[[3]]) && extends(argtypes[4], '_p_Schedule') && is.character(argv[[5]]) && extends(argtypes[6], '_p_DayCounter') && extends(argtypes[7], 'logical')) {
      f <- CreditDefaultSwap__SWIG_1; 
    }
    else if (is.character(argv[[1]]) && is.numeric(argv[[2]]) && is.numeric(argv[[3]]) && is.numeric(argv[[4]]) && extends(argtypes[5], '_p_Schedule') && is.character(argv[[6]]) && extends(argtypes[7], '_p_DayCounter')) {
      f <- CreditDefaultSwap__SWIG_5; 
    }
  } else if (argc == 8) {
    if (is.character(argv[[1]]) && is.numeric(argv[[2]]) && is.numeric(argv[[3]]) && extends(argtypes[4], '_p_Schedule') && is.character(argv[[5]]) && extends(argtypes[6], '_p_DayCounter') && extends(argtypes[7], 'logical') && extends(argtypes[8], 'logical')) {
      f <- CreditDefaultSwap__SWIG_0; 
    }
    else if (is.character(argv[[1]]) && is.numeric(argv[[2]]) && is.numeric(argv[[3]]) && is.numeric(argv[[4]]) && extends(argtypes[5], '_p_Schedule') && is.character(argv[[6]]) && extends(argtypes[7], '_p_DayCounter') && extends(argtypes[8], 'logical')) {
      f <- CreditDefaultSwap__SWIG_4; 
    }
  } else if (argc == 9) {
    if (is.character(argv[[1]]) && is.numeric(argv[[2]]) && is.numeric(argv[[3]]) && is.numeric(argv[[4]]) && extends(argtypes[5], '_p_Schedule') && is.character(argv[[6]]) && extends(argtypes[7], '_p_DayCounter') && extends(argtypes[8], 'logical') && extends(argtypes[9], 'logical')) {
      f <- CreditDefaultSwap__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for CreditDefaultSwap with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of CreditDefaultSwap_side

`CreditDefaultSwap_side` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_CreditDefaultSwap_side', self, as.logical(.copy), PACKAGE='QuantLib');
  ans = enumFromInteger(ans, "_Protection__Side");
  
  ans
  
}

attr(`CreditDefaultSwap_side`, 'returnType') = 'character'
attr(`CreditDefaultSwap_side`, "inputTypes") = c('_p_CreditDefaultSwapPtr')
class(`CreditDefaultSwap_side`) = c("SWIGFunction", class('CreditDefaultSwap_side'))

# Start of CreditDefaultSwap_notional

`CreditDefaultSwap_notional` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_CreditDefaultSwap_notional', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CreditDefaultSwap_notional`, 'returnType') = 'numeric'
attr(`CreditDefaultSwap_notional`, "inputTypes") = c('_p_CreditDefaultSwapPtr')
class(`CreditDefaultSwap_notional`) = c("SWIGFunction", class('CreditDefaultSwap_notional'))

# Start of CreditDefaultSwap_runningSpread

`CreditDefaultSwap_runningSpread` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_CreditDefaultSwap_runningSpread', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CreditDefaultSwap_runningSpread`, 'returnType') = 'numeric'
attr(`CreditDefaultSwap_runningSpread`, "inputTypes") = c('_p_CreditDefaultSwapPtr')
class(`CreditDefaultSwap_runningSpread`) = c("SWIGFunction", class('CreditDefaultSwap_runningSpread'))

# Start of CreditDefaultSwap_upfront

`CreditDefaultSwap_upfront` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_CreditDefaultSwap_upfront', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CreditDefaultSwap_upfront`, 'returnType') = 'numeric'
attr(`CreditDefaultSwap_upfront`, "inputTypes") = c('_p_CreditDefaultSwapPtr')
class(`CreditDefaultSwap_upfront`) = c("SWIGFunction", class('CreditDefaultSwap_upfront'))

# Start of CreditDefaultSwap_settlesAccrual

`CreditDefaultSwap_settlesAccrual` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_CreditDefaultSwap_settlesAccrual', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CreditDefaultSwap_settlesAccrual`, 'returnType') = 'logical'
attr(`CreditDefaultSwap_settlesAccrual`, "inputTypes") = c('_p_CreditDefaultSwapPtr')
class(`CreditDefaultSwap_settlesAccrual`) = c("SWIGFunction", class('CreditDefaultSwap_settlesAccrual'))

# Start of CreditDefaultSwap_paysAtDefaultTime

`CreditDefaultSwap_paysAtDefaultTime` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_CreditDefaultSwap_paysAtDefaultTime', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CreditDefaultSwap_paysAtDefaultTime`, 'returnType') = 'logical'
attr(`CreditDefaultSwap_paysAtDefaultTime`, "inputTypes") = c('_p_CreditDefaultSwapPtr')
class(`CreditDefaultSwap_paysAtDefaultTime`) = c("SWIGFunction", class('CreditDefaultSwap_paysAtDefaultTime'))

# Start of CreditDefaultSwap_fairSpread

`CreditDefaultSwap_fairSpread` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_CreditDefaultSwap_fairSpread', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CreditDefaultSwap_fairSpread`, 'returnType') = 'numeric'
attr(`CreditDefaultSwap_fairSpread`, "inputTypes") = c('_p_CreditDefaultSwapPtr')
class(`CreditDefaultSwap_fairSpread`) = c("SWIGFunction", class('CreditDefaultSwap_fairSpread'))

# Start of CreditDefaultSwap_fairUpfront

`CreditDefaultSwap_fairUpfront` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_CreditDefaultSwap_fairUpfront', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CreditDefaultSwap_fairUpfront`, 'returnType') = 'numeric'
attr(`CreditDefaultSwap_fairUpfront`, "inputTypes") = c('_p_CreditDefaultSwapPtr')
class(`CreditDefaultSwap_fairUpfront`) = c("SWIGFunction", class('CreditDefaultSwap_fairUpfront'))

# Start of CreditDefaultSwap_couponLegBPS

`CreditDefaultSwap_couponLegBPS` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_CreditDefaultSwap_couponLegBPS', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CreditDefaultSwap_couponLegBPS`, 'returnType') = 'numeric'
attr(`CreditDefaultSwap_couponLegBPS`, "inputTypes") = c('_p_CreditDefaultSwapPtr')
class(`CreditDefaultSwap_couponLegBPS`) = c("SWIGFunction", class('CreditDefaultSwap_couponLegBPS'))

# Start of CreditDefaultSwap_couponLegNPV

`CreditDefaultSwap_couponLegNPV` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_CreditDefaultSwap_couponLegNPV', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CreditDefaultSwap_couponLegNPV`, 'returnType') = 'numeric'
attr(`CreditDefaultSwap_couponLegNPV`, "inputTypes") = c('_p_CreditDefaultSwapPtr')
class(`CreditDefaultSwap_couponLegNPV`) = c("SWIGFunction", class('CreditDefaultSwap_couponLegNPV'))

# Start of CreditDefaultSwap_defaultLegNPV

`CreditDefaultSwap_defaultLegNPV` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_CreditDefaultSwap_defaultLegNPV', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CreditDefaultSwap_defaultLegNPV`, 'returnType') = 'numeric'
attr(`CreditDefaultSwap_defaultLegNPV`, "inputTypes") = c('_p_CreditDefaultSwapPtr')
class(`CreditDefaultSwap_defaultLegNPV`) = c("SWIGFunction", class('CreditDefaultSwap_defaultLegNPV'))

# Start of CreditDefaultSwap_upfrontBPS

`CreditDefaultSwap_upfrontBPS` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_CreditDefaultSwap_upfrontBPS', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CreditDefaultSwap_upfrontBPS`, 'returnType') = 'numeric'
attr(`CreditDefaultSwap_upfrontBPS`, "inputTypes") = c('_p_CreditDefaultSwapPtr')
class(`CreditDefaultSwap_upfrontBPS`) = c("SWIGFunction", class('CreditDefaultSwap_upfrontBPS'))

# Start of CreditDefaultSwap_upfrontNPV

`CreditDefaultSwap_upfrontNPV` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_CreditDefaultSwap_upfrontNPV', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CreditDefaultSwap_upfrontNPV`, 'returnType') = 'numeric'
attr(`CreditDefaultSwap_upfrontNPV`, "inputTypes") = c('_p_CreditDefaultSwapPtr')
class(`CreditDefaultSwap_upfrontNPV`) = c("SWIGFunction", class('CreditDefaultSwap_upfrontNPV'))

# Start of CreditDefaultSwap_impliedHazardRate

`CreditDefaultSwap_impliedHazardRate__SWIG_0` = function(self, targetNPV, discountCurve, dayCounter, recoveryRate, accuracy, .copy = FALSE)
{
  ;.Call('R_swig_CreditDefaultSwap_impliedHazardRate__SWIG_0', self, targetNPV, discountCurve, dayCounter, recoveryRate, accuracy, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CreditDefaultSwap_impliedHazardRate__SWIG_0`, 'returnType') = 'numeric'
attr(`CreditDefaultSwap_impliedHazardRate__SWIG_0`, "inputTypes") = c('_p_CreditDefaultSwapPtr', 'numeric', '_p_HandleT_YieldTermStructure_t', '_p_DayCounter', 'numeric', 'numeric')
class(`CreditDefaultSwap_impliedHazardRate__SWIG_0`) = c("SWIGFunction", class('CreditDefaultSwap_impliedHazardRate__SWIG_0'))

# Start of CreditDefaultSwap_impliedHazardRate

`CreditDefaultSwap_impliedHazardRate__SWIG_1` = function(self, targetNPV, discountCurve, dayCounter, recoveryRate, .copy = FALSE)
{
  ;.Call('R_swig_CreditDefaultSwap_impliedHazardRate__SWIG_1', self, targetNPV, discountCurve, dayCounter, recoveryRate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CreditDefaultSwap_impliedHazardRate__SWIG_1`, 'returnType') = 'numeric'
attr(`CreditDefaultSwap_impliedHazardRate__SWIG_1`, "inputTypes") = c('_p_CreditDefaultSwapPtr', 'numeric', '_p_HandleT_YieldTermStructure_t', '_p_DayCounter', 'numeric')
class(`CreditDefaultSwap_impliedHazardRate__SWIG_1`) = c("SWIGFunction", class('CreditDefaultSwap_impliedHazardRate__SWIG_1'))

# Start of CreditDefaultSwap_impliedHazardRate

`CreditDefaultSwap_impliedHazardRate__SWIG_2` = function(self, targetNPV, discountCurve, dayCounter, .copy = FALSE)
{
  ;.Call('R_swig_CreditDefaultSwap_impliedHazardRate__SWIG_2', self, targetNPV, discountCurve, dayCounter, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CreditDefaultSwap_impliedHazardRate__SWIG_2`, 'returnType') = 'numeric'
attr(`CreditDefaultSwap_impliedHazardRate__SWIG_2`, "inputTypes") = c('_p_CreditDefaultSwapPtr', 'numeric', '_p_HandleT_YieldTermStructure_t', '_p_DayCounter')
class(`CreditDefaultSwap_impliedHazardRate__SWIG_2`) = c("SWIGFunction", class('CreditDefaultSwap_impliedHazardRate__SWIG_2'))

`CreditDefaultSwap_impliedHazardRate` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 4) {
    if (extends(argtypes[1], '_p_CreditDefaultSwapPtr') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_HandleT_YieldTermStructure_t') && extends(argtypes[4], '_p_DayCounter')) {
      f <- CreditDefaultSwap_impliedHazardRate__SWIG_2; 
    }
  } else if (argc == 5) {
    if (extends(argtypes[1], '_p_CreditDefaultSwapPtr') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_HandleT_YieldTermStructure_t') && extends(argtypes[4], '_p_DayCounter') && is.numeric(argv[[5]])) {
      f <- CreditDefaultSwap_impliedHazardRate__SWIG_1; 
    }
  } else if (argc == 6) {
    if (extends(argtypes[1], '_p_CreditDefaultSwapPtr') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_HandleT_YieldTermStructure_t') && extends(argtypes[4], '_p_DayCounter') && is.numeric(argv[[5]]) && is.numeric(argv[[6]])) {
      f <- CreditDefaultSwap_impliedHazardRate__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for CreditDefaultSwap_impliedHazardRate with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of CreditDefaultSwap_coupons

`CreditDefaultSwap_coupons` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_CreditDefaultSwap_coupons', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t";
  
  ans
  
}

attr(`CreditDefaultSwap_coupons`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t'
attr(`CreditDefaultSwap_coupons`, "inputTypes") = c('_p_CreditDefaultSwapPtr')
class(`CreditDefaultSwap_coupons`) = c("SWIGFunction", class('CreditDefaultSwap_coupons'))

# Start of delete_CreditDefaultSwap

`delete_CreditDefaultSwap` = function(self)
{
  ;.Call('R_swig_delete_CreditDefaultSwap', self, PACKAGE='QuantLib');
  
}

attr(`delete_CreditDefaultSwap`, 'returnType') = 'void'
attr(`delete_CreditDefaultSwap`, "inputTypes") = c('_p_CreditDefaultSwapPtr')
class(`delete_CreditDefaultSwap`) = c("SWIGFunction", class('delete_CreditDefaultSwap'))

# Start of accessor method for CreditDefaultSwapPtr
setMethod('$', '_p_CreditDefaultSwapPtr', function(x, name)

{
  accessorFuns = list('side' = CreditDefaultSwap_side, 'notional' = CreditDefaultSwap_notional, 'runningSpread' = CreditDefaultSwap_runningSpread, 'upfront' = CreditDefaultSwap_upfront, 'settlesAccrual' = CreditDefaultSwap_settlesAccrual, 'paysAtDefaultTime' = CreditDefaultSwap_paysAtDefaultTime, 'fairSpread' = CreditDefaultSwap_fairSpread, 'fairUpfront' = CreditDefaultSwap_fairUpfront, 'couponLegBPS' = CreditDefaultSwap_couponLegBPS, 'couponLegNPV' = CreditDefaultSwap_couponLegNPV, 'defaultLegNPV' = CreditDefaultSwap_defaultLegNPV, 'upfrontBPS' = CreditDefaultSwap_upfrontBPS, 'upfrontNPV' = CreditDefaultSwap_upfrontNPV, 'impliedHazardRate' = CreditDefaultSwap_impliedHazardRate, 'coupons' = CreditDefaultSwap_coupons);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for CreditDefaultSwapPtr
setMethod('delete', '_p_CreditDefaultSwapPtr', function(obj) {delete_CreditDefaultSwapPtr(obj)})
# Start of new_MidPointCdsEngine

`MidPointCdsEngine` = function(probability, recoveryRate, discountCurve)
{
  ;ans = .Call('R_swig_new_MidPointCdsEngine', probability, recoveryRate, discountCurve, PACKAGE='QuantLib');
  class(ans) <- "_p_MidPointCdsEnginePtr";
  
  reg.finalizer(ans, delete_MidPointCdsEngine)
  ans
  
}

attr(`MidPointCdsEngine`, 'returnType') = '_p_MidPointCdsEnginePtr'
attr(`MidPointCdsEngine`, "inputTypes") = c('_p_HandleT_DefaultProbabilityTermStructure_t', 'numeric', '_p_HandleT_YieldTermStructure_t')
class(`MidPointCdsEngine`) = c("SWIGFunction", class('MidPointCdsEngine'))

# Start of delete_MidPointCdsEngine

`delete_MidPointCdsEngine` = function(self)
{
  ;.Call('R_swig_delete_MidPointCdsEngine', self, PACKAGE='QuantLib');
  
}

attr(`delete_MidPointCdsEngine`, 'returnType') = 'void'
attr(`delete_MidPointCdsEngine`, "inputTypes") = c('_p_MidPointCdsEnginePtr')
class(`delete_MidPointCdsEngine`) = c("SWIGFunction", class('delete_MidPointCdsEngine'))

setMethod('delete', '_p_MidPointCdsEnginePtr', function(obj) {delete_MidPointCdsEnginePtr(obj)})
# Start of new_DiscountCurve

`DiscountCurve__SWIG_0` = function(dates, discounts, dayCounter, calendar, i)
{
  ;ans = .Call('R_swig_new_DiscountCurve__SWIG_0', dates, discounts, dayCounter, calendar, i, PACKAGE='QuantLib');
  class(ans) <- "_p_DiscountCurvePtr";
  
  reg.finalizer(ans, delete_DiscountCurve)
  ans
  
}

attr(`DiscountCurve__SWIG_0`, 'returnType') = '_p_DiscountCurvePtr'
attr(`DiscountCurve__SWIG_0`, "inputTypes") = c('_p_std__vectorT_Date_std__allocatorT_Date_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_DayCounter', '_p_Calendar', '_p_LogLinear')
class(`DiscountCurve__SWIG_0`) = c("SWIGFunction", class('DiscountCurve__SWIG_0'))

# Start of new_DiscountCurve

`DiscountCurve__SWIG_1` = function(dates, discounts, dayCounter, calendar)
{
  ;ans = .Call('R_swig_new_DiscountCurve__SWIG_1', dates, discounts, dayCounter, calendar, PACKAGE='QuantLib');
  class(ans) <- "_p_DiscountCurvePtr";
  
  reg.finalizer(ans, delete_DiscountCurve)
  ans
  
}

attr(`DiscountCurve__SWIG_1`, 'returnType') = '_p_DiscountCurvePtr'
attr(`DiscountCurve__SWIG_1`, "inputTypes") = c('_p_std__vectorT_Date_std__allocatorT_Date_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_DayCounter', '_p_Calendar')
class(`DiscountCurve__SWIG_1`) = c("SWIGFunction", class('DiscountCurve__SWIG_1'))

# Start of new_DiscountCurve

`DiscountCurve__SWIG_2` = function(dates, discounts, dayCounter)
{
  ;ans = .Call('R_swig_new_DiscountCurve__SWIG_2', dates, discounts, dayCounter, PACKAGE='QuantLib');
  class(ans) <- "_p_DiscountCurvePtr";
  
  reg.finalizer(ans, delete_DiscountCurve)
  ans
  
}

attr(`DiscountCurve__SWIG_2`, 'returnType') = '_p_DiscountCurvePtr'
attr(`DiscountCurve__SWIG_2`, "inputTypes") = c('_p_std__vectorT_Date_std__allocatorT_Date_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_DayCounter')
class(`DiscountCurve__SWIG_2`) = c("SWIGFunction", class('DiscountCurve__SWIG_2'))

`DiscountCurve` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 3) {
    if (extends(argtypes[1], '_p_std__vectorT_Date_std__allocatorT_Date_t_t') && extends(argtypes[2], '_p_std__vectorT_double_std__allocatorT_double_t_t') && extends(argtypes[3], '_p_DayCounter')) {
      f <- DiscountCurve__SWIG_2; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_std__vectorT_Date_std__allocatorT_Date_t_t') && extends(argtypes[2], '_p_std__vectorT_double_std__allocatorT_double_t_t') && extends(argtypes[3], '_p_DayCounter') && extends(argtypes[4], '_p_Calendar')) {
      f <- DiscountCurve__SWIG_1; 
    }
  } else if (argc == 5) {
    if (extends(argtypes[1], '_p_std__vectorT_Date_std__allocatorT_Date_t_t') && extends(argtypes[2], '_p_std__vectorT_double_std__allocatorT_double_t_t') && extends(argtypes[3], '_p_DayCounter') && extends(argtypes[4], '_p_Calendar') && extends(argtypes[5], '_p_LogLinear')) {
      f <- DiscountCurve__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for DiscountCurve with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of DiscountCurve_dates

`DiscountCurve_dates` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_DiscountCurve_dates', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_Date_std__allocatorT_Date_t_t";
  
  ans
  
}

attr(`DiscountCurve_dates`, 'returnType') = '_p_std__vectorT_Date_std__allocatorT_Date_t_t'
attr(`DiscountCurve_dates`, "inputTypes") = c('_p_DiscountCurvePtr')
class(`DiscountCurve_dates`) = c("SWIGFunction", class('DiscountCurve_dates'))

# Start of DiscountCurve_discounts

`DiscountCurve_discounts` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_DiscountCurve_discounts', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_double_std__allocatorT_double_t_t";
  
  ans
  
}

attr(`DiscountCurve_discounts`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`DiscountCurve_discounts`, "inputTypes") = c('_p_DiscountCurvePtr')
class(`DiscountCurve_discounts`) = c("SWIGFunction", class('DiscountCurve_discounts'))

# Start of delete_DiscountCurve

`delete_DiscountCurve` = function(self)
{
  ;.Call('R_swig_delete_DiscountCurve', self, PACKAGE='QuantLib');
  
}

attr(`delete_DiscountCurve`, 'returnType') = 'void'
attr(`delete_DiscountCurve`, "inputTypes") = c('_p_DiscountCurvePtr')
class(`delete_DiscountCurve`) = c("SWIGFunction", class('delete_DiscountCurve'))

# Start of accessor method for DiscountCurvePtr
setMethod('$', '_p_DiscountCurvePtr', function(x, name)

{
  accessorFuns = list('dates' = DiscountCurve_dates, 'discounts' = DiscountCurve_discounts);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for DiscountCurvePtr
setMethod('delete', '_p_DiscountCurvePtr', function(obj) {delete_DiscountCurvePtr(obj)})
# Start of new_NormalDistribution

`NormalDistribution__SWIG_0` = function(average, sigma)
{
  ;ans = .Call('R_swig_new_NormalDistribution__SWIG_0', average, sigma, PACKAGE='QuantLib');
  class(ans) <- "_p_NormalDistribution";
  
  reg.finalizer(ans, delete_NormalDistribution)
  ans
  
}

attr(`NormalDistribution__SWIG_0`, 'returnType') = '_p_NormalDistribution'
attr(`NormalDistribution__SWIG_0`, "inputTypes") = c('numeric', 'numeric')
class(`NormalDistribution__SWIG_0`) = c("SWIGFunction", class('NormalDistribution__SWIG_0'))

# Start of new_NormalDistribution

`NormalDistribution__SWIG_1` = function(average)
{
  ;ans = .Call('R_swig_new_NormalDistribution__SWIG_1', average, PACKAGE='QuantLib');
  class(ans) <- "_p_NormalDistribution";
  
  reg.finalizer(ans, delete_NormalDistribution)
  ans
  
}

attr(`NormalDistribution__SWIG_1`, 'returnType') = '_p_NormalDistribution'
attr(`NormalDistribution__SWIG_1`, "inputTypes") = c('numeric')
class(`NormalDistribution__SWIG_1`) = c("SWIGFunction", class('NormalDistribution__SWIG_1'))

# Start of new_NormalDistribution

`NormalDistribution__SWIG_2` = function()
{
  ;ans = .Call('R_swig_new_NormalDistribution__SWIG_2', PACKAGE='QuantLib');
  class(ans) <- "_p_NormalDistribution";
  
  reg.finalizer(ans, delete_NormalDistribution)
  ans
  
}

attr(`NormalDistribution__SWIG_2`, 'returnType') = '_p_NormalDistribution'
class(`NormalDistribution__SWIG_2`) = c("SWIGFunction", class('NormalDistribution__SWIG_2'))

`NormalDistribution` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 0) {
    f <- NormalDistribution__SWIG_2; 
  } else if (argc == 1) {
    if (is.numeric(argv[[1]])) {
      f <- NormalDistribution__SWIG_1; 
    }
  } else if (argc == 2) {
    if (is.numeric(argv[[1]]) && is.numeric(argv[[2]])) {
      f <- NormalDistribution__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for NormalDistribution with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of NormalDistribution___call__

`NormalDistribution___call__` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_NormalDistribution___call__', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`NormalDistribution___call__`, 'returnType') = 'numeric'
attr(`NormalDistribution___call__`, "inputTypes") = c('_p_NormalDistribution', 'numeric')
class(`NormalDistribution___call__`) = c("SWIGFunction", class('NormalDistribution___call__'))

# Start of NormalDistribution_derivative

`NormalDistribution_derivative` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_NormalDistribution_derivative', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`NormalDistribution_derivative`, 'returnType') = 'numeric'
attr(`NormalDistribution_derivative`, "inputTypes") = c('_p_NormalDistribution', 'numeric')
class(`NormalDistribution_derivative`) = c("SWIGFunction", class('NormalDistribution_derivative'))

# Start of delete_NormalDistribution

`delete_NormalDistribution` = function(self)
{
  ;.Call('R_swig_delete_NormalDistribution', self, PACKAGE='QuantLib');
  
}

attr(`delete_NormalDistribution`, 'returnType') = 'void'
attr(`delete_NormalDistribution`, "inputTypes") = c('_p_NormalDistribution')
class(`delete_NormalDistribution`) = c("SWIGFunction", class('delete_NormalDistribution'))

# Start of accessor method for NormalDistribution
setMethod('$', '_p_NormalDistribution', function(x, name)

{
  accessorFuns = list('__call__' = NormalDistribution___call__, 'derivative' = NormalDistribution_derivative);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for NormalDistribution
setMethod('delete', '_p_NormalDistribution', function(obj) {delete_NormalDistribution(obj)})
# Start of new_CumulativeNormalDistribution

`CumulativeNormalDistribution__SWIG_0` = function(average, sigma)
{
  ;ans = .Call('R_swig_new_CumulativeNormalDistribution__SWIG_0', average, sigma, PACKAGE='QuantLib');
  class(ans) <- "_p_CumulativeNormalDistribution";
  
  reg.finalizer(ans, delete_CumulativeNormalDistribution)
  ans
  
}

attr(`CumulativeNormalDistribution__SWIG_0`, 'returnType') = '_p_CumulativeNormalDistribution'
attr(`CumulativeNormalDistribution__SWIG_0`, "inputTypes") = c('numeric', 'numeric')
class(`CumulativeNormalDistribution__SWIG_0`) = c("SWIGFunction", class('CumulativeNormalDistribution__SWIG_0'))

# Start of new_CumulativeNormalDistribution

`CumulativeNormalDistribution__SWIG_1` = function(average)
{
  ;ans = .Call('R_swig_new_CumulativeNormalDistribution__SWIG_1', average, PACKAGE='QuantLib');
  class(ans) <- "_p_CumulativeNormalDistribution";
  
  reg.finalizer(ans, delete_CumulativeNormalDistribution)
  ans
  
}

attr(`CumulativeNormalDistribution__SWIG_1`, 'returnType') = '_p_CumulativeNormalDistribution'
attr(`CumulativeNormalDistribution__SWIG_1`, "inputTypes") = c('numeric')
class(`CumulativeNormalDistribution__SWIG_1`) = c("SWIGFunction", class('CumulativeNormalDistribution__SWIG_1'))

# Start of new_CumulativeNormalDistribution

`CumulativeNormalDistribution__SWIG_2` = function()
{
  ;ans = .Call('R_swig_new_CumulativeNormalDistribution__SWIG_2', PACKAGE='QuantLib');
  class(ans) <- "_p_CumulativeNormalDistribution";
  
  reg.finalizer(ans, delete_CumulativeNormalDistribution)
  ans
  
}

attr(`CumulativeNormalDistribution__SWIG_2`, 'returnType') = '_p_CumulativeNormalDistribution'
class(`CumulativeNormalDistribution__SWIG_2`) = c("SWIGFunction", class('CumulativeNormalDistribution__SWIG_2'))

`CumulativeNormalDistribution` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 0) {
    f <- CumulativeNormalDistribution__SWIG_2; 
  } else if (argc == 1) {
    if (is.numeric(argv[[1]])) {
      f <- CumulativeNormalDistribution__SWIG_1; 
    }
  } else if (argc == 2) {
    if (is.numeric(argv[[1]]) && is.numeric(argv[[2]])) {
      f <- CumulativeNormalDistribution__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for CumulativeNormalDistribution with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of CumulativeNormalDistribution___call__

`CumulativeNormalDistribution___call__` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_CumulativeNormalDistribution___call__', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CumulativeNormalDistribution___call__`, 'returnType') = 'numeric'
attr(`CumulativeNormalDistribution___call__`, "inputTypes") = c('_p_CumulativeNormalDistribution', 'numeric')
class(`CumulativeNormalDistribution___call__`) = c("SWIGFunction", class('CumulativeNormalDistribution___call__'))

# Start of CumulativeNormalDistribution_derivative

`CumulativeNormalDistribution_derivative` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_CumulativeNormalDistribution_derivative', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CumulativeNormalDistribution_derivative`, 'returnType') = 'numeric'
attr(`CumulativeNormalDistribution_derivative`, "inputTypes") = c('_p_CumulativeNormalDistribution', 'numeric')
class(`CumulativeNormalDistribution_derivative`) = c("SWIGFunction", class('CumulativeNormalDistribution_derivative'))

# Start of delete_CumulativeNormalDistribution

`delete_CumulativeNormalDistribution` = function(self)
{
  ;.Call('R_swig_delete_CumulativeNormalDistribution', self, PACKAGE='QuantLib');
  
}

attr(`delete_CumulativeNormalDistribution`, 'returnType') = 'void'
attr(`delete_CumulativeNormalDistribution`, "inputTypes") = c('_p_CumulativeNormalDistribution')
class(`delete_CumulativeNormalDistribution`) = c("SWIGFunction", class('delete_CumulativeNormalDistribution'))

# Start of accessor method for CumulativeNormalDistribution
setMethod('$', '_p_CumulativeNormalDistribution', function(x, name)

{
  accessorFuns = list('__call__' = CumulativeNormalDistribution___call__, 'derivative' = CumulativeNormalDistribution_derivative);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for CumulativeNormalDistribution
setMethod('delete', '_p_CumulativeNormalDistribution', function(obj) {delete_CumulativeNormalDistribution(obj)})
# Start of new_InverseCumulativeNormal

`InverseCumulativeNormal__SWIG_0` = function(average, sigma)
{
  ;ans = .Call('R_swig_new_InverseCumulativeNormal__SWIG_0', average, sigma, PACKAGE='QuantLib');
  class(ans) <- "_p_InverseCumulativeNormal";
  
  reg.finalizer(ans, delete_InverseCumulativeNormal)
  ans
  
}

attr(`InverseCumulativeNormal__SWIG_0`, 'returnType') = '_p_InverseCumulativeNormal'
attr(`InverseCumulativeNormal__SWIG_0`, "inputTypes") = c('numeric', 'numeric')
class(`InverseCumulativeNormal__SWIG_0`) = c("SWIGFunction", class('InverseCumulativeNormal__SWIG_0'))

# Start of new_InverseCumulativeNormal

`InverseCumulativeNormal__SWIG_1` = function(average)
{
  ;ans = .Call('R_swig_new_InverseCumulativeNormal__SWIG_1', average, PACKAGE='QuantLib');
  class(ans) <- "_p_InverseCumulativeNormal";
  
  reg.finalizer(ans, delete_InverseCumulativeNormal)
  ans
  
}

attr(`InverseCumulativeNormal__SWIG_1`, 'returnType') = '_p_InverseCumulativeNormal'
attr(`InverseCumulativeNormal__SWIG_1`, "inputTypes") = c('numeric')
class(`InverseCumulativeNormal__SWIG_1`) = c("SWIGFunction", class('InverseCumulativeNormal__SWIG_1'))

# Start of new_InverseCumulativeNormal

`InverseCumulativeNormal__SWIG_2` = function()
{
  ;ans = .Call('R_swig_new_InverseCumulativeNormal__SWIG_2', PACKAGE='QuantLib');
  class(ans) <- "_p_InverseCumulativeNormal";
  
  reg.finalizer(ans, delete_InverseCumulativeNormal)
  ans
  
}

attr(`InverseCumulativeNormal__SWIG_2`, 'returnType') = '_p_InverseCumulativeNormal'
class(`InverseCumulativeNormal__SWIG_2`) = c("SWIGFunction", class('InverseCumulativeNormal__SWIG_2'))

`InverseCumulativeNormal` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 0) {
    f <- InverseCumulativeNormal__SWIG_2; 
  } else if (argc == 1) {
    if (is.numeric(argv[[1]])) {
      f <- InverseCumulativeNormal__SWIG_1; 
    }
  } else if (argc == 2) {
    if (is.numeric(argv[[1]]) && is.numeric(argv[[2]])) {
      f <- InverseCumulativeNormal__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for InverseCumulativeNormal with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InverseCumulativeNormal___call__

`InverseCumulativeNormal___call__` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_InverseCumulativeNormal___call__', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`InverseCumulativeNormal___call__`, 'returnType') = 'numeric'
attr(`InverseCumulativeNormal___call__`, "inputTypes") = c('_p_InverseCumulativeNormal', 'numeric')
class(`InverseCumulativeNormal___call__`) = c("SWIGFunction", class('InverseCumulativeNormal___call__'))

# Start of delete_InverseCumulativeNormal

`delete_InverseCumulativeNormal` = function(self)
{
  ;.Call('R_swig_delete_InverseCumulativeNormal', self, PACKAGE='QuantLib');
  
}

attr(`delete_InverseCumulativeNormal`, 'returnType') = 'void'
attr(`delete_InverseCumulativeNormal`, "inputTypes") = c('_p_InverseCumulativeNormal')
class(`delete_InverseCumulativeNormal`) = c("SWIGFunction", class('delete_InverseCumulativeNormal'))

# Start of accessor method for InverseCumulativeNormal
setMethod('$', '_p_InverseCumulativeNormal', function(x, name)

{
  accessorFuns = list('__call__' = InverseCumulativeNormal___call__);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for InverseCumulativeNormal
setMethod('delete', '_p_InverseCumulativeNormal', function(obj) {delete_InverseCumulativeNormal(obj)})
# Start of new_MoroInverseCumulativeNormal

`MoroInverseCumulativeNormal__SWIG_0` = function(average, sigma)
{
  ;ans = .Call('R_swig_new_MoroInverseCumulativeNormal__SWIG_0', average, sigma, PACKAGE='QuantLib');
  class(ans) <- "_p_MoroInverseCumulativeNormal";
  
  reg.finalizer(ans, delete_MoroInverseCumulativeNormal)
  ans
  
}

attr(`MoroInverseCumulativeNormal__SWIG_0`, 'returnType') = '_p_MoroInverseCumulativeNormal'
attr(`MoroInverseCumulativeNormal__SWIG_0`, "inputTypes") = c('numeric', 'numeric')
class(`MoroInverseCumulativeNormal__SWIG_0`) = c("SWIGFunction", class('MoroInverseCumulativeNormal__SWIG_0'))

# Start of new_MoroInverseCumulativeNormal

`MoroInverseCumulativeNormal__SWIG_1` = function(average)
{
  ;ans = .Call('R_swig_new_MoroInverseCumulativeNormal__SWIG_1', average, PACKAGE='QuantLib');
  class(ans) <- "_p_MoroInverseCumulativeNormal";
  
  reg.finalizer(ans, delete_MoroInverseCumulativeNormal)
  ans
  
}

attr(`MoroInverseCumulativeNormal__SWIG_1`, 'returnType') = '_p_MoroInverseCumulativeNormal'
attr(`MoroInverseCumulativeNormal__SWIG_1`, "inputTypes") = c('numeric')
class(`MoroInverseCumulativeNormal__SWIG_1`) = c("SWIGFunction", class('MoroInverseCumulativeNormal__SWIG_1'))

# Start of new_MoroInverseCumulativeNormal

`MoroInverseCumulativeNormal__SWIG_2` = function()
{
  ;ans = .Call('R_swig_new_MoroInverseCumulativeNormal__SWIG_2', PACKAGE='QuantLib');
  class(ans) <- "_p_MoroInverseCumulativeNormal";
  
  reg.finalizer(ans, delete_MoroInverseCumulativeNormal)
  ans
  
}

attr(`MoroInverseCumulativeNormal__SWIG_2`, 'returnType') = '_p_MoroInverseCumulativeNormal'
class(`MoroInverseCumulativeNormal__SWIG_2`) = c("SWIGFunction", class('MoroInverseCumulativeNormal__SWIG_2'))

`MoroInverseCumulativeNormal` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 0) {
    f <- MoroInverseCumulativeNormal__SWIG_2; 
  } else if (argc == 1) {
    if (is.numeric(argv[[1]])) {
      f <- MoroInverseCumulativeNormal__SWIG_1; 
    }
  } else if (argc == 2) {
    if (is.numeric(argv[[1]]) && is.numeric(argv[[2]])) {
      f <- MoroInverseCumulativeNormal__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for MoroInverseCumulativeNormal with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of MoroInverseCumulativeNormal___call__

`MoroInverseCumulativeNormal___call__` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_MoroInverseCumulativeNormal___call__', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`MoroInverseCumulativeNormal___call__`, 'returnType') = 'numeric'
attr(`MoroInverseCumulativeNormal___call__`, "inputTypes") = c('_p_MoroInverseCumulativeNormal', 'numeric')
class(`MoroInverseCumulativeNormal___call__`) = c("SWIGFunction", class('MoroInverseCumulativeNormal___call__'))

# Start of delete_MoroInverseCumulativeNormal

`delete_MoroInverseCumulativeNormal` = function(self)
{
  ;.Call('R_swig_delete_MoroInverseCumulativeNormal', self, PACKAGE='QuantLib');
  
}

attr(`delete_MoroInverseCumulativeNormal`, 'returnType') = 'void'
attr(`delete_MoroInverseCumulativeNormal`, "inputTypes") = c('_p_MoroInverseCumulativeNormal')
class(`delete_MoroInverseCumulativeNormal`) = c("SWIGFunction", class('delete_MoroInverseCumulativeNormal'))

# Start of accessor method for MoroInverseCumulativeNormal
setMethod('$', '_p_MoroInverseCumulativeNormal', function(x, name)

{
  accessorFuns = list('__call__' = MoroInverseCumulativeNormal___call__);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for MoroInverseCumulativeNormal
setMethod('delete', '_p_MoroInverseCumulativeNormal', function(obj) {delete_MoroInverseCumulativeNormal(obj)})
# Start of new_BivariateCumulativeNormalDistribution

`BivariateCumulativeNormalDistribution` = function(rho)
{
  ;ans = .Call('R_swig_new_BivariateCumulativeNormalDistribution', rho, PACKAGE='QuantLib');
  class(ans) <- "_p_BivariateCumulativeNormalDistribution";
  
  reg.finalizer(ans, delete_BivariateCumulativeNormalDistribution)
  ans
  
}

attr(`BivariateCumulativeNormalDistribution`, 'returnType') = '_p_BivariateCumulativeNormalDistribution'
attr(`BivariateCumulativeNormalDistribution`, "inputTypes") = c('numeric')
class(`BivariateCumulativeNormalDistribution`) = c("SWIGFunction", class('BivariateCumulativeNormalDistribution'))

# Start of BivariateCumulativeNormalDistribution___call__

`BivariateCumulativeNormalDistribution___call__` = function(self, x, y, .copy = FALSE)
{
  ;.Call('R_swig_BivariateCumulativeNormalDistribution___call__', self, x, y, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BivariateCumulativeNormalDistribution___call__`, 'returnType') = 'numeric'
attr(`BivariateCumulativeNormalDistribution___call__`, "inputTypes") = c('_p_BivariateCumulativeNormalDistribution', 'numeric', 'numeric')
class(`BivariateCumulativeNormalDistribution___call__`) = c("SWIGFunction", class('BivariateCumulativeNormalDistribution___call__'))

# Start of delete_BivariateCumulativeNormalDistribution

`delete_BivariateCumulativeNormalDistribution` = function(self)
{
  ;.Call('R_swig_delete_BivariateCumulativeNormalDistribution', self, PACKAGE='QuantLib');
  
}

attr(`delete_BivariateCumulativeNormalDistribution`, 'returnType') = 'void'
attr(`delete_BivariateCumulativeNormalDistribution`, "inputTypes") = c('_p_BivariateCumulativeNormalDistribution')
class(`delete_BivariateCumulativeNormalDistribution`) = c("SWIGFunction", class('delete_BivariateCumulativeNormalDistribution'))

# Start of accessor method for BivariateCumulativeNormalDistribution
setMethod('$', '_p_BivariateCumulativeNormalDistribution', function(x, name)

{
  accessorFuns = list('__call__' = BivariateCumulativeNormalDistribution___call__);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for BivariateCumulativeNormalDistribution
setMethod('delete', '_p_BivariateCumulativeNormalDistribution', function(obj) {delete_BivariateCumulativeNormalDistribution(obj)})
# Start of new_BinomialDistribution

`BinomialDistribution` = function(p, n)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;ans = .Call('R_swig_new_BinomialDistribution', p, n, PACKAGE='QuantLib');
  class(ans) <- "_p_BinomialDistribution";
  
  reg.finalizer(ans, delete_BinomialDistribution)
  ans
  
}

attr(`BinomialDistribution`, 'returnType') = '_p_BinomialDistribution'
attr(`BinomialDistribution`, "inputTypes") = c('numeric', 'integer')
class(`BinomialDistribution`) = c("SWIGFunction", class('BinomialDistribution'))

# Start of BinomialDistribution___call__

`BinomialDistribution___call__` = function(self, k, .copy = FALSE)
{
  if(length(k) > 1) {
    warning("using only the first element of k");
  };
  
  ;.Call('R_swig_BinomialDistribution___call__', self, k, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BinomialDistribution___call__`, 'returnType') = 'numeric'
attr(`BinomialDistribution___call__`, "inputTypes") = c('_p_BinomialDistribution', 'integer')
class(`BinomialDistribution___call__`) = c("SWIGFunction", class('BinomialDistribution___call__'))

# Start of delete_BinomialDistribution

`delete_BinomialDistribution` = function(self)
{
  ;.Call('R_swig_delete_BinomialDistribution', self, PACKAGE='QuantLib');
  
}

attr(`delete_BinomialDistribution`, 'returnType') = 'void'
attr(`delete_BinomialDistribution`, "inputTypes") = c('_p_BinomialDistribution')
class(`delete_BinomialDistribution`) = c("SWIGFunction", class('delete_BinomialDistribution'))

# Start of accessor method for BinomialDistribution
setMethod('$', '_p_BinomialDistribution', function(x, name)

{
  accessorFuns = list('__call__' = BinomialDistribution___call__);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for BinomialDistribution
setMethod('delete', '_p_BinomialDistribution', function(obj) {delete_BinomialDistribution(obj)})
# Start of new_CumulativeBinomialDistribution

`CumulativeBinomialDistribution` = function(p, n)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;ans = .Call('R_swig_new_CumulativeBinomialDistribution', p, n, PACKAGE='QuantLib');
  class(ans) <- "_p_CumulativeBinomialDistribution";
  
  reg.finalizer(ans, delete_CumulativeBinomialDistribution)
  ans
  
}

attr(`CumulativeBinomialDistribution`, 'returnType') = '_p_CumulativeBinomialDistribution'
attr(`CumulativeBinomialDistribution`, "inputTypes") = c('numeric', 'integer')
class(`CumulativeBinomialDistribution`) = c("SWIGFunction", class('CumulativeBinomialDistribution'))

# Start of CumulativeBinomialDistribution___call__

`CumulativeBinomialDistribution___call__` = function(self, k, .copy = FALSE)
{
  if(length(k) > 1) {
    warning("using only the first element of k");
  };
  
  ;.Call('R_swig_CumulativeBinomialDistribution___call__', self, k, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CumulativeBinomialDistribution___call__`, 'returnType') = 'numeric'
attr(`CumulativeBinomialDistribution___call__`, "inputTypes") = c('_p_CumulativeBinomialDistribution', 'integer')
class(`CumulativeBinomialDistribution___call__`) = c("SWIGFunction", class('CumulativeBinomialDistribution___call__'))

# Start of delete_CumulativeBinomialDistribution

`delete_CumulativeBinomialDistribution` = function(self)
{
  ;.Call('R_swig_delete_CumulativeBinomialDistribution', self, PACKAGE='QuantLib');
  
}

attr(`delete_CumulativeBinomialDistribution`, 'returnType') = 'void'
attr(`delete_CumulativeBinomialDistribution`, "inputTypes") = c('_p_CumulativeBinomialDistribution')
class(`delete_CumulativeBinomialDistribution`) = c("SWIGFunction", class('delete_CumulativeBinomialDistribution'))

# Start of accessor method for CumulativeBinomialDistribution
setMethod('$', '_p_CumulativeBinomialDistribution', function(x, name)

{
  accessorFuns = list('__call__' = CumulativeBinomialDistribution___call__);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for CumulativeBinomialDistribution
setMethod('delete', '_p_CumulativeBinomialDistribution', function(obj) {delete_CumulativeBinomialDistribution(obj)})
# Start of new_BivariateCumulativeNormalDistributionDr78

`BivariateCumulativeNormalDistributionDr78` = function(rho)
{
  ;ans = .Call('R_swig_new_BivariateCumulativeNormalDistributionDr78', rho, PACKAGE='QuantLib');
  class(ans) <- "_p_BivariateCumulativeNormalDistributionDr78";
  
  reg.finalizer(ans, delete_BivariateCumulativeNormalDistributionDr78)
  ans
  
}

attr(`BivariateCumulativeNormalDistributionDr78`, 'returnType') = '_p_BivariateCumulativeNormalDistributionDr78'
attr(`BivariateCumulativeNormalDistributionDr78`, "inputTypes") = c('numeric')
class(`BivariateCumulativeNormalDistributionDr78`) = c("SWIGFunction", class('BivariateCumulativeNormalDistributionDr78'))

# Start of BivariateCumulativeNormalDistributionDr78___call__

`BivariateCumulativeNormalDistributionDr78___call__` = function(self, a, b, .copy = FALSE)
{
  ;.Call('R_swig_BivariateCumulativeNormalDistributionDr78___call__', self, a, b, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BivariateCumulativeNormalDistributionDr78___call__`, 'returnType') = 'numeric'
attr(`BivariateCumulativeNormalDistributionDr78___call__`, "inputTypes") = c('_p_BivariateCumulativeNormalDistributionDr78', 'numeric', 'numeric')
class(`BivariateCumulativeNormalDistributionDr78___call__`) = c("SWIGFunction", class('BivariateCumulativeNormalDistributionDr78___call__'))

# Start of delete_BivariateCumulativeNormalDistributionDr78

`delete_BivariateCumulativeNormalDistributionDr78` = function(self)
{
  ;.Call('R_swig_delete_BivariateCumulativeNormalDistributionDr78', self, PACKAGE='QuantLib');
  
}

attr(`delete_BivariateCumulativeNormalDistributionDr78`, 'returnType') = 'void'
attr(`delete_BivariateCumulativeNormalDistributionDr78`, "inputTypes") = c('_p_BivariateCumulativeNormalDistributionDr78')
class(`delete_BivariateCumulativeNormalDistributionDr78`) = c("SWIGFunction", class('delete_BivariateCumulativeNormalDistributionDr78'))

# Start of accessor method for BivariateCumulativeNormalDistributionDr78
setMethod('$', '_p_BivariateCumulativeNormalDistributionDr78', function(x, name)

{
  accessorFuns = list('__call__' = BivariateCumulativeNormalDistributionDr78___call__);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for BivariateCumulativeNormalDistributionDr78
setMethod('delete', '_p_BivariateCumulativeNormalDistributionDr78', function(obj) {delete_BivariateCumulativeNormalDistributionDr78(obj)})
# Start of new_BivariateCumulativeNormalDistributionWe04DP

`BivariateCumulativeNormalDistributionWe04DP` = function(rho)
{
  ;ans = .Call('R_swig_new_BivariateCumulativeNormalDistributionWe04DP', rho, PACKAGE='QuantLib');
  class(ans) <- "_p_BivariateCumulativeNormalDistributionWe04DP";
  
  reg.finalizer(ans, delete_BivariateCumulativeNormalDistributionWe04DP)
  ans
  
}

attr(`BivariateCumulativeNormalDistributionWe04DP`, 'returnType') = '_p_BivariateCumulativeNormalDistributionWe04DP'
attr(`BivariateCumulativeNormalDistributionWe04DP`, "inputTypes") = c('numeric')
class(`BivariateCumulativeNormalDistributionWe04DP`) = c("SWIGFunction", class('BivariateCumulativeNormalDistributionWe04DP'))

# Start of BivariateCumulativeNormalDistributionWe04DP___call__

`BivariateCumulativeNormalDistributionWe04DP___call__` = function(self, a, b, .copy = FALSE)
{
  ;.Call('R_swig_BivariateCumulativeNormalDistributionWe04DP___call__', self, a, b, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BivariateCumulativeNormalDistributionWe04DP___call__`, 'returnType') = 'numeric'
attr(`BivariateCumulativeNormalDistributionWe04DP___call__`, "inputTypes") = c('_p_BivariateCumulativeNormalDistributionWe04DP', 'numeric', 'numeric')
class(`BivariateCumulativeNormalDistributionWe04DP___call__`) = c("SWIGFunction", class('BivariateCumulativeNormalDistributionWe04DP___call__'))

# Start of delete_BivariateCumulativeNormalDistributionWe04DP

`delete_BivariateCumulativeNormalDistributionWe04DP` = function(self)
{
  ;.Call('R_swig_delete_BivariateCumulativeNormalDistributionWe04DP', self, PACKAGE='QuantLib');
  
}

attr(`delete_BivariateCumulativeNormalDistributionWe04DP`, 'returnType') = 'void'
attr(`delete_BivariateCumulativeNormalDistributionWe04DP`, "inputTypes") = c('_p_BivariateCumulativeNormalDistributionWe04DP')
class(`delete_BivariateCumulativeNormalDistributionWe04DP`) = c("SWIGFunction", class('delete_BivariateCumulativeNormalDistributionWe04DP'))

# Start of accessor method for BivariateCumulativeNormalDistributionWe04DP
setMethod('$', '_p_BivariateCumulativeNormalDistributionWe04DP', function(x, name)

{
  accessorFuns = list('__call__' = BivariateCumulativeNormalDistributionWe04DP___call__);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for BivariateCumulativeNormalDistributionWe04DP
setMethod('delete', '_p_BivariateCumulativeNormalDistributionWe04DP', function(obj) {delete_BivariateCumulativeNormalDistributionWe04DP(obj)})
# Start of new_ChiSquareDistribution

`ChiSquareDistribution` = function(df)
{
  ;ans = .Call('R_swig_new_ChiSquareDistribution', df, PACKAGE='QuantLib');
  class(ans) <- "_p_ChiSquareDistribution";
  
  reg.finalizer(ans, delete_ChiSquareDistribution)
  ans
  
}

attr(`ChiSquareDistribution`, 'returnType') = '_p_ChiSquareDistribution'
attr(`ChiSquareDistribution`, "inputTypes") = c('numeric')
class(`ChiSquareDistribution`) = c("SWIGFunction", class('ChiSquareDistribution'))

# Start of ChiSquareDistribution___call__

`ChiSquareDistribution___call__` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_ChiSquareDistribution___call__', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`ChiSquareDistribution___call__`, 'returnType') = 'numeric'
attr(`ChiSquareDistribution___call__`, "inputTypes") = c('_p_ChiSquareDistribution', 'numeric')
class(`ChiSquareDistribution___call__`) = c("SWIGFunction", class('ChiSquareDistribution___call__'))

# Start of delete_ChiSquareDistribution

`delete_ChiSquareDistribution` = function(self)
{
  ;.Call('R_swig_delete_ChiSquareDistribution', self, PACKAGE='QuantLib');
  
}

attr(`delete_ChiSquareDistribution`, 'returnType') = 'void'
attr(`delete_ChiSquareDistribution`, "inputTypes") = c('_p_ChiSquareDistribution')
class(`delete_ChiSquareDistribution`) = c("SWIGFunction", class('delete_ChiSquareDistribution'))

# Start of accessor method for ChiSquareDistribution
setMethod('$', '_p_ChiSquareDistribution', function(x, name)

{
  accessorFuns = list('__call__' = ChiSquareDistribution___call__);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for ChiSquareDistribution
setMethod('delete', '_p_ChiSquareDistribution', function(obj) {delete_ChiSquareDistribution(obj)})
# Start of new_NonCentralChiSquareDistribution

`NonCentralChiSquareDistribution` = function(df, ncp)
{
  ;ans = .Call('R_swig_new_NonCentralChiSquareDistribution', df, ncp, PACKAGE='QuantLib');
  class(ans) <- "_p_NonCentralChiSquareDistribution";
  
  reg.finalizer(ans, delete_NonCentralChiSquareDistribution)
  ans
  
}

attr(`NonCentralChiSquareDistribution`, 'returnType') = '_p_NonCentralChiSquareDistribution'
attr(`NonCentralChiSquareDistribution`, "inputTypes") = c('numeric', 'numeric')
class(`NonCentralChiSquareDistribution`) = c("SWIGFunction", class('NonCentralChiSquareDistribution'))

# Start of NonCentralChiSquareDistribution___call__

`NonCentralChiSquareDistribution___call__` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_NonCentralChiSquareDistribution___call__', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`NonCentralChiSquareDistribution___call__`, 'returnType') = 'numeric'
attr(`NonCentralChiSquareDistribution___call__`, "inputTypes") = c('_p_NonCentralChiSquareDistribution', 'numeric')
class(`NonCentralChiSquareDistribution___call__`) = c("SWIGFunction", class('NonCentralChiSquareDistribution___call__'))

# Start of delete_NonCentralChiSquareDistribution

`delete_NonCentralChiSquareDistribution` = function(self)
{
  ;.Call('R_swig_delete_NonCentralChiSquareDistribution', self, PACKAGE='QuantLib');
  
}

attr(`delete_NonCentralChiSquareDistribution`, 'returnType') = 'void'
attr(`delete_NonCentralChiSquareDistribution`, "inputTypes") = c('_p_NonCentralChiSquareDistribution')
class(`delete_NonCentralChiSquareDistribution`) = c("SWIGFunction", class('delete_NonCentralChiSquareDistribution'))

# Start of accessor method for NonCentralChiSquareDistribution
setMethod('$', '_p_NonCentralChiSquareDistribution', function(x, name)

{
  accessorFuns = list('__call__' = NonCentralChiSquareDistribution___call__);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for NonCentralChiSquareDistribution
setMethod('delete', '_p_NonCentralChiSquareDistribution', function(obj) {delete_NonCentralChiSquareDistribution(obj)})
# Start of new_InverseNonCentralChiSquareDistribution

`InverseNonCentralChiSquareDistribution__SWIG_0` = function(df, ncp, maxEvaluations, accuracy)
{
  if(length(maxEvaluations) > 1) {
    warning("using only the first element of maxEvaluations");
  };
  
  
  ;ans = .Call('R_swig_new_InverseNonCentralChiSquareDistribution__SWIG_0', df, ncp, maxEvaluations, accuracy, PACKAGE='QuantLib');
  class(ans) <- "_p_InverseNonCentralChiSquareDistribution";
  
  reg.finalizer(ans, delete_InverseNonCentralChiSquareDistribution)
  ans
  
}

attr(`InverseNonCentralChiSquareDistribution__SWIG_0`, 'returnType') = '_p_InverseNonCentralChiSquareDistribution'
attr(`InverseNonCentralChiSquareDistribution__SWIG_0`, "inputTypes") = c('numeric', 'numeric', 'integer', 'numeric')
class(`InverseNonCentralChiSquareDistribution__SWIG_0`) = c("SWIGFunction", class('InverseNonCentralChiSquareDistribution__SWIG_0'))

# Start of new_InverseNonCentralChiSquareDistribution

`InverseNonCentralChiSquareDistribution__SWIG_1` = function(df, ncp, maxEvaluations)
{
  if(length(maxEvaluations) > 1) {
    warning("using only the first element of maxEvaluations");
  };
  
  ;ans = .Call('R_swig_new_InverseNonCentralChiSquareDistribution__SWIG_1', df, ncp, maxEvaluations, PACKAGE='QuantLib');
  class(ans) <- "_p_InverseNonCentralChiSquareDistribution";
  
  reg.finalizer(ans, delete_InverseNonCentralChiSquareDistribution)
  ans
  
}

attr(`InverseNonCentralChiSquareDistribution__SWIG_1`, 'returnType') = '_p_InverseNonCentralChiSquareDistribution'
attr(`InverseNonCentralChiSquareDistribution__SWIG_1`, "inputTypes") = c('numeric', 'numeric', 'integer')
class(`InverseNonCentralChiSquareDistribution__SWIG_1`) = c("SWIGFunction", class('InverseNonCentralChiSquareDistribution__SWIG_1'))

# Start of new_InverseNonCentralChiSquareDistribution

`InverseNonCentralChiSquareDistribution__SWIG_2` = function(df, ncp)
{
  ;ans = .Call('R_swig_new_InverseNonCentralChiSquareDistribution__SWIG_2', df, ncp, PACKAGE='QuantLib');
  class(ans) <- "_p_InverseNonCentralChiSquareDistribution";
  
  reg.finalizer(ans, delete_InverseNonCentralChiSquareDistribution)
  ans
  
}

attr(`InverseNonCentralChiSquareDistribution__SWIG_2`, 'returnType') = '_p_InverseNonCentralChiSquareDistribution'
attr(`InverseNonCentralChiSquareDistribution__SWIG_2`, "inputTypes") = c('numeric', 'numeric')
class(`InverseNonCentralChiSquareDistribution__SWIG_2`) = c("SWIGFunction", class('InverseNonCentralChiSquareDistribution__SWIG_2'))

`InverseNonCentralChiSquareDistribution` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 2) {
    if (is.numeric(argv[[1]]) && is.numeric(argv[[2]])) {
      f <- InverseNonCentralChiSquareDistribution__SWIG_2; 
    }
  } else if (argc == 3) {
    if (is.numeric(argv[[1]]) && is.numeric(argv[[2]]) && (is.integer(argv[[3]]) || is.numeric(argv[[3]]))) {
      f <- InverseNonCentralChiSquareDistribution__SWIG_1; 
    }
  } else if (argc == 4) {
    if (is.numeric(argv[[1]]) && is.numeric(argv[[2]]) && (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && is.numeric(argv[[4]])) {
      f <- InverseNonCentralChiSquareDistribution__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for InverseNonCentralChiSquareDistribution with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InverseNonCentralChiSquareDistribution___call__

`InverseNonCentralChiSquareDistribution___call__` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_InverseNonCentralChiSquareDistribution___call__', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`InverseNonCentralChiSquareDistribution___call__`, 'returnType') = 'numeric'
attr(`InverseNonCentralChiSquareDistribution___call__`, "inputTypes") = c('_p_InverseNonCentralChiSquareDistribution', 'numeric')
class(`InverseNonCentralChiSquareDistribution___call__`) = c("SWIGFunction", class('InverseNonCentralChiSquareDistribution___call__'))

# Start of delete_InverseNonCentralChiSquareDistribution

`delete_InverseNonCentralChiSquareDistribution` = function(self)
{
  ;.Call('R_swig_delete_InverseNonCentralChiSquareDistribution', self, PACKAGE='QuantLib');
  
}

attr(`delete_InverseNonCentralChiSquareDistribution`, 'returnType') = 'void'
attr(`delete_InverseNonCentralChiSquareDistribution`, "inputTypes") = c('_p_InverseNonCentralChiSquareDistribution')
class(`delete_InverseNonCentralChiSquareDistribution`) = c("SWIGFunction", class('delete_InverseNonCentralChiSquareDistribution'))

# Start of accessor method for InverseNonCentralChiSquareDistribution
setMethod('$', '_p_InverseNonCentralChiSquareDistribution', function(x, name)

{
  accessorFuns = list('__call__' = InverseNonCentralChiSquareDistribution___call__);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for InverseNonCentralChiSquareDistribution
setMethod('delete', '_p_InverseNonCentralChiSquareDistribution', function(obj) {delete_InverseNonCentralChiSquareDistribution(obj)})
# Start of new_GammaDistribution

`GammaDistribution` = function(a)
{
  ;ans = .Call('R_swig_new_GammaDistribution', a, PACKAGE='QuantLib');
  class(ans) <- "_p_GammaDistribution";
  
  reg.finalizer(ans, delete_GammaDistribution)
  ans
  
}

attr(`GammaDistribution`, 'returnType') = '_p_GammaDistribution'
attr(`GammaDistribution`, "inputTypes") = c('numeric')
class(`GammaDistribution`) = c("SWIGFunction", class('GammaDistribution'))

# Start of GammaDistribution___call__

`GammaDistribution___call__` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_GammaDistribution___call__', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`GammaDistribution___call__`, 'returnType') = 'numeric'
attr(`GammaDistribution___call__`, "inputTypes") = c('_p_GammaDistribution', 'numeric')
class(`GammaDistribution___call__`) = c("SWIGFunction", class('GammaDistribution___call__'))

# Start of delete_GammaDistribution

`delete_GammaDistribution` = function(self)
{
  ;.Call('R_swig_delete_GammaDistribution', self, PACKAGE='QuantLib');
  
}

attr(`delete_GammaDistribution`, 'returnType') = 'void'
attr(`delete_GammaDistribution`, "inputTypes") = c('_p_GammaDistribution')
class(`delete_GammaDistribution`) = c("SWIGFunction", class('delete_GammaDistribution'))

# Start of accessor method for GammaDistribution
setMethod('$', '_p_GammaDistribution', function(x, name)

{
  accessorFuns = list('__call__' = GammaDistribution___call__);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for GammaDistribution
setMethod('delete', '_p_GammaDistribution', function(obj) {delete_GammaDistribution(obj)})
# Start of GammaFunction_logValue

`GammaFunction_logValue` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_GammaFunction_logValue', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`GammaFunction_logValue`, 'returnType') = 'numeric'
attr(`GammaFunction_logValue`, "inputTypes") = c('_p_GammaFunction', 'numeric')
class(`GammaFunction_logValue`) = c("SWIGFunction", class('GammaFunction_logValue'))

# Start of new_GammaFunction

`GammaFunction` = function()
{
  ;ans = .Call('R_swig_new_GammaFunction', PACKAGE='QuantLib');
  class(ans) <- "_p_GammaFunction";
  
  reg.finalizer(ans, delete_GammaFunction)
  ans
  
}

attr(`GammaFunction`, 'returnType') = '_p_GammaFunction'
class(`GammaFunction`) = c("SWIGFunction", class('GammaFunction'))

# Start of delete_GammaFunction

`delete_GammaFunction` = function(self)
{
  ;.Call('R_swig_delete_GammaFunction', self, PACKAGE='QuantLib');
  
}

attr(`delete_GammaFunction`, 'returnType') = 'void'
attr(`delete_GammaFunction`, "inputTypes") = c('_p_GammaFunction')
class(`delete_GammaFunction`) = c("SWIGFunction", class('delete_GammaFunction'))

# Start of accessor method for GammaFunction
setMethod('$', '_p_GammaFunction', function(x, name)

{
  accessorFuns = list('logValue' = GammaFunction_logValue);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for GammaFunction
setMethod('delete', '_p_GammaFunction', function(obj) {delete_GammaFunction(obj)})
# Start of new_PoissonDistribution

`PoissonDistribution` = function(mu)
{
  ;ans = .Call('R_swig_new_PoissonDistribution', mu, PACKAGE='QuantLib');
  class(ans) <- "_p_PoissonDistribution";
  
  reg.finalizer(ans, delete_PoissonDistribution)
  ans
  
}

attr(`PoissonDistribution`, 'returnType') = '_p_PoissonDistribution'
attr(`PoissonDistribution`, "inputTypes") = c('numeric')
class(`PoissonDistribution`) = c("SWIGFunction", class('PoissonDistribution'))

# Start of PoissonDistribution___call__

`PoissonDistribution___call__` = function(self, k, .copy = FALSE)
{
  if(length(k) > 1) {
    warning("using only the first element of k");
  };
  
  ;.Call('R_swig_PoissonDistribution___call__', self, k, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`PoissonDistribution___call__`, 'returnType') = 'numeric'
attr(`PoissonDistribution___call__`, "inputTypes") = c('_p_PoissonDistribution', 'integer')
class(`PoissonDistribution___call__`) = c("SWIGFunction", class('PoissonDistribution___call__'))

# Start of delete_PoissonDistribution

`delete_PoissonDistribution` = function(self)
{
  ;.Call('R_swig_delete_PoissonDistribution', self, PACKAGE='QuantLib');
  
}

attr(`delete_PoissonDistribution`, 'returnType') = 'void'
attr(`delete_PoissonDistribution`, "inputTypes") = c('_p_PoissonDistribution')
class(`delete_PoissonDistribution`) = c("SWIGFunction", class('delete_PoissonDistribution'))

# Start of accessor method for PoissonDistribution
setMethod('$', '_p_PoissonDistribution', function(x, name)

{
  accessorFuns = list('__call__' = PoissonDistribution___call__);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for PoissonDistribution
setMethod('delete', '_p_PoissonDistribution', function(obj) {delete_PoissonDistribution(obj)})
# Start of new_CumulativePoissonDistribution

`CumulativePoissonDistribution` = function(mu)
{
  ;ans = .Call('R_swig_new_CumulativePoissonDistribution', mu, PACKAGE='QuantLib');
  class(ans) <- "_p_CumulativePoissonDistribution";
  
  reg.finalizer(ans, delete_CumulativePoissonDistribution)
  ans
  
}

attr(`CumulativePoissonDistribution`, 'returnType') = '_p_CumulativePoissonDistribution'
attr(`CumulativePoissonDistribution`, "inputTypes") = c('numeric')
class(`CumulativePoissonDistribution`) = c("SWIGFunction", class('CumulativePoissonDistribution'))

# Start of CumulativePoissonDistribution___call__

`CumulativePoissonDistribution___call__` = function(self, k, .copy = FALSE)
{
  if(length(k) > 1) {
    warning("using only the first element of k");
  };
  
  ;.Call('R_swig_CumulativePoissonDistribution___call__', self, k, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CumulativePoissonDistribution___call__`, 'returnType') = 'numeric'
attr(`CumulativePoissonDistribution___call__`, "inputTypes") = c('_p_CumulativePoissonDistribution', 'integer')
class(`CumulativePoissonDistribution___call__`) = c("SWIGFunction", class('CumulativePoissonDistribution___call__'))

# Start of delete_CumulativePoissonDistribution

`delete_CumulativePoissonDistribution` = function(self)
{
  ;.Call('R_swig_delete_CumulativePoissonDistribution', self, PACKAGE='QuantLib');
  
}

attr(`delete_CumulativePoissonDistribution`, 'returnType') = 'void'
attr(`delete_CumulativePoissonDistribution`, "inputTypes") = c('_p_CumulativePoissonDistribution')
class(`delete_CumulativePoissonDistribution`) = c("SWIGFunction", class('delete_CumulativePoissonDistribution'))

# Start of accessor method for CumulativePoissonDistribution
setMethod('$', '_p_CumulativePoissonDistribution', function(x, name)

{
  accessorFuns = list('__call__' = CumulativePoissonDistribution___call__);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for CumulativePoissonDistribution
setMethod('delete', '_p_CumulativePoissonDistribution', function(obj) {delete_CumulativePoissonDistribution(obj)})
# Start of new_InverseCumulativePoisson

`InverseCumulativePoisson` = function(lambda)
{
  ;ans = .Call('R_swig_new_InverseCumulativePoisson', lambda, PACKAGE='QuantLib');
  class(ans) <- "_p_InverseCumulativePoisson";
  
  reg.finalizer(ans, delete_InverseCumulativePoisson)
  ans
  
}

attr(`InverseCumulativePoisson`, 'returnType') = '_p_InverseCumulativePoisson'
attr(`InverseCumulativePoisson`, "inputTypes") = c('numeric')
class(`InverseCumulativePoisson`) = c("SWIGFunction", class('InverseCumulativePoisson'))

# Start of InverseCumulativePoisson___call__

`InverseCumulativePoisson___call__` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_InverseCumulativePoisson___call__', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`InverseCumulativePoisson___call__`, 'returnType') = 'numeric'
attr(`InverseCumulativePoisson___call__`, "inputTypes") = c('_p_InverseCumulativePoisson', 'numeric')
class(`InverseCumulativePoisson___call__`) = c("SWIGFunction", class('InverseCumulativePoisson___call__'))

# Start of delete_InverseCumulativePoisson

`delete_InverseCumulativePoisson` = function(self)
{
  ;.Call('R_swig_delete_InverseCumulativePoisson', self, PACKAGE='QuantLib');
  
}

attr(`delete_InverseCumulativePoisson`, 'returnType') = 'void'
attr(`delete_InverseCumulativePoisson`, "inputTypes") = c('_p_InverseCumulativePoisson')
class(`delete_InverseCumulativePoisson`) = c("SWIGFunction", class('delete_InverseCumulativePoisson'))

# Start of accessor method for InverseCumulativePoisson
setMethod('$', '_p_InverseCumulativePoisson', function(x, name)

{
  accessorFuns = list('__call__' = InverseCumulativePoisson___call__);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for InverseCumulativePoisson
setMethod('delete', '_p_InverseCumulativePoisson', function(obj) {delete_InverseCumulativePoisson(obj)})
# Start of new_StudentDistribution

`StudentDistribution` = function(n)
{
  n = as.integer(n); 
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;ans = .Call('R_swig_new_StudentDistribution', n, PACKAGE='QuantLib');
  class(ans) <- "_p_StudentDistribution";
  
  reg.finalizer(ans, delete_StudentDistribution)
  ans
  
}

attr(`StudentDistribution`, 'returnType') = '_p_StudentDistribution'
attr(`StudentDistribution`, "inputTypes") = c('integer')
class(`StudentDistribution`) = c("SWIGFunction", class('StudentDistribution'))

# Start of StudentDistribution___call__

`StudentDistribution___call__` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_StudentDistribution___call__', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`StudentDistribution___call__`, 'returnType') = 'numeric'
attr(`StudentDistribution___call__`, "inputTypes") = c('_p_StudentDistribution', 'numeric')
class(`StudentDistribution___call__`) = c("SWIGFunction", class('StudentDistribution___call__'))

# Start of delete_StudentDistribution

`delete_StudentDistribution` = function(self)
{
  ;.Call('R_swig_delete_StudentDistribution', self, PACKAGE='QuantLib');
  
}

attr(`delete_StudentDistribution`, 'returnType') = 'void'
attr(`delete_StudentDistribution`, "inputTypes") = c('_p_StudentDistribution')
class(`delete_StudentDistribution`) = c("SWIGFunction", class('delete_StudentDistribution'))

# Start of accessor method for StudentDistribution
setMethod('$', '_p_StudentDistribution', function(x, name)

{
  accessorFuns = list('__call__' = StudentDistribution___call__);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for StudentDistribution
setMethod('delete', '_p_StudentDistribution', function(obj) {delete_StudentDistribution(obj)})
# Start of new_CumulativeStudentDistribution

`CumulativeStudentDistribution` = function(n)
{
  n = as.integer(n); 
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;ans = .Call('R_swig_new_CumulativeStudentDistribution', n, PACKAGE='QuantLib');
  class(ans) <- "_p_CumulativeStudentDistribution";
  
  reg.finalizer(ans, delete_CumulativeStudentDistribution)
  ans
  
}

attr(`CumulativeStudentDistribution`, 'returnType') = '_p_CumulativeStudentDistribution'
attr(`CumulativeStudentDistribution`, "inputTypes") = c('integer')
class(`CumulativeStudentDistribution`) = c("SWIGFunction", class('CumulativeStudentDistribution'))

# Start of CumulativeStudentDistribution___call__

`CumulativeStudentDistribution___call__` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_CumulativeStudentDistribution___call__', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CumulativeStudentDistribution___call__`, 'returnType') = 'numeric'
attr(`CumulativeStudentDistribution___call__`, "inputTypes") = c('_p_CumulativeStudentDistribution', 'numeric')
class(`CumulativeStudentDistribution___call__`) = c("SWIGFunction", class('CumulativeStudentDistribution___call__'))

# Start of delete_CumulativeStudentDistribution

`delete_CumulativeStudentDistribution` = function(self)
{
  ;.Call('R_swig_delete_CumulativeStudentDistribution', self, PACKAGE='QuantLib');
  
}

attr(`delete_CumulativeStudentDistribution`, 'returnType') = 'void'
attr(`delete_CumulativeStudentDistribution`, "inputTypes") = c('_p_CumulativeStudentDistribution')
class(`delete_CumulativeStudentDistribution`) = c("SWIGFunction", class('delete_CumulativeStudentDistribution'))

# Start of accessor method for CumulativeStudentDistribution
setMethod('$', '_p_CumulativeStudentDistribution', function(x, name)

{
  accessorFuns = list('__call__' = CumulativeStudentDistribution___call__);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for CumulativeStudentDistribution
setMethod('delete', '_p_CumulativeStudentDistribution', function(obj) {delete_CumulativeStudentDistribution(obj)})
# Start of new_InverseCumulativeStudent

`InverseCumulativeStudent__SWIG_0` = function(n, accuracy, maxIterations)
{
  n = as.integer(n); 
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  
  
  
  if(length(maxIterations) > 1) {
    warning("using only the first element of maxIterations");
  };
  
  ;ans = .Call('R_swig_new_InverseCumulativeStudent__SWIG_0', n, accuracy, maxIterations, PACKAGE='QuantLib');
  class(ans) <- "_p_InverseCumulativeStudent";
  
  reg.finalizer(ans, delete_InverseCumulativeStudent)
  ans
  
}

attr(`InverseCumulativeStudent__SWIG_0`, 'returnType') = '_p_InverseCumulativeStudent'
attr(`InverseCumulativeStudent__SWIG_0`, "inputTypes") = c('integer', 'numeric', 'integer')
class(`InverseCumulativeStudent__SWIG_0`) = c("SWIGFunction", class('InverseCumulativeStudent__SWIG_0'))

# Start of new_InverseCumulativeStudent

`InverseCumulativeStudent__SWIG_1` = function(n, accuracy)
{
  n = as.integer(n); 
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  
  ;ans = .Call('R_swig_new_InverseCumulativeStudent__SWIG_1', n, accuracy, PACKAGE='QuantLib');
  class(ans) <- "_p_InverseCumulativeStudent";
  
  reg.finalizer(ans, delete_InverseCumulativeStudent)
  ans
  
}

attr(`InverseCumulativeStudent__SWIG_1`, 'returnType') = '_p_InverseCumulativeStudent'
attr(`InverseCumulativeStudent__SWIG_1`, "inputTypes") = c('integer', 'numeric')
class(`InverseCumulativeStudent__SWIG_1`) = c("SWIGFunction", class('InverseCumulativeStudent__SWIG_1'))

# Start of new_InverseCumulativeStudent

`InverseCumulativeStudent__SWIG_2` = function(n)
{
  n = as.integer(n); 
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;ans = .Call('R_swig_new_InverseCumulativeStudent__SWIG_2', n, PACKAGE='QuantLib');
  class(ans) <- "_p_InverseCumulativeStudent";
  
  reg.finalizer(ans, delete_InverseCumulativeStudent)
  ans
  
}

attr(`InverseCumulativeStudent__SWIG_2`, 'returnType') = '_p_InverseCumulativeStudent'
attr(`InverseCumulativeStudent__SWIG_2`, "inputTypes") = c('integer')
class(`InverseCumulativeStudent__SWIG_2`) = c("SWIGFunction", class('InverseCumulativeStudent__SWIG_2'))

`InverseCumulativeStudent` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 1) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]]))) {
      f <- InverseCumulativeStudent__SWIG_2; 
    }
  } else if (argc == 2) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && is.numeric(argv[[2]])) {
      f <- InverseCumulativeStudent__SWIG_1; 
    }
  } else if (argc == 3) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && is.numeric(argv[[2]]) && (is.integer(argv[[3]]) || is.numeric(argv[[3]]))) {
      f <- InverseCumulativeStudent__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for InverseCumulativeStudent with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InverseCumulativeStudent___call__

`InverseCumulativeStudent___call__` = function(self, x, .copy = FALSE)
{
  ;.Call('R_swig_InverseCumulativeStudent___call__', self, x, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`InverseCumulativeStudent___call__`, 'returnType') = 'numeric'
attr(`InverseCumulativeStudent___call__`, "inputTypes") = c('_p_InverseCumulativeStudent', 'numeric')
class(`InverseCumulativeStudent___call__`) = c("SWIGFunction", class('InverseCumulativeStudent___call__'))

# Start of delete_InverseCumulativeStudent

`delete_InverseCumulativeStudent` = function(self)
{
  ;.Call('R_swig_delete_InverseCumulativeStudent', self, PACKAGE='QuantLib');
  
}

attr(`delete_InverseCumulativeStudent`, 'returnType') = 'void'
attr(`delete_InverseCumulativeStudent`, "inputTypes") = c('_p_InverseCumulativeStudent')
class(`delete_InverseCumulativeStudent`) = c("SWIGFunction", class('delete_InverseCumulativeStudent'))

# Start of accessor method for InverseCumulativeStudent
setMethod('$', '_p_InverseCumulativeStudent', function(x, name)

{
  accessorFuns = list('__call__' = InverseCumulativeStudent___call__);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for InverseCumulativeStudent
setMethod('delete', '_p_InverseCumulativeStudent', function(obj) {delete_InverseCumulativeStudent(obj)})
# Start of new_Money

`Money__SWIG_0` = function(currency, value)
{
  ;ans = .Call('R_swig_new_Money__SWIG_0', currency, value, PACKAGE='QuantLib');
  class(ans) <- "_p_Money";
  
  reg.finalizer(ans, delete_Money)
  ans
  
}

attr(`Money__SWIG_0`, 'returnType') = '_p_Money'
attr(`Money__SWIG_0`, "inputTypes") = c('_p_Currency', 'numeric')
class(`Money__SWIG_0`) = c("SWIGFunction", class('Money__SWIG_0'))

# Start of new_Money

`Money__SWIG_1` = function(value, currency)
{
  ;ans = .Call('R_swig_new_Money__SWIG_1', value, currency, PACKAGE='QuantLib');
  class(ans) <- "_p_Money";
  
  reg.finalizer(ans, delete_Money)
  ans
  
}

attr(`Money__SWIG_1`, 'returnType') = '_p_Money'
attr(`Money__SWIG_1`, "inputTypes") = c('numeric', '_p_Currency')
class(`Money__SWIG_1`) = c("SWIGFunction", class('Money__SWIG_1'))

`Money` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_Currency') && is.numeric(argv[[2]])) {
      f <- Money__SWIG_0; 
    }
    else if (is.numeric(argv[[1]]) && extends(argtypes[2], '_p_Currency')) {
      f <- Money__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for Money with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of Money_currency

`Money_currency` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_Money_currency', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Currency";
  
  ans
  
}

attr(`Money_currency`, 'returnType') = '_p_Currency'
attr(`Money_currency`, "inputTypes") = c('_p_Money')
class(`Money_currency`) = c("SWIGFunction", class('Money_currency'))

# Start of Money_value

`Money_value` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Money_value', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Money_value`, 'returnType') = 'numeric'
attr(`Money_value`, "inputTypes") = c('_p_Money')
class(`Money_value`) = c("SWIGFunction", class('Money_value'))

# Start of Money_rounded

`Money_rounded` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_Money_rounded', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Money";
  
  ans
  
}

attr(`Money_rounded`, 'returnType') = '_p_Money'
attr(`Money_rounded`, "inputTypes") = c('_p_Money')
class(`Money_rounded`) = c("SWIGFunction", class('Money_rounded'))

defineEnumeration('_Money__ConversionType',
                    .values = c(
                        'NoConversion' = 0, 
                        'BaseCurrencyConversion' = 1, 
                        'AutomatedConversion' = 2
))
# Start of Money_setConversionType

`Money_setConversionType` = function(type)
{
  type = enumToInteger(type, "_Money__ConversionType"); 
  
  if(length(type) > 1) {
    warning("using only the first element of type");
  };
  
  ;.Call('R_swig_Money_setConversionType', type, PACKAGE='QuantLib');
  
}

attr(`Money_setConversionType`, 'returnType') = 'void'
attr(`Money_setConversionType`, "inputTypes") = c('character')
class(`Money_setConversionType`) = c("SWIGFunction", class('Money_setConversionType'))

# Start of Money_setBaseCurrency

`Money_setBaseCurrency` = function(c)
{
  ;.Call('R_swig_Money_setBaseCurrency', c, PACKAGE='QuantLib');
  
}

attr(`Money_setBaseCurrency`, 'returnType') = 'void'
attr(`Money_setBaseCurrency`, "inputTypes") = c('_p_Currency')
class(`Money_setBaseCurrency`) = c("SWIGFunction", class('Money_setBaseCurrency'))

# Start of delete_Money

`delete_Money` = function(self)
{
  ;.Call('R_swig_delete_Money', self, PACKAGE='QuantLib');
  
}

attr(`delete_Money`, 'returnType') = 'void'
attr(`delete_Money`, "inputTypes") = c('_p_Money')
class(`delete_Money`) = c("SWIGFunction", class('delete_Money'))

# Start of accessor method for Money
setMethod('$', '_p_Money', function(x, name)

{
  accessorFuns = list('currency' = Money_currency, 'value' = Money_value, 'rounded' = Money_rounded);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for Money
setMethod('delete', '_p_Money', function(obj) {delete_Money(obj)})
defineEnumeration('_ExchangeRate__Type',
                    .values = c(
                        'Direct' = 0, 
                        'Derived' = 1
))
# Start of new_ExchangeRate

`ExchangeRate` = function(source, target, rate)
{
  ;ans = .Call('R_swig_new_ExchangeRate', source, target, rate, PACKAGE='QuantLib');
  class(ans) <- "_p_ExchangeRate";
  
  reg.finalizer(ans, delete_ExchangeRate)
  ans
  
}

attr(`ExchangeRate`, 'returnType') = '_p_ExchangeRate'
attr(`ExchangeRate`, "inputTypes") = c('_p_Currency', '_p_Currency', 'numeric')
class(`ExchangeRate`) = c("SWIGFunction", class('ExchangeRate'))

# Start of ExchangeRate_source

`ExchangeRate_source` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_ExchangeRate_source', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Currency";
  
  ans
  
}

attr(`ExchangeRate_source`, 'returnType') = '_p_Currency'
attr(`ExchangeRate_source`, "inputTypes") = c('_p_ExchangeRate')
class(`ExchangeRate_source`) = c("SWIGFunction", class('ExchangeRate_source'))

# Start of ExchangeRate_target

`ExchangeRate_target` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_ExchangeRate_target', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Currency";
  
  ans
  
}

attr(`ExchangeRate_target`, 'returnType') = '_p_Currency'
attr(`ExchangeRate_target`, "inputTypes") = c('_p_ExchangeRate')
class(`ExchangeRate_target`) = c("SWIGFunction", class('ExchangeRate_target'))

# Start of ExchangeRate_type

`ExchangeRate_type` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_ExchangeRate_type', self, as.logical(.copy), PACKAGE='QuantLib');
  ans = enumFromInteger(ans, "_ExchangeRate__Type");
  
  ans
  
}

attr(`ExchangeRate_type`, 'returnType') = 'character'
attr(`ExchangeRate_type`, "inputTypes") = c('_p_ExchangeRate')
class(`ExchangeRate_type`) = c("SWIGFunction", class('ExchangeRate_type'))

# Start of ExchangeRate_rate

`ExchangeRate_rate` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_ExchangeRate_rate', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`ExchangeRate_rate`, 'returnType') = 'numeric'
attr(`ExchangeRate_rate`, "inputTypes") = c('_p_ExchangeRate')
class(`ExchangeRate_rate`) = c("SWIGFunction", class('ExchangeRate_rate'))

# Start of ExchangeRate_exchange

`ExchangeRate_exchange` = function(self, amount, .copy = FALSE)
{
  ;ans = .Call('R_swig_ExchangeRate_exchange', self, amount, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Money";
  
  ans
  
}

attr(`ExchangeRate_exchange`, 'returnType') = '_p_Money'
attr(`ExchangeRate_exchange`, "inputTypes") = c('_p_ExchangeRate', '_p_Money')
class(`ExchangeRate_exchange`) = c("SWIGFunction", class('ExchangeRate_exchange'))

# Start of ExchangeRate_chain

`ExchangeRate_chain` = function(r1, r2, .copy = FALSE)
{
  ;ans = .Call('R_swig_ExchangeRate_chain', r1, r2, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_ExchangeRate";
  
  ans
  
}

attr(`ExchangeRate_chain`, 'returnType') = '_p_ExchangeRate'
attr(`ExchangeRate_chain`, "inputTypes") = c('_p_ExchangeRate', '_p_ExchangeRate')
class(`ExchangeRate_chain`) = c("SWIGFunction", class('ExchangeRate_chain'))

# Start of delete_ExchangeRate

`delete_ExchangeRate` = function(self)
{
  ;.Call('R_swig_delete_ExchangeRate', self, PACKAGE='QuantLib');
  
}

attr(`delete_ExchangeRate`, 'returnType') = 'void'
attr(`delete_ExchangeRate`, "inputTypes") = c('_p_ExchangeRate')
class(`delete_ExchangeRate`) = c("SWIGFunction", class('delete_ExchangeRate'))

# Start of accessor method for ExchangeRate
setMethod('$', '_p_ExchangeRate', function(x, name)

{
  accessorFuns = list('source' = ExchangeRate_source, 'target' = ExchangeRate_target, 'type' = ExchangeRate_type, 'rate' = ExchangeRate_rate, 'exchange' = ExchangeRate_exchange);
  vaccessors = c('target');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  if (is.na(match(name, vaccessors))) f else f(x);
}


);
# end of accessor method for ExchangeRate
setMethod('delete', '_p_ExchangeRate', function(obj) {delete_ExchangeRate(obj)})
# Start of ExchangeRateManager_instance

`ExchangeRateManager_instance` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_ExchangeRateManager_instance', as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_ExchangeRateManager";
  
  ans
  
}

attr(`ExchangeRateManager_instance`, 'returnType') = '_p_ExchangeRateManager'
class(`ExchangeRateManager_instance`) = c("SWIGFunction", class('ExchangeRateManager_instance'))

# Start of ExchangeRateManager_add

`ExchangeRateManager_add__SWIG_0` = function(self, s_arg2, startDate, endDate)
{
  ;.Call('R_swig_ExchangeRateManager_add__SWIG_0', self, s_arg2, startDate, endDate, PACKAGE='QuantLib');
  
}

attr(`ExchangeRateManager_add__SWIG_0`, 'returnType') = 'void'
attr(`ExchangeRateManager_add__SWIG_0`, "inputTypes") = c('_p_ExchangeRateManager', '_p_ExchangeRate', '_p_Date', '_p_Date')
class(`ExchangeRateManager_add__SWIG_0`) = c("SWIGFunction", class('ExchangeRateManager_add__SWIG_0'))

# Start of ExchangeRateManager_add

`ExchangeRateManager_add__SWIG_1` = function(self, s_arg2, startDate)
{
  ;.Call('R_swig_ExchangeRateManager_add__SWIG_1', self, s_arg2, startDate, PACKAGE='QuantLib');
  
}

attr(`ExchangeRateManager_add__SWIG_1`, 'returnType') = 'void'
attr(`ExchangeRateManager_add__SWIG_1`, "inputTypes") = c('_p_ExchangeRateManager', '_p_ExchangeRate', '_p_Date')
class(`ExchangeRateManager_add__SWIG_1`) = c("SWIGFunction", class('ExchangeRateManager_add__SWIG_1'))

# Start of ExchangeRateManager_add

`ExchangeRateManager_add__SWIG_2` = function(self, s_arg2)
{
  ;.Call('R_swig_ExchangeRateManager_add__SWIG_2', self, s_arg2, PACKAGE='QuantLib');
  
}

attr(`ExchangeRateManager_add__SWIG_2`, 'returnType') = 'void'
attr(`ExchangeRateManager_add__SWIG_2`, "inputTypes") = c('_p_ExchangeRateManager', '_p_ExchangeRate')
class(`ExchangeRateManager_add__SWIG_2`) = c("SWIGFunction", class('ExchangeRateManager_add__SWIG_2'))

`ExchangeRateManager_add` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 2) {
    if (extends(argtypes[1], '_p_ExchangeRateManager') && extends(argtypes[2], '_p_ExchangeRate')) {
      f <- ExchangeRateManager_add__SWIG_2; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_ExchangeRateManager') && extends(argtypes[2], '_p_ExchangeRate') && extends(argtypes[3], '_p_Date')) {
      f <- ExchangeRateManager_add__SWIG_1; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_ExchangeRateManager') && extends(argtypes[2], '_p_ExchangeRate') && extends(argtypes[3], '_p_Date') && extends(argtypes[4], '_p_Date')) {
      f <- ExchangeRateManager_add__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for ExchangeRateManager_add with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of ExchangeRateManager_lookup

`ExchangeRateManager_lookup__SWIG_0` = function(self, source, target, date, type, .copy = FALSE)
{
  type = enumToInteger(type, "_ExchangeRate__Type"); 
  
  if(length(type) > 1) {
    warning("using only the first element of type");
  };
  
  ;ans = .Call('R_swig_ExchangeRateManager_lookup__SWIG_0', self, source, target, date, type, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_ExchangeRate";
  
  ans
  
}

attr(`ExchangeRateManager_lookup__SWIG_0`, 'returnType') = '_p_ExchangeRate'
attr(`ExchangeRateManager_lookup__SWIG_0`, "inputTypes") = c('_p_ExchangeRateManager', '_p_Currency', '_p_Currency', '_p_Date', 'character')
class(`ExchangeRateManager_lookup__SWIG_0`) = c("SWIGFunction", class('ExchangeRateManager_lookup__SWIG_0'))

# Start of ExchangeRateManager_lookup

`ExchangeRateManager_lookup__SWIG_1` = function(self, source, target, date, .copy = FALSE)
{
  ;ans = .Call('R_swig_ExchangeRateManager_lookup__SWIG_1', self, source, target, date, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_ExchangeRate";
  
  ans
  
}

attr(`ExchangeRateManager_lookup__SWIG_1`, 'returnType') = '_p_ExchangeRate'
attr(`ExchangeRateManager_lookup__SWIG_1`, "inputTypes") = c('_p_ExchangeRateManager', '_p_Currency', '_p_Currency', '_p_Date')
class(`ExchangeRateManager_lookup__SWIG_1`) = c("SWIGFunction", class('ExchangeRateManager_lookup__SWIG_1'))

`ExchangeRateManager_lookup` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 4) {
    if (extends(argtypes[1], '_p_ExchangeRateManager') && extends(argtypes[2], '_p_Currency') && extends(argtypes[3], '_p_Currency') && extends(argtypes[4], '_p_Date')) {
      f <- ExchangeRateManager_lookup__SWIG_1; 
    }
  } else if (argc == 5) {
    if (extends(argtypes[1], '_p_ExchangeRateManager') && extends(argtypes[2], '_p_Currency') && extends(argtypes[3], '_p_Currency') && extends(argtypes[4], '_p_Date') && is.character(argv[[5]])) {
      f <- ExchangeRateManager_lookup__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for ExchangeRateManager_lookup with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of ExchangeRateManager_clear

`ExchangeRateManager_clear` = function(self)
{
  ;.Call('R_swig_ExchangeRateManager_clear', self, PACKAGE='QuantLib');
  
}

attr(`ExchangeRateManager_clear`, 'returnType') = 'void'
attr(`ExchangeRateManager_clear`, "inputTypes") = c('_p_ExchangeRateManager')
class(`ExchangeRateManager_clear`) = c("SWIGFunction", class('ExchangeRateManager_clear'))

# Start of delete_ExchangeRateManager

`delete_ExchangeRateManager` = function(self)
{
  ;.Call('R_swig_delete_ExchangeRateManager', self, PACKAGE='QuantLib');
  
}

attr(`delete_ExchangeRateManager`, 'returnType') = 'void'
attr(`delete_ExchangeRateManager`, "inputTypes") = c('_p_ExchangeRateManager')
class(`delete_ExchangeRateManager`) = c("SWIGFunction", class('delete_ExchangeRateManager'))

# Start of accessor method for ExchangeRateManager
setMethod('$', '_p_ExchangeRateManager', function(x, name)

{
  accessorFuns = list('add' = ExchangeRateManager_add, 'lookup' = ExchangeRateManager_lookup, 'clear' = ExchangeRateManager_clear);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for ExchangeRateManager
setMethod('delete', '_p_ExchangeRateManager', function(obj) {delete_ExchangeRateManager(obj)})
# Start of new_ForwardCurve

`ForwardCurve__SWIG_0` = function(dates, forwards, dayCounter, calendar, i)
{
  ;ans = .Call('R_swig_new_ForwardCurve__SWIG_0', dates, forwards, dayCounter, calendar, i, PACKAGE='QuantLib');
  class(ans) <- "_p_ForwardCurvePtr";
  
  reg.finalizer(ans, delete_ForwardCurve)
  ans
  
}

attr(`ForwardCurve__SWIG_0`, 'returnType') = '_p_ForwardCurvePtr'
attr(`ForwardCurve__SWIG_0`, "inputTypes") = c('_p_std__vectorT_Date_std__allocatorT_Date_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_DayCounter', '_p_Calendar', '_p_BackwardFlat')
class(`ForwardCurve__SWIG_0`) = c("SWIGFunction", class('ForwardCurve__SWIG_0'))

# Start of new_ForwardCurve

`ForwardCurve__SWIG_1` = function(dates, forwards, dayCounter, calendar)
{
  ;ans = .Call('R_swig_new_ForwardCurve__SWIG_1', dates, forwards, dayCounter, calendar, PACKAGE='QuantLib');
  class(ans) <- "_p_ForwardCurvePtr";
  
  reg.finalizer(ans, delete_ForwardCurve)
  ans
  
}

attr(`ForwardCurve__SWIG_1`, 'returnType') = '_p_ForwardCurvePtr'
attr(`ForwardCurve__SWIG_1`, "inputTypes") = c('_p_std__vectorT_Date_std__allocatorT_Date_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_DayCounter', '_p_Calendar')
class(`ForwardCurve__SWIG_1`) = c("SWIGFunction", class('ForwardCurve__SWIG_1'))

# Start of new_ForwardCurve

`ForwardCurve__SWIG_2` = function(dates, forwards, dayCounter)
{
  ;ans = .Call('R_swig_new_ForwardCurve__SWIG_2', dates, forwards, dayCounter, PACKAGE='QuantLib');
  class(ans) <- "_p_ForwardCurvePtr";
  
  reg.finalizer(ans, delete_ForwardCurve)
  ans
  
}

attr(`ForwardCurve__SWIG_2`, 'returnType') = '_p_ForwardCurvePtr'
attr(`ForwardCurve__SWIG_2`, "inputTypes") = c('_p_std__vectorT_Date_std__allocatorT_Date_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_DayCounter')
class(`ForwardCurve__SWIG_2`) = c("SWIGFunction", class('ForwardCurve__SWIG_2'))

`ForwardCurve` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 3) {
    if (extends(argtypes[1], '_p_std__vectorT_Date_std__allocatorT_Date_t_t') && extends(argtypes[2], '_p_std__vectorT_double_std__allocatorT_double_t_t') && extends(argtypes[3], '_p_DayCounter')) {
      f <- ForwardCurve__SWIG_2; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_std__vectorT_Date_std__allocatorT_Date_t_t') && extends(argtypes[2], '_p_std__vectorT_double_std__allocatorT_double_t_t') && extends(argtypes[3], '_p_DayCounter') && extends(argtypes[4], '_p_Calendar')) {
      f <- ForwardCurve__SWIG_1; 
    }
  } else if (argc == 5) {
    if (extends(argtypes[1], '_p_std__vectorT_Date_std__allocatorT_Date_t_t') && extends(argtypes[2], '_p_std__vectorT_double_std__allocatorT_double_t_t') && extends(argtypes[3], '_p_DayCounter') && extends(argtypes[4], '_p_Calendar') && extends(argtypes[5], '_p_BackwardFlat')) {
      f <- ForwardCurve__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for ForwardCurve with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of ForwardCurve_dates

`ForwardCurve_dates` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_ForwardCurve_dates', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_Date_std__allocatorT_Date_t_t";
  
  ans
  
}

attr(`ForwardCurve_dates`, 'returnType') = '_p_std__vectorT_Date_std__allocatorT_Date_t_t'
attr(`ForwardCurve_dates`, "inputTypes") = c('_p_ForwardCurvePtr')
class(`ForwardCurve_dates`) = c("SWIGFunction", class('ForwardCurve_dates'))

# Start of ForwardCurve_forwards

`ForwardCurve_forwards` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_ForwardCurve_forwards', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_double_std__allocatorT_double_t_t";
  
  ans
  
}

attr(`ForwardCurve_forwards`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`ForwardCurve_forwards`, "inputTypes") = c('_p_ForwardCurvePtr')
class(`ForwardCurve_forwards`) = c("SWIGFunction", class('ForwardCurve_forwards'))

# Start of delete_ForwardCurve

`delete_ForwardCurve` = function(self)
{
  ;.Call('R_swig_delete_ForwardCurve', self, PACKAGE='QuantLib');
  
}

attr(`delete_ForwardCurve`, 'returnType') = 'void'
attr(`delete_ForwardCurve`, "inputTypes") = c('_p_ForwardCurvePtr')
class(`delete_ForwardCurve`) = c("SWIGFunction", class('delete_ForwardCurve'))

# Start of accessor method for ForwardCurvePtr
setMethod('$', '_p_ForwardCurvePtr', function(x, name)

{
  accessorFuns = list('dates' = ForwardCurve_dates, 'forwards' = ForwardCurve_forwards);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for ForwardCurvePtr
setMethod('delete', '_p_ForwardCurvePtr', function(obj) {delete_ForwardCurvePtr(obj)})
# Start of new_TimeGrid

`TimeGrid__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_TimeGrid__SWIG_0', PACKAGE='QuantLib');
  class(ans) <- "_p_TimeGrid";
  
  reg.finalizer(ans, delete_TimeGrid)
  ans
  
}

attr(`TimeGrid__SWIG_0`, 'returnType') = '_p_TimeGrid'
class(`TimeGrid__SWIG_0`) = c("SWIGFunction", class('TimeGrid__SWIG_0'))

# Start of new_TimeGrid

`TimeGrid__SWIG_1` = function(end, steps)
{
  if(length(steps) > 1) {
    warning("using only the first element of steps");
  };
  
  ;ans = .Call('R_swig_new_TimeGrid__SWIG_1', end, steps, PACKAGE='QuantLib');
  class(ans) <- "_p_TimeGrid";
  
  reg.finalizer(ans, delete_TimeGrid)
  ans
  
}

attr(`TimeGrid__SWIG_1`, 'returnType') = '_p_TimeGrid'
attr(`TimeGrid__SWIG_1`, "inputTypes") = c('numeric', 'integer')
class(`TimeGrid__SWIG_1`) = c("SWIGFunction", class('TimeGrid__SWIG_1'))

# Start of new_TimeGrid

`TimeGrid__SWIG_2` = function(times)
{
  ;ans = .Call('R_swig_new_TimeGrid__SWIG_2', times, PACKAGE='QuantLib');
  class(ans) <- "_p_TimeGrid";
  
  reg.finalizer(ans, delete_TimeGrid)
  ans
  
}

attr(`TimeGrid__SWIG_2`, 'returnType') = '_p_TimeGrid'
attr(`TimeGrid__SWIG_2`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`TimeGrid__SWIG_2`) = c("SWIGFunction", class('TimeGrid__SWIG_2'))

# Start of new_TimeGrid

`TimeGrid__SWIG_3` = function(times, steps)
{
  if(length(steps) > 1) {
    warning("using only the first element of steps");
  };
  
  ;ans = .Call('R_swig_new_TimeGrid__SWIG_3', times, steps, PACKAGE='QuantLib');
  class(ans) <- "_p_TimeGrid";
  
  reg.finalizer(ans, delete_TimeGrid)
  ans
  
}

attr(`TimeGrid__SWIG_3`, 'returnType') = '_p_TimeGrid'
attr(`TimeGrid__SWIG_3`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer')
class(`TimeGrid__SWIG_3`) = c("SWIGFunction", class('TimeGrid__SWIG_3'))

`TimeGrid` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- TimeGrid__SWIG_0; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_std__vectorT_double_std__allocatorT_double_t_t')) {
      f <- TimeGrid__SWIG_2; 
    }
  } else if (argc == 2) {
    if (is.numeric(argv[[1]]) && (is.integer(argv[[2]]) || is.numeric(argv[[2]]))) {
      f <- TimeGrid__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_double_std__allocatorT_double_t_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]]))) {
      f <- TimeGrid__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for TimeGrid with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of TimeGrid_size

`TimeGrid_size` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_TimeGrid_size', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__size_t";
  
  ans
  
}

attr(`TimeGrid_size`, 'returnType') = 'integer'
attr(`TimeGrid_size`, "inputTypes") = c('_p_TimeGrid')
class(`TimeGrid_size`) = c("SWIGFunction", class('TimeGrid_size'))

# Start of delete_TimeGrid

`delete_TimeGrid` = function(self)
{
  ;.Call('R_swig_delete_TimeGrid', self, PACKAGE='QuantLib');
  
}

attr(`delete_TimeGrid`, 'returnType') = 'void'
attr(`delete_TimeGrid`, "inputTypes") = c('_p_TimeGrid')
class(`delete_TimeGrid`) = c("SWIGFunction", class('delete_TimeGrid'))

# Start of accessor method for TimeGrid
setMethod('$', '_p_TimeGrid', function(x, name)

{
  accessorFuns = list('size' = TimeGrid_size);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for TimeGrid
setMethod('delete', '_p_TimeGrid', function(obj) {delete_TimeGrid(obj)})
# Start of Seasonality___deref__

`Seasonality___deref__` = function(self)
{
  ;ans = .Call('R_swig_Seasonality___deref__', self, PACKAGE='QuantLib');
  class(ans) <- "_p_Seasonality";
  
  ans
  
}

attr(`Seasonality___deref__`, 'returnType') = '_p_Seasonality'
attr(`Seasonality___deref__`, "inputTypes") = c('_p_boost__shared_ptrT_Seasonality_t')
class(`Seasonality___deref__`) = c("SWIGFunction", class('Seasonality___deref__'))

# Start of Seasonality_isNull

`Seasonality_isNull` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Seasonality_isNull', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Seasonality_isNull`, 'returnType') = 'logical'
attr(`Seasonality_isNull`, "inputTypes") = c('_p_boost__shared_ptrT_Seasonality_t')
class(`Seasonality_isNull`) = c("SWIGFunction", class('Seasonality_isNull'))

# Start of new_Seasonality

`Seasonality` = function()
{
  ;ans = .Call('R_swig_new_Seasonality', PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_Seasonality_t";
  
  reg.finalizer(ans, delete_Seasonality)
  ans
  
}

attr(`Seasonality`, 'returnType') = '_p_boost__shared_ptrT_Seasonality_t'
class(`Seasonality`) = c("SWIGFunction", class('Seasonality'))

# Start of delete_Seasonality

`delete_Seasonality` = function(self)
{
  ;.Call('R_swig_delete_Seasonality', self, PACKAGE='QuantLib');
  
}

attr(`delete_Seasonality`, 'returnType') = 'void'
attr(`delete_Seasonality`, "inputTypes") = c('_p_boost__shared_ptrT_Seasonality_t')
class(`delete_Seasonality`) = c("SWIGFunction", class('delete_Seasonality'))

# Start of Seasonality_correctZeroRate

`Seasonality_correctZeroRate` = function(self, d, r, iTS, .copy = FALSE)
{
  ;.Call('R_swig_Seasonality_correctZeroRate', self, d, r, iTS, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Seasonality_correctZeroRate`, 'returnType') = 'numeric'
attr(`Seasonality_correctZeroRate`, "inputTypes") = c('_p_boost__shared_ptrT_Seasonality_t', '_p_Date', 'numeric', '_p_InflationTermStructure')
class(`Seasonality_correctZeroRate`) = c("SWIGFunction", class('Seasonality_correctZeroRate'))

# Start of Seasonality_correctYoYRate

`Seasonality_correctYoYRate` = function(self, d, r, iTS, .copy = FALSE)
{
  ;.Call('R_swig_Seasonality_correctYoYRate', self, d, r, iTS, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Seasonality_correctYoYRate`, 'returnType') = 'numeric'
attr(`Seasonality_correctYoYRate`, "inputTypes") = c('_p_boost__shared_ptrT_Seasonality_t', '_p_Date', 'numeric', '_p_InflationTermStructure')
class(`Seasonality_correctYoYRate`) = c("SWIGFunction", class('Seasonality_correctYoYRate'))

# Start of Seasonality_isConsistent

`Seasonality_isConsistent` = function(self, iTS, .copy = FALSE)
{
  ;.Call('R_swig_Seasonality_isConsistent', self, iTS, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Seasonality_isConsistent`, 'returnType') = 'logical'
attr(`Seasonality_isConsistent`, "inputTypes") = c('_p_boost__shared_ptrT_Seasonality_t', '_p_InflationTermStructure')
class(`Seasonality_isConsistent`) = c("SWIGFunction", class('Seasonality_isConsistent'))

# Start of accessor method for boost::shared_ptr<(Seasonality)>
setMethod('$', '_p_boost__shared_ptrT_Seasonality_t', function(x, name)

{
  accessorFuns = list('__deref__' = Seasonality___deref__, 'isNull' = Seasonality_isNull, 'correctZeroRate' = Seasonality_correctZeroRate, 'correctYoYRate' = Seasonality_correctYoYRate, 'isConsistent' = Seasonality_isConsistent);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for boost::shared_ptr<(Seasonality)>
setMethod('delete', '_p_boost__shared_ptrT_Seasonality_t', function(obj) {delete_boost__shared_ptrT_Seasonality_t(obj)})
# Start of new_MultiplicativePriceSeasonalityPtr

`MultiplicativePriceSeasonalityPtr` = function(seasonalityBaseDate, frequency, seasonalityFactors)
{
  frequency = enumToInteger(frequency, "_Frequency"); 
  
  if(length(frequency) > 1) {
    warning("using only the first element of frequency");
  };
  
  
  ;ans = .Call('R_swig_new_MultiplicativePriceSeasonalityPtr', seasonalityBaseDate, frequency, seasonalityFactors, PACKAGE='QuantLib');
  class(ans) <- "_p_MultiplicativePriceSeasonalityPtr";
  
  reg.finalizer(ans, delete_MultiplicativePriceSeasonalityPtr)
  ans
  
}

attr(`MultiplicativePriceSeasonalityPtr`, 'returnType') = '_p_MultiplicativePriceSeasonalityPtr'
attr(`MultiplicativePriceSeasonalityPtr`, "inputTypes") = c('_p_Date', 'character', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`MultiplicativePriceSeasonalityPtr`) = c("SWIGFunction", class('MultiplicativePriceSeasonalityPtr'))

# Start of delete_MultiplicativePriceSeasonalityPtr

`delete_MultiplicativePriceSeasonalityPtr` = function(self)
{
  ;.Call('R_swig_delete_MultiplicativePriceSeasonalityPtr', self, PACKAGE='QuantLib');
  
}

attr(`delete_MultiplicativePriceSeasonalityPtr`, 'returnType') = 'void'
attr(`delete_MultiplicativePriceSeasonalityPtr`, "inputTypes") = c('_p_MultiplicativePriceSeasonalityPtr')
class(`delete_MultiplicativePriceSeasonalityPtr`) = c("SWIGFunction", class('delete_MultiplicativePriceSeasonalityPtr'))

setMethod('delete', '_p_MultiplicativePriceSeasonalityPtr', function(obj) {delete_MultiplicativePriceSeasonalityPtr(obj)})
# Start of YoYInflationTermStructure___deref__

`YoYInflationTermStructure___deref__` = function(self)
{
  ;ans = .Call('R_swig_YoYInflationTermStructure___deref__', self, PACKAGE='QuantLib');
  class(ans) <- "_p_YoYInflationTermStructure";
  
  ans
  
}

attr(`YoYInflationTermStructure___deref__`, 'returnType') = '_p_YoYInflationTermStructure'
attr(`YoYInflationTermStructure___deref__`, "inputTypes") = c('_p_boost__shared_ptrT_YoYInflationTermStructure_t')
class(`YoYInflationTermStructure___deref__`) = c("SWIGFunction", class('YoYInflationTermStructure___deref__'))

# Start of YoYInflationTermStructure_isNull

`YoYInflationTermStructure_isNull` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_YoYInflationTermStructure_isNull', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`YoYInflationTermStructure_isNull`, 'returnType') = 'logical'
attr(`YoYInflationTermStructure_isNull`, "inputTypes") = c('_p_boost__shared_ptrT_YoYInflationTermStructure_t')
class(`YoYInflationTermStructure_isNull`) = c("SWIGFunction", class('YoYInflationTermStructure_isNull'))

# Start of YoYInflationTermStructure_asObservable

`YoYInflationTermStructure_asObservable` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_YoYInflationTermStructure_asObservable', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_Observable_t";
  
  ans
  
}

attr(`YoYInflationTermStructure_asObservable`, 'returnType') = '_p_boost__shared_ptrT_Observable_t'
attr(`YoYInflationTermStructure_asObservable`, "inputTypes") = c('_p_boost__shared_ptrT_YoYInflationTermStructure_t')
class(`YoYInflationTermStructure_asObservable`) = c("SWIGFunction", class('YoYInflationTermStructure_asObservable'))

# Start of new_YoYInflationTermStructure

`YoYInflationTermStructure` = function()
{
  ;ans = .Call('R_swig_new_YoYInflationTermStructure', PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_YoYInflationTermStructure_t";
  
  reg.finalizer(ans, delete_YoYInflationTermStructure)
  ans
  
}

attr(`YoYInflationTermStructure`, 'returnType') = '_p_boost__shared_ptrT_YoYInflationTermStructure_t'
class(`YoYInflationTermStructure`) = c("SWIGFunction", class('YoYInflationTermStructure'))

# Start of delete_YoYInflationTermStructure

`delete_YoYInflationTermStructure` = function(self)
{
  ;.Call('R_swig_delete_YoYInflationTermStructure', self, PACKAGE='QuantLib');
  
}

attr(`delete_YoYInflationTermStructure`, 'returnType') = 'void'
attr(`delete_YoYInflationTermStructure`, "inputTypes") = c('_p_boost__shared_ptrT_YoYInflationTermStructure_t')
class(`delete_YoYInflationTermStructure`) = c("SWIGFunction", class('delete_YoYInflationTermStructure'))

# Start of YoYInflationTermStructure_yoyRate

`YoYInflationTermStructure_yoyRate__SWIG_0` = function(self, d, instObsLag, forceLinearInterpolation, extrapolate, .copy = FALSE)
{
  forceLinearInterpolation = as.logical(forceLinearInterpolation);
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_YoYInflationTermStructure_yoyRate__SWIG_0', self, d, instObsLag, forceLinearInterpolation, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`YoYInflationTermStructure_yoyRate__SWIG_0`, 'returnType') = 'numeric'
attr(`YoYInflationTermStructure_yoyRate__SWIG_0`, "inputTypes") = c('_p_boost__shared_ptrT_YoYInflationTermStructure_t', '_p_Date', '_p_Period', 'logical', 'logical')
class(`YoYInflationTermStructure_yoyRate__SWIG_0`) = c("SWIGFunction", class('YoYInflationTermStructure_yoyRate__SWIG_0'))

# Start of YoYInflationTermStructure_yoyRate

`YoYInflationTermStructure_yoyRate__SWIG_1` = function(self, d, instObsLag, forceLinearInterpolation, .copy = FALSE)
{
  forceLinearInterpolation = as.logical(forceLinearInterpolation);
  ;.Call('R_swig_YoYInflationTermStructure_yoyRate__SWIG_1', self, d, instObsLag, forceLinearInterpolation, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`YoYInflationTermStructure_yoyRate__SWIG_1`, 'returnType') = 'numeric'
attr(`YoYInflationTermStructure_yoyRate__SWIG_1`, "inputTypes") = c('_p_boost__shared_ptrT_YoYInflationTermStructure_t', '_p_Date', '_p_Period', 'logical')
class(`YoYInflationTermStructure_yoyRate__SWIG_1`) = c("SWIGFunction", class('YoYInflationTermStructure_yoyRate__SWIG_1'))

# Start of YoYInflationTermStructure_yoyRate

`YoYInflationTermStructure_yoyRate__SWIG_2` = function(self, d, instObsLag, .copy = FALSE)
{
  ;.Call('R_swig_YoYInflationTermStructure_yoyRate__SWIG_2', self, d, instObsLag, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`YoYInflationTermStructure_yoyRate__SWIG_2`, 'returnType') = 'numeric'
attr(`YoYInflationTermStructure_yoyRate__SWIG_2`, "inputTypes") = c('_p_boost__shared_ptrT_YoYInflationTermStructure_t', '_p_Date', '_p_Period')
class(`YoYInflationTermStructure_yoyRate__SWIG_2`) = c("SWIGFunction", class('YoYInflationTermStructure_yoyRate__SWIG_2'))

# Start of YoYInflationTermStructure_yoyRate

`YoYInflationTermStructure_yoyRate__SWIG_3` = function(self, d, .copy = FALSE)
{
  ;.Call('R_swig_YoYInflationTermStructure_yoyRate__SWIG_3', self, d, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`YoYInflationTermStructure_yoyRate__SWIG_3`, 'returnType') = 'numeric'
attr(`YoYInflationTermStructure_yoyRate__SWIG_3`, "inputTypes") = c('_p_boost__shared_ptrT_YoYInflationTermStructure_t', '_p_Date')
class(`YoYInflationTermStructure_yoyRate__SWIG_3`) = c("SWIGFunction", class('YoYInflationTermStructure_yoyRate__SWIG_3'))

`YoYInflationTermStructure_yoyRate` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 2) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_YoYInflationTermStructure_t') && extends(argtypes[2], '_p_Date')) {
      f <- YoYInflationTermStructure_yoyRate__SWIG_3; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_YoYInflationTermStructure_t') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_Period')) {
      f <- YoYInflationTermStructure_yoyRate__SWIG_2; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_YoYInflationTermStructure_t') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_Period') && extends(argtypes[4], 'logical')) {
      f <- YoYInflationTermStructure_yoyRate__SWIG_1; 
    }
  } else if (argc == 5) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_YoYInflationTermStructure_t') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_Period') && extends(argtypes[4], 'logical') && extends(argtypes[5], 'logical')) {
      f <- YoYInflationTermStructure_yoyRate__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for YoYInflationTermStructure_yoyRate with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of YoYInflationTermStructure_dayCounter

`YoYInflationTermStructure_dayCounter` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_YoYInflationTermStructure_dayCounter', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_DayCounter";
  
  ans
  
}

attr(`YoYInflationTermStructure_dayCounter`, 'returnType') = '_p_DayCounter'
attr(`YoYInflationTermStructure_dayCounter`, "inputTypes") = c('_p_boost__shared_ptrT_YoYInflationTermStructure_t')
class(`YoYInflationTermStructure_dayCounter`) = c("SWIGFunction", class('YoYInflationTermStructure_dayCounter'))

# Start of YoYInflationTermStructure_calendar

`YoYInflationTermStructure_calendar` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_YoYInflationTermStructure_calendar', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Calendar";
  
  ans
  
}

attr(`YoYInflationTermStructure_calendar`, 'returnType') = '_p_Calendar'
attr(`YoYInflationTermStructure_calendar`, "inputTypes") = c('_p_boost__shared_ptrT_YoYInflationTermStructure_t')
class(`YoYInflationTermStructure_calendar`) = c("SWIGFunction", class('YoYInflationTermStructure_calendar'))

# Start of YoYInflationTermStructure_referenceDate

`YoYInflationTermStructure_referenceDate` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_YoYInflationTermStructure_referenceDate', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`YoYInflationTermStructure_referenceDate`, 'returnType') = '_p_Date'
attr(`YoYInflationTermStructure_referenceDate`, "inputTypes") = c('_p_boost__shared_ptrT_YoYInflationTermStructure_t')
class(`YoYInflationTermStructure_referenceDate`) = c("SWIGFunction", class('YoYInflationTermStructure_referenceDate'))

# Start of YoYInflationTermStructure_maxDate

`YoYInflationTermStructure_maxDate` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_YoYInflationTermStructure_maxDate', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`YoYInflationTermStructure_maxDate`, 'returnType') = '_p_Date'
attr(`YoYInflationTermStructure_maxDate`, "inputTypes") = c('_p_boost__shared_ptrT_YoYInflationTermStructure_t')
class(`YoYInflationTermStructure_maxDate`) = c("SWIGFunction", class('YoYInflationTermStructure_maxDate'))

# Start of YoYInflationTermStructure_maxTime

`YoYInflationTermStructure_maxTime` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_YoYInflationTermStructure_maxTime', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`YoYInflationTermStructure_maxTime`, 'returnType') = 'numeric'
attr(`YoYInflationTermStructure_maxTime`, "inputTypes") = c('_p_boost__shared_ptrT_YoYInflationTermStructure_t')
class(`YoYInflationTermStructure_maxTime`) = c("SWIGFunction", class('YoYInflationTermStructure_maxTime'))

# Start of YoYInflationTermStructure_observationLag

`YoYInflationTermStructure_observationLag` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_YoYInflationTermStructure_observationLag', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Period";
  
  ans
  
}

attr(`YoYInflationTermStructure_observationLag`, 'returnType') = '_p_Period'
attr(`YoYInflationTermStructure_observationLag`, "inputTypes") = c('_p_boost__shared_ptrT_YoYInflationTermStructure_t')
class(`YoYInflationTermStructure_observationLag`) = c("SWIGFunction", class('YoYInflationTermStructure_observationLag'))

# Start of YoYInflationTermStructure_frequency

`YoYInflationTermStructure_frequency` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_YoYInflationTermStructure_frequency', self, as.logical(.copy), PACKAGE='QuantLib');
  ans = enumFromInteger(ans, "_Frequency");
  
  ans
  
}

attr(`YoYInflationTermStructure_frequency`, 'returnType') = 'character'
attr(`YoYInflationTermStructure_frequency`, "inputTypes") = c('_p_boost__shared_ptrT_YoYInflationTermStructure_t')
class(`YoYInflationTermStructure_frequency`) = c("SWIGFunction", class('YoYInflationTermStructure_frequency'))

# Start of YoYInflationTermStructure_indexIsInterpolated

`YoYInflationTermStructure_indexIsInterpolated` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_YoYInflationTermStructure_indexIsInterpolated', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`YoYInflationTermStructure_indexIsInterpolated`, 'returnType') = 'logical'
attr(`YoYInflationTermStructure_indexIsInterpolated`, "inputTypes") = c('_p_boost__shared_ptrT_YoYInflationTermStructure_t')
class(`YoYInflationTermStructure_indexIsInterpolated`) = c("SWIGFunction", class('YoYInflationTermStructure_indexIsInterpolated'))

# Start of YoYInflationTermStructure_baseRate

`YoYInflationTermStructure_baseRate` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_YoYInflationTermStructure_baseRate', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`YoYInflationTermStructure_baseRate`, 'returnType') = 'numeric'
attr(`YoYInflationTermStructure_baseRate`, "inputTypes") = c('_p_boost__shared_ptrT_YoYInflationTermStructure_t')
class(`YoYInflationTermStructure_baseRate`) = c("SWIGFunction", class('YoYInflationTermStructure_baseRate'))

# Start of YoYInflationTermStructure_nominalTermStructure

`YoYInflationTermStructure_nominalTermStructure` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_YoYInflationTermStructure_nominalTermStructure', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_HandleT_YieldTermStructure_t";
  
  ans
  
}

attr(`YoYInflationTermStructure_nominalTermStructure`, 'returnType') = '_p_HandleT_YieldTermStructure_t'
attr(`YoYInflationTermStructure_nominalTermStructure`, "inputTypes") = c('_p_boost__shared_ptrT_YoYInflationTermStructure_t')
class(`YoYInflationTermStructure_nominalTermStructure`) = c("SWIGFunction", class('YoYInflationTermStructure_nominalTermStructure'))

# Start of YoYInflationTermStructure_baseDate

`YoYInflationTermStructure_baseDate` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_YoYInflationTermStructure_baseDate', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`YoYInflationTermStructure_baseDate`, 'returnType') = '_p_Date'
attr(`YoYInflationTermStructure_baseDate`, "inputTypes") = c('_p_boost__shared_ptrT_YoYInflationTermStructure_t')
class(`YoYInflationTermStructure_baseDate`) = c("SWIGFunction", class('YoYInflationTermStructure_baseDate'))

# Start of YoYInflationTermStructure_setSeasonality

`YoYInflationTermStructure_setSeasonality__SWIG_0` = function(self, seasonality)
{
  ;.Call('R_swig_YoYInflationTermStructure_setSeasonality__SWIG_0', self, seasonality, PACKAGE='QuantLib');
  
}

attr(`YoYInflationTermStructure_setSeasonality__SWIG_0`, 'returnType') = 'void'
attr(`YoYInflationTermStructure_setSeasonality__SWIG_0`, "inputTypes") = c('_p_boost__shared_ptrT_YoYInflationTermStructure_t', '_p_boost__shared_ptrT_Seasonality_t')
class(`YoYInflationTermStructure_setSeasonality__SWIG_0`) = c("SWIGFunction", class('YoYInflationTermStructure_setSeasonality__SWIG_0'))

# Start of YoYInflationTermStructure_setSeasonality

`YoYInflationTermStructure_setSeasonality__SWIG_1` = function(self)
{
  ;.Call('R_swig_YoYInflationTermStructure_setSeasonality__SWIG_1', self, PACKAGE='QuantLib');
  
}

attr(`YoYInflationTermStructure_setSeasonality__SWIG_1`, 'returnType') = 'void'
attr(`YoYInflationTermStructure_setSeasonality__SWIG_1`, "inputTypes") = c('_p_boost__shared_ptrT_YoYInflationTermStructure_t')
class(`YoYInflationTermStructure_setSeasonality__SWIG_1`) = c("SWIGFunction", class('YoYInflationTermStructure_setSeasonality__SWIG_1'))

`YoYInflationTermStructure_setSeasonality` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_YoYInflationTermStructure_t')) {
      f <- YoYInflationTermStructure_setSeasonality__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_YoYInflationTermStructure_t') && extends(argtypes[2], '_p_boost__shared_ptrT_Seasonality_t')) {
      f <- YoYInflationTermStructure_setSeasonality__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for YoYInflationTermStructure_setSeasonality with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of YoYInflationTermStructure_seasonality

`YoYInflationTermStructure_seasonality` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_YoYInflationTermStructure_seasonality', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_Seasonality_t";
  
  ans
  
}

attr(`YoYInflationTermStructure_seasonality`, 'returnType') = '_p_boost__shared_ptrT_Seasonality_t'
attr(`YoYInflationTermStructure_seasonality`, "inputTypes") = c('_p_boost__shared_ptrT_YoYInflationTermStructure_t')
class(`YoYInflationTermStructure_seasonality`) = c("SWIGFunction", class('YoYInflationTermStructure_seasonality'))

# Start of YoYInflationTermStructure_hasSeasonality

`YoYInflationTermStructure_hasSeasonality` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_YoYInflationTermStructure_hasSeasonality', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`YoYInflationTermStructure_hasSeasonality`, 'returnType') = 'logical'
attr(`YoYInflationTermStructure_hasSeasonality`, "inputTypes") = c('_p_boost__shared_ptrT_YoYInflationTermStructure_t')
class(`YoYInflationTermStructure_hasSeasonality`) = c("SWIGFunction", class('YoYInflationTermStructure_hasSeasonality'))

# Start of YoYInflationTermStructure_enableExtrapolation

`YoYInflationTermStructure_enableExtrapolation` = function(self)
{
  ;.Call('R_swig_YoYInflationTermStructure_enableExtrapolation', self, PACKAGE='QuantLib');
  
}

attr(`YoYInflationTermStructure_enableExtrapolation`, 'returnType') = 'void'
attr(`YoYInflationTermStructure_enableExtrapolation`, "inputTypes") = c('_p_boost__shared_ptrT_YoYInflationTermStructure_t')
class(`YoYInflationTermStructure_enableExtrapolation`) = c("SWIGFunction", class('YoYInflationTermStructure_enableExtrapolation'))

# Start of YoYInflationTermStructure_disableExtrapolation

`YoYInflationTermStructure_disableExtrapolation` = function(self)
{
  ;.Call('R_swig_YoYInflationTermStructure_disableExtrapolation', self, PACKAGE='QuantLib');
  
}

attr(`YoYInflationTermStructure_disableExtrapolation`, 'returnType') = 'void'
attr(`YoYInflationTermStructure_disableExtrapolation`, "inputTypes") = c('_p_boost__shared_ptrT_YoYInflationTermStructure_t')
class(`YoYInflationTermStructure_disableExtrapolation`) = c("SWIGFunction", class('YoYInflationTermStructure_disableExtrapolation'))

# Start of YoYInflationTermStructure_allowsExtrapolation

`YoYInflationTermStructure_allowsExtrapolation` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_YoYInflationTermStructure_allowsExtrapolation', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`YoYInflationTermStructure_allowsExtrapolation`, 'returnType') = 'logical'
attr(`YoYInflationTermStructure_allowsExtrapolation`, "inputTypes") = c('_p_boost__shared_ptrT_YoYInflationTermStructure_t')
class(`YoYInflationTermStructure_allowsExtrapolation`) = c("SWIGFunction", class('YoYInflationTermStructure_allowsExtrapolation'))

# Start of accessor method for boost::shared_ptr<(YoYInflationTermStructure)>
setMethod('$', '_p_boost__shared_ptrT_YoYInflationTermStructure_t', function(x, name)

{
  accessorFuns = list('__deref__' = YoYInflationTermStructure___deref__, 'isNull' = YoYInflationTermStructure_isNull, 'asObservable' = YoYInflationTermStructure_asObservable, 'yoyRate' = YoYInflationTermStructure_yoyRate, 'dayCounter' = YoYInflationTermStructure_dayCounter, 'calendar' = YoYInflationTermStructure_calendar, 'referenceDate' = YoYInflationTermStructure_referenceDate, 'maxDate' = YoYInflationTermStructure_maxDate, 'maxTime' = YoYInflationTermStructure_maxTime, 'observationLag' = YoYInflationTermStructure_observationLag, 'frequency' = YoYInflationTermStructure_frequency, 'indexIsInterpolated' = YoYInflationTermStructure_indexIsInterpolated, 'baseRate' = YoYInflationTermStructure_baseRate, 'nominalTermStructure' = YoYInflationTermStructure_nominalTermStructure, 'baseDate' = YoYInflationTermStructure_baseDate, 'setSeasonality' = YoYInflationTermStructure_setSeasonality, 'seasonality' = YoYInflationTermStructure_seasonality, 'hasSeasonality' = YoYInflationTermStructure_hasSeasonality, 'enableExtrapolation' = YoYInflationTermStructure_enableExtrapolation, 'disableExtrapolation' = YoYInflationTermStructure_disableExtrapolation, 'allowsExtrapolation' = YoYInflationTermStructure_allowsExtrapolation);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for boost::shared_ptr<(YoYInflationTermStructure)>
setMethod('delete', '_p_boost__shared_ptrT_YoYInflationTermStructure_t', function(obj) {delete_boost__shared_ptrT_YoYInflationTermStructure_t(obj)})
# Start of new_YoYInflationTermStructureHandle

`YoYInflationTermStructureHandle__SWIG_0` = function(s_arg1)
{
  ;ans = .Call('R_swig_new_YoYInflationTermStructureHandle__SWIG_0', s_arg1, PACKAGE='QuantLib');
  class(ans) <- "_p_HandleT_YoYInflationTermStructure_t";
  
  reg.finalizer(ans, delete_YoYInflationTermStructureHandle)
  ans
  
}

attr(`YoYInflationTermStructureHandle__SWIG_0`, 'returnType') = '_p_HandleT_YoYInflationTermStructure_t'
attr(`YoYInflationTermStructureHandle__SWIG_0`, "inputTypes") = c('_p_boost__shared_ptrT_YoYInflationTermStructure_t')
class(`YoYInflationTermStructureHandle__SWIG_0`) = c("SWIGFunction", class('YoYInflationTermStructureHandle__SWIG_0'))

# Start of new_YoYInflationTermStructureHandle

`YoYInflationTermStructureHandle__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_YoYInflationTermStructureHandle__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_HandleT_YoYInflationTermStructure_t";
  
  reg.finalizer(ans, delete_YoYInflationTermStructureHandle)
  ans
  
}

attr(`YoYInflationTermStructureHandle__SWIG_1`, 'returnType') = '_p_HandleT_YoYInflationTermStructure_t'
class(`YoYInflationTermStructureHandle__SWIG_1`) = c("SWIGFunction", class('YoYInflationTermStructureHandle__SWIG_1'))

`YoYInflationTermStructureHandle` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- YoYInflationTermStructureHandle__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_YoYInflationTermStructure_t')) {
      f <- YoYInflationTermStructureHandle__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for YoYInflationTermStructureHandle with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of YoYInflationTermStructureHandle___deref__

`YoYInflationTermStructureHandle___deref__` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_YoYInflationTermStructureHandle___deref__', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_YoYInflationTermStructure_t";
  
  ans
  
}

attr(`YoYInflationTermStructureHandle___deref__`, 'returnType') = '_p_boost__shared_ptrT_YoYInflationTermStructure_t'
attr(`YoYInflationTermStructureHandle___deref__`, "inputTypes") = c('_p_HandleT_YoYInflationTermStructure_t')
class(`YoYInflationTermStructureHandle___deref__`) = c("SWIGFunction", class('YoYInflationTermStructureHandle___deref__'))

# Start of YoYInflationTermStructureHandle_empty

`YoYInflationTermStructureHandle_empty` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_YoYInflationTermStructureHandle_empty', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`YoYInflationTermStructureHandle_empty`, 'returnType') = 'logical'
attr(`YoYInflationTermStructureHandle_empty`, "inputTypes") = c('_p_HandleT_YoYInflationTermStructure_t')
class(`YoYInflationTermStructureHandle_empty`) = c("SWIGFunction", class('YoYInflationTermStructureHandle_empty'))

# Start of YoYInflationTermStructureHandle_asObservable

`YoYInflationTermStructureHandle_asObservable` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_YoYInflationTermStructureHandle_asObservable', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_Observable_t";
  
  ans
  
}

attr(`YoYInflationTermStructureHandle_asObservable`, 'returnType') = '_p_boost__shared_ptrT_Observable_t'
attr(`YoYInflationTermStructureHandle_asObservable`, "inputTypes") = c('_p_HandleT_YoYInflationTermStructure_t')
class(`YoYInflationTermStructureHandle_asObservable`) = c("SWIGFunction", class('YoYInflationTermStructureHandle_asObservable'))

# Start of delete_YoYInflationTermStructureHandle

`delete_YoYInflationTermStructureHandle` = function(self)
{
  ;.Call('R_swig_delete_YoYInflationTermStructureHandle', self, PACKAGE='QuantLib');
  
}

attr(`delete_YoYInflationTermStructureHandle`, 'returnType') = 'void'
attr(`delete_YoYInflationTermStructureHandle`, "inputTypes") = c('_p_HandleT_YoYInflationTermStructure_t')
class(`delete_YoYInflationTermStructureHandle`) = c("SWIGFunction", class('delete_YoYInflationTermStructureHandle'))

# Start of YoYInflationTermStructureHandle_yoyRate

`YoYInflationTermStructureHandle_yoyRate__SWIG_0` = function(self, d, instObsLag, forceLinearInterpolation, extrapolate, .copy = FALSE)
{
  forceLinearInterpolation = as.logical(forceLinearInterpolation);
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_YoYInflationTermStructureHandle_yoyRate__SWIG_0', self, d, instObsLag, forceLinearInterpolation, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`YoYInflationTermStructureHandle_yoyRate__SWIG_0`, 'returnType') = 'numeric'
attr(`YoYInflationTermStructureHandle_yoyRate__SWIG_0`, "inputTypes") = c('_p_HandleT_YoYInflationTermStructure_t', '_p_Date', '_p_Period', 'logical', 'logical')
class(`YoYInflationTermStructureHandle_yoyRate__SWIG_0`) = c("SWIGFunction", class('YoYInflationTermStructureHandle_yoyRate__SWIG_0'))

# Start of YoYInflationTermStructureHandle_yoyRate

`YoYInflationTermStructureHandle_yoyRate__SWIG_1` = function(self, d, instObsLag, forceLinearInterpolation, .copy = FALSE)
{
  forceLinearInterpolation = as.logical(forceLinearInterpolation);
  ;.Call('R_swig_YoYInflationTermStructureHandle_yoyRate__SWIG_1', self, d, instObsLag, forceLinearInterpolation, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`YoYInflationTermStructureHandle_yoyRate__SWIG_1`, 'returnType') = 'numeric'
attr(`YoYInflationTermStructureHandle_yoyRate__SWIG_1`, "inputTypes") = c('_p_HandleT_YoYInflationTermStructure_t', '_p_Date', '_p_Period', 'logical')
class(`YoYInflationTermStructureHandle_yoyRate__SWIG_1`) = c("SWIGFunction", class('YoYInflationTermStructureHandle_yoyRate__SWIG_1'))

# Start of YoYInflationTermStructureHandle_yoyRate

`YoYInflationTermStructureHandle_yoyRate__SWIG_2` = function(self, d, instObsLag, .copy = FALSE)
{
  ;.Call('R_swig_YoYInflationTermStructureHandle_yoyRate__SWIG_2', self, d, instObsLag, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`YoYInflationTermStructureHandle_yoyRate__SWIG_2`, 'returnType') = 'numeric'
attr(`YoYInflationTermStructureHandle_yoyRate__SWIG_2`, "inputTypes") = c('_p_HandleT_YoYInflationTermStructure_t', '_p_Date', '_p_Period')
class(`YoYInflationTermStructureHandle_yoyRate__SWIG_2`) = c("SWIGFunction", class('YoYInflationTermStructureHandle_yoyRate__SWIG_2'))

# Start of YoYInflationTermStructureHandle_yoyRate

`YoYInflationTermStructureHandle_yoyRate__SWIG_3` = function(self, d, .copy = FALSE)
{
  ;.Call('R_swig_YoYInflationTermStructureHandle_yoyRate__SWIG_3', self, d, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`YoYInflationTermStructureHandle_yoyRate__SWIG_3`, 'returnType') = 'numeric'
attr(`YoYInflationTermStructureHandle_yoyRate__SWIG_3`, "inputTypes") = c('_p_HandleT_YoYInflationTermStructure_t', '_p_Date')
class(`YoYInflationTermStructureHandle_yoyRate__SWIG_3`) = c("SWIGFunction", class('YoYInflationTermStructureHandle_yoyRate__SWIG_3'))

`YoYInflationTermStructureHandle_yoyRate` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 2) {
    if (extends(argtypes[1], '_p_HandleT_YoYInflationTermStructure_t') && extends(argtypes[2], '_p_Date')) {
      f <- YoYInflationTermStructureHandle_yoyRate__SWIG_3; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_HandleT_YoYInflationTermStructure_t') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_Period')) {
      f <- YoYInflationTermStructureHandle_yoyRate__SWIG_2; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_HandleT_YoYInflationTermStructure_t') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_Period') && extends(argtypes[4], 'logical')) {
      f <- YoYInflationTermStructureHandle_yoyRate__SWIG_1; 
    }
  } else if (argc == 5) {
    if (extends(argtypes[1], '_p_HandleT_YoYInflationTermStructure_t') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_Period') && extends(argtypes[4], 'logical') && extends(argtypes[5], 'logical')) {
      f <- YoYInflationTermStructureHandle_yoyRate__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for YoYInflationTermStructureHandle_yoyRate with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of YoYInflationTermStructureHandle_dayCounter

`YoYInflationTermStructureHandle_dayCounter` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_YoYInflationTermStructureHandle_dayCounter', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_DayCounter";
  
  ans
  
}

attr(`YoYInflationTermStructureHandle_dayCounter`, 'returnType') = '_p_DayCounter'
attr(`YoYInflationTermStructureHandle_dayCounter`, "inputTypes") = c('_p_HandleT_YoYInflationTermStructure_t')
class(`YoYInflationTermStructureHandle_dayCounter`) = c("SWIGFunction", class('YoYInflationTermStructureHandle_dayCounter'))

# Start of YoYInflationTermStructureHandle_calendar

`YoYInflationTermStructureHandle_calendar` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_YoYInflationTermStructureHandle_calendar', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Calendar";
  
  ans
  
}

attr(`YoYInflationTermStructureHandle_calendar`, 'returnType') = '_p_Calendar'
attr(`YoYInflationTermStructureHandle_calendar`, "inputTypes") = c('_p_HandleT_YoYInflationTermStructure_t')
class(`YoYInflationTermStructureHandle_calendar`) = c("SWIGFunction", class('YoYInflationTermStructureHandle_calendar'))

# Start of YoYInflationTermStructureHandle_referenceDate

`YoYInflationTermStructureHandle_referenceDate` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_YoYInflationTermStructureHandle_referenceDate', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`YoYInflationTermStructureHandle_referenceDate`, 'returnType') = '_p_Date'
attr(`YoYInflationTermStructureHandle_referenceDate`, "inputTypes") = c('_p_HandleT_YoYInflationTermStructure_t')
class(`YoYInflationTermStructureHandle_referenceDate`) = c("SWIGFunction", class('YoYInflationTermStructureHandle_referenceDate'))

# Start of YoYInflationTermStructureHandle_maxDate

`YoYInflationTermStructureHandle_maxDate` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_YoYInflationTermStructureHandle_maxDate', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`YoYInflationTermStructureHandle_maxDate`, 'returnType') = '_p_Date'
attr(`YoYInflationTermStructureHandle_maxDate`, "inputTypes") = c('_p_HandleT_YoYInflationTermStructure_t')
class(`YoYInflationTermStructureHandle_maxDate`) = c("SWIGFunction", class('YoYInflationTermStructureHandle_maxDate'))

# Start of YoYInflationTermStructureHandle_maxTime

`YoYInflationTermStructureHandle_maxTime` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_YoYInflationTermStructureHandle_maxTime', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`YoYInflationTermStructureHandle_maxTime`, 'returnType') = 'numeric'
attr(`YoYInflationTermStructureHandle_maxTime`, "inputTypes") = c('_p_HandleT_YoYInflationTermStructure_t')
class(`YoYInflationTermStructureHandle_maxTime`) = c("SWIGFunction", class('YoYInflationTermStructureHandle_maxTime'))

# Start of YoYInflationTermStructureHandle_observationLag

`YoYInflationTermStructureHandle_observationLag` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_YoYInflationTermStructureHandle_observationLag', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Period";
  
  ans
  
}

attr(`YoYInflationTermStructureHandle_observationLag`, 'returnType') = '_p_Period'
attr(`YoYInflationTermStructureHandle_observationLag`, "inputTypes") = c('_p_HandleT_YoYInflationTermStructure_t')
class(`YoYInflationTermStructureHandle_observationLag`) = c("SWIGFunction", class('YoYInflationTermStructureHandle_observationLag'))

# Start of YoYInflationTermStructureHandle_frequency

`YoYInflationTermStructureHandle_frequency` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_YoYInflationTermStructureHandle_frequency', self, as.logical(.copy), PACKAGE='QuantLib');
  ans = enumFromInteger(ans, "_Frequency");
  
  ans
  
}

attr(`YoYInflationTermStructureHandle_frequency`, 'returnType') = 'character'
attr(`YoYInflationTermStructureHandle_frequency`, "inputTypes") = c('_p_HandleT_YoYInflationTermStructure_t')
class(`YoYInflationTermStructureHandle_frequency`) = c("SWIGFunction", class('YoYInflationTermStructureHandle_frequency'))

# Start of YoYInflationTermStructureHandle_indexIsInterpolated

`YoYInflationTermStructureHandle_indexIsInterpolated` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_YoYInflationTermStructureHandle_indexIsInterpolated', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`YoYInflationTermStructureHandle_indexIsInterpolated`, 'returnType') = 'logical'
attr(`YoYInflationTermStructureHandle_indexIsInterpolated`, "inputTypes") = c('_p_HandleT_YoYInflationTermStructure_t')
class(`YoYInflationTermStructureHandle_indexIsInterpolated`) = c("SWIGFunction", class('YoYInflationTermStructureHandle_indexIsInterpolated'))

# Start of YoYInflationTermStructureHandle_baseRate

`YoYInflationTermStructureHandle_baseRate` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_YoYInflationTermStructureHandle_baseRate', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`YoYInflationTermStructureHandle_baseRate`, 'returnType') = 'numeric'
attr(`YoYInflationTermStructureHandle_baseRate`, "inputTypes") = c('_p_HandleT_YoYInflationTermStructure_t')
class(`YoYInflationTermStructureHandle_baseRate`) = c("SWIGFunction", class('YoYInflationTermStructureHandle_baseRate'))

# Start of YoYInflationTermStructureHandle_nominalTermStructure

`YoYInflationTermStructureHandle_nominalTermStructure` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_YoYInflationTermStructureHandle_nominalTermStructure', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_HandleT_YieldTermStructure_t";
  
  ans
  
}

attr(`YoYInflationTermStructureHandle_nominalTermStructure`, 'returnType') = '_p_HandleT_YieldTermStructure_t'
attr(`YoYInflationTermStructureHandle_nominalTermStructure`, "inputTypes") = c('_p_HandleT_YoYInflationTermStructure_t')
class(`YoYInflationTermStructureHandle_nominalTermStructure`) = c("SWIGFunction", class('YoYInflationTermStructureHandle_nominalTermStructure'))

# Start of YoYInflationTermStructureHandle_baseDate

`YoYInflationTermStructureHandle_baseDate` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_YoYInflationTermStructureHandle_baseDate', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`YoYInflationTermStructureHandle_baseDate`, 'returnType') = '_p_Date'
attr(`YoYInflationTermStructureHandle_baseDate`, "inputTypes") = c('_p_HandleT_YoYInflationTermStructure_t')
class(`YoYInflationTermStructureHandle_baseDate`) = c("SWIGFunction", class('YoYInflationTermStructureHandle_baseDate'))

# Start of YoYInflationTermStructureHandle_setSeasonality

`YoYInflationTermStructureHandle_setSeasonality__SWIG_0` = function(self, seasonality)
{
  ;.Call('R_swig_YoYInflationTermStructureHandle_setSeasonality__SWIG_0', self, seasonality, PACKAGE='QuantLib');
  
}

attr(`YoYInflationTermStructureHandle_setSeasonality__SWIG_0`, 'returnType') = 'void'
attr(`YoYInflationTermStructureHandle_setSeasonality__SWIG_0`, "inputTypes") = c('_p_HandleT_YoYInflationTermStructure_t', '_p_boost__shared_ptrT_Seasonality_t')
class(`YoYInflationTermStructureHandle_setSeasonality__SWIG_0`) = c("SWIGFunction", class('YoYInflationTermStructureHandle_setSeasonality__SWIG_0'))

# Start of YoYInflationTermStructureHandle_setSeasonality

`YoYInflationTermStructureHandle_setSeasonality__SWIG_1` = function(self)
{
  ;.Call('R_swig_YoYInflationTermStructureHandle_setSeasonality__SWIG_1', self, PACKAGE='QuantLib');
  
}

attr(`YoYInflationTermStructureHandle_setSeasonality__SWIG_1`, 'returnType') = 'void'
attr(`YoYInflationTermStructureHandle_setSeasonality__SWIG_1`, "inputTypes") = c('_p_HandleT_YoYInflationTermStructure_t')
class(`YoYInflationTermStructureHandle_setSeasonality__SWIG_1`) = c("SWIGFunction", class('YoYInflationTermStructureHandle_setSeasonality__SWIG_1'))

`YoYInflationTermStructureHandle_setSeasonality` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_HandleT_YoYInflationTermStructure_t')) {
      f <- YoYInflationTermStructureHandle_setSeasonality__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_HandleT_YoYInflationTermStructure_t') && extends(argtypes[2], '_p_boost__shared_ptrT_Seasonality_t')) {
      f <- YoYInflationTermStructureHandle_setSeasonality__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for YoYInflationTermStructureHandle_setSeasonality with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of YoYInflationTermStructureHandle_seasonality

`YoYInflationTermStructureHandle_seasonality` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_YoYInflationTermStructureHandle_seasonality', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_Seasonality_t";
  
  ans
  
}

attr(`YoYInflationTermStructureHandle_seasonality`, 'returnType') = '_p_boost__shared_ptrT_Seasonality_t'
attr(`YoYInflationTermStructureHandle_seasonality`, "inputTypes") = c('_p_HandleT_YoYInflationTermStructure_t')
class(`YoYInflationTermStructureHandle_seasonality`) = c("SWIGFunction", class('YoYInflationTermStructureHandle_seasonality'))

# Start of YoYInflationTermStructureHandle_hasSeasonality

`YoYInflationTermStructureHandle_hasSeasonality` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_YoYInflationTermStructureHandle_hasSeasonality', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`YoYInflationTermStructureHandle_hasSeasonality`, 'returnType') = 'logical'
attr(`YoYInflationTermStructureHandle_hasSeasonality`, "inputTypes") = c('_p_HandleT_YoYInflationTermStructure_t')
class(`YoYInflationTermStructureHandle_hasSeasonality`) = c("SWIGFunction", class('YoYInflationTermStructureHandle_hasSeasonality'))

# Start of YoYInflationTermStructureHandle_enableExtrapolation

`YoYInflationTermStructureHandle_enableExtrapolation` = function(self)
{
  ;.Call('R_swig_YoYInflationTermStructureHandle_enableExtrapolation', self, PACKAGE='QuantLib');
  
}

attr(`YoYInflationTermStructureHandle_enableExtrapolation`, 'returnType') = 'void'
attr(`YoYInflationTermStructureHandle_enableExtrapolation`, "inputTypes") = c('_p_HandleT_YoYInflationTermStructure_t')
class(`YoYInflationTermStructureHandle_enableExtrapolation`) = c("SWIGFunction", class('YoYInflationTermStructureHandle_enableExtrapolation'))

# Start of YoYInflationTermStructureHandle_disableExtrapolation

`YoYInflationTermStructureHandle_disableExtrapolation` = function(self)
{
  ;.Call('R_swig_YoYInflationTermStructureHandle_disableExtrapolation', self, PACKAGE='QuantLib');
  
}

attr(`YoYInflationTermStructureHandle_disableExtrapolation`, 'returnType') = 'void'
attr(`YoYInflationTermStructureHandle_disableExtrapolation`, "inputTypes") = c('_p_HandleT_YoYInflationTermStructure_t')
class(`YoYInflationTermStructureHandle_disableExtrapolation`) = c("SWIGFunction", class('YoYInflationTermStructureHandle_disableExtrapolation'))

# Start of YoYInflationTermStructureHandle_allowsExtrapolation

`YoYInflationTermStructureHandle_allowsExtrapolation` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_YoYInflationTermStructureHandle_allowsExtrapolation', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`YoYInflationTermStructureHandle_allowsExtrapolation`, 'returnType') = 'logical'
attr(`YoYInflationTermStructureHandle_allowsExtrapolation`, "inputTypes") = c('_p_HandleT_YoYInflationTermStructure_t')
class(`YoYInflationTermStructureHandle_allowsExtrapolation`) = c("SWIGFunction", class('YoYInflationTermStructureHandle_allowsExtrapolation'))

# Start of accessor method for Handle<(YoYInflationTermStructure)>
setMethod('$', '_p_HandleT_YoYInflationTermStructure_t', function(x, name)

{
  accessorFuns = list('__deref__' = YoYInflationTermStructureHandle___deref__, 'empty' = YoYInflationTermStructureHandle_empty, 'asObservable' = YoYInflationTermStructureHandle_asObservable, 'yoyRate' = YoYInflationTermStructureHandle_yoyRate, 'dayCounter' = YoYInflationTermStructureHandle_dayCounter, 'calendar' = YoYInflationTermStructureHandle_calendar, 'referenceDate' = YoYInflationTermStructureHandle_referenceDate, 'maxDate' = YoYInflationTermStructureHandle_maxDate, 'maxTime' = YoYInflationTermStructureHandle_maxTime, 'observationLag' = YoYInflationTermStructureHandle_observationLag, 'frequency' = YoYInflationTermStructureHandle_frequency, 'indexIsInterpolated' = YoYInflationTermStructureHandle_indexIsInterpolated, 'baseRate' = YoYInflationTermStructureHandle_baseRate, 'nominalTermStructure' = YoYInflationTermStructureHandle_nominalTermStructure, 'baseDate' = YoYInflationTermStructureHandle_baseDate, 'setSeasonality' = YoYInflationTermStructureHandle_setSeasonality, 'seasonality' = YoYInflationTermStructureHandle_seasonality, 'hasSeasonality' = YoYInflationTermStructureHandle_hasSeasonality, 'enableExtrapolation' = YoYInflationTermStructureHandle_enableExtrapolation, 'disableExtrapolation' = YoYInflationTermStructureHandle_disableExtrapolation, 'allowsExtrapolation' = YoYInflationTermStructureHandle_allowsExtrapolation);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for Handle<(YoYInflationTermStructure)>
setMethod('delete', '_p_HandleT_YoYInflationTermStructure_t', function(obj) {delete_HandleT_YoYInflationTermStructure_t(obj)})
# Start of new_RelinkableYoYInflationTermStructureHandle

`RelinkableYoYInflationTermStructureHandle__SWIG_0` = function(s_arg1)
{
  ;ans = .Call('R_swig_new_RelinkableYoYInflationTermStructureHandle__SWIG_0', s_arg1, PACKAGE='QuantLib');
  class(ans) <- "_p_RelinkableHandleT_YoYInflationTermStructure_t";
  
  reg.finalizer(ans, delete_RelinkableYoYInflationTermStructureHandle)
  ans
  
}

attr(`RelinkableYoYInflationTermStructureHandle__SWIG_0`, 'returnType') = '_p_RelinkableHandleT_YoYInflationTermStructure_t'
attr(`RelinkableYoYInflationTermStructureHandle__SWIG_0`, "inputTypes") = c('_p_boost__shared_ptrT_YoYInflationTermStructure_t')
class(`RelinkableYoYInflationTermStructureHandle__SWIG_0`) = c("SWIGFunction", class('RelinkableYoYInflationTermStructureHandle__SWIG_0'))

# Start of new_RelinkableYoYInflationTermStructureHandle

`RelinkableYoYInflationTermStructureHandle__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_RelinkableYoYInflationTermStructureHandle__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_RelinkableHandleT_YoYInflationTermStructure_t";
  
  reg.finalizer(ans, delete_RelinkableYoYInflationTermStructureHandle)
  ans
  
}

attr(`RelinkableYoYInflationTermStructureHandle__SWIG_1`, 'returnType') = '_p_RelinkableHandleT_YoYInflationTermStructure_t'
class(`RelinkableYoYInflationTermStructureHandle__SWIG_1`) = c("SWIGFunction", class('RelinkableYoYInflationTermStructureHandle__SWIG_1'))

`RelinkableYoYInflationTermStructureHandle` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- RelinkableYoYInflationTermStructureHandle__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_YoYInflationTermStructure_t')) {
      f <- RelinkableYoYInflationTermStructureHandle__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for RelinkableYoYInflationTermStructureHandle with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of RelinkableYoYInflationTermStructureHandle_linkTo

`RelinkableYoYInflationTermStructureHandle_linkTo` = function(self, s_arg2)
{
  ;.Call('R_swig_RelinkableYoYInflationTermStructureHandle_linkTo', self, s_arg2, PACKAGE='QuantLib');
  
}

attr(`RelinkableYoYInflationTermStructureHandle_linkTo`, 'returnType') = 'void'
attr(`RelinkableYoYInflationTermStructureHandle_linkTo`, "inputTypes") = c('_p_RelinkableHandleT_YoYInflationTermStructure_t', '_p_boost__shared_ptrT_YoYInflationTermStructure_t')
class(`RelinkableYoYInflationTermStructureHandle_linkTo`) = c("SWIGFunction", class('RelinkableYoYInflationTermStructureHandle_linkTo'))

# Start of delete_RelinkableYoYInflationTermStructureHandle

`delete_RelinkableYoYInflationTermStructureHandle` = function(self)
{
  ;.Call('R_swig_delete_RelinkableYoYInflationTermStructureHandle', self, PACKAGE='QuantLib');
  
}

attr(`delete_RelinkableYoYInflationTermStructureHandle`, 'returnType') = 'void'
attr(`delete_RelinkableYoYInflationTermStructureHandle`, "inputTypes") = c('_p_RelinkableHandleT_YoYInflationTermStructure_t')
class(`delete_RelinkableYoYInflationTermStructureHandle`) = c("SWIGFunction", class('delete_RelinkableYoYInflationTermStructureHandle'))

# Start of accessor method for RelinkableHandle<(YoYInflationTermStructure)>
setMethod('$', '_p_RelinkableHandleT_YoYInflationTermStructure_t', function(x, name)

{
  accessorFuns = list('linkTo' = RelinkableYoYInflationTermStructureHandle_linkTo);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for RelinkableHandle<(YoYInflationTermStructure)>
setMethod('delete', '_p_RelinkableHandleT_YoYInflationTermStructure_t', function(obj) {delete_RelinkableHandleT_YoYInflationTermStructure_t(obj)})
# Start of ZeroInflationTermStructure___deref__

`ZeroInflationTermStructure___deref__` = function(self)
{
  ;ans = .Call('R_swig_ZeroInflationTermStructure___deref__', self, PACKAGE='QuantLib');
  class(ans) <- "_p_ZeroInflationTermStructure";
  
  ans
  
}

attr(`ZeroInflationTermStructure___deref__`, 'returnType') = '_p_ZeroInflationTermStructure'
attr(`ZeroInflationTermStructure___deref__`, "inputTypes") = c('_p_boost__shared_ptrT_ZeroInflationTermStructure_t')
class(`ZeroInflationTermStructure___deref__`) = c("SWIGFunction", class('ZeroInflationTermStructure___deref__'))

# Start of ZeroInflationTermStructure_isNull

`ZeroInflationTermStructure_isNull` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_ZeroInflationTermStructure_isNull', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`ZeroInflationTermStructure_isNull`, 'returnType') = 'logical'
attr(`ZeroInflationTermStructure_isNull`, "inputTypes") = c('_p_boost__shared_ptrT_ZeroInflationTermStructure_t')
class(`ZeroInflationTermStructure_isNull`) = c("SWIGFunction", class('ZeroInflationTermStructure_isNull'))

# Start of ZeroInflationTermStructure_asObservable

`ZeroInflationTermStructure_asObservable` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_ZeroInflationTermStructure_asObservable', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_Observable_t";
  
  ans
  
}

attr(`ZeroInflationTermStructure_asObservable`, 'returnType') = '_p_boost__shared_ptrT_Observable_t'
attr(`ZeroInflationTermStructure_asObservable`, "inputTypes") = c('_p_boost__shared_ptrT_ZeroInflationTermStructure_t')
class(`ZeroInflationTermStructure_asObservable`) = c("SWIGFunction", class('ZeroInflationTermStructure_asObservable'))

# Start of new_ZeroInflationTermStructure

`ZeroInflationTermStructure` = function()
{
  ;ans = .Call('R_swig_new_ZeroInflationTermStructure', PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_ZeroInflationTermStructure_t";
  
  reg.finalizer(ans, delete_ZeroInflationTermStructure)
  ans
  
}

attr(`ZeroInflationTermStructure`, 'returnType') = '_p_boost__shared_ptrT_ZeroInflationTermStructure_t'
class(`ZeroInflationTermStructure`) = c("SWIGFunction", class('ZeroInflationTermStructure'))

# Start of delete_ZeroInflationTermStructure

`delete_ZeroInflationTermStructure` = function(self)
{
  ;.Call('R_swig_delete_ZeroInflationTermStructure', self, PACKAGE='QuantLib');
  
}

attr(`delete_ZeroInflationTermStructure`, 'returnType') = 'void'
attr(`delete_ZeroInflationTermStructure`, "inputTypes") = c('_p_boost__shared_ptrT_ZeroInflationTermStructure_t')
class(`delete_ZeroInflationTermStructure`) = c("SWIGFunction", class('delete_ZeroInflationTermStructure'))

# Start of ZeroInflationTermStructure_zeroRate

`ZeroInflationTermStructure_zeroRate__SWIG_0` = function(self, d, instObsLag, forceLinearInterpolation, extrapolate, .copy = FALSE)
{
  forceLinearInterpolation = as.logical(forceLinearInterpolation);
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_ZeroInflationTermStructure_zeroRate__SWIG_0', self, d, instObsLag, forceLinearInterpolation, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`ZeroInflationTermStructure_zeroRate__SWIG_0`, 'returnType') = 'numeric'
attr(`ZeroInflationTermStructure_zeroRate__SWIG_0`, "inputTypes") = c('_p_boost__shared_ptrT_ZeroInflationTermStructure_t', '_p_Date', '_p_Period', 'logical', 'logical')
class(`ZeroInflationTermStructure_zeroRate__SWIG_0`) = c("SWIGFunction", class('ZeroInflationTermStructure_zeroRate__SWIG_0'))

# Start of ZeroInflationTermStructure_zeroRate

`ZeroInflationTermStructure_zeroRate__SWIG_1` = function(self, d, instObsLag, forceLinearInterpolation, .copy = FALSE)
{
  forceLinearInterpolation = as.logical(forceLinearInterpolation);
  ;.Call('R_swig_ZeroInflationTermStructure_zeroRate__SWIG_1', self, d, instObsLag, forceLinearInterpolation, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`ZeroInflationTermStructure_zeroRate__SWIG_1`, 'returnType') = 'numeric'
attr(`ZeroInflationTermStructure_zeroRate__SWIG_1`, "inputTypes") = c('_p_boost__shared_ptrT_ZeroInflationTermStructure_t', '_p_Date', '_p_Period', 'logical')
class(`ZeroInflationTermStructure_zeroRate__SWIG_1`) = c("SWIGFunction", class('ZeroInflationTermStructure_zeroRate__SWIG_1'))

# Start of ZeroInflationTermStructure_zeroRate

`ZeroInflationTermStructure_zeroRate__SWIG_2` = function(self, d, instObsLag, .copy = FALSE)
{
  ;.Call('R_swig_ZeroInflationTermStructure_zeroRate__SWIG_2', self, d, instObsLag, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`ZeroInflationTermStructure_zeroRate__SWIG_2`, 'returnType') = 'numeric'
attr(`ZeroInflationTermStructure_zeroRate__SWIG_2`, "inputTypes") = c('_p_boost__shared_ptrT_ZeroInflationTermStructure_t', '_p_Date', '_p_Period')
class(`ZeroInflationTermStructure_zeroRate__SWIG_2`) = c("SWIGFunction", class('ZeroInflationTermStructure_zeroRate__SWIG_2'))

# Start of ZeroInflationTermStructure_zeroRate

`ZeroInflationTermStructure_zeroRate__SWIG_3` = function(self, d, .copy = FALSE)
{
  ;.Call('R_swig_ZeroInflationTermStructure_zeroRate__SWIG_3', self, d, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`ZeroInflationTermStructure_zeroRate__SWIG_3`, 'returnType') = 'numeric'
attr(`ZeroInflationTermStructure_zeroRate__SWIG_3`, "inputTypes") = c('_p_boost__shared_ptrT_ZeroInflationTermStructure_t', '_p_Date')
class(`ZeroInflationTermStructure_zeroRate__SWIG_3`) = c("SWIGFunction", class('ZeroInflationTermStructure_zeroRate__SWIG_3'))

`ZeroInflationTermStructure_zeroRate` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 2) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_ZeroInflationTermStructure_t') && extends(argtypes[2], '_p_Date')) {
      f <- ZeroInflationTermStructure_zeroRate__SWIG_3; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_ZeroInflationTermStructure_t') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_Period')) {
      f <- ZeroInflationTermStructure_zeroRate__SWIG_2; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_ZeroInflationTermStructure_t') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_Period') && extends(argtypes[4], 'logical')) {
      f <- ZeroInflationTermStructure_zeroRate__SWIG_1; 
    }
  } else if (argc == 5) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_ZeroInflationTermStructure_t') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_Period') && extends(argtypes[4], 'logical') && extends(argtypes[5], 'logical')) {
      f <- ZeroInflationTermStructure_zeroRate__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for ZeroInflationTermStructure_zeroRate with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of ZeroInflationTermStructure_dayCounter

`ZeroInflationTermStructure_dayCounter` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_ZeroInflationTermStructure_dayCounter', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_DayCounter";
  
  ans
  
}

attr(`ZeroInflationTermStructure_dayCounter`, 'returnType') = '_p_DayCounter'
attr(`ZeroInflationTermStructure_dayCounter`, "inputTypes") = c('_p_boost__shared_ptrT_ZeroInflationTermStructure_t')
class(`ZeroInflationTermStructure_dayCounter`) = c("SWIGFunction", class('ZeroInflationTermStructure_dayCounter'))

# Start of ZeroInflationTermStructure_calendar

`ZeroInflationTermStructure_calendar` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_ZeroInflationTermStructure_calendar', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Calendar";
  
  ans
  
}

attr(`ZeroInflationTermStructure_calendar`, 'returnType') = '_p_Calendar'
attr(`ZeroInflationTermStructure_calendar`, "inputTypes") = c('_p_boost__shared_ptrT_ZeroInflationTermStructure_t')
class(`ZeroInflationTermStructure_calendar`) = c("SWIGFunction", class('ZeroInflationTermStructure_calendar'))

# Start of ZeroInflationTermStructure_referenceDate

`ZeroInflationTermStructure_referenceDate` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_ZeroInflationTermStructure_referenceDate', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`ZeroInflationTermStructure_referenceDate`, 'returnType') = '_p_Date'
attr(`ZeroInflationTermStructure_referenceDate`, "inputTypes") = c('_p_boost__shared_ptrT_ZeroInflationTermStructure_t')
class(`ZeroInflationTermStructure_referenceDate`) = c("SWIGFunction", class('ZeroInflationTermStructure_referenceDate'))

# Start of ZeroInflationTermStructure_maxDate

`ZeroInflationTermStructure_maxDate` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_ZeroInflationTermStructure_maxDate', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`ZeroInflationTermStructure_maxDate`, 'returnType') = '_p_Date'
attr(`ZeroInflationTermStructure_maxDate`, "inputTypes") = c('_p_boost__shared_ptrT_ZeroInflationTermStructure_t')
class(`ZeroInflationTermStructure_maxDate`) = c("SWIGFunction", class('ZeroInflationTermStructure_maxDate'))

# Start of ZeroInflationTermStructure_maxTime

`ZeroInflationTermStructure_maxTime` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_ZeroInflationTermStructure_maxTime', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`ZeroInflationTermStructure_maxTime`, 'returnType') = 'numeric'
attr(`ZeroInflationTermStructure_maxTime`, "inputTypes") = c('_p_boost__shared_ptrT_ZeroInflationTermStructure_t')
class(`ZeroInflationTermStructure_maxTime`) = c("SWIGFunction", class('ZeroInflationTermStructure_maxTime'))

# Start of ZeroInflationTermStructure_observationLag

`ZeroInflationTermStructure_observationLag` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_ZeroInflationTermStructure_observationLag', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Period";
  
  ans
  
}

attr(`ZeroInflationTermStructure_observationLag`, 'returnType') = '_p_Period'
attr(`ZeroInflationTermStructure_observationLag`, "inputTypes") = c('_p_boost__shared_ptrT_ZeroInflationTermStructure_t')
class(`ZeroInflationTermStructure_observationLag`) = c("SWIGFunction", class('ZeroInflationTermStructure_observationLag'))

# Start of ZeroInflationTermStructure_frequency

`ZeroInflationTermStructure_frequency` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_ZeroInflationTermStructure_frequency', self, as.logical(.copy), PACKAGE='QuantLib');
  ans = enumFromInteger(ans, "_Frequency");
  
  ans
  
}

attr(`ZeroInflationTermStructure_frequency`, 'returnType') = 'character'
attr(`ZeroInflationTermStructure_frequency`, "inputTypes") = c('_p_boost__shared_ptrT_ZeroInflationTermStructure_t')
class(`ZeroInflationTermStructure_frequency`) = c("SWIGFunction", class('ZeroInflationTermStructure_frequency'))

# Start of ZeroInflationTermStructure_indexIsInterpolated

`ZeroInflationTermStructure_indexIsInterpolated` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_ZeroInflationTermStructure_indexIsInterpolated', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`ZeroInflationTermStructure_indexIsInterpolated`, 'returnType') = 'logical'
attr(`ZeroInflationTermStructure_indexIsInterpolated`, "inputTypes") = c('_p_boost__shared_ptrT_ZeroInflationTermStructure_t')
class(`ZeroInflationTermStructure_indexIsInterpolated`) = c("SWIGFunction", class('ZeroInflationTermStructure_indexIsInterpolated'))

# Start of ZeroInflationTermStructure_baseRate

`ZeroInflationTermStructure_baseRate` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_ZeroInflationTermStructure_baseRate', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`ZeroInflationTermStructure_baseRate`, 'returnType') = 'numeric'
attr(`ZeroInflationTermStructure_baseRate`, "inputTypes") = c('_p_boost__shared_ptrT_ZeroInflationTermStructure_t')
class(`ZeroInflationTermStructure_baseRate`) = c("SWIGFunction", class('ZeroInflationTermStructure_baseRate'))

# Start of ZeroInflationTermStructure_nominalTermStructure

`ZeroInflationTermStructure_nominalTermStructure` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_ZeroInflationTermStructure_nominalTermStructure', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_HandleT_YieldTermStructure_t";
  
  ans
  
}

attr(`ZeroInflationTermStructure_nominalTermStructure`, 'returnType') = '_p_HandleT_YieldTermStructure_t'
attr(`ZeroInflationTermStructure_nominalTermStructure`, "inputTypes") = c('_p_boost__shared_ptrT_ZeroInflationTermStructure_t')
class(`ZeroInflationTermStructure_nominalTermStructure`) = c("SWIGFunction", class('ZeroInflationTermStructure_nominalTermStructure'))

# Start of ZeroInflationTermStructure_baseDate

`ZeroInflationTermStructure_baseDate` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_ZeroInflationTermStructure_baseDate', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`ZeroInflationTermStructure_baseDate`, 'returnType') = '_p_Date'
attr(`ZeroInflationTermStructure_baseDate`, "inputTypes") = c('_p_boost__shared_ptrT_ZeroInflationTermStructure_t')
class(`ZeroInflationTermStructure_baseDate`) = c("SWIGFunction", class('ZeroInflationTermStructure_baseDate'))

# Start of ZeroInflationTermStructure_setSeasonality

`ZeroInflationTermStructure_setSeasonality__SWIG_0` = function(self, seasonality)
{
  ;.Call('R_swig_ZeroInflationTermStructure_setSeasonality__SWIG_0', self, seasonality, PACKAGE='QuantLib');
  
}

attr(`ZeroInflationTermStructure_setSeasonality__SWIG_0`, 'returnType') = 'void'
attr(`ZeroInflationTermStructure_setSeasonality__SWIG_0`, "inputTypes") = c('_p_boost__shared_ptrT_ZeroInflationTermStructure_t', '_p_boost__shared_ptrT_Seasonality_t')
class(`ZeroInflationTermStructure_setSeasonality__SWIG_0`) = c("SWIGFunction", class('ZeroInflationTermStructure_setSeasonality__SWIG_0'))

# Start of ZeroInflationTermStructure_setSeasonality

`ZeroInflationTermStructure_setSeasonality__SWIG_1` = function(self)
{
  ;.Call('R_swig_ZeroInflationTermStructure_setSeasonality__SWIG_1', self, PACKAGE='QuantLib');
  
}

attr(`ZeroInflationTermStructure_setSeasonality__SWIG_1`, 'returnType') = 'void'
attr(`ZeroInflationTermStructure_setSeasonality__SWIG_1`, "inputTypes") = c('_p_boost__shared_ptrT_ZeroInflationTermStructure_t')
class(`ZeroInflationTermStructure_setSeasonality__SWIG_1`) = c("SWIGFunction", class('ZeroInflationTermStructure_setSeasonality__SWIG_1'))

`ZeroInflationTermStructure_setSeasonality` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_ZeroInflationTermStructure_t')) {
      f <- ZeroInflationTermStructure_setSeasonality__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_ZeroInflationTermStructure_t') && extends(argtypes[2], '_p_boost__shared_ptrT_Seasonality_t')) {
      f <- ZeroInflationTermStructure_setSeasonality__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for ZeroInflationTermStructure_setSeasonality with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of ZeroInflationTermStructure_seasonality

`ZeroInflationTermStructure_seasonality` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_ZeroInflationTermStructure_seasonality', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_Seasonality_t";
  
  ans
  
}

attr(`ZeroInflationTermStructure_seasonality`, 'returnType') = '_p_boost__shared_ptrT_Seasonality_t'
attr(`ZeroInflationTermStructure_seasonality`, "inputTypes") = c('_p_boost__shared_ptrT_ZeroInflationTermStructure_t')
class(`ZeroInflationTermStructure_seasonality`) = c("SWIGFunction", class('ZeroInflationTermStructure_seasonality'))

# Start of ZeroInflationTermStructure_hasSeasonality

`ZeroInflationTermStructure_hasSeasonality` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_ZeroInflationTermStructure_hasSeasonality', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`ZeroInflationTermStructure_hasSeasonality`, 'returnType') = 'logical'
attr(`ZeroInflationTermStructure_hasSeasonality`, "inputTypes") = c('_p_boost__shared_ptrT_ZeroInflationTermStructure_t')
class(`ZeroInflationTermStructure_hasSeasonality`) = c("SWIGFunction", class('ZeroInflationTermStructure_hasSeasonality'))

# Start of ZeroInflationTermStructure_enableExtrapolation

`ZeroInflationTermStructure_enableExtrapolation` = function(self)
{
  ;.Call('R_swig_ZeroInflationTermStructure_enableExtrapolation', self, PACKAGE='QuantLib');
  
}

attr(`ZeroInflationTermStructure_enableExtrapolation`, 'returnType') = 'void'
attr(`ZeroInflationTermStructure_enableExtrapolation`, "inputTypes") = c('_p_boost__shared_ptrT_ZeroInflationTermStructure_t')
class(`ZeroInflationTermStructure_enableExtrapolation`) = c("SWIGFunction", class('ZeroInflationTermStructure_enableExtrapolation'))

# Start of ZeroInflationTermStructure_disableExtrapolation

`ZeroInflationTermStructure_disableExtrapolation` = function(self)
{
  ;.Call('R_swig_ZeroInflationTermStructure_disableExtrapolation', self, PACKAGE='QuantLib');
  
}

attr(`ZeroInflationTermStructure_disableExtrapolation`, 'returnType') = 'void'
attr(`ZeroInflationTermStructure_disableExtrapolation`, "inputTypes") = c('_p_boost__shared_ptrT_ZeroInflationTermStructure_t')
class(`ZeroInflationTermStructure_disableExtrapolation`) = c("SWIGFunction", class('ZeroInflationTermStructure_disableExtrapolation'))

# Start of ZeroInflationTermStructure_allowsExtrapolation

`ZeroInflationTermStructure_allowsExtrapolation` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_ZeroInflationTermStructure_allowsExtrapolation', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`ZeroInflationTermStructure_allowsExtrapolation`, 'returnType') = 'logical'
attr(`ZeroInflationTermStructure_allowsExtrapolation`, "inputTypes") = c('_p_boost__shared_ptrT_ZeroInflationTermStructure_t')
class(`ZeroInflationTermStructure_allowsExtrapolation`) = c("SWIGFunction", class('ZeroInflationTermStructure_allowsExtrapolation'))

# Start of accessor method for boost::shared_ptr<(ZeroInflationTermStructure)>
setMethod('$', '_p_boost__shared_ptrT_ZeroInflationTermStructure_t', function(x, name)

{
  accessorFuns = list('__deref__' = ZeroInflationTermStructure___deref__, 'isNull' = ZeroInflationTermStructure_isNull, 'asObservable' = ZeroInflationTermStructure_asObservable, 'zeroRate' = ZeroInflationTermStructure_zeroRate, 'dayCounter' = ZeroInflationTermStructure_dayCounter, 'calendar' = ZeroInflationTermStructure_calendar, 'referenceDate' = ZeroInflationTermStructure_referenceDate, 'maxDate' = ZeroInflationTermStructure_maxDate, 'maxTime' = ZeroInflationTermStructure_maxTime, 'observationLag' = ZeroInflationTermStructure_observationLag, 'frequency' = ZeroInflationTermStructure_frequency, 'indexIsInterpolated' = ZeroInflationTermStructure_indexIsInterpolated, 'baseRate' = ZeroInflationTermStructure_baseRate, 'nominalTermStructure' = ZeroInflationTermStructure_nominalTermStructure, 'baseDate' = ZeroInflationTermStructure_baseDate, 'setSeasonality' = ZeroInflationTermStructure_setSeasonality, 'seasonality' = ZeroInflationTermStructure_seasonality, 'hasSeasonality' = ZeroInflationTermStructure_hasSeasonality, 'enableExtrapolation' = ZeroInflationTermStructure_enableExtrapolation, 'disableExtrapolation' = ZeroInflationTermStructure_disableExtrapolation, 'allowsExtrapolation' = ZeroInflationTermStructure_allowsExtrapolation);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for boost::shared_ptr<(ZeroInflationTermStructure)>
setMethod('delete', '_p_boost__shared_ptrT_ZeroInflationTermStructure_t', function(obj) {delete_boost__shared_ptrT_ZeroInflationTermStructure_t(obj)})
# Start of new_ZeroInflationTermStructureHandle

`ZeroInflationTermStructureHandle__SWIG_0` = function(s_arg1)
{
  ;ans = .Call('R_swig_new_ZeroInflationTermStructureHandle__SWIG_0', s_arg1, PACKAGE='QuantLib');
  class(ans) <- "_p_HandleT_ZeroInflationTermStructure_t";
  
  reg.finalizer(ans, delete_ZeroInflationTermStructureHandle)
  ans
  
}

attr(`ZeroInflationTermStructureHandle__SWIG_0`, 'returnType') = '_p_HandleT_ZeroInflationTermStructure_t'
attr(`ZeroInflationTermStructureHandle__SWIG_0`, "inputTypes") = c('_p_boost__shared_ptrT_ZeroInflationTermStructure_t')
class(`ZeroInflationTermStructureHandle__SWIG_0`) = c("SWIGFunction", class('ZeroInflationTermStructureHandle__SWIG_0'))

# Start of new_ZeroInflationTermStructureHandle

`ZeroInflationTermStructureHandle__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_ZeroInflationTermStructureHandle__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_HandleT_ZeroInflationTermStructure_t";
  
  reg.finalizer(ans, delete_ZeroInflationTermStructureHandle)
  ans
  
}

attr(`ZeroInflationTermStructureHandle__SWIG_1`, 'returnType') = '_p_HandleT_ZeroInflationTermStructure_t'
class(`ZeroInflationTermStructureHandle__SWIG_1`) = c("SWIGFunction", class('ZeroInflationTermStructureHandle__SWIG_1'))

`ZeroInflationTermStructureHandle` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- ZeroInflationTermStructureHandle__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_ZeroInflationTermStructure_t')) {
      f <- ZeroInflationTermStructureHandle__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for ZeroInflationTermStructureHandle with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of ZeroInflationTermStructureHandle___deref__

`ZeroInflationTermStructureHandle___deref__` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_ZeroInflationTermStructureHandle___deref__', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_ZeroInflationTermStructure_t";
  
  ans
  
}

attr(`ZeroInflationTermStructureHandle___deref__`, 'returnType') = '_p_boost__shared_ptrT_ZeroInflationTermStructure_t'
attr(`ZeroInflationTermStructureHandle___deref__`, "inputTypes") = c('_p_HandleT_ZeroInflationTermStructure_t')
class(`ZeroInflationTermStructureHandle___deref__`) = c("SWIGFunction", class('ZeroInflationTermStructureHandle___deref__'))

# Start of ZeroInflationTermStructureHandle_empty

`ZeroInflationTermStructureHandle_empty` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_ZeroInflationTermStructureHandle_empty', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`ZeroInflationTermStructureHandle_empty`, 'returnType') = 'logical'
attr(`ZeroInflationTermStructureHandle_empty`, "inputTypes") = c('_p_HandleT_ZeroInflationTermStructure_t')
class(`ZeroInflationTermStructureHandle_empty`) = c("SWIGFunction", class('ZeroInflationTermStructureHandle_empty'))

# Start of ZeroInflationTermStructureHandle_asObservable

`ZeroInflationTermStructureHandle_asObservable` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_ZeroInflationTermStructureHandle_asObservable', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_Observable_t";
  
  ans
  
}

attr(`ZeroInflationTermStructureHandle_asObservable`, 'returnType') = '_p_boost__shared_ptrT_Observable_t'
attr(`ZeroInflationTermStructureHandle_asObservable`, "inputTypes") = c('_p_HandleT_ZeroInflationTermStructure_t')
class(`ZeroInflationTermStructureHandle_asObservable`) = c("SWIGFunction", class('ZeroInflationTermStructureHandle_asObservable'))

# Start of delete_ZeroInflationTermStructureHandle

`delete_ZeroInflationTermStructureHandle` = function(self)
{
  ;.Call('R_swig_delete_ZeroInflationTermStructureHandle', self, PACKAGE='QuantLib');
  
}

attr(`delete_ZeroInflationTermStructureHandle`, 'returnType') = 'void'
attr(`delete_ZeroInflationTermStructureHandle`, "inputTypes") = c('_p_HandleT_ZeroInflationTermStructure_t')
class(`delete_ZeroInflationTermStructureHandle`) = c("SWIGFunction", class('delete_ZeroInflationTermStructureHandle'))

# Start of ZeroInflationTermStructureHandle_zeroRate

`ZeroInflationTermStructureHandle_zeroRate__SWIG_0` = function(self, d, instObsLag, forceLinearInterpolation, extrapolate, .copy = FALSE)
{
  forceLinearInterpolation = as.logical(forceLinearInterpolation);
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_ZeroInflationTermStructureHandle_zeroRate__SWIG_0', self, d, instObsLag, forceLinearInterpolation, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`ZeroInflationTermStructureHandle_zeroRate__SWIG_0`, 'returnType') = 'numeric'
attr(`ZeroInflationTermStructureHandle_zeroRate__SWIG_0`, "inputTypes") = c('_p_HandleT_ZeroInflationTermStructure_t', '_p_Date', '_p_Period', 'logical', 'logical')
class(`ZeroInflationTermStructureHandle_zeroRate__SWIG_0`) = c("SWIGFunction", class('ZeroInflationTermStructureHandle_zeroRate__SWIG_0'))

# Start of ZeroInflationTermStructureHandle_zeroRate

`ZeroInflationTermStructureHandle_zeroRate__SWIG_1` = function(self, d, instObsLag, forceLinearInterpolation, .copy = FALSE)
{
  forceLinearInterpolation = as.logical(forceLinearInterpolation);
  ;.Call('R_swig_ZeroInflationTermStructureHandle_zeroRate__SWIG_1', self, d, instObsLag, forceLinearInterpolation, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`ZeroInflationTermStructureHandle_zeroRate__SWIG_1`, 'returnType') = 'numeric'
attr(`ZeroInflationTermStructureHandle_zeroRate__SWIG_1`, "inputTypes") = c('_p_HandleT_ZeroInflationTermStructure_t', '_p_Date', '_p_Period', 'logical')
class(`ZeroInflationTermStructureHandle_zeroRate__SWIG_1`) = c("SWIGFunction", class('ZeroInflationTermStructureHandle_zeroRate__SWIG_1'))

# Start of ZeroInflationTermStructureHandle_zeroRate

`ZeroInflationTermStructureHandle_zeroRate__SWIG_2` = function(self, d, instObsLag, .copy = FALSE)
{
  ;.Call('R_swig_ZeroInflationTermStructureHandle_zeroRate__SWIG_2', self, d, instObsLag, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`ZeroInflationTermStructureHandle_zeroRate__SWIG_2`, 'returnType') = 'numeric'
attr(`ZeroInflationTermStructureHandle_zeroRate__SWIG_2`, "inputTypes") = c('_p_HandleT_ZeroInflationTermStructure_t', '_p_Date', '_p_Period')
class(`ZeroInflationTermStructureHandle_zeroRate__SWIG_2`) = c("SWIGFunction", class('ZeroInflationTermStructureHandle_zeroRate__SWIG_2'))

# Start of ZeroInflationTermStructureHandle_zeroRate

`ZeroInflationTermStructureHandle_zeroRate__SWIG_3` = function(self, d, .copy = FALSE)
{
  ;.Call('R_swig_ZeroInflationTermStructureHandle_zeroRate__SWIG_3', self, d, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`ZeroInflationTermStructureHandle_zeroRate__SWIG_3`, 'returnType') = 'numeric'
attr(`ZeroInflationTermStructureHandle_zeroRate__SWIG_3`, "inputTypes") = c('_p_HandleT_ZeroInflationTermStructure_t', '_p_Date')
class(`ZeroInflationTermStructureHandle_zeroRate__SWIG_3`) = c("SWIGFunction", class('ZeroInflationTermStructureHandle_zeroRate__SWIG_3'))

`ZeroInflationTermStructureHandle_zeroRate` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 2) {
    if (extends(argtypes[1], '_p_HandleT_ZeroInflationTermStructure_t') && extends(argtypes[2], '_p_Date')) {
      f <- ZeroInflationTermStructureHandle_zeroRate__SWIG_3; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_HandleT_ZeroInflationTermStructure_t') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_Period')) {
      f <- ZeroInflationTermStructureHandle_zeroRate__SWIG_2; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_HandleT_ZeroInflationTermStructure_t') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_Period') && extends(argtypes[4], 'logical')) {
      f <- ZeroInflationTermStructureHandle_zeroRate__SWIG_1; 
    }
  } else if (argc == 5) {
    if (extends(argtypes[1], '_p_HandleT_ZeroInflationTermStructure_t') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_Period') && extends(argtypes[4], 'logical') && extends(argtypes[5], 'logical')) {
      f <- ZeroInflationTermStructureHandle_zeroRate__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for ZeroInflationTermStructureHandle_zeroRate with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of ZeroInflationTermStructureHandle_dayCounter

`ZeroInflationTermStructureHandle_dayCounter` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_ZeroInflationTermStructureHandle_dayCounter', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_DayCounter";
  
  ans
  
}

attr(`ZeroInflationTermStructureHandle_dayCounter`, 'returnType') = '_p_DayCounter'
attr(`ZeroInflationTermStructureHandle_dayCounter`, "inputTypes") = c('_p_HandleT_ZeroInflationTermStructure_t')
class(`ZeroInflationTermStructureHandle_dayCounter`) = c("SWIGFunction", class('ZeroInflationTermStructureHandle_dayCounter'))

# Start of ZeroInflationTermStructureHandle_calendar

`ZeroInflationTermStructureHandle_calendar` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_ZeroInflationTermStructureHandle_calendar', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Calendar";
  
  ans
  
}

attr(`ZeroInflationTermStructureHandle_calendar`, 'returnType') = '_p_Calendar'
attr(`ZeroInflationTermStructureHandle_calendar`, "inputTypes") = c('_p_HandleT_ZeroInflationTermStructure_t')
class(`ZeroInflationTermStructureHandle_calendar`) = c("SWIGFunction", class('ZeroInflationTermStructureHandle_calendar'))

# Start of ZeroInflationTermStructureHandle_referenceDate

`ZeroInflationTermStructureHandle_referenceDate` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_ZeroInflationTermStructureHandle_referenceDate', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`ZeroInflationTermStructureHandle_referenceDate`, 'returnType') = '_p_Date'
attr(`ZeroInflationTermStructureHandle_referenceDate`, "inputTypes") = c('_p_HandleT_ZeroInflationTermStructure_t')
class(`ZeroInflationTermStructureHandle_referenceDate`) = c("SWIGFunction", class('ZeroInflationTermStructureHandle_referenceDate'))

# Start of ZeroInflationTermStructureHandle_maxDate

`ZeroInflationTermStructureHandle_maxDate` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_ZeroInflationTermStructureHandle_maxDate', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`ZeroInflationTermStructureHandle_maxDate`, 'returnType') = '_p_Date'
attr(`ZeroInflationTermStructureHandle_maxDate`, "inputTypes") = c('_p_HandleT_ZeroInflationTermStructure_t')
class(`ZeroInflationTermStructureHandle_maxDate`) = c("SWIGFunction", class('ZeroInflationTermStructureHandle_maxDate'))

# Start of ZeroInflationTermStructureHandle_maxTime

`ZeroInflationTermStructureHandle_maxTime` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_ZeroInflationTermStructureHandle_maxTime', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`ZeroInflationTermStructureHandle_maxTime`, 'returnType') = 'numeric'
attr(`ZeroInflationTermStructureHandle_maxTime`, "inputTypes") = c('_p_HandleT_ZeroInflationTermStructure_t')
class(`ZeroInflationTermStructureHandle_maxTime`) = c("SWIGFunction", class('ZeroInflationTermStructureHandle_maxTime'))

# Start of ZeroInflationTermStructureHandle_observationLag

`ZeroInflationTermStructureHandle_observationLag` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_ZeroInflationTermStructureHandle_observationLag', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Period";
  
  ans
  
}

attr(`ZeroInflationTermStructureHandle_observationLag`, 'returnType') = '_p_Period'
attr(`ZeroInflationTermStructureHandle_observationLag`, "inputTypes") = c('_p_HandleT_ZeroInflationTermStructure_t')
class(`ZeroInflationTermStructureHandle_observationLag`) = c("SWIGFunction", class('ZeroInflationTermStructureHandle_observationLag'))

# Start of ZeroInflationTermStructureHandle_frequency

`ZeroInflationTermStructureHandle_frequency` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_ZeroInflationTermStructureHandle_frequency', self, as.logical(.copy), PACKAGE='QuantLib');
  ans = enumFromInteger(ans, "_Frequency");
  
  ans
  
}

attr(`ZeroInflationTermStructureHandle_frequency`, 'returnType') = 'character'
attr(`ZeroInflationTermStructureHandle_frequency`, "inputTypes") = c('_p_HandleT_ZeroInflationTermStructure_t')
class(`ZeroInflationTermStructureHandle_frequency`) = c("SWIGFunction", class('ZeroInflationTermStructureHandle_frequency'))

# Start of ZeroInflationTermStructureHandle_indexIsInterpolated

`ZeroInflationTermStructureHandle_indexIsInterpolated` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_ZeroInflationTermStructureHandle_indexIsInterpolated', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`ZeroInflationTermStructureHandle_indexIsInterpolated`, 'returnType') = 'logical'
attr(`ZeroInflationTermStructureHandle_indexIsInterpolated`, "inputTypes") = c('_p_HandleT_ZeroInflationTermStructure_t')
class(`ZeroInflationTermStructureHandle_indexIsInterpolated`) = c("SWIGFunction", class('ZeroInflationTermStructureHandle_indexIsInterpolated'))

# Start of ZeroInflationTermStructureHandle_baseRate

`ZeroInflationTermStructureHandle_baseRate` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_ZeroInflationTermStructureHandle_baseRate', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`ZeroInflationTermStructureHandle_baseRate`, 'returnType') = 'numeric'
attr(`ZeroInflationTermStructureHandle_baseRate`, "inputTypes") = c('_p_HandleT_ZeroInflationTermStructure_t')
class(`ZeroInflationTermStructureHandle_baseRate`) = c("SWIGFunction", class('ZeroInflationTermStructureHandle_baseRate'))

# Start of ZeroInflationTermStructureHandle_nominalTermStructure

`ZeroInflationTermStructureHandle_nominalTermStructure` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_ZeroInflationTermStructureHandle_nominalTermStructure', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_HandleT_YieldTermStructure_t";
  
  ans
  
}

attr(`ZeroInflationTermStructureHandle_nominalTermStructure`, 'returnType') = '_p_HandleT_YieldTermStructure_t'
attr(`ZeroInflationTermStructureHandle_nominalTermStructure`, "inputTypes") = c('_p_HandleT_ZeroInflationTermStructure_t')
class(`ZeroInflationTermStructureHandle_nominalTermStructure`) = c("SWIGFunction", class('ZeroInflationTermStructureHandle_nominalTermStructure'))

# Start of ZeroInflationTermStructureHandle_baseDate

`ZeroInflationTermStructureHandle_baseDate` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_ZeroInflationTermStructureHandle_baseDate', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`ZeroInflationTermStructureHandle_baseDate`, 'returnType') = '_p_Date'
attr(`ZeroInflationTermStructureHandle_baseDate`, "inputTypes") = c('_p_HandleT_ZeroInflationTermStructure_t')
class(`ZeroInflationTermStructureHandle_baseDate`) = c("SWIGFunction", class('ZeroInflationTermStructureHandle_baseDate'))

# Start of ZeroInflationTermStructureHandle_setSeasonality

`ZeroInflationTermStructureHandle_setSeasonality__SWIG_0` = function(self, seasonality)
{
  ;.Call('R_swig_ZeroInflationTermStructureHandle_setSeasonality__SWIG_0', self, seasonality, PACKAGE='QuantLib');
  
}

attr(`ZeroInflationTermStructureHandle_setSeasonality__SWIG_0`, 'returnType') = 'void'
attr(`ZeroInflationTermStructureHandle_setSeasonality__SWIG_0`, "inputTypes") = c('_p_HandleT_ZeroInflationTermStructure_t', '_p_boost__shared_ptrT_Seasonality_t')
class(`ZeroInflationTermStructureHandle_setSeasonality__SWIG_0`) = c("SWIGFunction", class('ZeroInflationTermStructureHandle_setSeasonality__SWIG_0'))

# Start of ZeroInflationTermStructureHandle_setSeasonality

`ZeroInflationTermStructureHandle_setSeasonality__SWIG_1` = function(self)
{
  ;.Call('R_swig_ZeroInflationTermStructureHandle_setSeasonality__SWIG_1', self, PACKAGE='QuantLib');
  
}

attr(`ZeroInflationTermStructureHandle_setSeasonality__SWIG_1`, 'returnType') = 'void'
attr(`ZeroInflationTermStructureHandle_setSeasonality__SWIG_1`, "inputTypes") = c('_p_HandleT_ZeroInflationTermStructure_t')
class(`ZeroInflationTermStructureHandle_setSeasonality__SWIG_1`) = c("SWIGFunction", class('ZeroInflationTermStructureHandle_setSeasonality__SWIG_1'))

`ZeroInflationTermStructureHandle_setSeasonality` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_HandleT_ZeroInflationTermStructure_t')) {
      f <- ZeroInflationTermStructureHandle_setSeasonality__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_HandleT_ZeroInflationTermStructure_t') && extends(argtypes[2], '_p_boost__shared_ptrT_Seasonality_t')) {
      f <- ZeroInflationTermStructureHandle_setSeasonality__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for ZeroInflationTermStructureHandle_setSeasonality with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of ZeroInflationTermStructureHandle_seasonality

`ZeroInflationTermStructureHandle_seasonality` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_ZeroInflationTermStructureHandle_seasonality', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_Seasonality_t";
  
  ans
  
}

attr(`ZeroInflationTermStructureHandle_seasonality`, 'returnType') = '_p_boost__shared_ptrT_Seasonality_t'
attr(`ZeroInflationTermStructureHandle_seasonality`, "inputTypes") = c('_p_HandleT_ZeroInflationTermStructure_t')
class(`ZeroInflationTermStructureHandle_seasonality`) = c("SWIGFunction", class('ZeroInflationTermStructureHandle_seasonality'))

# Start of ZeroInflationTermStructureHandle_hasSeasonality

`ZeroInflationTermStructureHandle_hasSeasonality` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_ZeroInflationTermStructureHandle_hasSeasonality', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`ZeroInflationTermStructureHandle_hasSeasonality`, 'returnType') = 'logical'
attr(`ZeroInflationTermStructureHandle_hasSeasonality`, "inputTypes") = c('_p_HandleT_ZeroInflationTermStructure_t')
class(`ZeroInflationTermStructureHandle_hasSeasonality`) = c("SWIGFunction", class('ZeroInflationTermStructureHandle_hasSeasonality'))

# Start of ZeroInflationTermStructureHandle_enableExtrapolation

`ZeroInflationTermStructureHandle_enableExtrapolation` = function(self)
{
  ;.Call('R_swig_ZeroInflationTermStructureHandle_enableExtrapolation', self, PACKAGE='QuantLib');
  
}

attr(`ZeroInflationTermStructureHandle_enableExtrapolation`, 'returnType') = 'void'
attr(`ZeroInflationTermStructureHandle_enableExtrapolation`, "inputTypes") = c('_p_HandleT_ZeroInflationTermStructure_t')
class(`ZeroInflationTermStructureHandle_enableExtrapolation`) = c("SWIGFunction", class('ZeroInflationTermStructureHandle_enableExtrapolation'))

# Start of ZeroInflationTermStructureHandle_disableExtrapolation

`ZeroInflationTermStructureHandle_disableExtrapolation` = function(self)
{
  ;.Call('R_swig_ZeroInflationTermStructureHandle_disableExtrapolation', self, PACKAGE='QuantLib');
  
}

attr(`ZeroInflationTermStructureHandle_disableExtrapolation`, 'returnType') = 'void'
attr(`ZeroInflationTermStructureHandle_disableExtrapolation`, "inputTypes") = c('_p_HandleT_ZeroInflationTermStructure_t')
class(`ZeroInflationTermStructureHandle_disableExtrapolation`) = c("SWIGFunction", class('ZeroInflationTermStructureHandle_disableExtrapolation'))

# Start of ZeroInflationTermStructureHandle_allowsExtrapolation

`ZeroInflationTermStructureHandle_allowsExtrapolation` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_ZeroInflationTermStructureHandle_allowsExtrapolation', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`ZeroInflationTermStructureHandle_allowsExtrapolation`, 'returnType') = 'logical'
attr(`ZeroInflationTermStructureHandle_allowsExtrapolation`, "inputTypes") = c('_p_HandleT_ZeroInflationTermStructure_t')
class(`ZeroInflationTermStructureHandle_allowsExtrapolation`) = c("SWIGFunction", class('ZeroInflationTermStructureHandle_allowsExtrapolation'))

# Start of accessor method for Handle<(ZeroInflationTermStructure)>
setMethod('$', '_p_HandleT_ZeroInflationTermStructure_t', function(x, name)

{
  accessorFuns = list('__deref__' = ZeroInflationTermStructureHandle___deref__, 'empty' = ZeroInflationTermStructureHandle_empty, 'asObservable' = ZeroInflationTermStructureHandle_asObservable, 'zeroRate' = ZeroInflationTermStructureHandle_zeroRate, 'dayCounter' = ZeroInflationTermStructureHandle_dayCounter, 'calendar' = ZeroInflationTermStructureHandle_calendar, 'referenceDate' = ZeroInflationTermStructureHandle_referenceDate, 'maxDate' = ZeroInflationTermStructureHandle_maxDate, 'maxTime' = ZeroInflationTermStructureHandle_maxTime, 'observationLag' = ZeroInflationTermStructureHandle_observationLag, 'frequency' = ZeroInflationTermStructureHandle_frequency, 'indexIsInterpolated' = ZeroInflationTermStructureHandle_indexIsInterpolated, 'baseRate' = ZeroInflationTermStructureHandle_baseRate, 'nominalTermStructure' = ZeroInflationTermStructureHandle_nominalTermStructure, 'baseDate' = ZeroInflationTermStructureHandle_baseDate, 'setSeasonality' = ZeroInflationTermStructureHandle_setSeasonality, 'seasonality' = ZeroInflationTermStructureHandle_seasonality, 'hasSeasonality' = ZeroInflationTermStructureHandle_hasSeasonality, 'enableExtrapolation' = ZeroInflationTermStructureHandle_enableExtrapolation, 'disableExtrapolation' = ZeroInflationTermStructureHandle_disableExtrapolation, 'allowsExtrapolation' = ZeroInflationTermStructureHandle_allowsExtrapolation);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for Handle<(ZeroInflationTermStructure)>
setMethod('delete', '_p_HandleT_ZeroInflationTermStructure_t', function(obj) {delete_HandleT_ZeroInflationTermStructure_t(obj)})
# Start of new_RelinkableZeroInflationTermStructureHandle

`RelinkableZeroInflationTermStructureHandle__SWIG_0` = function(s_arg1)
{
  ;ans = .Call('R_swig_new_RelinkableZeroInflationTermStructureHandle__SWIG_0', s_arg1, PACKAGE='QuantLib');
  class(ans) <- "_p_RelinkableHandleT_ZeroInflationTermStructure_t";
  
  reg.finalizer(ans, delete_RelinkableZeroInflationTermStructureHandle)
  ans
  
}

attr(`RelinkableZeroInflationTermStructureHandle__SWIG_0`, 'returnType') = '_p_RelinkableHandleT_ZeroInflationTermStructure_t'
attr(`RelinkableZeroInflationTermStructureHandle__SWIG_0`, "inputTypes") = c('_p_boost__shared_ptrT_ZeroInflationTermStructure_t')
class(`RelinkableZeroInflationTermStructureHandle__SWIG_0`) = c("SWIGFunction", class('RelinkableZeroInflationTermStructureHandle__SWIG_0'))

# Start of new_RelinkableZeroInflationTermStructureHandle

`RelinkableZeroInflationTermStructureHandle__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_RelinkableZeroInflationTermStructureHandle__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_RelinkableHandleT_ZeroInflationTermStructure_t";
  
  reg.finalizer(ans, delete_RelinkableZeroInflationTermStructureHandle)
  ans
  
}

attr(`RelinkableZeroInflationTermStructureHandle__SWIG_1`, 'returnType') = '_p_RelinkableHandleT_ZeroInflationTermStructure_t'
class(`RelinkableZeroInflationTermStructureHandle__SWIG_1`) = c("SWIGFunction", class('RelinkableZeroInflationTermStructureHandle__SWIG_1'))

`RelinkableZeroInflationTermStructureHandle` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- RelinkableZeroInflationTermStructureHandle__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_ZeroInflationTermStructure_t')) {
      f <- RelinkableZeroInflationTermStructureHandle__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for RelinkableZeroInflationTermStructureHandle with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of RelinkableZeroInflationTermStructureHandle_linkTo

`RelinkableZeroInflationTermStructureHandle_linkTo` = function(self, s_arg2)
{
  ;.Call('R_swig_RelinkableZeroInflationTermStructureHandle_linkTo', self, s_arg2, PACKAGE='QuantLib');
  
}

attr(`RelinkableZeroInflationTermStructureHandle_linkTo`, 'returnType') = 'void'
attr(`RelinkableZeroInflationTermStructureHandle_linkTo`, "inputTypes") = c('_p_RelinkableHandleT_ZeroInflationTermStructure_t', '_p_boost__shared_ptrT_ZeroInflationTermStructure_t')
class(`RelinkableZeroInflationTermStructureHandle_linkTo`) = c("SWIGFunction", class('RelinkableZeroInflationTermStructureHandle_linkTo'))

# Start of delete_RelinkableZeroInflationTermStructureHandle

`delete_RelinkableZeroInflationTermStructureHandle` = function(self)
{
  ;.Call('R_swig_delete_RelinkableZeroInflationTermStructureHandle', self, PACKAGE='QuantLib');
  
}

attr(`delete_RelinkableZeroInflationTermStructureHandle`, 'returnType') = 'void'
attr(`delete_RelinkableZeroInflationTermStructureHandle`, "inputTypes") = c('_p_RelinkableHandleT_ZeroInflationTermStructure_t')
class(`delete_RelinkableZeroInflationTermStructureHandle`) = c("SWIGFunction", class('delete_RelinkableZeroInflationTermStructureHandle'))

# Start of accessor method for RelinkableHandle<(ZeroInflationTermStructure)>
setMethod('$', '_p_RelinkableHandleT_ZeroInflationTermStructure_t', function(x, name)

{
  accessorFuns = list('linkTo' = RelinkableZeroInflationTermStructureHandle_linkTo);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for RelinkableHandle<(ZeroInflationTermStructure)>
setMethod('delete', '_p_RelinkableHandleT_ZeroInflationTermStructure_t', function(obj) {delete_RelinkableHandleT_ZeroInflationTermStructure_t(obj)})
# Start of InflationIndex_interpolated

`InflationIndex_interpolated` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_InflationIndex_interpolated', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`InflationIndex_interpolated`, 'returnType') = 'logical'
attr(`InflationIndex_interpolated`, "inputTypes") = c('_p_InflationIndexPtr')
class(`InflationIndex_interpolated`) = c("SWIGFunction", class('InflationIndex_interpolated'))

# Start of InflationIndex_frequency

`InflationIndex_frequency` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_InflationIndex_frequency', self, as.logical(.copy), PACKAGE='QuantLib');
  ans = enumFromInteger(ans, "_Frequency");
  
  ans
  
}

attr(`InflationIndex_frequency`, 'returnType') = 'character'
attr(`InflationIndex_frequency`, "inputTypes") = c('_p_InflationIndexPtr')
class(`InflationIndex_frequency`) = c("SWIGFunction", class('InflationIndex_frequency'))

# Start of InflationIndex_availabilityLag

`InflationIndex_availabilityLag` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_InflationIndex_availabilityLag', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Period";
  
  ans
  
}

attr(`InflationIndex_availabilityLag`, 'returnType') = '_p_Period'
attr(`InflationIndex_availabilityLag`, "inputTypes") = c('_p_InflationIndexPtr')
class(`InflationIndex_availabilityLag`) = c("SWIGFunction", class('InflationIndex_availabilityLag'))

# Start of InflationIndex_currency

`InflationIndex_currency` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_InflationIndex_currency', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Currency";
  
  ans
  
}

attr(`InflationIndex_currency`, 'returnType') = '_p_Currency'
attr(`InflationIndex_currency`, "inputTypes") = c('_p_InflationIndexPtr')
class(`InflationIndex_currency`) = c("SWIGFunction", class('InflationIndex_currency'))

# Start of delete_InflationIndex

`delete_InflationIndex` = function(self)
{
  ;.Call('R_swig_delete_InflationIndex', self, PACKAGE='QuantLib');
  
}

attr(`delete_InflationIndex`, 'returnType') = 'void'
attr(`delete_InflationIndex`, "inputTypes") = c('_p_InflationIndexPtr')
class(`delete_InflationIndex`) = c("SWIGFunction", class('delete_InflationIndex'))

# Start of accessor method for InflationIndexPtr
setMethod('$', '_p_InflationIndexPtr', function(x, name)

{
  accessorFuns = list('interpolated' = InflationIndex_interpolated, 'frequency' = InflationIndex_frequency, 'availabilityLag' = InflationIndex_availabilityLag, 'currency' = InflationIndex_currency);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for InflationIndexPtr
setMethod('delete', '_p_InflationIndexPtr', function(obj) {delete_InflationIndexPtr(obj)})
# Start of delete_ZeroInflationIndex

`delete_ZeroInflationIndex` = function(self)
{
  ;.Call('R_swig_delete_ZeroInflationIndex', self, PACKAGE='QuantLib');
  
}

attr(`delete_ZeroInflationIndex`, 'returnType') = 'void'
attr(`delete_ZeroInflationIndex`, "inputTypes") = c('_p_ZeroInflationIndexPtr')
class(`delete_ZeroInflationIndex`) = c("SWIGFunction", class('delete_ZeroInflationIndex'))

setMethod('delete', '_p_ZeroInflationIndexPtr', function(obj) {delete_ZeroInflationIndexPtr(obj)})
# Start of delete_YoYInflationIndex

`delete_YoYInflationIndex` = function(self)
{
  ;.Call('R_swig_delete_YoYInflationIndex', self, PACKAGE='QuantLib');
  
}

attr(`delete_YoYInflationIndex`, 'returnType') = 'void'
attr(`delete_YoYInflationIndex`, "inputTypes") = c('_p_YoYInflationIndexPtr')
class(`delete_YoYInflationIndex`) = c("SWIGFunction", class('delete_YoYInflationIndex'))

setMethod('delete', '_p_YoYInflationIndexPtr', function(obj) {delete_YoYInflationIndexPtr(obj)})
# Start of new_EUHICP

`EUHICP__SWIG_0` = function(interpolated, h)
{
  interpolated = as.logical(interpolated);
  
  ;ans = .Call('R_swig_new_EUHICP__SWIG_0', interpolated, h, PACKAGE='QuantLib');
  class(ans) <- "_p_EUHICPPtr";
  
  reg.finalizer(ans, delete_EUHICP)
  ans
  
}

attr(`EUHICP__SWIG_0`, 'returnType') = '_p_EUHICPPtr'
attr(`EUHICP__SWIG_0`, "inputTypes") = c('logical', '_p_HandleT_ZeroInflationTermStructure_t')
class(`EUHICP__SWIG_0`) = c("SWIGFunction", class('EUHICP__SWIG_0'))

# Start of new_EUHICP

`EUHICP__SWIG_1` = function(interpolated)
{
  interpolated = as.logical(interpolated);
  ;ans = .Call('R_swig_new_EUHICP__SWIG_1', interpolated, PACKAGE='QuantLib');
  class(ans) <- "_p_EUHICPPtr";
  
  reg.finalizer(ans, delete_EUHICP)
  ans
  
}

attr(`EUHICP__SWIG_1`, 'returnType') = '_p_EUHICPPtr'
attr(`EUHICP__SWIG_1`, "inputTypes") = c('logical')
class(`EUHICP__SWIG_1`) = c("SWIGFunction", class('EUHICP__SWIG_1'))

`EUHICP` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], 'logical')) {
      f <- EUHICP__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], 'logical') && extends(argtypes[2], '_p_HandleT_ZeroInflationTermStructure_t')) {
      f <- EUHICP__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for EUHICP with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_EUHICP

`delete_EUHICP` = function(self)
{
  ;.Call('R_swig_delete_EUHICP', self, PACKAGE='QuantLib');
  
}

attr(`delete_EUHICP`, 'returnType') = 'void'
attr(`delete_EUHICP`, "inputTypes") = c('_p_EUHICPPtr')
class(`delete_EUHICP`) = c("SWIGFunction", class('delete_EUHICP'))

setMethod('delete', '_p_EUHICPPtr', function(obj) {delete_EUHICPPtr(obj)})
# Start of new_EUHICPXT

`EUHICPXT__SWIG_0` = function(interpolated, h)
{
  interpolated = as.logical(interpolated);
  
  ;ans = .Call('R_swig_new_EUHICPXT__SWIG_0', interpolated, h, PACKAGE='QuantLib');
  class(ans) <- "_p_EUHICPXTPtr";
  
  reg.finalizer(ans, delete_EUHICPXT)
  ans
  
}

attr(`EUHICPXT__SWIG_0`, 'returnType') = '_p_EUHICPXTPtr'
attr(`EUHICPXT__SWIG_0`, "inputTypes") = c('logical', '_p_HandleT_ZeroInflationTermStructure_t')
class(`EUHICPXT__SWIG_0`) = c("SWIGFunction", class('EUHICPXT__SWIG_0'))

# Start of new_EUHICPXT

`EUHICPXT__SWIG_1` = function(interpolated)
{
  interpolated = as.logical(interpolated);
  ;ans = .Call('R_swig_new_EUHICPXT__SWIG_1', interpolated, PACKAGE='QuantLib');
  class(ans) <- "_p_EUHICPXTPtr";
  
  reg.finalizer(ans, delete_EUHICPXT)
  ans
  
}

attr(`EUHICPXT__SWIG_1`, 'returnType') = '_p_EUHICPXTPtr'
attr(`EUHICPXT__SWIG_1`, "inputTypes") = c('logical')
class(`EUHICPXT__SWIG_1`) = c("SWIGFunction", class('EUHICPXT__SWIG_1'))

`EUHICPXT` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], 'logical')) {
      f <- EUHICPXT__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], 'logical') && extends(argtypes[2], '_p_HandleT_ZeroInflationTermStructure_t')) {
      f <- EUHICPXT__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for EUHICPXT with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_EUHICPXT

`delete_EUHICPXT` = function(self)
{
  ;.Call('R_swig_delete_EUHICPXT', self, PACKAGE='QuantLib');
  
}

attr(`delete_EUHICPXT`, 'returnType') = 'void'
attr(`delete_EUHICPXT`, "inputTypes") = c('_p_EUHICPXTPtr')
class(`delete_EUHICPXT`) = c("SWIGFunction", class('delete_EUHICPXT'))

setMethod('delete', '_p_EUHICPXTPtr', function(obj) {delete_EUHICPXTPtr(obj)})
# Start of new_FRHICP

`FRHICP__SWIG_0` = function(interpolated, h)
{
  interpolated = as.logical(interpolated);
  
  ;ans = .Call('R_swig_new_FRHICP__SWIG_0', interpolated, h, PACKAGE='QuantLib');
  class(ans) <- "_p_FRHICPPtr";
  
  reg.finalizer(ans, delete_FRHICP)
  ans
  
}

attr(`FRHICP__SWIG_0`, 'returnType') = '_p_FRHICPPtr'
attr(`FRHICP__SWIG_0`, "inputTypes") = c('logical', '_p_HandleT_ZeroInflationTermStructure_t')
class(`FRHICP__SWIG_0`) = c("SWIGFunction", class('FRHICP__SWIG_0'))

# Start of new_FRHICP

`FRHICP__SWIG_1` = function(interpolated)
{
  interpolated = as.logical(interpolated);
  ;ans = .Call('R_swig_new_FRHICP__SWIG_1', interpolated, PACKAGE='QuantLib');
  class(ans) <- "_p_FRHICPPtr";
  
  reg.finalizer(ans, delete_FRHICP)
  ans
  
}

attr(`FRHICP__SWIG_1`, 'returnType') = '_p_FRHICPPtr'
attr(`FRHICP__SWIG_1`, "inputTypes") = c('logical')
class(`FRHICP__SWIG_1`) = c("SWIGFunction", class('FRHICP__SWIG_1'))

`FRHICP` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], 'logical')) {
      f <- FRHICP__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], 'logical') && extends(argtypes[2], '_p_HandleT_ZeroInflationTermStructure_t')) {
      f <- FRHICP__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for FRHICP with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_FRHICP

`delete_FRHICP` = function(self)
{
  ;.Call('R_swig_delete_FRHICP', self, PACKAGE='QuantLib');
  
}

attr(`delete_FRHICP`, 'returnType') = 'void'
attr(`delete_FRHICP`, "inputTypes") = c('_p_FRHICPPtr')
class(`delete_FRHICP`) = c("SWIGFunction", class('delete_FRHICP'))

setMethod('delete', '_p_FRHICPPtr', function(obj) {delete_FRHICPPtr(obj)})
# Start of new_UKRPI

`UKRPI__SWIG_0` = function(interpolated, h)
{
  interpolated = as.logical(interpolated);
  
  ;ans = .Call('R_swig_new_UKRPI__SWIG_0', interpolated, h, PACKAGE='QuantLib');
  class(ans) <- "_p_UKRPIPtr";
  
  reg.finalizer(ans, delete_UKRPI)
  ans
  
}

attr(`UKRPI__SWIG_0`, 'returnType') = '_p_UKRPIPtr'
attr(`UKRPI__SWIG_0`, "inputTypes") = c('logical', '_p_HandleT_ZeroInflationTermStructure_t')
class(`UKRPI__SWIG_0`) = c("SWIGFunction", class('UKRPI__SWIG_0'))

# Start of new_UKRPI

`UKRPI__SWIG_1` = function(interpolated)
{
  interpolated = as.logical(interpolated);
  ;ans = .Call('R_swig_new_UKRPI__SWIG_1', interpolated, PACKAGE='QuantLib');
  class(ans) <- "_p_UKRPIPtr";
  
  reg.finalizer(ans, delete_UKRPI)
  ans
  
}

attr(`UKRPI__SWIG_1`, 'returnType') = '_p_UKRPIPtr'
attr(`UKRPI__SWIG_1`, "inputTypes") = c('logical')
class(`UKRPI__SWIG_1`) = c("SWIGFunction", class('UKRPI__SWIG_1'))

`UKRPI` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], 'logical')) {
      f <- UKRPI__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], 'logical') && extends(argtypes[2], '_p_HandleT_ZeroInflationTermStructure_t')) {
      f <- UKRPI__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for UKRPI with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_UKRPI

`delete_UKRPI` = function(self)
{
  ;.Call('R_swig_delete_UKRPI', self, PACKAGE='QuantLib');
  
}

attr(`delete_UKRPI`, 'returnType') = 'void'
attr(`delete_UKRPI`, "inputTypes") = c('_p_UKRPIPtr')
class(`delete_UKRPI`) = c("SWIGFunction", class('delete_UKRPI'))

setMethod('delete', '_p_UKRPIPtr', function(obj) {delete_UKRPIPtr(obj)})
# Start of new_USCPI

`USCPI__SWIG_0` = function(interpolated, h)
{
  interpolated = as.logical(interpolated);
  
  ;ans = .Call('R_swig_new_USCPI__SWIG_0', interpolated, h, PACKAGE='QuantLib');
  class(ans) <- "_p_USCPIPtr";
  
  reg.finalizer(ans, delete_USCPI)
  ans
  
}

attr(`USCPI__SWIG_0`, 'returnType') = '_p_USCPIPtr'
attr(`USCPI__SWIG_0`, "inputTypes") = c('logical', '_p_HandleT_ZeroInflationTermStructure_t')
class(`USCPI__SWIG_0`) = c("SWIGFunction", class('USCPI__SWIG_0'))

# Start of new_USCPI

`USCPI__SWIG_1` = function(interpolated)
{
  interpolated = as.logical(interpolated);
  ;ans = .Call('R_swig_new_USCPI__SWIG_1', interpolated, PACKAGE='QuantLib');
  class(ans) <- "_p_USCPIPtr";
  
  reg.finalizer(ans, delete_USCPI)
  ans
  
}

attr(`USCPI__SWIG_1`, 'returnType') = '_p_USCPIPtr'
attr(`USCPI__SWIG_1`, "inputTypes") = c('logical')
class(`USCPI__SWIG_1`) = c("SWIGFunction", class('USCPI__SWIG_1'))

`USCPI` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], 'logical')) {
      f <- USCPI__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], 'logical') && extends(argtypes[2], '_p_HandleT_ZeroInflationTermStructure_t')) {
      f <- USCPI__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for USCPI with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_USCPI

`delete_USCPI` = function(self)
{
  ;.Call('R_swig_delete_USCPI', self, PACKAGE='QuantLib');
  
}

attr(`delete_USCPI`, 'returnType') = 'void'
attr(`delete_USCPI`, "inputTypes") = c('_p_USCPIPtr')
class(`delete_USCPI`) = c("SWIGFunction", class('delete_USCPI'))

setMethod('delete', '_p_USCPIPtr', function(obj) {delete_USCPIPtr(obj)})
# Start of new_YYEUHICP

`YYEUHICP__SWIG_0` = function(interpolated, h)
{
  interpolated = as.logical(interpolated);
  
  ;ans = .Call('R_swig_new_YYEUHICP__SWIG_0', interpolated, h, PACKAGE='QuantLib');
  class(ans) <- "_p_YYEUHICPPtr";
  
  reg.finalizer(ans, delete_YYEUHICP)
  ans
  
}

attr(`YYEUHICP__SWIG_0`, 'returnType') = '_p_YYEUHICPPtr'
attr(`YYEUHICP__SWIG_0`, "inputTypes") = c('logical', '_p_HandleT_YoYInflationTermStructure_t')
class(`YYEUHICP__SWIG_0`) = c("SWIGFunction", class('YYEUHICP__SWIG_0'))

# Start of new_YYEUHICP

`YYEUHICP__SWIG_1` = function(interpolated)
{
  interpolated = as.logical(interpolated);
  ;ans = .Call('R_swig_new_YYEUHICP__SWIG_1', interpolated, PACKAGE='QuantLib');
  class(ans) <- "_p_YYEUHICPPtr";
  
  reg.finalizer(ans, delete_YYEUHICP)
  ans
  
}

attr(`YYEUHICP__SWIG_1`, 'returnType') = '_p_YYEUHICPPtr'
attr(`YYEUHICP__SWIG_1`, "inputTypes") = c('logical')
class(`YYEUHICP__SWIG_1`) = c("SWIGFunction", class('YYEUHICP__SWIG_1'))

`YYEUHICP` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], 'logical')) {
      f <- YYEUHICP__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], 'logical') && extends(argtypes[2], '_p_HandleT_YoYInflationTermStructure_t')) {
      f <- YYEUHICP__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for YYEUHICP with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_YYEUHICP

`delete_YYEUHICP` = function(self)
{
  ;.Call('R_swig_delete_YYEUHICP', self, PACKAGE='QuantLib');
  
}

attr(`delete_YYEUHICP`, 'returnType') = 'void'
attr(`delete_YYEUHICP`, "inputTypes") = c('_p_YYEUHICPPtr')
class(`delete_YYEUHICP`) = c("SWIGFunction", class('delete_YYEUHICP'))

setMethod('delete', '_p_YYEUHICPPtr', function(obj) {delete_YYEUHICPPtr(obj)})
# Start of new_YYEUHICPXT

`YYEUHICPXT__SWIG_0` = function(interpolated, h)
{
  interpolated = as.logical(interpolated);
  
  ;ans = .Call('R_swig_new_YYEUHICPXT__SWIG_0', interpolated, h, PACKAGE='QuantLib');
  class(ans) <- "_p_YYEUHICPXTPtr";
  
  reg.finalizer(ans, delete_YYEUHICPXT)
  ans
  
}

attr(`YYEUHICPXT__SWIG_0`, 'returnType') = '_p_YYEUHICPXTPtr'
attr(`YYEUHICPXT__SWIG_0`, "inputTypes") = c('logical', '_p_HandleT_YoYInflationTermStructure_t')
class(`YYEUHICPXT__SWIG_0`) = c("SWIGFunction", class('YYEUHICPXT__SWIG_0'))

# Start of new_YYEUHICPXT

`YYEUHICPXT__SWIG_1` = function(interpolated)
{
  interpolated = as.logical(interpolated);
  ;ans = .Call('R_swig_new_YYEUHICPXT__SWIG_1', interpolated, PACKAGE='QuantLib');
  class(ans) <- "_p_YYEUHICPXTPtr";
  
  reg.finalizer(ans, delete_YYEUHICPXT)
  ans
  
}

attr(`YYEUHICPXT__SWIG_1`, 'returnType') = '_p_YYEUHICPXTPtr'
attr(`YYEUHICPXT__SWIG_1`, "inputTypes") = c('logical')
class(`YYEUHICPXT__SWIG_1`) = c("SWIGFunction", class('YYEUHICPXT__SWIG_1'))

`YYEUHICPXT` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], 'logical')) {
      f <- YYEUHICPXT__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], 'logical') && extends(argtypes[2], '_p_HandleT_YoYInflationTermStructure_t')) {
      f <- YYEUHICPXT__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for YYEUHICPXT with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_YYEUHICPXT

`delete_YYEUHICPXT` = function(self)
{
  ;.Call('R_swig_delete_YYEUHICPXT', self, PACKAGE='QuantLib');
  
}

attr(`delete_YYEUHICPXT`, 'returnType') = 'void'
attr(`delete_YYEUHICPXT`, "inputTypes") = c('_p_YYEUHICPXTPtr')
class(`delete_YYEUHICPXT`) = c("SWIGFunction", class('delete_YYEUHICPXT'))

setMethod('delete', '_p_YYEUHICPXTPtr', function(obj) {delete_YYEUHICPXTPtr(obj)})
# Start of new_YYFRHICP

`YYFRHICP__SWIG_0` = function(interpolated, h)
{
  interpolated = as.logical(interpolated);
  
  ;ans = .Call('R_swig_new_YYFRHICP__SWIG_0', interpolated, h, PACKAGE='QuantLib');
  class(ans) <- "_p_YYFRHICPPtr";
  
  reg.finalizer(ans, delete_YYFRHICP)
  ans
  
}

attr(`YYFRHICP__SWIG_0`, 'returnType') = '_p_YYFRHICPPtr'
attr(`YYFRHICP__SWIG_0`, "inputTypes") = c('logical', '_p_HandleT_YoYInflationTermStructure_t')
class(`YYFRHICP__SWIG_0`) = c("SWIGFunction", class('YYFRHICP__SWIG_0'))

# Start of new_YYFRHICP

`YYFRHICP__SWIG_1` = function(interpolated)
{
  interpolated = as.logical(interpolated);
  ;ans = .Call('R_swig_new_YYFRHICP__SWIG_1', interpolated, PACKAGE='QuantLib');
  class(ans) <- "_p_YYFRHICPPtr";
  
  reg.finalizer(ans, delete_YYFRHICP)
  ans
  
}

attr(`YYFRHICP__SWIG_1`, 'returnType') = '_p_YYFRHICPPtr'
attr(`YYFRHICP__SWIG_1`, "inputTypes") = c('logical')
class(`YYFRHICP__SWIG_1`) = c("SWIGFunction", class('YYFRHICP__SWIG_1'))

`YYFRHICP` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], 'logical')) {
      f <- YYFRHICP__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], 'logical') && extends(argtypes[2], '_p_HandleT_YoYInflationTermStructure_t')) {
      f <- YYFRHICP__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for YYFRHICP with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_YYFRHICP

`delete_YYFRHICP` = function(self)
{
  ;.Call('R_swig_delete_YYFRHICP', self, PACKAGE='QuantLib');
  
}

attr(`delete_YYFRHICP`, 'returnType') = 'void'
attr(`delete_YYFRHICP`, "inputTypes") = c('_p_YYFRHICPPtr')
class(`delete_YYFRHICP`) = c("SWIGFunction", class('delete_YYFRHICP'))

setMethod('delete', '_p_YYFRHICPPtr', function(obj) {delete_YYFRHICPPtr(obj)})
# Start of new_YYUKRPI

`YYUKRPI__SWIG_0` = function(interpolated, h)
{
  interpolated = as.logical(interpolated);
  
  ;ans = .Call('R_swig_new_YYUKRPI__SWIG_0', interpolated, h, PACKAGE='QuantLib');
  class(ans) <- "_p_YYUKRPIPtr";
  
  reg.finalizer(ans, delete_YYUKRPI)
  ans
  
}

attr(`YYUKRPI__SWIG_0`, 'returnType') = '_p_YYUKRPIPtr'
attr(`YYUKRPI__SWIG_0`, "inputTypes") = c('logical', '_p_HandleT_YoYInflationTermStructure_t')
class(`YYUKRPI__SWIG_0`) = c("SWIGFunction", class('YYUKRPI__SWIG_0'))

# Start of new_YYUKRPI

`YYUKRPI__SWIG_1` = function(interpolated)
{
  interpolated = as.logical(interpolated);
  ;ans = .Call('R_swig_new_YYUKRPI__SWIG_1', interpolated, PACKAGE='QuantLib');
  class(ans) <- "_p_YYUKRPIPtr";
  
  reg.finalizer(ans, delete_YYUKRPI)
  ans
  
}

attr(`YYUKRPI__SWIG_1`, 'returnType') = '_p_YYUKRPIPtr'
attr(`YYUKRPI__SWIG_1`, "inputTypes") = c('logical')
class(`YYUKRPI__SWIG_1`) = c("SWIGFunction", class('YYUKRPI__SWIG_1'))

`YYUKRPI` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], 'logical')) {
      f <- YYUKRPI__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], 'logical') && extends(argtypes[2], '_p_HandleT_YoYInflationTermStructure_t')) {
      f <- YYUKRPI__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for YYUKRPI with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_YYUKRPI

`delete_YYUKRPI` = function(self)
{
  ;.Call('R_swig_delete_YYUKRPI', self, PACKAGE='QuantLib');
  
}

attr(`delete_YYUKRPI`, 'returnType') = 'void'
attr(`delete_YYUKRPI`, "inputTypes") = c('_p_YYUKRPIPtr')
class(`delete_YYUKRPI`) = c("SWIGFunction", class('delete_YYUKRPI'))

setMethod('delete', '_p_YYUKRPIPtr', function(obj) {delete_YYUKRPIPtr(obj)})
# Start of new_YYUSCPI

`YYUSCPI__SWIG_0` = function(interpolated, h)
{
  interpolated = as.logical(interpolated);
  
  ;ans = .Call('R_swig_new_YYUSCPI__SWIG_0', interpolated, h, PACKAGE='QuantLib');
  class(ans) <- "_p_YYUSCPIPtr";
  
  reg.finalizer(ans, delete_YYUSCPI)
  ans
  
}

attr(`YYUSCPI__SWIG_0`, 'returnType') = '_p_YYUSCPIPtr'
attr(`YYUSCPI__SWIG_0`, "inputTypes") = c('logical', '_p_HandleT_YoYInflationTermStructure_t')
class(`YYUSCPI__SWIG_0`) = c("SWIGFunction", class('YYUSCPI__SWIG_0'))

# Start of new_YYUSCPI

`YYUSCPI__SWIG_1` = function(interpolated)
{
  interpolated = as.logical(interpolated);
  ;ans = .Call('R_swig_new_YYUSCPI__SWIG_1', interpolated, PACKAGE='QuantLib');
  class(ans) <- "_p_YYUSCPIPtr";
  
  reg.finalizer(ans, delete_YYUSCPI)
  ans
  
}

attr(`YYUSCPI__SWIG_1`, 'returnType') = '_p_YYUSCPIPtr'
attr(`YYUSCPI__SWIG_1`, "inputTypes") = c('logical')
class(`YYUSCPI__SWIG_1`) = c("SWIGFunction", class('YYUSCPI__SWIG_1'))

`YYUSCPI` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], 'logical')) {
      f <- YYUSCPI__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], 'logical') && extends(argtypes[2], '_p_HandleT_YoYInflationTermStructure_t')) {
      f <- YYUSCPI__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for YYUSCPI with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_YYUSCPI

`delete_YYUSCPI` = function(self)
{
  ;.Call('R_swig_delete_YYUSCPI', self, PACKAGE='QuantLib');
  
}

attr(`delete_YYUSCPI`, 'returnType') = 'void'
attr(`delete_YYUSCPI`, "inputTypes") = c('_p_YYUSCPIPtr')
class(`delete_YYUSCPI`) = c("SWIGFunction", class('delete_YYUSCPI'))

setMethod('delete', '_p_YYUSCPIPtr', function(obj) {delete_YYUSCPIPtr(obj)})
# Start of ZeroHelper___deref__

`ZeroHelper___deref__` = function(self)
{
  ;ans = .Call('R_swig_ZeroHelper___deref__', self, PACKAGE='QuantLib');
  class(ans) <- "_p_ZeroHelper";
  
  ans
  
}

attr(`ZeroHelper___deref__`, 'returnType') = '_p_ZeroHelper'
attr(`ZeroHelper___deref__`, "inputTypes") = c('_p_boost__shared_ptrT_ZeroHelper_t')
class(`ZeroHelper___deref__`) = c("SWIGFunction", class('ZeroHelper___deref__'))

# Start of ZeroHelper_isNull

`ZeroHelper_isNull` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_ZeroHelper_isNull', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`ZeroHelper_isNull`, 'returnType') = 'logical'
attr(`ZeroHelper_isNull`, "inputTypes") = c('_p_boost__shared_ptrT_ZeroHelper_t')
class(`ZeroHelper_isNull`) = c("SWIGFunction", class('ZeroHelper_isNull'))

# Start of new_ZeroHelper

`ZeroHelper` = function()
{
  ;ans = .Call('R_swig_new_ZeroHelper', PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_ZeroHelper_t";
  
  reg.finalizer(ans, delete_ZeroHelper)
  ans
  
}

attr(`ZeroHelper`, 'returnType') = '_p_boost__shared_ptrT_ZeroHelper_t'
class(`ZeroHelper`) = c("SWIGFunction", class('ZeroHelper'))

# Start of delete_ZeroHelper

`delete_ZeroHelper` = function(self)
{
  ;.Call('R_swig_delete_ZeroHelper', self, PACKAGE='QuantLib');
  
}

attr(`delete_ZeroHelper`, 'returnType') = 'void'
attr(`delete_ZeroHelper`, "inputTypes") = c('_p_boost__shared_ptrT_ZeroHelper_t')
class(`delete_ZeroHelper`) = c("SWIGFunction", class('delete_ZeroHelper'))

# Start of accessor method for boost::shared_ptr<(ZeroHelper)>
setMethod('$', '_p_boost__shared_ptrT_ZeroHelper_t', function(x, name)

{
  accessorFuns = list('__deref__' = ZeroHelper___deref__, 'isNull' = ZeroHelper_isNull);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for boost::shared_ptr<(ZeroHelper)>
setMethod('delete', '_p_boost__shared_ptrT_ZeroHelper_t', function(obj) {delete_boost__shared_ptrT_ZeroHelper_t(obj)})
# Start of YoYHelper___deref__

`YoYHelper___deref__` = function(self)
{
  ;ans = .Call('R_swig_YoYHelper___deref__', self, PACKAGE='QuantLib');
  class(ans) <- "_p_YoYHelper";
  
  ans
  
}

attr(`YoYHelper___deref__`, 'returnType') = '_p_YoYHelper'
attr(`YoYHelper___deref__`, "inputTypes") = c('_p_boost__shared_ptrT_YoYHelper_t')
class(`YoYHelper___deref__`) = c("SWIGFunction", class('YoYHelper___deref__'))

# Start of YoYHelper_isNull

`YoYHelper_isNull` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_YoYHelper_isNull', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`YoYHelper_isNull`, 'returnType') = 'logical'
attr(`YoYHelper_isNull`, "inputTypes") = c('_p_boost__shared_ptrT_YoYHelper_t')
class(`YoYHelper_isNull`) = c("SWIGFunction", class('YoYHelper_isNull'))

# Start of new_YoYHelper

`YoYHelper` = function()
{
  ;ans = .Call('R_swig_new_YoYHelper', PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_YoYHelper_t";
  
  reg.finalizer(ans, delete_YoYHelper)
  ans
  
}

attr(`YoYHelper`, 'returnType') = '_p_boost__shared_ptrT_YoYHelper_t'
class(`YoYHelper`) = c("SWIGFunction", class('YoYHelper'))

# Start of delete_YoYHelper

`delete_YoYHelper` = function(self)
{
  ;.Call('R_swig_delete_YoYHelper', self, PACKAGE='QuantLib');
  
}

attr(`delete_YoYHelper`, 'returnType') = 'void'
attr(`delete_YoYHelper`, "inputTypes") = c('_p_boost__shared_ptrT_YoYHelper_t')
class(`delete_YoYHelper`) = c("SWIGFunction", class('delete_YoYHelper'))

# Start of accessor method for boost::shared_ptr<(YoYHelper)>
setMethod('$', '_p_boost__shared_ptrT_YoYHelper_t', function(x, name)

{
  accessorFuns = list('__deref__' = YoYHelper___deref__, 'isNull' = YoYHelper_isNull);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for boost::shared_ptr<(YoYHelper)>
setMethod('delete', '_p_boost__shared_ptrT_YoYHelper_t', function(obj) {delete_boost__shared_ptrT_YoYHelper_t(obj)})
# Start of ZeroHelperVector___nonzero__

`ZeroHelperVector___nonzero__` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_ZeroHelperVector___nonzero__', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`ZeroHelperVector___nonzero__`, 'returnType') = 'logical'
attr(`ZeroHelperVector___nonzero__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_ZeroHelper_t_std__allocatorT_boost__shared_ptrT_ZeroHelper_t_t_t')
class(`ZeroHelperVector___nonzero__`) = c("SWIGFunction", class('ZeroHelperVector___nonzero__'))

# Start of ZeroHelperVector___len__

`ZeroHelperVector___len__` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_ZeroHelperVector___len__', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`ZeroHelperVector___len__`, 'returnType') = 'integer'
attr(`ZeroHelperVector___len__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_ZeroHelper_t_std__allocatorT_boost__shared_ptrT_ZeroHelper_t_t_t')
class(`ZeroHelperVector___len__`) = c("SWIGFunction", class('ZeroHelperVector___len__'))

# Start of ZeroHelperVector_pop

`ZeroHelperVector_pop` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_ZeroHelperVector_pop', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_ZeroHelper_t";
  
  ans
  
}

attr(`ZeroHelperVector_pop`, 'returnType') = '_p_boost__shared_ptrT_ZeroHelper_t'
attr(`ZeroHelperVector_pop`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_ZeroHelper_t_std__allocatorT_boost__shared_ptrT_ZeroHelper_t_t_t')
class(`ZeroHelperVector_pop`) = c("SWIGFunction", class('ZeroHelperVector_pop'))

# Start of ZeroHelperVector___getslice__

`ZeroHelperVector___getslice__` = function(self, i, j)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;ans = .Call('R_swig_ZeroHelperVector___getslice__', self, i, j, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_ZeroHelper_t_std__allocatorT_boost__shared_ptrT_ZeroHelper_t_t_t";
  
  ans
  
}

attr(`ZeroHelperVector___getslice__`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_ZeroHelper_t_std__allocatorT_boost__shared_ptrT_ZeroHelper_t_t_t'
attr(`ZeroHelperVector___getslice__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_ZeroHelper_t_std__allocatorT_boost__shared_ptrT_ZeroHelper_t_t_t', 'integer', 'integer')
class(`ZeroHelperVector___getslice__`) = c("SWIGFunction", class('ZeroHelperVector___getslice__'))

# Start of ZeroHelperVector___setslice__

`ZeroHelperVector___setslice__` = function(self, i, j, v)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  
  ;.Call('R_swig_ZeroHelperVector___setslice__', self, i, j, v, PACKAGE='QuantLib');
  
}

attr(`ZeroHelperVector___setslice__`, 'returnType') = 'void'
attr(`ZeroHelperVector___setslice__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_ZeroHelper_t_std__allocatorT_boost__shared_ptrT_ZeroHelper_t_t_t', 'integer', 'integer', '_p_std__vectorT_boost__shared_ptrT_ZeroHelper_t_std__allocatorT_boost__shared_ptrT_ZeroHelper_t_t_t')
class(`ZeroHelperVector___setslice__`) = c("SWIGFunction", class('ZeroHelperVector___setslice__'))

# Start of ZeroHelperVector___delslice__

`ZeroHelperVector___delslice__` = function(self, i, j)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_ZeroHelperVector___delslice__', self, i, j, PACKAGE='QuantLib');
  
}

attr(`ZeroHelperVector___delslice__`, 'returnType') = 'void'
attr(`ZeroHelperVector___delslice__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_ZeroHelper_t_std__allocatorT_boost__shared_ptrT_ZeroHelper_t_t_t', 'integer', 'integer')
class(`ZeroHelperVector___delslice__`) = c("SWIGFunction", class('ZeroHelperVector___delslice__'))

# Start of ZeroHelperVector___delitem__

`ZeroHelperVector___delitem__` = function(self, i)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_ZeroHelperVector___delitem__', self, i, PACKAGE='QuantLib');
  
}

attr(`ZeroHelperVector___delitem__`, 'returnType') = 'void'
attr(`ZeroHelperVector___delitem__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_ZeroHelper_t_std__allocatorT_boost__shared_ptrT_ZeroHelper_t_t_t', 'integer')
class(`ZeroHelperVector___delitem__`) = c("SWIGFunction", class('ZeroHelperVector___delitem__'))

# Start of ZeroHelperVector___getitem__

`ZeroHelperVector___getitem__` = function(self, i, .copy = FALSE)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;ans = .Call('R_swig_ZeroHelperVector___getitem__', self, i, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_ZeroHelper_t";
  
  ans
  
}

attr(`ZeroHelperVector___getitem__`, 'returnType') = '_p_boost__shared_ptrT_ZeroHelper_t'
attr(`ZeroHelperVector___getitem__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_ZeroHelper_t_std__allocatorT_boost__shared_ptrT_ZeroHelper_t_t_t', 'integer')
class(`ZeroHelperVector___getitem__`) = c("SWIGFunction", class('ZeroHelperVector___getitem__'))

# Start of ZeroHelperVector___setitem__

`ZeroHelperVector___setitem__` = function(self, i, x)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  ;.Call('R_swig_ZeroHelperVector___setitem__', self, i, x, PACKAGE='QuantLib');
  
}

attr(`ZeroHelperVector___setitem__`, 'returnType') = 'void'
attr(`ZeroHelperVector___setitem__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_ZeroHelper_t_std__allocatorT_boost__shared_ptrT_ZeroHelper_t_t_t', 'integer', '_p_boost__shared_ptrT_ZeroHelper_t')
class(`ZeroHelperVector___setitem__`) = c("SWIGFunction", class('ZeroHelperVector___setitem__'))

# Start of ZeroHelperVector_append

`ZeroHelperVector_append` = function(self, x)
{
  ;.Call('R_swig_ZeroHelperVector_append', self, x, PACKAGE='QuantLib');
  
}

attr(`ZeroHelperVector_append`, 'returnType') = 'void'
attr(`ZeroHelperVector_append`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_ZeroHelper_t_std__allocatorT_boost__shared_ptrT_ZeroHelper_t_t_t', '_p_boost__shared_ptrT_ZeroHelper_t')
class(`ZeroHelperVector_append`) = c("SWIGFunction", class('ZeroHelperVector_append'))

# Start of new_ZeroHelperVector

`ZeroHelperVector__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_ZeroHelperVector__SWIG_0', PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_ZeroHelper_t_std__allocatorT_boost__shared_ptrT_ZeroHelper_t_t_t";
  
  reg.finalizer(ans, delete_ZeroHelperVector)
  ans
  
}

attr(`ZeroHelperVector__SWIG_0`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_ZeroHelper_t_std__allocatorT_boost__shared_ptrT_ZeroHelper_t_t_t'
class(`ZeroHelperVector__SWIG_0`) = c("SWIGFunction", class('ZeroHelperVector__SWIG_0'))

# Start of new_ZeroHelperVector

`ZeroHelperVector__SWIG_1` = function(s_arg1)
{
  ;ans = .Call('R_swig_new_ZeroHelperVector__SWIG_1', s_arg1, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_ZeroHelper_t_std__allocatorT_boost__shared_ptrT_ZeroHelper_t_t_t";
  
  reg.finalizer(ans, delete_ZeroHelperVector)
  ans
  
}

attr(`ZeroHelperVector__SWIG_1`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_ZeroHelper_t_std__allocatorT_boost__shared_ptrT_ZeroHelper_t_t_t'
attr(`ZeroHelperVector__SWIG_1`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_ZeroHelper_t_std__allocatorT_boost__shared_ptrT_ZeroHelper_t_t_t')
class(`ZeroHelperVector__SWIG_1`) = c("SWIGFunction", class('ZeroHelperVector__SWIG_1'))

# Start of ZeroHelperVector_empty

`ZeroHelperVector_empty` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_ZeroHelperVector_empty', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`ZeroHelperVector_empty`, 'returnType') = 'logical'
attr(`ZeroHelperVector_empty`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_ZeroHelper_t_std__allocatorT_boost__shared_ptrT_ZeroHelper_t_t_t')
class(`ZeroHelperVector_empty`) = c("SWIGFunction", class('ZeroHelperVector_empty'))

# Start of ZeroHelperVector_size

`ZeroHelperVector_size` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_ZeroHelperVector_size', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`ZeroHelperVector_size`, 'returnType') = 'integer'
attr(`ZeroHelperVector_size`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_ZeroHelper_t_std__allocatorT_boost__shared_ptrT_ZeroHelper_t_t_t')
class(`ZeroHelperVector_size`) = c("SWIGFunction", class('ZeroHelperVector_size'))

# Start of ZeroHelperVector_clear

`ZeroHelperVector_clear` = function(self)
{
  ;.Call('R_swig_ZeroHelperVector_clear', self, PACKAGE='QuantLib');
  
}

attr(`ZeroHelperVector_clear`, 'returnType') = 'void'
attr(`ZeroHelperVector_clear`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_ZeroHelper_t_std__allocatorT_boost__shared_ptrT_ZeroHelper_t_t_t')
class(`ZeroHelperVector_clear`) = c("SWIGFunction", class('ZeroHelperVector_clear'))

# Start of ZeroHelperVector_swap

`ZeroHelperVector_swap` = function(self, v)
{
  ;.Call('R_swig_ZeroHelperVector_swap', self, v, PACKAGE='QuantLib');
  
}

attr(`ZeroHelperVector_swap`, 'returnType') = 'void'
attr(`ZeroHelperVector_swap`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_ZeroHelper_t_std__allocatorT_boost__shared_ptrT_ZeroHelper_t_t_t', '_p_std__vectorT_boost__shared_ptrT_ZeroHelper_t_std__allocatorT_boost__shared_ptrT_ZeroHelper_t_t_t')
class(`ZeroHelperVector_swap`) = c("SWIGFunction", class('ZeroHelperVector_swap'))

# Start of ZeroHelperVector_get_allocator

`ZeroHelperVector_get_allocator` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_ZeroHelperVector_get_allocator', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__allocatorT_boost__shared_ptrT_ZeroHelper_t_t";
  
  ans
  
}

attr(`ZeroHelperVector_get_allocator`, 'returnType') = '_p_std__allocatorT_boost__shared_ptrT_ZeroHelper_t_t'
attr(`ZeroHelperVector_get_allocator`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_ZeroHelper_t_std__allocatorT_boost__shared_ptrT_ZeroHelper_t_t_t')
class(`ZeroHelperVector_get_allocator`) = c("SWIGFunction", class('ZeroHelperVector_get_allocator'))

# Start of new_ZeroHelperVector

`ZeroHelperVector__SWIG_2` = function(size)
{
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_new_ZeroHelperVector__SWIG_2', size, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_ZeroHelper_t_std__allocatorT_boost__shared_ptrT_ZeroHelper_t_t_t";
  
  reg.finalizer(ans, delete_ZeroHelperVector)
  ans
  
}

attr(`ZeroHelperVector__SWIG_2`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_ZeroHelper_t_std__allocatorT_boost__shared_ptrT_ZeroHelper_t_t_t'
attr(`ZeroHelperVector__SWIG_2`, "inputTypes") = c('integer')
class(`ZeroHelperVector__SWIG_2`) = c("SWIGFunction", class('ZeroHelperVector__SWIG_2'))

# Start of ZeroHelperVector_pop_back

`ZeroHelperVector_pop_back` = function(self)
{
  ;.Call('R_swig_ZeroHelperVector_pop_back', self, PACKAGE='QuantLib');
  
}

attr(`ZeroHelperVector_pop_back`, 'returnType') = 'void'
attr(`ZeroHelperVector_pop_back`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_ZeroHelper_t_std__allocatorT_boost__shared_ptrT_ZeroHelper_t_t_t')
class(`ZeroHelperVector_pop_back`) = c("SWIGFunction", class('ZeroHelperVector_pop_back'))

# Start of ZeroHelperVector_resize

`ZeroHelperVector_resize__SWIG_0` = function(self, new_size)
{
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_ZeroHelperVector_resize__SWIG_0', self, new_size, PACKAGE='QuantLib');
  
}

attr(`ZeroHelperVector_resize__SWIG_0`, 'returnType') = 'void'
attr(`ZeroHelperVector_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_ZeroHelper_t_std__allocatorT_boost__shared_ptrT_ZeroHelper_t_t_t', 'integer')
class(`ZeroHelperVector_resize__SWIG_0`) = c("SWIGFunction", class('ZeroHelperVector_resize__SWIG_0'))

# Start of new_ZeroHelperVector

`ZeroHelperVector__SWIG_3` = function(size, value)
{
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  
  ;ans = .Call('R_swig_new_ZeroHelperVector__SWIG_3', size, value, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_ZeroHelper_t_std__allocatorT_boost__shared_ptrT_ZeroHelper_t_t_t";
  
  reg.finalizer(ans, delete_ZeroHelperVector)
  ans
  
}

attr(`ZeroHelperVector__SWIG_3`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_ZeroHelper_t_std__allocatorT_boost__shared_ptrT_ZeroHelper_t_t_t'
attr(`ZeroHelperVector__SWIG_3`, "inputTypes") = c('integer', '_p_boost__shared_ptrT_ZeroHelper_t')
class(`ZeroHelperVector__SWIG_3`) = c("SWIGFunction", class('ZeroHelperVector__SWIG_3'))

`ZeroHelperVector` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- ZeroHelperVector__SWIG_0; 
  } else if (argc == 1) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]]))) {
      f <- ZeroHelperVector__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_ZeroHelper_t_std__allocatorT_boost__shared_ptrT_ZeroHelper_t_t_t')) {
      f <- ZeroHelperVector__SWIG_1; 
    }
  } else if (argc == 2) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && extends(argtypes[2], '_p_boost__shared_ptrT_ZeroHelper_t')) {
      f <- ZeroHelperVector__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for ZeroHelperVector with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of ZeroHelperVector_push_back

`ZeroHelperVector_push_back` = function(self, x)
{
  ;.Call('R_swig_ZeroHelperVector_push_back', self, x, PACKAGE='QuantLib');
  
}

attr(`ZeroHelperVector_push_back`, 'returnType') = 'void'
attr(`ZeroHelperVector_push_back`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_ZeroHelper_t_std__allocatorT_boost__shared_ptrT_ZeroHelper_t_t_t', '_p_boost__shared_ptrT_ZeroHelper_t')
class(`ZeroHelperVector_push_back`) = c("SWIGFunction", class('ZeroHelperVector_push_back'))

# Start of ZeroHelperVector_front

`ZeroHelperVector_front` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_ZeroHelperVector_front', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_ZeroHelper_t";
  
  ans
  
}

attr(`ZeroHelperVector_front`, 'returnType') = '_p_boost__shared_ptrT_ZeroHelper_t'
attr(`ZeroHelperVector_front`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_ZeroHelper_t_std__allocatorT_boost__shared_ptrT_ZeroHelper_t_t_t')
class(`ZeroHelperVector_front`) = c("SWIGFunction", class('ZeroHelperVector_front'))

# Start of ZeroHelperVector_back

`ZeroHelperVector_back` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_ZeroHelperVector_back', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_ZeroHelper_t";
  
  ans
  
}

attr(`ZeroHelperVector_back`, 'returnType') = '_p_boost__shared_ptrT_ZeroHelper_t'
attr(`ZeroHelperVector_back`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_ZeroHelper_t_std__allocatorT_boost__shared_ptrT_ZeroHelper_t_t_t')
class(`ZeroHelperVector_back`) = c("SWIGFunction", class('ZeroHelperVector_back'))

# Start of ZeroHelperVector_assign

`ZeroHelperVector_assign` = function(self, n, x)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  
  ;.Call('R_swig_ZeroHelperVector_assign', self, n, x, PACKAGE='QuantLib');
  
}

attr(`ZeroHelperVector_assign`, 'returnType') = 'void'
attr(`ZeroHelperVector_assign`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_ZeroHelper_t_std__allocatorT_boost__shared_ptrT_ZeroHelper_t_t_t', 'integer', '_p_boost__shared_ptrT_ZeroHelper_t')
class(`ZeroHelperVector_assign`) = c("SWIGFunction", class('ZeroHelperVector_assign'))

# Start of ZeroHelperVector_resize

`ZeroHelperVector_resize__SWIG_1` = function(self, new_size, x)
{
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  
  ;.Call('R_swig_ZeroHelperVector_resize__SWIG_1', self, new_size, x, PACKAGE='QuantLib');
  
}

attr(`ZeroHelperVector_resize__SWIG_1`, 'returnType') = 'void'
attr(`ZeroHelperVector_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_ZeroHelper_t_std__allocatorT_boost__shared_ptrT_ZeroHelper_t_t_t', 'integer', '_p_boost__shared_ptrT_ZeroHelper_t')
class(`ZeroHelperVector_resize__SWIG_1`) = c("SWIGFunction", class('ZeroHelperVector_resize__SWIG_1'))

`ZeroHelperVector_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_ZeroHelper_t_std__allocatorT_boost__shared_ptrT_ZeroHelper_t_t_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]]))) {
      f <- ZeroHelperVector_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_ZeroHelper_t_std__allocatorT_boost__shared_ptrT_ZeroHelper_t_t_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && extends(argtypes[3], '_p_boost__shared_ptrT_ZeroHelper_t')) {
      f <- ZeroHelperVector_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for ZeroHelperVector_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of ZeroHelperVector_reserve

`ZeroHelperVector_reserve` = function(self, n)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_ZeroHelperVector_reserve', self, n, PACKAGE='QuantLib');
  
}

attr(`ZeroHelperVector_reserve`, 'returnType') = 'void'
attr(`ZeroHelperVector_reserve`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_ZeroHelper_t_std__allocatorT_boost__shared_ptrT_ZeroHelper_t_t_t', 'integer')
class(`ZeroHelperVector_reserve`) = c("SWIGFunction", class('ZeroHelperVector_reserve'))

# Start of ZeroHelperVector_capacity

`ZeroHelperVector_capacity` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_ZeroHelperVector_capacity', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`ZeroHelperVector_capacity`, 'returnType') = 'integer'
attr(`ZeroHelperVector_capacity`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_ZeroHelper_t_std__allocatorT_boost__shared_ptrT_ZeroHelper_t_t_t')
class(`ZeroHelperVector_capacity`) = c("SWIGFunction", class('ZeroHelperVector_capacity'))

# Start of delete_ZeroHelperVector

`delete_ZeroHelperVector` = function(self)
{
  ;.Call('R_swig_delete_ZeroHelperVector', self, PACKAGE='QuantLib');
  
}

attr(`delete_ZeroHelperVector`, 'returnType') = 'void'
attr(`delete_ZeroHelperVector`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_ZeroHelper_t_std__allocatorT_boost__shared_ptrT_ZeroHelper_t_t_t')
class(`delete_ZeroHelperVector`) = c("SWIGFunction", class('delete_ZeroHelperVector'))

# Start of accessor method for std::vector<(boost::shared_ptr<(ZeroHelper)>)>
setMethod('$', '_p_std__vectorT_boost__shared_ptrT_ZeroHelper_t_std__allocatorT_boost__shared_ptrT_ZeroHelper_t_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = ZeroHelperVector___nonzero__, '__len__' = ZeroHelperVector___len__, 'pop' = ZeroHelperVector_pop, '__getslice__' = ZeroHelperVector___getslice__, '__setslice__' = ZeroHelperVector___setslice__, '__delslice__' = ZeroHelperVector___delslice__, '__delitem__' = ZeroHelperVector___delitem__, '__getitem__' = ZeroHelperVector___getitem__, '__setitem__' = ZeroHelperVector___setitem__, 'append' = ZeroHelperVector_append, 'empty' = ZeroHelperVector_empty, 'size' = ZeroHelperVector_size, 'clear' = ZeroHelperVector_clear, 'swap' = ZeroHelperVector_swap, 'get_allocator' = ZeroHelperVector_get_allocator, 'pop_back' = ZeroHelperVector_pop_back, 'resize' = ZeroHelperVector_resize, 'push_back' = ZeroHelperVector_push_back, 'front' = ZeroHelperVector_front, 'back' = ZeroHelperVector_back, 'assign' = ZeroHelperVector_assign, 'reserve' = ZeroHelperVector_reserve, 'capacity' = ZeroHelperVector_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for std::vector<(boost::shared_ptr<(ZeroHelper)>)>
setMethod('delete', '_p_std__vectorT_boost__shared_ptrT_ZeroHelper_t_std__allocatorT_boost__shared_ptrT_ZeroHelper_t_t_t', function(obj) {delete_std__vectorT_boost__shared_ptrT_ZeroHelper_t_std__allocatorT_boost__shared_ptrT_ZeroHelper_t_t_t(obj)})
# Start of YoYHelperVector___nonzero__

`YoYHelperVector___nonzero__` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_YoYHelperVector___nonzero__', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`YoYHelperVector___nonzero__`, 'returnType') = 'logical'
attr(`YoYHelperVector___nonzero__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_YoYHelper_t_std__allocatorT_boost__shared_ptrT_YoYHelper_t_t_t')
class(`YoYHelperVector___nonzero__`) = c("SWIGFunction", class('YoYHelperVector___nonzero__'))

# Start of YoYHelperVector___len__

`YoYHelperVector___len__` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_YoYHelperVector___len__', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`YoYHelperVector___len__`, 'returnType') = 'integer'
attr(`YoYHelperVector___len__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_YoYHelper_t_std__allocatorT_boost__shared_ptrT_YoYHelper_t_t_t')
class(`YoYHelperVector___len__`) = c("SWIGFunction", class('YoYHelperVector___len__'))

# Start of YoYHelperVector_pop

`YoYHelperVector_pop` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_YoYHelperVector_pop', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_YoYHelper_t";
  
  ans
  
}

attr(`YoYHelperVector_pop`, 'returnType') = '_p_boost__shared_ptrT_YoYHelper_t'
attr(`YoYHelperVector_pop`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_YoYHelper_t_std__allocatorT_boost__shared_ptrT_YoYHelper_t_t_t')
class(`YoYHelperVector_pop`) = c("SWIGFunction", class('YoYHelperVector_pop'))

# Start of YoYHelperVector___getslice__

`YoYHelperVector___getslice__` = function(self, i, j)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;ans = .Call('R_swig_YoYHelperVector___getslice__', self, i, j, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_YoYHelper_t_std__allocatorT_boost__shared_ptrT_YoYHelper_t_t_t";
  
  ans
  
}

attr(`YoYHelperVector___getslice__`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_YoYHelper_t_std__allocatorT_boost__shared_ptrT_YoYHelper_t_t_t'
attr(`YoYHelperVector___getslice__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_YoYHelper_t_std__allocatorT_boost__shared_ptrT_YoYHelper_t_t_t', 'integer', 'integer')
class(`YoYHelperVector___getslice__`) = c("SWIGFunction", class('YoYHelperVector___getslice__'))

# Start of YoYHelperVector___setslice__

`YoYHelperVector___setslice__` = function(self, i, j, v)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  
  ;.Call('R_swig_YoYHelperVector___setslice__', self, i, j, v, PACKAGE='QuantLib');
  
}

attr(`YoYHelperVector___setslice__`, 'returnType') = 'void'
attr(`YoYHelperVector___setslice__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_YoYHelper_t_std__allocatorT_boost__shared_ptrT_YoYHelper_t_t_t', 'integer', 'integer', '_p_std__vectorT_boost__shared_ptrT_YoYHelper_t_std__allocatorT_boost__shared_ptrT_YoYHelper_t_t_t')
class(`YoYHelperVector___setslice__`) = c("SWIGFunction", class('YoYHelperVector___setslice__'))

# Start of YoYHelperVector___delslice__

`YoYHelperVector___delslice__` = function(self, i, j)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_YoYHelperVector___delslice__', self, i, j, PACKAGE='QuantLib');
  
}

attr(`YoYHelperVector___delslice__`, 'returnType') = 'void'
attr(`YoYHelperVector___delslice__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_YoYHelper_t_std__allocatorT_boost__shared_ptrT_YoYHelper_t_t_t', 'integer', 'integer')
class(`YoYHelperVector___delslice__`) = c("SWIGFunction", class('YoYHelperVector___delslice__'))

# Start of YoYHelperVector___delitem__

`YoYHelperVector___delitem__` = function(self, i)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_YoYHelperVector___delitem__', self, i, PACKAGE='QuantLib');
  
}

attr(`YoYHelperVector___delitem__`, 'returnType') = 'void'
attr(`YoYHelperVector___delitem__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_YoYHelper_t_std__allocatorT_boost__shared_ptrT_YoYHelper_t_t_t', 'integer')
class(`YoYHelperVector___delitem__`) = c("SWIGFunction", class('YoYHelperVector___delitem__'))

# Start of YoYHelperVector___getitem__

`YoYHelperVector___getitem__` = function(self, i, .copy = FALSE)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;ans = .Call('R_swig_YoYHelperVector___getitem__', self, i, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_YoYHelper_t";
  
  ans
  
}

attr(`YoYHelperVector___getitem__`, 'returnType') = '_p_boost__shared_ptrT_YoYHelper_t'
attr(`YoYHelperVector___getitem__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_YoYHelper_t_std__allocatorT_boost__shared_ptrT_YoYHelper_t_t_t', 'integer')
class(`YoYHelperVector___getitem__`) = c("SWIGFunction", class('YoYHelperVector___getitem__'))

# Start of YoYHelperVector___setitem__

`YoYHelperVector___setitem__` = function(self, i, x)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  ;.Call('R_swig_YoYHelperVector___setitem__', self, i, x, PACKAGE='QuantLib');
  
}

attr(`YoYHelperVector___setitem__`, 'returnType') = 'void'
attr(`YoYHelperVector___setitem__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_YoYHelper_t_std__allocatorT_boost__shared_ptrT_YoYHelper_t_t_t', 'integer', '_p_boost__shared_ptrT_YoYHelper_t')
class(`YoYHelperVector___setitem__`) = c("SWIGFunction", class('YoYHelperVector___setitem__'))

# Start of YoYHelperVector_append

`YoYHelperVector_append` = function(self, x)
{
  ;.Call('R_swig_YoYHelperVector_append', self, x, PACKAGE='QuantLib');
  
}

attr(`YoYHelperVector_append`, 'returnType') = 'void'
attr(`YoYHelperVector_append`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_YoYHelper_t_std__allocatorT_boost__shared_ptrT_YoYHelper_t_t_t', '_p_boost__shared_ptrT_YoYHelper_t')
class(`YoYHelperVector_append`) = c("SWIGFunction", class('YoYHelperVector_append'))

# Start of new_YoYHelperVector

`YoYHelperVector__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_YoYHelperVector__SWIG_0', PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_YoYHelper_t_std__allocatorT_boost__shared_ptrT_YoYHelper_t_t_t";
  
  reg.finalizer(ans, delete_YoYHelperVector)
  ans
  
}

attr(`YoYHelperVector__SWIG_0`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_YoYHelper_t_std__allocatorT_boost__shared_ptrT_YoYHelper_t_t_t'
class(`YoYHelperVector__SWIG_0`) = c("SWIGFunction", class('YoYHelperVector__SWIG_0'))

# Start of new_YoYHelperVector

`YoYHelperVector__SWIG_1` = function(s_arg1)
{
  ;ans = .Call('R_swig_new_YoYHelperVector__SWIG_1', s_arg1, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_YoYHelper_t_std__allocatorT_boost__shared_ptrT_YoYHelper_t_t_t";
  
  reg.finalizer(ans, delete_YoYHelperVector)
  ans
  
}

attr(`YoYHelperVector__SWIG_1`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_YoYHelper_t_std__allocatorT_boost__shared_ptrT_YoYHelper_t_t_t'
attr(`YoYHelperVector__SWIG_1`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_YoYHelper_t_std__allocatorT_boost__shared_ptrT_YoYHelper_t_t_t')
class(`YoYHelperVector__SWIG_1`) = c("SWIGFunction", class('YoYHelperVector__SWIG_1'))

# Start of YoYHelperVector_empty

`YoYHelperVector_empty` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_YoYHelperVector_empty', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`YoYHelperVector_empty`, 'returnType') = 'logical'
attr(`YoYHelperVector_empty`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_YoYHelper_t_std__allocatorT_boost__shared_ptrT_YoYHelper_t_t_t')
class(`YoYHelperVector_empty`) = c("SWIGFunction", class('YoYHelperVector_empty'))

# Start of YoYHelperVector_size

`YoYHelperVector_size` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_YoYHelperVector_size', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`YoYHelperVector_size`, 'returnType') = 'integer'
attr(`YoYHelperVector_size`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_YoYHelper_t_std__allocatorT_boost__shared_ptrT_YoYHelper_t_t_t')
class(`YoYHelperVector_size`) = c("SWIGFunction", class('YoYHelperVector_size'))

# Start of YoYHelperVector_clear

`YoYHelperVector_clear` = function(self)
{
  ;.Call('R_swig_YoYHelperVector_clear', self, PACKAGE='QuantLib');
  
}

attr(`YoYHelperVector_clear`, 'returnType') = 'void'
attr(`YoYHelperVector_clear`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_YoYHelper_t_std__allocatorT_boost__shared_ptrT_YoYHelper_t_t_t')
class(`YoYHelperVector_clear`) = c("SWIGFunction", class('YoYHelperVector_clear'))

# Start of YoYHelperVector_swap

`YoYHelperVector_swap` = function(self, v)
{
  ;.Call('R_swig_YoYHelperVector_swap', self, v, PACKAGE='QuantLib');
  
}

attr(`YoYHelperVector_swap`, 'returnType') = 'void'
attr(`YoYHelperVector_swap`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_YoYHelper_t_std__allocatorT_boost__shared_ptrT_YoYHelper_t_t_t', '_p_std__vectorT_boost__shared_ptrT_YoYHelper_t_std__allocatorT_boost__shared_ptrT_YoYHelper_t_t_t')
class(`YoYHelperVector_swap`) = c("SWIGFunction", class('YoYHelperVector_swap'))

# Start of YoYHelperVector_get_allocator

`YoYHelperVector_get_allocator` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_YoYHelperVector_get_allocator', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__allocatorT_boost__shared_ptrT_YoYHelper_t_t";
  
  ans
  
}

attr(`YoYHelperVector_get_allocator`, 'returnType') = '_p_std__allocatorT_boost__shared_ptrT_YoYHelper_t_t'
attr(`YoYHelperVector_get_allocator`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_YoYHelper_t_std__allocatorT_boost__shared_ptrT_YoYHelper_t_t_t')
class(`YoYHelperVector_get_allocator`) = c("SWIGFunction", class('YoYHelperVector_get_allocator'))

# Start of new_YoYHelperVector

`YoYHelperVector__SWIG_2` = function(size)
{
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_new_YoYHelperVector__SWIG_2', size, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_YoYHelper_t_std__allocatorT_boost__shared_ptrT_YoYHelper_t_t_t";
  
  reg.finalizer(ans, delete_YoYHelperVector)
  ans
  
}

attr(`YoYHelperVector__SWIG_2`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_YoYHelper_t_std__allocatorT_boost__shared_ptrT_YoYHelper_t_t_t'
attr(`YoYHelperVector__SWIG_2`, "inputTypes") = c('integer')
class(`YoYHelperVector__SWIG_2`) = c("SWIGFunction", class('YoYHelperVector__SWIG_2'))

# Start of YoYHelperVector_pop_back

`YoYHelperVector_pop_back` = function(self)
{
  ;.Call('R_swig_YoYHelperVector_pop_back', self, PACKAGE='QuantLib');
  
}

attr(`YoYHelperVector_pop_back`, 'returnType') = 'void'
attr(`YoYHelperVector_pop_back`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_YoYHelper_t_std__allocatorT_boost__shared_ptrT_YoYHelper_t_t_t')
class(`YoYHelperVector_pop_back`) = c("SWIGFunction", class('YoYHelperVector_pop_back'))

# Start of YoYHelperVector_resize

`YoYHelperVector_resize__SWIG_0` = function(self, new_size)
{
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_YoYHelperVector_resize__SWIG_0', self, new_size, PACKAGE='QuantLib');
  
}

attr(`YoYHelperVector_resize__SWIG_0`, 'returnType') = 'void'
attr(`YoYHelperVector_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_YoYHelper_t_std__allocatorT_boost__shared_ptrT_YoYHelper_t_t_t', 'integer')
class(`YoYHelperVector_resize__SWIG_0`) = c("SWIGFunction", class('YoYHelperVector_resize__SWIG_0'))

# Start of new_YoYHelperVector

`YoYHelperVector__SWIG_3` = function(size, value)
{
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  
  ;ans = .Call('R_swig_new_YoYHelperVector__SWIG_3', size, value, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_YoYHelper_t_std__allocatorT_boost__shared_ptrT_YoYHelper_t_t_t";
  
  reg.finalizer(ans, delete_YoYHelperVector)
  ans
  
}

attr(`YoYHelperVector__SWIG_3`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_YoYHelper_t_std__allocatorT_boost__shared_ptrT_YoYHelper_t_t_t'
attr(`YoYHelperVector__SWIG_3`, "inputTypes") = c('integer', '_p_boost__shared_ptrT_YoYHelper_t')
class(`YoYHelperVector__SWIG_3`) = c("SWIGFunction", class('YoYHelperVector__SWIG_3'))

`YoYHelperVector` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- YoYHelperVector__SWIG_0; 
  } else if (argc == 1) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]]))) {
      f <- YoYHelperVector__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_YoYHelper_t_std__allocatorT_boost__shared_ptrT_YoYHelper_t_t_t')) {
      f <- YoYHelperVector__SWIG_1; 
    }
  } else if (argc == 2) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && extends(argtypes[2], '_p_boost__shared_ptrT_YoYHelper_t')) {
      f <- YoYHelperVector__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for YoYHelperVector with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of YoYHelperVector_push_back

`YoYHelperVector_push_back` = function(self, x)
{
  ;.Call('R_swig_YoYHelperVector_push_back', self, x, PACKAGE='QuantLib');
  
}

attr(`YoYHelperVector_push_back`, 'returnType') = 'void'
attr(`YoYHelperVector_push_back`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_YoYHelper_t_std__allocatorT_boost__shared_ptrT_YoYHelper_t_t_t', '_p_boost__shared_ptrT_YoYHelper_t')
class(`YoYHelperVector_push_back`) = c("SWIGFunction", class('YoYHelperVector_push_back'))

# Start of YoYHelperVector_front

`YoYHelperVector_front` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_YoYHelperVector_front', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_YoYHelper_t";
  
  ans
  
}

attr(`YoYHelperVector_front`, 'returnType') = '_p_boost__shared_ptrT_YoYHelper_t'
attr(`YoYHelperVector_front`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_YoYHelper_t_std__allocatorT_boost__shared_ptrT_YoYHelper_t_t_t')
class(`YoYHelperVector_front`) = c("SWIGFunction", class('YoYHelperVector_front'))

# Start of YoYHelperVector_back

`YoYHelperVector_back` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_YoYHelperVector_back', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_YoYHelper_t";
  
  ans
  
}

attr(`YoYHelperVector_back`, 'returnType') = '_p_boost__shared_ptrT_YoYHelper_t'
attr(`YoYHelperVector_back`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_YoYHelper_t_std__allocatorT_boost__shared_ptrT_YoYHelper_t_t_t')
class(`YoYHelperVector_back`) = c("SWIGFunction", class('YoYHelperVector_back'))

# Start of YoYHelperVector_assign

`YoYHelperVector_assign` = function(self, n, x)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  
  ;.Call('R_swig_YoYHelperVector_assign', self, n, x, PACKAGE='QuantLib');
  
}

attr(`YoYHelperVector_assign`, 'returnType') = 'void'
attr(`YoYHelperVector_assign`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_YoYHelper_t_std__allocatorT_boost__shared_ptrT_YoYHelper_t_t_t', 'integer', '_p_boost__shared_ptrT_YoYHelper_t')
class(`YoYHelperVector_assign`) = c("SWIGFunction", class('YoYHelperVector_assign'))

# Start of YoYHelperVector_resize

`YoYHelperVector_resize__SWIG_1` = function(self, new_size, x)
{
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  
  ;.Call('R_swig_YoYHelperVector_resize__SWIG_1', self, new_size, x, PACKAGE='QuantLib');
  
}

attr(`YoYHelperVector_resize__SWIG_1`, 'returnType') = 'void'
attr(`YoYHelperVector_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_YoYHelper_t_std__allocatorT_boost__shared_ptrT_YoYHelper_t_t_t', 'integer', '_p_boost__shared_ptrT_YoYHelper_t')
class(`YoYHelperVector_resize__SWIG_1`) = c("SWIGFunction", class('YoYHelperVector_resize__SWIG_1'))

`YoYHelperVector_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_YoYHelper_t_std__allocatorT_boost__shared_ptrT_YoYHelper_t_t_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]]))) {
      f <- YoYHelperVector_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_YoYHelper_t_std__allocatorT_boost__shared_ptrT_YoYHelper_t_t_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && extends(argtypes[3], '_p_boost__shared_ptrT_YoYHelper_t')) {
      f <- YoYHelperVector_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for YoYHelperVector_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of YoYHelperVector_reserve

`YoYHelperVector_reserve` = function(self, n)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_YoYHelperVector_reserve', self, n, PACKAGE='QuantLib');
  
}

attr(`YoYHelperVector_reserve`, 'returnType') = 'void'
attr(`YoYHelperVector_reserve`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_YoYHelper_t_std__allocatorT_boost__shared_ptrT_YoYHelper_t_t_t', 'integer')
class(`YoYHelperVector_reserve`) = c("SWIGFunction", class('YoYHelperVector_reserve'))

# Start of YoYHelperVector_capacity

`YoYHelperVector_capacity` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_YoYHelperVector_capacity', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`YoYHelperVector_capacity`, 'returnType') = 'integer'
attr(`YoYHelperVector_capacity`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_YoYHelper_t_std__allocatorT_boost__shared_ptrT_YoYHelper_t_t_t')
class(`YoYHelperVector_capacity`) = c("SWIGFunction", class('YoYHelperVector_capacity'))

# Start of delete_YoYHelperVector

`delete_YoYHelperVector` = function(self)
{
  ;.Call('R_swig_delete_YoYHelperVector', self, PACKAGE='QuantLib');
  
}

attr(`delete_YoYHelperVector`, 'returnType') = 'void'
attr(`delete_YoYHelperVector`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_YoYHelper_t_std__allocatorT_boost__shared_ptrT_YoYHelper_t_t_t')
class(`delete_YoYHelperVector`) = c("SWIGFunction", class('delete_YoYHelperVector'))

# Start of accessor method for std::vector<(boost::shared_ptr<(YoYHelper)>)>
setMethod('$', '_p_std__vectorT_boost__shared_ptrT_YoYHelper_t_std__allocatorT_boost__shared_ptrT_YoYHelper_t_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = YoYHelperVector___nonzero__, '__len__' = YoYHelperVector___len__, 'pop' = YoYHelperVector_pop, '__getslice__' = YoYHelperVector___getslice__, '__setslice__' = YoYHelperVector___setslice__, '__delslice__' = YoYHelperVector___delslice__, '__delitem__' = YoYHelperVector___delitem__, '__getitem__' = YoYHelperVector___getitem__, '__setitem__' = YoYHelperVector___setitem__, 'append' = YoYHelperVector_append, 'empty' = YoYHelperVector_empty, 'size' = YoYHelperVector_size, 'clear' = YoYHelperVector_clear, 'swap' = YoYHelperVector_swap, 'get_allocator' = YoYHelperVector_get_allocator, 'pop_back' = YoYHelperVector_pop_back, 'resize' = YoYHelperVector_resize, 'push_back' = YoYHelperVector_push_back, 'front' = YoYHelperVector_front, 'back' = YoYHelperVector_back, 'assign' = YoYHelperVector_assign, 'reserve' = YoYHelperVector_reserve, 'capacity' = YoYHelperVector_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for std::vector<(boost::shared_ptr<(YoYHelper)>)>
setMethod('delete', '_p_std__vectorT_boost__shared_ptrT_YoYHelper_t_std__allocatorT_boost__shared_ptrT_YoYHelper_t_t_t', function(obj) {delete_std__vectorT_boost__shared_ptrT_YoYHelper_t_std__allocatorT_boost__shared_ptrT_YoYHelper_t_t_t(obj)})
# Start of new_ZeroCouponInflationSwapHelper

`ZeroCouponInflationSwapHelper` = function(rate, lag, maturity, calendar, bdc, dayCounter, index)
{
  bdc = enumToInteger(bdc, "_BusinessDayConvention"); 
  
  if(length(bdc) > 1) {
    warning("using only the first element of bdc");
  };
  
  
  
  ;ans = .Call('R_swig_new_ZeroCouponInflationSwapHelper', rate, lag, maturity, calendar, bdc, dayCounter, index, PACKAGE='QuantLib');
  class(ans) <- "_p_ZeroCouponInflationSwapHelperPtr";
  
  reg.finalizer(ans, delete_ZeroCouponInflationSwapHelper)
  ans
  
}

attr(`ZeroCouponInflationSwapHelper`, 'returnType') = '_p_ZeroCouponInflationSwapHelperPtr'
attr(`ZeroCouponInflationSwapHelper`, "inputTypes") = c('numeric', '_p_Period', '_p_Date', '_p_Calendar', 'character', '_p_DayCounter', '_p_ZeroInflationIndexPtr')
class(`ZeroCouponInflationSwapHelper`) = c("SWIGFunction", class('ZeroCouponInflationSwapHelper'))

# Start of delete_ZeroCouponInflationSwapHelper

`delete_ZeroCouponInflationSwapHelper` = function(self)
{
  ;.Call('R_swig_delete_ZeroCouponInflationSwapHelper', self, PACKAGE='QuantLib');
  
}

attr(`delete_ZeroCouponInflationSwapHelper`, 'returnType') = 'void'
attr(`delete_ZeroCouponInflationSwapHelper`, "inputTypes") = c('_p_ZeroCouponInflationSwapHelperPtr')
class(`delete_ZeroCouponInflationSwapHelper`) = c("SWIGFunction", class('delete_ZeroCouponInflationSwapHelper'))

setMethod('delete', '_p_ZeroCouponInflationSwapHelperPtr', function(obj) {delete_ZeroCouponInflationSwapHelperPtr(obj)})
# Start of new_YearOnYearInflationSwapHelper

`YearOnYearInflationSwapHelper` = function(rate, lag, maturity, calendar, bdc, dayCounter, index)
{
  bdc = enumToInteger(bdc, "_BusinessDayConvention"); 
  
  if(length(bdc) > 1) {
    warning("using only the first element of bdc");
  };
  
  
  
  ;ans = .Call('R_swig_new_YearOnYearInflationSwapHelper', rate, lag, maturity, calendar, bdc, dayCounter, index, PACKAGE='QuantLib');
  class(ans) <- "_p_YearOnYearInflationSwapHelperPtr";
  
  reg.finalizer(ans, delete_YearOnYearInflationSwapHelper)
  ans
  
}

attr(`YearOnYearInflationSwapHelper`, 'returnType') = '_p_YearOnYearInflationSwapHelperPtr'
attr(`YearOnYearInflationSwapHelper`, "inputTypes") = c('numeric', '_p_Period', '_p_Date', '_p_Calendar', 'character', '_p_DayCounter', '_p_YoYInflationIndexPtr')
class(`YearOnYearInflationSwapHelper`) = c("SWIGFunction", class('YearOnYearInflationSwapHelper'))

# Start of delete_YearOnYearInflationSwapHelper

`delete_YearOnYearInflationSwapHelper` = function(self)
{
  ;.Call('R_swig_delete_YearOnYearInflationSwapHelper', self, PACKAGE='QuantLib');
  
}

attr(`delete_YearOnYearInflationSwapHelper`, 'returnType') = 'void'
attr(`delete_YearOnYearInflationSwapHelper`, "inputTypes") = c('_p_YearOnYearInflationSwapHelperPtr')
class(`delete_YearOnYearInflationSwapHelper`) = c("SWIGFunction", class('delete_YearOnYearInflationSwapHelper'))

setMethod('delete', '_p_YearOnYearInflationSwapHelperPtr', function(obj) {delete_YearOnYearInflationSwapHelperPtr(obj)})
# Start of new_PiecewiseZeroInflation

`PiecewiseZeroInflation` = function(referenceDate, calendar, dayCounter, lag, frequency, indexIsInterpolated, baseRate, nominalTS, instruments, accuracy, i)
{
  frequency = enumToInteger(frequency, "_Frequency"); 
  
  if(length(frequency) > 1) {
    warning("using only the first element of frequency");
  };
  
  indexIsInterpolated = as.logical(indexIsInterpolated);
  
  
  
  
  
  ;ans = .Call('R_swig_new_PiecewiseZeroInflation', referenceDate, calendar, dayCounter, lag, frequency, indexIsInterpolated, baseRate, nominalTS, instruments, accuracy, i, PACKAGE='QuantLib');
  class(ans) <- "_p_PiecewiseZeroInflationPtr";
  
  reg.finalizer(ans, delete_PiecewiseZeroInflation)
  ans
  
}

attr(`PiecewiseZeroInflation`, 'returnType') = '_p_PiecewiseZeroInflationPtr'
attr(`PiecewiseZeroInflation`, "inputTypes") = c('_p_Date', '_p_Calendar', '_p_DayCounter', '_p_Period', 'character', 'logical', 'numeric', '_p_HandleT_YieldTermStructure_t', '_p_std__vectorT_boost__shared_ptrT_ZeroHelper_t_std__allocatorT_boost__shared_ptrT_ZeroHelper_t_t_t', 'numeric', '_p_BackwardFlat')
class(`PiecewiseZeroInflation`) = c("SWIGFunction", class('PiecewiseZeroInflation'))

# Start of PiecewiseZeroInflation_dates

`PiecewiseZeroInflation_dates` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_PiecewiseZeroInflation_dates', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_Date_std__allocatorT_Date_t_t";
  
  ans
  
}

attr(`PiecewiseZeroInflation_dates`, 'returnType') = '_p_std__vectorT_Date_std__allocatorT_Date_t_t'
attr(`PiecewiseZeroInflation_dates`, "inputTypes") = c('_p_PiecewiseZeroInflationPtr')
class(`PiecewiseZeroInflation_dates`) = c("SWIGFunction", class('PiecewiseZeroInflation_dates'))

# Start of PiecewiseZeroInflation_times

`PiecewiseZeroInflation_times` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_PiecewiseZeroInflation_times', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_double_std__allocatorT_double_t_t";
  
  ans
  
}

attr(`PiecewiseZeroInflation_times`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`PiecewiseZeroInflation_times`, "inputTypes") = c('_p_PiecewiseZeroInflationPtr')
class(`PiecewiseZeroInflation_times`) = c("SWIGFunction", class('PiecewiseZeroInflation_times'))

# Start of delete_PiecewiseZeroInflation

`delete_PiecewiseZeroInflation` = function(self)
{
  ;.Call('R_swig_delete_PiecewiseZeroInflation', self, PACKAGE='QuantLib');
  
}

attr(`delete_PiecewiseZeroInflation`, 'returnType') = 'void'
attr(`delete_PiecewiseZeroInflation`, "inputTypes") = c('_p_PiecewiseZeroInflationPtr')
class(`delete_PiecewiseZeroInflation`) = c("SWIGFunction", class('delete_PiecewiseZeroInflation'))

# Start of accessor method for PiecewiseZeroInflationPtr
setMethod('$', '_p_PiecewiseZeroInflationPtr', function(x, name)

{
  accessorFuns = list('dates' = PiecewiseZeroInflation_dates, 'times' = PiecewiseZeroInflation_times);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for PiecewiseZeroInflationPtr
setMethod('delete', '_p_PiecewiseZeroInflationPtr', function(obj) {delete_PiecewiseZeroInflationPtr(obj)})
# Start of new_PiecewiseYoYInflation

`PiecewiseYoYInflation` = function(referenceDate, calendar, dayCounter, lag, frequency, indexIsInterpolated, baseRate, nominalTS, instruments, accuracy, i)
{
  frequency = enumToInteger(frequency, "_Frequency"); 
  
  if(length(frequency) > 1) {
    warning("using only the first element of frequency");
  };
  
  indexIsInterpolated = as.logical(indexIsInterpolated);
  
  
  
  
  
  ;ans = .Call('R_swig_new_PiecewiseYoYInflation', referenceDate, calendar, dayCounter, lag, frequency, indexIsInterpolated, baseRate, nominalTS, instruments, accuracy, i, PACKAGE='QuantLib');
  class(ans) <- "_p_PiecewiseYoYInflationPtr";
  
  reg.finalizer(ans, delete_PiecewiseYoYInflation)
  ans
  
}

attr(`PiecewiseYoYInflation`, 'returnType') = '_p_PiecewiseYoYInflationPtr'
attr(`PiecewiseYoYInflation`, "inputTypes") = c('_p_Date', '_p_Calendar', '_p_DayCounter', '_p_Period', 'character', 'logical', 'numeric', '_p_HandleT_YieldTermStructure_t', '_p_std__vectorT_boost__shared_ptrT_YoYHelper_t_std__allocatorT_boost__shared_ptrT_YoYHelper_t_t_t', 'numeric', '_p_BackwardFlat')
class(`PiecewiseYoYInflation`) = c("SWIGFunction", class('PiecewiseYoYInflation'))

# Start of PiecewiseYoYInflation_dates

`PiecewiseYoYInflation_dates` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_PiecewiseYoYInflation_dates', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_Date_std__allocatorT_Date_t_t";
  
  ans
  
}

attr(`PiecewiseYoYInflation_dates`, 'returnType') = '_p_std__vectorT_Date_std__allocatorT_Date_t_t'
attr(`PiecewiseYoYInflation_dates`, "inputTypes") = c('_p_PiecewiseYoYInflationPtr')
class(`PiecewiseYoYInflation_dates`) = c("SWIGFunction", class('PiecewiseYoYInflation_dates'))

# Start of PiecewiseYoYInflation_times

`PiecewiseYoYInflation_times` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_PiecewiseYoYInflation_times', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_double_std__allocatorT_double_t_t";
  
  ans
  
}

attr(`PiecewiseYoYInflation_times`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`PiecewiseYoYInflation_times`, "inputTypes") = c('_p_PiecewiseYoYInflationPtr')
class(`PiecewiseYoYInflation_times`) = c("SWIGFunction", class('PiecewiseYoYInflation_times'))

# Start of delete_PiecewiseYoYInflation

`delete_PiecewiseYoYInflation` = function(self)
{
  ;.Call('R_swig_delete_PiecewiseYoYInflation', self, PACKAGE='QuantLib');
  
}

attr(`delete_PiecewiseYoYInflation`, 'returnType') = 'void'
attr(`delete_PiecewiseYoYInflation`, "inputTypes") = c('_p_PiecewiseYoYInflationPtr')
class(`delete_PiecewiseYoYInflation`) = c("SWIGFunction", class('delete_PiecewiseYoYInflation'))

# Start of accessor method for PiecewiseYoYInflationPtr
setMethod('$', '_p_PiecewiseYoYInflationPtr', function(x, name)

{
  accessorFuns = list('dates' = PiecewiseYoYInflation_dates, 'times' = PiecewiseYoYInflation_times);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for PiecewiseYoYInflationPtr
setMethod('delete', '_p_PiecewiseYoYInflationPtr', function(obj) {delete_PiecewiseYoYInflationPtr(obj)})
# Start of new_ZeroCouponInflationSwap

`ZeroCouponInflationSwap__SWIG_0` = function(type, nominal, start, maturity, calendar, convention, dayCounter, fixedRate, index, lag, adjustInfObsDates, infCalendar, infConvention)
{
  type = enumToInteger(type, "_ZeroCouponInflationSwap__Type"); 
  
  if(length(type) > 1) {
    warning("using only the first element of type");
  };
  
  
  
  
  
  convention = enumToInteger(convention, "_BusinessDayConvention"); 
  
  if(length(convention) > 1) {
    warning("using only the first element of convention");
  };
  
  
  
  
  
  adjustInfObsDates = as.logical(adjustInfObsDates);
  
  infConvention = enumToInteger(infConvention, "_BusinessDayConvention"); 
  
  if(length(infConvention) > 1) {
    warning("using only the first element of infConvention");
  };
  
  ;ans = .Call('R_swig_new_ZeroCouponInflationSwap__SWIG_0', type, nominal, start, maturity, calendar, convention, dayCounter, fixedRate, index, lag, adjustInfObsDates, infCalendar, infConvention, PACKAGE='QuantLib');
  class(ans) <- "_p_ZeroCouponInflationSwapPtr";
  
  reg.finalizer(ans, delete_ZeroCouponInflationSwap)
  ans
  
}

attr(`ZeroCouponInflationSwap__SWIG_0`, 'returnType') = '_p_ZeroCouponInflationSwapPtr'
attr(`ZeroCouponInflationSwap__SWIG_0`, "inputTypes") = c('character', 'numeric', '_p_Date', '_p_Date', '_p_Calendar', 'character', '_p_DayCounter', 'numeric', '_p_ZeroInflationIndexPtr', '_p_Period', 'logical', '_p_Calendar', 'character')
class(`ZeroCouponInflationSwap__SWIG_0`) = c("SWIGFunction", class('ZeroCouponInflationSwap__SWIG_0'))

# Start of new_ZeroCouponInflationSwap

`ZeroCouponInflationSwap__SWIG_1` = function(type, nominal, start, maturity, calendar, convention, dayCounter, fixedRate, index, lag, adjustInfObsDates, infCalendar)
{
  type = enumToInteger(type, "_ZeroCouponInflationSwap__Type"); 
  
  if(length(type) > 1) {
    warning("using only the first element of type");
  };
  
  
  
  
  
  convention = enumToInteger(convention, "_BusinessDayConvention"); 
  
  if(length(convention) > 1) {
    warning("using only the first element of convention");
  };
  
  
  
  
  
  adjustInfObsDates = as.logical(adjustInfObsDates);
  
  ;ans = .Call('R_swig_new_ZeroCouponInflationSwap__SWIG_1', type, nominal, start, maturity, calendar, convention, dayCounter, fixedRate, index, lag, adjustInfObsDates, infCalendar, PACKAGE='QuantLib');
  class(ans) <- "_p_ZeroCouponInflationSwapPtr";
  
  reg.finalizer(ans, delete_ZeroCouponInflationSwap)
  ans
  
}

attr(`ZeroCouponInflationSwap__SWIG_1`, 'returnType') = '_p_ZeroCouponInflationSwapPtr'
attr(`ZeroCouponInflationSwap__SWIG_1`, "inputTypes") = c('character', 'numeric', '_p_Date', '_p_Date', '_p_Calendar', 'character', '_p_DayCounter', 'numeric', '_p_ZeroInflationIndexPtr', '_p_Period', 'logical', '_p_Calendar')
class(`ZeroCouponInflationSwap__SWIG_1`) = c("SWIGFunction", class('ZeroCouponInflationSwap__SWIG_1'))

# Start of new_ZeroCouponInflationSwap

`ZeroCouponInflationSwap__SWIG_2` = function(type, nominal, start, maturity, calendar, convention, dayCounter, fixedRate, index, lag, adjustInfObsDates)
{
  type = enumToInteger(type, "_ZeroCouponInflationSwap__Type"); 
  
  if(length(type) > 1) {
    warning("using only the first element of type");
  };
  
  
  
  
  
  convention = enumToInteger(convention, "_BusinessDayConvention"); 
  
  if(length(convention) > 1) {
    warning("using only the first element of convention");
  };
  
  
  
  
  
  adjustInfObsDates = as.logical(adjustInfObsDates);
  ;ans = .Call('R_swig_new_ZeroCouponInflationSwap__SWIG_2', type, nominal, start, maturity, calendar, convention, dayCounter, fixedRate, index, lag, adjustInfObsDates, PACKAGE='QuantLib');
  class(ans) <- "_p_ZeroCouponInflationSwapPtr";
  
  reg.finalizer(ans, delete_ZeroCouponInflationSwap)
  ans
  
}

attr(`ZeroCouponInflationSwap__SWIG_2`, 'returnType') = '_p_ZeroCouponInflationSwapPtr'
attr(`ZeroCouponInflationSwap__SWIG_2`, "inputTypes") = c('character', 'numeric', '_p_Date', '_p_Date', '_p_Calendar', 'character', '_p_DayCounter', 'numeric', '_p_ZeroInflationIndexPtr', '_p_Period', 'logical')
class(`ZeroCouponInflationSwap__SWIG_2`) = c("SWIGFunction", class('ZeroCouponInflationSwap__SWIG_2'))

# Start of new_ZeroCouponInflationSwap

`ZeroCouponInflationSwap__SWIG_3` = function(type, nominal, start, maturity, calendar, convention, dayCounter, fixedRate, index, lag)
{
  type = enumToInteger(type, "_ZeroCouponInflationSwap__Type"); 
  
  if(length(type) > 1) {
    warning("using only the first element of type");
  };
  
  
  
  
  
  convention = enumToInteger(convention, "_BusinessDayConvention"); 
  
  if(length(convention) > 1) {
    warning("using only the first element of convention");
  };
  
  
  
  
  
  ;ans = .Call('R_swig_new_ZeroCouponInflationSwap__SWIG_3', type, nominal, start, maturity, calendar, convention, dayCounter, fixedRate, index, lag, PACKAGE='QuantLib');
  class(ans) <- "_p_ZeroCouponInflationSwapPtr";
  
  reg.finalizer(ans, delete_ZeroCouponInflationSwap)
  ans
  
}

attr(`ZeroCouponInflationSwap__SWIG_3`, 'returnType') = '_p_ZeroCouponInflationSwapPtr'
attr(`ZeroCouponInflationSwap__SWIG_3`, "inputTypes") = c('character', 'numeric', '_p_Date', '_p_Date', '_p_Calendar', 'character', '_p_DayCounter', 'numeric', '_p_ZeroInflationIndexPtr', '_p_Period')
class(`ZeroCouponInflationSwap__SWIG_3`) = c("SWIGFunction", class('ZeroCouponInflationSwap__SWIG_3'))

`ZeroCouponInflationSwap` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 10) {
    if (is.character(argv[[1]]) && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_Date') && extends(argtypes[4], '_p_Date') && extends(argtypes[5], '_p_Calendar') && is.character(argv[[6]]) && extends(argtypes[7], '_p_DayCounter') && is.numeric(argv[[8]]) && extends(argtypes[9], '_p_ZeroInflationIndexPtr') && extends(argtypes[10], '_p_Period')) {
      f <- ZeroCouponInflationSwap__SWIG_3; 
    }
  } else if (argc == 11) {
    if (is.character(argv[[1]]) && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_Date') && extends(argtypes[4], '_p_Date') && extends(argtypes[5], '_p_Calendar') && is.character(argv[[6]]) && extends(argtypes[7], '_p_DayCounter') && is.numeric(argv[[8]]) && extends(argtypes[9], '_p_ZeroInflationIndexPtr') && extends(argtypes[10], '_p_Period') && extends(argtypes[11], 'logical')) {
      f <- ZeroCouponInflationSwap__SWIG_2; 
    }
  } else if (argc == 12) {
    if (is.character(argv[[1]]) && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_Date') && extends(argtypes[4], '_p_Date') && extends(argtypes[5], '_p_Calendar') && is.character(argv[[6]]) && extends(argtypes[7], '_p_DayCounter') && is.numeric(argv[[8]]) && extends(argtypes[9], '_p_ZeroInflationIndexPtr') && extends(argtypes[10], '_p_Period') && extends(argtypes[11], 'logical') && extends(argtypes[12], '_p_Calendar')) {
      f <- ZeroCouponInflationSwap__SWIG_1; 
    }
  } else if (argc == 13) {
    if (is.character(argv[[1]]) && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_Date') && extends(argtypes[4], '_p_Date') && extends(argtypes[5], '_p_Calendar') && is.character(argv[[6]]) && extends(argtypes[7], '_p_DayCounter') && is.numeric(argv[[8]]) && extends(argtypes[9], '_p_ZeroInflationIndexPtr') && extends(argtypes[10], '_p_Period') && extends(argtypes[11], 'logical') && extends(argtypes[12], '_p_Calendar') && is.character(argv[[13]])) {
      f <- ZeroCouponInflationSwap__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for ZeroCouponInflationSwap with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of ZeroCouponInflationSwap_fairRate

`ZeroCouponInflationSwap_fairRate` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_ZeroCouponInflationSwap_fairRate', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`ZeroCouponInflationSwap_fairRate`, 'returnType') = 'numeric'
attr(`ZeroCouponInflationSwap_fairRate`, "inputTypes") = c('_p_ZeroCouponInflationSwapPtr')
class(`ZeroCouponInflationSwap_fairRate`) = c("SWIGFunction", class('ZeroCouponInflationSwap_fairRate'))

# Start of delete_ZeroCouponInflationSwap

`delete_ZeroCouponInflationSwap` = function(self)
{
  ;.Call('R_swig_delete_ZeroCouponInflationSwap', self, PACKAGE='QuantLib');
  
}

attr(`delete_ZeroCouponInflationSwap`, 'returnType') = 'void'
attr(`delete_ZeroCouponInflationSwap`, "inputTypes") = c('_p_ZeroCouponInflationSwapPtr')
class(`delete_ZeroCouponInflationSwap`) = c("SWIGFunction", class('delete_ZeroCouponInflationSwap'))

# Start of accessor method for ZeroCouponInflationSwapPtr
setMethod('$', '_p_ZeroCouponInflationSwapPtr', function(x, name)

{
  accessorFuns = list('fairRate' = ZeroCouponInflationSwap_fairRate);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for ZeroCouponInflationSwapPtr
setMethod('delete', '_p_ZeroCouponInflationSwapPtr', function(obj) {delete_ZeroCouponInflationSwapPtr(obj)})
# Start of new_YearOnYearInflationSwap

`YearOnYearInflationSwap__SWIG_0` = function(type, nominal, fixedSchedule, fixedRate, fixedDayCounter, yoySchedule, index, lag, spread, yoyDayCounter, paymentCalendar, paymentConvention)
{
  type = enumToInteger(type, "_YearOnYearInflationSwap__Type"); 
  
  if(length(type) > 1) {
    warning("using only the first element of type");
  };
  
  
  
  
  
  
  
  
  
  
  
  paymentConvention = enumToInteger(paymentConvention, "_BusinessDayConvention"); 
  
  if(length(paymentConvention) > 1) {
    warning("using only the first element of paymentConvention");
  };
  
  ;ans = .Call('R_swig_new_YearOnYearInflationSwap__SWIG_0', type, nominal, fixedSchedule, fixedRate, fixedDayCounter, yoySchedule, index, lag, spread, yoyDayCounter, paymentCalendar, paymentConvention, PACKAGE='QuantLib');
  class(ans) <- "_p_YearOnYearInflationSwapPtr";
  
  reg.finalizer(ans, delete_YearOnYearInflationSwap)
  ans
  
}

attr(`YearOnYearInflationSwap__SWIG_0`, 'returnType') = '_p_YearOnYearInflationSwapPtr'
attr(`YearOnYearInflationSwap__SWIG_0`, "inputTypes") = c('character', 'numeric', '_p_Schedule', 'numeric', '_p_DayCounter', '_p_Schedule', '_p_YoYInflationIndexPtr', '_p_Period', 'numeric', '_p_DayCounter', '_p_Calendar', 'character')
class(`YearOnYearInflationSwap__SWIG_0`) = c("SWIGFunction", class('YearOnYearInflationSwap__SWIG_0'))

# Start of new_YearOnYearInflationSwap

`YearOnYearInflationSwap__SWIG_1` = function(type, nominal, fixedSchedule, fixedRate, fixedDayCounter, yoySchedule, index, lag, spread, yoyDayCounter, paymentCalendar)
{
  type = enumToInteger(type, "_YearOnYearInflationSwap__Type"); 
  
  if(length(type) > 1) {
    warning("using only the first element of type");
  };
  
  
  
  
  
  
  
  
  
  
  
  ;ans = .Call('R_swig_new_YearOnYearInflationSwap__SWIG_1', type, nominal, fixedSchedule, fixedRate, fixedDayCounter, yoySchedule, index, lag, spread, yoyDayCounter, paymentCalendar, PACKAGE='QuantLib');
  class(ans) <- "_p_YearOnYearInflationSwapPtr";
  
  reg.finalizer(ans, delete_YearOnYearInflationSwap)
  ans
  
}

attr(`YearOnYearInflationSwap__SWIG_1`, 'returnType') = '_p_YearOnYearInflationSwapPtr'
attr(`YearOnYearInflationSwap__SWIG_1`, "inputTypes") = c('character', 'numeric', '_p_Schedule', 'numeric', '_p_DayCounter', '_p_Schedule', '_p_YoYInflationIndexPtr', '_p_Period', 'numeric', '_p_DayCounter', '_p_Calendar')
class(`YearOnYearInflationSwap__SWIG_1`) = c("SWIGFunction", class('YearOnYearInflationSwap__SWIG_1'))

`YearOnYearInflationSwap` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 11) {
    if (is.character(argv[[1]]) && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_Schedule') && is.numeric(argv[[4]]) && extends(argtypes[5], '_p_DayCounter') && extends(argtypes[6], '_p_Schedule') && extends(argtypes[7], '_p_YoYInflationIndexPtr') && extends(argtypes[8], '_p_Period') && is.numeric(argv[[9]]) && extends(argtypes[10], '_p_DayCounter') && extends(argtypes[11], '_p_Calendar')) {
      f <- YearOnYearInflationSwap__SWIG_1; 
    }
  } else if (argc == 12) {
    if (is.character(argv[[1]]) && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_Schedule') && is.numeric(argv[[4]]) && extends(argtypes[5], '_p_DayCounter') && extends(argtypes[6], '_p_Schedule') && extends(argtypes[7], '_p_YoYInflationIndexPtr') && extends(argtypes[8], '_p_Period') && is.numeric(argv[[9]]) && extends(argtypes[10], '_p_DayCounter') && extends(argtypes[11], '_p_Calendar') && is.character(argv[[12]])) {
      f <- YearOnYearInflationSwap__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for YearOnYearInflationSwap with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of YearOnYearInflationSwap_fairRate

`YearOnYearInflationSwap_fairRate` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_YearOnYearInflationSwap_fairRate', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`YearOnYearInflationSwap_fairRate`, 'returnType') = 'numeric'
attr(`YearOnYearInflationSwap_fairRate`, "inputTypes") = c('_p_YearOnYearInflationSwapPtr')
class(`YearOnYearInflationSwap_fairRate`) = c("SWIGFunction", class('YearOnYearInflationSwap_fairRate'))

# Start of delete_YearOnYearInflationSwap

`delete_YearOnYearInflationSwap` = function(self)
{
  ;.Call('R_swig_delete_YearOnYearInflationSwap', self, PACKAGE='QuantLib');
  
}

attr(`delete_YearOnYearInflationSwap`, 'returnType') = 'void'
attr(`delete_YearOnYearInflationSwap`, "inputTypes") = c('_p_YearOnYearInflationSwapPtr')
class(`delete_YearOnYearInflationSwap`) = c("SWIGFunction", class('delete_YearOnYearInflationSwap'))

# Start of accessor method for YearOnYearInflationSwapPtr
setMethod('$', '_p_YearOnYearInflationSwapPtr', function(x, name)

{
  accessorFuns = list('fairRate' = YearOnYearInflationSwap_fairRate);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for YearOnYearInflationSwapPtr
setMethod('delete', '_p_YearOnYearInflationSwapPtr', function(obj) {delete_YearOnYearInflationSwapPtr(obj)})
# Start of YoYInflationCapFloor_impliedVolatility

`YoYInflationCapFloor_impliedVolatility__SWIG_0` = function(self, price, curve, guess, accuracy, maxEvaluations, minVol, maxVol, .copy = FALSE)
{
  if(length(maxEvaluations) > 1) {
    warning("using only the first element of maxEvaluations");
  };
  
  
  
  ;.Call('R_swig_YoYInflationCapFloor_impliedVolatility__SWIG_0', self, price, curve, guess, accuracy, maxEvaluations, minVol, maxVol, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`YoYInflationCapFloor_impliedVolatility__SWIG_0`, 'returnType') = 'numeric'
attr(`YoYInflationCapFloor_impliedVolatility__SWIG_0`, "inputTypes") = c('_p_YoYInflationCapFloorPtr', 'numeric', '_p_HandleT_YoYInflationTermStructure_t', 'numeric', 'numeric', 'integer', 'numeric', 'numeric')
class(`YoYInflationCapFloor_impliedVolatility__SWIG_0`) = c("SWIGFunction", class('YoYInflationCapFloor_impliedVolatility__SWIG_0'))

# Start of YoYInflationCapFloor_impliedVolatility

`YoYInflationCapFloor_impliedVolatility__SWIG_1` = function(self, price, curve, guess, accuracy, maxEvaluations, minVol, .copy = FALSE)
{
  if(length(maxEvaluations) > 1) {
    warning("using only the first element of maxEvaluations");
  };
  
  
  ;.Call('R_swig_YoYInflationCapFloor_impliedVolatility__SWIG_1', self, price, curve, guess, accuracy, maxEvaluations, minVol, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`YoYInflationCapFloor_impliedVolatility__SWIG_1`, 'returnType') = 'numeric'
attr(`YoYInflationCapFloor_impliedVolatility__SWIG_1`, "inputTypes") = c('_p_YoYInflationCapFloorPtr', 'numeric', '_p_HandleT_YoYInflationTermStructure_t', 'numeric', 'numeric', 'integer', 'numeric')
class(`YoYInflationCapFloor_impliedVolatility__SWIG_1`) = c("SWIGFunction", class('YoYInflationCapFloor_impliedVolatility__SWIG_1'))

# Start of YoYInflationCapFloor_impliedVolatility

`YoYInflationCapFloor_impliedVolatility__SWIG_2` = function(self, price, curve, guess, accuracy, maxEvaluations, .copy = FALSE)
{
  if(length(maxEvaluations) > 1) {
    warning("using only the first element of maxEvaluations");
  };
  
  ;.Call('R_swig_YoYInflationCapFloor_impliedVolatility__SWIG_2', self, price, curve, guess, accuracy, maxEvaluations, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`YoYInflationCapFloor_impliedVolatility__SWIG_2`, 'returnType') = 'numeric'
attr(`YoYInflationCapFloor_impliedVolatility__SWIG_2`, "inputTypes") = c('_p_YoYInflationCapFloorPtr', 'numeric', '_p_HandleT_YoYInflationTermStructure_t', 'numeric', 'numeric', 'integer')
class(`YoYInflationCapFloor_impliedVolatility__SWIG_2`) = c("SWIGFunction", class('YoYInflationCapFloor_impliedVolatility__SWIG_2'))

# Start of YoYInflationCapFloor_impliedVolatility

`YoYInflationCapFloor_impliedVolatility__SWIG_3` = function(self, price, curve, guess, accuracy, .copy = FALSE)
{
  ;.Call('R_swig_YoYInflationCapFloor_impliedVolatility__SWIG_3', self, price, curve, guess, accuracy, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`YoYInflationCapFloor_impliedVolatility__SWIG_3`, 'returnType') = 'numeric'
attr(`YoYInflationCapFloor_impliedVolatility__SWIG_3`, "inputTypes") = c('_p_YoYInflationCapFloorPtr', 'numeric', '_p_HandleT_YoYInflationTermStructure_t', 'numeric', 'numeric')
class(`YoYInflationCapFloor_impliedVolatility__SWIG_3`) = c("SWIGFunction", class('YoYInflationCapFloor_impliedVolatility__SWIG_3'))

# Start of YoYInflationCapFloor_impliedVolatility

`YoYInflationCapFloor_impliedVolatility__SWIG_4` = function(self, price, curve, guess, .copy = FALSE)
{
  ;.Call('R_swig_YoYInflationCapFloor_impliedVolatility__SWIG_4', self, price, curve, guess, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`YoYInflationCapFloor_impliedVolatility__SWIG_4`, 'returnType') = 'numeric'
attr(`YoYInflationCapFloor_impliedVolatility__SWIG_4`, "inputTypes") = c('_p_YoYInflationCapFloorPtr', 'numeric', '_p_HandleT_YoYInflationTermStructure_t', 'numeric')
class(`YoYInflationCapFloor_impliedVolatility__SWIG_4`) = c("SWIGFunction", class('YoYInflationCapFloor_impliedVolatility__SWIG_4'))

`YoYInflationCapFloor_impliedVolatility` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 5
  if (argc == 4) {
    if (extends(argtypes[1], '_p_YoYInflationCapFloorPtr') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_HandleT_YoYInflationTermStructure_t') && is.numeric(argv[[4]])) {
      f <- YoYInflationCapFloor_impliedVolatility__SWIG_4; 
    }
  } else if (argc == 5) {
    if (extends(argtypes[1], '_p_YoYInflationCapFloorPtr') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_HandleT_YoYInflationTermStructure_t') && is.numeric(argv[[4]]) && is.numeric(argv[[5]])) {
      f <- YoYInflationCapFloor_impliedVolatility__SWIG_3; 
    }
  } else if (argc == 6) {
    if (extends(argtypes[1], '_p_YoYInflationCapFloorPtr') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_HandleT_YoYInflationTermStructure_t') && is.numeric(argv[[4]]) && is.numeric(argv[[5]]) && (is.integer(argv[[6]]) || is.numeric(argv[[6]]))) {
      f <- YoYInflationCapFloor_impliedVolatility__SWIG_2; 
    }
  } else if (argc == 7) {
    if (extends(argtypes[1], '_p_YoYInflationCapFloorPtr') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_HandleT_YoYInflationTermStructure_t') && is.numeric(argv[[4]]) && is.numeric(argv[[5]]) && (is.integer(argv[[6]]) || is.numeric(argv[[6]])) && is.numeric(argv[[7]])) {
      f <- YoYInflationCapFloor_impliedVolatility__SWIG_1; 
    }
  } else if (argc == 8) {
    if (extends(argtypes[1], '_p_YoYInflationCapFloorPtr') && is.numeric(argv[[2]]) && extends(argtypes[3], '_p_HandleT_YoYInflationTermStructure_t') && is.numeric(argv[[4]]) && is.numeric(argv[[5]]) && (is.integer(argv[[6]]) || is.numeric(argv[[6]])) && is.numeric(argv[[7]]) && is.numeric(argv[[8]])) {
      f <- YoYInflationCapFloor_impliedVolatility__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for YoYInflationCapFloor_impliedVolatility with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of new_YoYInflationCapFloor

`YoYInflationCapFloor` = function()
{
  ;ans = .Call('R_swig_new_YoYInflationCapFloor', PACKAGE='QuantLib');
  class(ans) <- "_p_YoYInflationCapFloorPtr";
  
  reg.finalizer(ans, delete_YoYInflationCapFloor)
  ans
  
}

attr(`YoYInflationCapFloor`, 'returnType') = '_p_YoYInflationCapFloorPtr'
class(`YoYInflationCapFloor`) = c("SWIGFunction", class('YoYInflationCapFloor'))

# Start of delete_YoYInflationCapFloor

`delete_YoYInflationCapFloor` = function(self)
{
  ;.Call('R_swig_delete_YoYInflationCapFloor', self, PACKAGE='QuantLib');
  
}

attr(`delete_YoYInflationCapFloor`, 'returnType') = 'void'
attr(`delete_YoYInflationCapFloor`, "inputTypes") = c('_p_YoYInflationCapFloorPtr')
class(`delete_YoYInflationCapFloor`) = c("SWIGFunction", class('delete_YoYInflationCapFloor'))

# Start of accessor method for YoYInflationCapFloorPtr
setMethod('$', '_p_YoYInflationCapFloorPtr', function(x, name)

{
  accessorFuns = list('impliedVolatility' = YoYInflationCapFloor_impliedVolatility);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for YoYInflationCapFloorPtr
setMethod('delete', '_p_YoYInflationCapFloorPtr', function(obj) {delete_YoYInflationCapFloorPtr(obj)})
# Start of new_YoYInflationCap

`YoYInflationCap` = function(leg, capRates)
{
  ;ans = .Call('R_swig_new_YoYInflationCap', leg, capRates, PACKAGE='QuantLib');
  class(ans) <- "_p_YoYInflationCapPtr";
  
  reg.finalizer(ans, delete_YoYInflationCap)
  ans
  
}

attr(`YoYInflationCap`, 'returnType') = '_p_YoYInflationCapPtr'
attr(`YoYInflationCap`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`YoYInflationCap`) = c("SWIGFunction", class('YoYInflationCap'))

# Start of delete_YoYInflationCap

`delete_YoYInflationCap` = function(self)
{
  ;.Call('R_swig_delete_YoYInflationCap', self, PACKAGE='QuantLib');
  
}

attr(`delete_YoYInflationCap`, 'returnType') = 'void'
attr(`delete_YoYInflationCap`, "inputTypes") = c('_p_YoYInflationCapPtr')
class(`delete_YoYInflationCap`) = c("SWIGFunction", class('delete_YoYInflationCap'))

setMethod('delete', '_p_YoYInflationCapPtr', function(obj) {delete_YoYInflationCapPtr(obj)})
# Start of new_YoYInflationFloor

`YoYInflationFloor` = function(leg, floorRates)
{
  ;ans = .Call('R_swig_new_YoYInflationFloor', leg, floorRates, PACKAGE='QuantLib');
  class(ans) <- "_p_YoYInflationFloorPtr";
  
  reg.finalizer(ans, delete_YoYInflationFloor)
  ans
  
}

attr(`YoYInflationFloor`, 'returnType') = '_p_YoYInflationFloorPtr'
attr(`YoYInflationFloor`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`YoYInflationFloor`) = c("SWIGFunction", class('YoYInflationFloor'))

# Start of delete_YoYInflationFloor

`delete_YoYInflationFloor` = function(self)
{
  ;.Call('R_swig_delete_YoYInflationFloor', self, PACKAGE='QuantLib');
  
}

attr(`delete_YoYInflationFloor`, 'returnType') = 'void'
attr(`delete_YoYInflationFloor`, "inputTypes") = c('_p_YoYInflationFloorPtr')
class(`delete_YoYInflationFloor`) = c("SWIGFunction", class('delete_YoYInflationFloor'))

setMethod('delete', '_p_YoYInflationFloorPtr', function(obj) {delete_YoYInflationFloorPtr(obj)})
# Start of new_YoYInflationCollar

`YoYInflationCollar` = function(leg, capRates, floorRates)
{
  ;ans = .Call('R_swig_new_YoYInflationCollar', leg, capRates, floorRates, PACKAGE='QuantLib');
  class(ans) <- "_p_YoYInflationCollarPtr";
  
  reg.finalizer(ans, delete_YoYInflationCollar)
  ans
  
}

attr(`YoYInflationCollar`, 'returnType') = '_p_YoYInflationCollarPtr'
attr(`YoYInflationCollar`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`YoYInflationCollar`) = c("SWIGFunction", class('YoYInflationCollar'))

# Start of delete_YoYInflationCollar

`delete_YoYInflationCollar` = function(self)
{
  ;.Call('R_swig_delete_YoYInflationCollar', self, PACKAGE='QuantLib');
  
}

attr(`delete_YoYInflationCollar`, 'returnType') = 'void'
attr(`delete_YoYInflationCollar`, "inputTypes") = c('_p_YoYInflationCollarPtr')
class(`delete_YoYInflationCollar`) = c("SWIGFunction", class('delete_YoYInflationCollar'))

setMethod('delete', '_p_YoYInflationCollarPtr', function(obj) {delete_YoYInflationCollarPtr(obj)})
# Start of new_SegmentIntegral

`SegmentIntegral` = function(intervals)
{
  if(length(intervals) > 1) {
    warning("using only the first element of intervals");
  };
  
  ;ans = .Call('R_swig_new_SegmentIntegral', intervals, PACKAGE='QuantLib');
  class(ans) <- "_p_SegmentIntegral";
  
  reg.finalizer(ans, delete_SegmentIntegral)
  ans
  
}

attr(`SegmentIntegral`, 'returnType') = '_p_SegmentIntegral'
attr(`SegmentIntegral`, "inputTypes") = c('integer')
class(`SegmentIntegral`) = c("SWIGFunction", class('SegmentIntegral'))

# Start of delete_SegmentIntegral

`delete_SegmentIntegral` = function(self)
{
  ;.Call('R_swig_delete_SegmentIntegral', self, PACKAGE='QuantLib');
  
}

attr(`delete_SegmentIntegral`, 'returnType') = 'void'
attr(`delete_SegmentIntegral`, "inputTypes") = c('_p_SegmentIntegral')
class(`delete_SegmentIntegral`) = c("SWIGFunction", class('delete_SegmentIntegral'))

setMethod('delete', '_p_SegmentIntegral', function(obj) {delete_SegmentIntegral(obj)})
# Start of new_TrapezoidIntegralDefault

`TrapezoidIntegralDefault` = function(accuracy, maxIterations)
{
  if(length(maxIterations) > 1) {
    warning("using only the first element of maxIterations");
  };
  
  ;ans = .Call('R_swig_new_TrapezoidIntegralDefault', accuracy, maxIterations, PACKAGE='QuantLib');
  class(ans) <- "_p_TrapezoidIntegralT_Default_t";
  
  reg.finalizer(ans, delete_TrapezoidIntegralDefault)
  ans
  
}

attr(`TrapezoidIntegralDefault`, 'returnType') = '_p_TrapezoidIntegralT_Default_t'
attr(`TrapezoidIntegralDefault`, "inputTypes") = c('numeric', 'integer')
class(`TrapezoidIntegralDefault`) = c("SWIGFunction", class('TrapezoidIntegralDefault'))

# Start of delete_TrapezoidIntegralDefault

`delete_TrapezoidIntegralDefault` = function(self)
{
  ;.Call('R_swig_delete_TrapezoidIntegralDefault', self, PACKAGE='QuantLib');
  
}

attr(`delete_TrapezoidIntegralDefault`, 'returnType') = 'void'
attr(`delete_TrapezoidIntegralDefault`, "inputTypes") = c('_p_TrapezoidIntegralT_Default_t')
class(`delete_TrapezoidIntegralDefault`) = c("SWIGFunction", class('delete_TrapezoidIntegralDefault'))

setMethod('delete', '_p_TrapezoidIntegralT_Default_t', function(obj) {delete_TrapezoidIntegralT_Default_t(obj)})
# Start of new_TrapezoidIntegralMidPoint

`TrapezoidIntegralMidPoint` = function(accuracy, maxIterations)
{
  if(length(maxIterations) > 1) {
    warning("using only the first element of maxIterations");
  };
  
  ;ans = .Call('R_swig_new_TrapezoidIntegralMidPoint', accuracy, maxIterations, PACKAGE='QuantLib');
  class(ans) <- "_p_TrapezoidIntegralT_MidPoint_t";
  
  reg.finalizer(ans, delete_TrapezoidIntegralMidPoint)
  ans
  
}

attr(`TrapezoidIntegralMidPoint`, 'returnType') = '_p_TrapezoidIntegralT_MidPoint_t'
attr(`TrapezoidIntegralMidPoint`, "inputTypes") = c('numeric', 'integer')
class(`TrapezoidIntegralMidPoint`) = c("SWIGFunction", class('TrapezoidIntegralMidPoint'))

# Start of delete_TrapezoidIntegralMidPoint

`delete_TrapezoidIntegralMidPoint` = function(self)
{
  ;.Call('R_swig_delete_TrapezoidIntegralMidPoint', self, PACKAGE='QuantLib');
  
}

attr(`delete_TrapezoidIntegralMidPoint`, 'returnType') = 'void'
attr(`delete_TrapezoidIntegralMidPoint`, "inputTypes") = c('_p_TrapezoidIntegralT_MidPoint_t')
class(`delete_TrapezoidIntegralMidPoint`) = c("SWIGFunction", class('delete_TrapezoidIntegralMidPoint'))

setMethod('delete', '_p_TrapezoidIntegralT_MidPoint_t', function(obj) {delete_TrapezoidIntegralT_MidPoint_t(obj)})
# Start of new_SimpsonIntegral

`SimpsonIntegral` = function(accuracy, maxIterations)
{
  if(length(maxIterations) > 1) {
    warning("using only the first element of maxIterations");
  };
  
  ;ans = .Call('R_swig_new_SimpsonIntegral', accuracy, maxIterations, PACKAGE='QuantLib');
  class(ans) <- "_p_SimpsonIntegral";
  
  reg.finalizer(ans, delete_SimpsonIntegral)
  ans
  
}

attr(`SimpsonIntegral`, 'returnType') = '_p_SimpsonIntegral'
attr(`SimpsonIntegral`, "inputTypes") = c('numeric', 'integer')
class(`SimpsonIntegral`) = c("SWIGFunction", class('SimpsonIntegral'))

# Start of delete_SimpsonIntegral

`delete_SimpsonIntegral` = function(self)
{
  ;.Call('R_swig_delete_SimpsonIntegral', self, PACKAGE='QuantLib');
  
}

attr(`delete_SimpsonIntegral`, 'returnType') = 'void'
attr(`delete_SimpsonIntegral`, "inputTypes") = c('_p_SimpsonIntegral')
class(`delete_SimpsonIntegral`) = c("SWIGFunction", class('delete_SimpsonIntegral'))

setMethod('delete', '_p_SimpsonIntegral', function(obj) {delete_SimpsonIntegral(obj)})
# Start of new_GaussKronrodAdaptive

`GaussKronrodAdaptive__SWIG_0` = function(tolerance, maxFunctionEvaluations)
{
  if(length(maxFunctionEvaluations) > 1) {
    warning("using only the first element of maxFunctionEvaluations");
  };
  
  ;ans = .Call('R_swig_new_GaussKronrodAdaptive__SWIG_0', tolerance, maxFunctionEvaluations, PACKAGE='QuantLib');
  class(ans) <- "_p_GaussKronrodAdaptive";
  
  reg.finalizer(ans, delete_GaussKronrodAdaptive)
  ans
  
}

attr(`GaussKronrodAdaptive__SWIG_0`, 'returnType') = '_p_GaussKronrodAdaptive'
attr(`GaussKronrodAdaptive__SWIG_0`, "inputTypes") = c('numeric', 'integer')
class(`GaussKronrodAdaptive__SWIG_0`) = c("SWIGFunction", class('GaussKronrodAdaptive__SWIG_0'))

# Start of new_GaussKronrodAdaptive

`GaussKronrodAdaptive__SWIG_1` = function(tolerance)
{
  ;ans = .Call('R_swig_new_GaussKronrodAdaptive__SWIG_1', tolerance, PACKAGE='QuantLib');
  class(ans) <- "_p_GaussKronrodAdaptive";
  
  reg.finalizer(ans, delete_GaussKronrodAdaptive)
  ans
  
}

attr(`GaussKronrodAdaptive__SWIG_1`, 'returnType') = '_p_GaussKronrodAdaptive'
attr(`GaussKronrodAdaptive__SWIG_1`, "inputTypes") = c('numeric')
class(`GaussKronrodAdaptive__SWIG_1`) = c("SWIGFunction", class('GaussKronrodAdaptive__SWIG_1'))

`GaussKronrodAdaptive` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (is.numeric(argv[[1]])) {
      f <- GaussKronrodAdaptive__SWIG_1; 
    }
  } else if (argc == 2) {
    if (is.numeric(argv[[1]]) && (is.integer(argv[[2]]) || is.numeric(argv[[2]]))) {
      f <- GaussKronrodAdaptive__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for GaussKronrodAdaptive with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_GaussKronrodAdaptive

`delete_GaussKronrodAdaptive` = function(self)
{
  ;.Call('R_swig_delete_GaussKronrodAdaptive', self, PACKAGE='QuantLib');
  
}

attr(`delete_GaussKronrodAdaptive`, 'returnType') = 'void'
attr(`delete_GaussKronrodAdaptive`, "inputTypes") = c('_p_GaussKronrodAdaptive')
class(`delete_GaussKronrodAdaptive`) = c("SWIGFunction", class('delete_GaussKronrodAdaptive'))

setMethod('delete', '_p_GaussKronrodAdaptive', function(obj) {delete_GaussKronrodAdaptive(obj)})
# Start of new_GaussKronrodNonAdaptive

`GaussKronrodNonAdaptive` = function(absoluteAccuracy, maxEvaluations, relativeAccuracy)
{
  if(length(maxEvaluations) > 1) {
    warning("using only the first element of maxEvaluations");
  };
  
  
  ;ans = .Call('R_swig_new_GaussKronrodNonAdaptive', absoluteAccuracy, maxEvaluations, relativeAccuracy, PACKAGE='QuantLib');
  class(ans) <- "_p_GaussKronrodNonAdaptive";
  
  reg.finalizer(ans, delete_GaussKronrodNonAdaptive)
  ans
  
}

attr(`GaussKronrodNonAdaptive`, 'returnType') = '_p_GaussKronrodNonAdaptive'
attr(`GaussKronrodNonAdaptive`, "inputTypes") = c('numeric', 'integer', 'numeric')
class(`GaussKronrodNonAdaptive`) = c("SWIGFunction", class('GaussKronrodNonAdaptive'))

# Start of delete_GaussKronrodNonAdaptive

`delete_GaussKronrodNonAdaptive` = function(self)
{
  ;.Call('R_swig_delete_GaussKronrodNonAdaptive', self, PACKAGE='QuantLib');
  
}

attr(`delete_GaussKronrodNonAdaptive`, 'returnType') = 'void'
attr(`delete_GaussKronrodNonAdaptive`, "inputTypes") = c('_p_GaussKronrodNonAdaptive')
class(`delete_GaussKronrodNonAdaptive`) = c("SWIGFunction", class('delete_GaussKronrodNonAdaptive'))

setMethod('delete', '_p_GaussKronrodNonAdaptive', function(obj) {delete_GaussKronrodNonAdaptive(obj)})
# Start of SampleNumber_value

`SampleNumber_value` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_SampleNumber_value', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`SampleNumber_value`, 'returnType') = 'numeric'
attr(`SampleNumber_value`, "inputTypes") = c('_p_SampleT_double_t')
class(`SampleNumber_value`) = c("SWIGFunction", class('SampleNumber_value'))

# Start of SampleNumber_weight

`SampleNumber_weight` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_SampleNumber_weight', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`SampleNumber_weight`, 'returnType') = 'numeric'
attr(`SampleNumber_weight`, "inputTypes") = c('_p_SampleT_double_t')
class(`SampleNumber_weight`) = c("SWIGFunction", class('SampleNumber_weight'))

# Start of delete_SampleNumber

`delete_SampleNumber` = function(self)
{
  ;.Call('R_swig_delete_SampleNumber', self, PACKAGE='QuantLib');
  
}

attr(`delete_SampleNumber`, 'returnType') = 'void'
attr(`delete_SampleNumber`, "inputTypes") = c('_p_SampleT_double_t')
class(`delete_SampleNumber`) = c("SWIGFunction", class('delete_SampleNumber'))

# Start of accessor method for Sample<(Real)>
setMethod('$', '_p_SampleT_double_t', function(x, name)

{
  accessorFuns = list('value' = SampleNumber_value, 'weight' = SampleNumber_weight);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for Sample<(Real)>
setMethod('delete', '_p_SampleT_double_t', function(obj) {delete_SampleT_double_t(obj)})
# Start of SampleArray_value

`SampleArray_value` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_SampleArray_value', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Array";
  
  ans
  
}

attr(`SampleArray_value`, 'returnType') = '_p_Array'
attr(`SampleArray_value`, "inputTypes") = c('_p_SampleT_Array_t')
class(`SampleArray_value`) = c("SWIGFunction", class('SampleArray_value'))

# Start of SampleArray_weight

`SampleArray_weight` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_SampleArray_weight', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`SampleArray_weight`, 'returnType') = 'numeric'
attr(`SampleArray_weight`, "inputTypes") = c('_p_SampleT_Array_t')
class(`SampleArray_weight`) = c("SWIGFunction", class('SampleArray_weight'))

# Start of delete_SampleArray

`delete_SampleArray` = function(self)
{
  ;.Call('R_swig_delete_SampleArray', self, PACKAGE='QuantLib');
  
}

attr(`delete_SampleArray`, 'returnType') = 'void'
attr(`delete_SampleArray`, "inputTypes") = c('_p_SampleT_Array_t')
class(`delete_SampleArray`) = c("SWIGFunction", class('delete_SampleArray'))

# Start of accessor method for Sample<(Array)>
setMethod('$', '_p_SampleT_Array_t', function(x, name)

{
  accessorFuns = list('value' = SampleArray_value, 'weight' = SampleArray_weight);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for Sample<(Array)>
setMethod('delete', '_p_SampleT_Array_t', function(obj) {delete_SampleT_Array_t(obj)})
# Start of SampleRealVector_value

`SampleRealVector_value` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_SampleRealVector_value', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_double_std__allocatorT_double_t_t";
  
  ans
  
}

attr(`SampleRealVector_value`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`SampleRealVector_value`, "inputTypes") = c('_p_SampleT_std__vectorT_double_std__allocatorT_double_t_t_t')
class(`SampleRealVector_value`) = c("SWIGFunction", class('SampleRealVector_value'))

# Start of SampleRealVector_weight

`SampleRealVector_weight` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_SampleRealVector_weight', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`SampleRealVector_weight`, 'returnType') = 'numeric'
attr(`SampleRealVector_weight`, "inputTypes") = c('_p_SampleT_std__vectorT_double_std__allocatorT_double_t_t_t')
class(`SampleRealVector_weight`) = c("SWIGFunction", class('SampleRealVector_weight'))

# Start of delete_SampleRealVector

`delete_SampleRealVector` = function(self)
{
  ;.Call('R_swig_delete_SampleRealVector', self, PACKAGE='QuantLib');
  
}

attr(`delete_SampleRealVector`, 'returnType') = 'void'
attr(`delete_SampleRealVector`, "inputTypes") = c('_p_SampleT_std__vectorT_double_std__allocatorT_double_t_t_t')
class(`delete_SampleRealVector`) = c("SWIGFunction", class('delete_SampleRealVector'))

# Start of accessor method for Sample<(std::vector<(Real)>)>
setMethod('$', '_p_SampleT_std__vectorT_double_std__allocatorT_double_t_t_t', function(x, name)

{
  accessorFuns = list('value' = SampleRealVector_value, 'weight' = SampleRealVector_weight);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for Sample<(std::vector<(Real)>)>
setMethod('delete', '_p_SampleT_std__vectorT_double_std__allocatorT_double_t_t_t', function(obj) {delete_SampleT_std__vectorT_double_std__allocatorT_double_t_t_t(obj)})
# Start of new_LecuyerUniformRng

`LecuyerUniformRng__SWIG_0` = function(seed)
{
  seed = as.integer(seed); 
  
  if(length(seed) > 1) {
    warning("using only the first element of seed");
  };
  
  ;ans = .Call('R_swig_new_LecuyerUniformRng__SWIG_0', seed, PACKAGE='QuantLib');
  class(ans) <- "_p_LecuyerUniformRng";
  
  reg.finalizer(ans, delete_LecuyerUniformRng)
  ans
  
}

attr(`LecuyerUniformRng__SWIG_0`, 'returnType') = '_p_LecuyerUniformRng'
attr(`LecuyerUniformRng__SWIG_0`, "inputTypes") = c('integer')
class(`LecuyerUniformRng__SWIG_0`) = c("SWIGFunction", class('LecuyerUniformRng__SWIG_0'))

# Start of new_LecuyerUniformRng

`LecuyerUniformRng__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_LecuyerUniformRng__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_LecuyerUniformRng";
  
  reg.finalizer(ans, delete_LecuyerUniformRng)
  ans
  
}

attr(`LecuyerUniformRng__SWIG_1`, 'returnType') = '_p_LecuyerUniformRng'
class(`LecuyerUniformRng__SWIG_1`) = c("SWIGFunction", class('LecuyerUniformRng__SWIG_1'))

`LecuyerUniformRng` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- LecuyerUniformRng__SWIG_1; 
  } else if (argc == 1) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]]))) {
      f <- LecuyerUniformRng__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for LecuyerUniformRng with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of LecuyerUniformRng__next

`LecuyerUniformRng__next` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_LecuyerUniformRng__next', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_SampleT_double_t";
  
  ans
  
}

attr(`LecuyerUniformRng__next`, 'returnType') = '_p_SampleT_double_t'
attr(`LecuyerUniformRng__next`, "inputTypes") = c('_p_LecuyerUniformRng')
class(`LecuyerUniformRng__next`) = c("SWIGFunction", class('LecuyerUniformRng__next'))

# Start of delete_LecuyerUniformRng

`delete_LecuyerUniformRng` = function(self)
{
  ;.Call('R_swig_delete_LecuyerUniformRng', self, PACKAGE='QuantLib');
  
}

attr(`delete_LecuyerUniformRng`, 'returnType') = 'void'
attr(`delete_LecuyerUniformRng`, "inputTypes") = c('_p_LecuyerUniformRng')
class(`delete_LecuyerUniformRng`) = c("SWIGFunction", class('delete_LecuyerUniformRng'))

# Start of accessor method for LecuyerUniformRng
setMethod('$', '_p_LecuyerUniformRng', function(x, name)

{
  accessorFuns = list('_next' = LecuyerUniformRng__next);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for LecuyerUniformRng
setMethod('delete', '_p_LecuyerUniformRng', function(obj) {delete_LecuyerUniformRng(obj)})
# Start of new_KnuthUniformRng

`KnuthUniformRng__SWIG_0` = function(seed)
{
  seed = as.integer(seed); 
  
  if(length(seed) > 1) {
    warning("using only the first element of seed");
  };
  
  ;ans = .Call('R_swig_new_KnuthUniformRng__SWIG_0', seed, PACKAGE='QuantLib');
  class(ans) <- "_p_KnuthUniformRng";
  
  reg.finalizer(ans, delete_KnuthUniformRng)
  ans
  
}

attr(`KnuthUniformRng__SWIG_0`, 'returnType') = '_p_KnuthUniformRng'
attr(`KnuthUniformRng__SWIG_0`, "inputTypes") = c('integer')
class(`KnuthUniformRng__SWIG_0`) = c("SWIGFunction", class('KnuthUniformRng__SWIG_0'))

# Start of new_KnuthUniformRng

`KnuthUniformRng__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_KnuthUniformRng__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_KnuthUniformRng";
  
  reg.finalizer(ans, delete_KnuthUniformRng)
  ans
  
}

attr(`KnuthUniformRng__SWIG_1`, 'returnType') = '_p_KnuthUniformRng'
class(`KnuthUniformRng__SWIG_1`) = c("SWIGFunction", class('KnuthUniformRng__SWIG_1'))

`KnuthUniformRng` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- KnuthUniformRng__SWIG_1; 
  } else if (argc == 1) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]]))) {
      f <- KnuthUniformRng__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for KnuthUniformRng with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of KnuthUniformRng__next

`KnuthUniformRng__next` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_KnuthUniformRng__next', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_SampleT_double_t";
  
  ans
  
}

attr(`KnuthUniformRng__next`, 'returnType') = '_p_SampleT_double_t'
attr(`KnuthUniformRng__next`, "inputTypes") = c('_p_KnuthUniformRng')
class(`KnuthUniformRng__next`) = c("SWIGFunction", class('KnuthUniformRng__next'))

# Start of delete_KnuthUniformRng

`delete_KnuthUniformRng` = function(self)
{
  ;.Call('R_swig_delete_KnuthUniformRng', self, PACKAGE='QuantLib');
  
}

attr(`delete_KnuthUniformRng`, 'returnType') = 'void'
attr(`delete_KnuthUniformRng`, "inputTypes") = c('_p_KnuthUniformRng')
class(`delete_KnuthUniformRng`) = c("SWIGFunction", class('delete_KnuthUniformRng'))

# Start of accessor method for KnuthUniformRng
setMethod('$', '_p_KnuthUniformRng', function(x, name)

{
  accessorFuns = list('_next' = KnuthUniformRng__next);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for KnuthUniformRng
setMethod('delete', '_p_KnuthUniformRng', function(obj) {delete_KnuthUniformRng(obj)})
# Start of new_MersenneTwisterUniformRng

`MersenneTwisterUniformRng__SWIG_0` = function(seed)
{
  seed = as.integer(seed); 
  
  if(length(seed) > 1) {
    warning("using only the first element of seed");
  };
  
  ;ans = .Call('R_swig_new_MersenneTwisterUniformRng__SWIG_0', seed, PACKAGE='QuantLib');
  class(ans) <- "_p_MersenneTwisterUniformRng";
  
  reg.finalizer(ans, delete_MersenneTwisterUniformRng)
  ans
  
}

attr(`MersenneTwisterUniformRng__SWIG_0`, 'returnType') = '_p_MersenneTwisterUniformRng'
attr(`MersenneTwisterUniformRng__SWIG_0`, "inputTypes") = c('integer')
class(`MersenneTwisterUniformRng__SWIG_0`) = c("SWIGFunction", class('MersenneTwisterUniformRng__SWIG_0'))

# Start of new_MersenneTwisterUniformRng

`MersenneTwisterUniformRng__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_MersenneTwisterUniformRng__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_MersenneTwisterUniformRng";
  
  reg.finalizer(ans, delete_MersenneTwisterUniformRng)
  ans
  
}

attr(`MersenneTwisterUniformRng__SWIG_1`, 'returnType') = '_p_MersenneTwisterUniformRng'
class(`MersenneTwisterUniformRng__SWIG_1`) = c("SWIGFunction", class('MersenneTwisterUniformRng__SWIG_1'))

`MersenneTwisterUniformRng` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- MersenneTwisterUniformRng__SWIG_1; 
  } else if (argc == 1) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]]))) {
      f <- MersenneTwisterUniformRng__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for MersenneTwisterUniformRng with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of MersenneTwisterUniformRng__next

`MersenneTwisterUniformRng__next` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_MersenneTwisterUniformRng__next', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_SampleT_double_t";
  
  ans
  
}

attr(`MersenneTwisterUniformRng__next`, 'returnType') = '_p_SampleT_double_t'
attr(`MersenneTwisterUniformRng__next`, "inputTypes") = c('_p_MersenneTwisterUniformRng')
class(`MersenneTwisterUniformRng__next`) = c("SWIGFunction", class('MersenneTwisterUniformRng__next'))

# Start of delete_MersenneTwisterUniformRng

`delete_MersenneTwisterUniformRng` = function(self)
{
  ;.Call('R_swig_delete_MersenneTwisterUniformRng', self, PACKAGE='QuantLib');
  
}

attr(`delete_MersenneTwisterUniformRng`, 'returnType') = 'void'
attr(`delete_MersenneTwisterUniformRng`, "inputTypes") = c('_p_MersenneTwisterUniformRng')
class(`delete_MersenneTwisterUniformRng`) = c("SWIGFunction", class('delete_MersenneTwisterUniformRng'))

# Start of accessor method for MersenneTwisterUniformRng
setMethod('$', '_p_MersenneTwisterUniformRng', function(x, name)

{
  accessorFuns = list('_next' = MersenneTwisterUniformRng__next);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for MersenneTwisterUniformRng
setMethod('delete', '_p_MersenneTwisterUniformRng', function(obj) {delete_MersenneTwisterUniformRng(obj)})
# Start of new_UniformRandomGenerator

`UniformRandomGenerator__SWIG_0` = function(seed)
{
  seed = as.integer(seed); 
  
  if(length(seed) > 1) {
    warning("using only the first element of seed");
  };
  
  ;ans = .Call('R_swig_new_UniformRandomGenerator__SWIG_0', seed, PACKAGE='QuantLib');
  class(ans) <- "_p_UniformRandomGenerator";
  
  reg.finalizer(ans, delete_UniformRandomGenerator)
  ans
  
}

attr(`UniformRandomGenerator__SWIG_0`, 'returnType') = '_p_UniformRandomGenerator'
attr(`UniformRandomGenerator__SWIG_0`, "inputTypes") = c('integer')
class(`UniformRandomGenerator__SWIG_0`) = c("SWIGFunction", class('UniformRandomGenerator__SWIG_0'))

# Start of new_UniformRandomGenerator

`UniformRandomGenerator__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_UniformRandomGenerator__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_UniformRandomGenerator";
  
  reg.finalizer(ans, delete_UniformRandomGenerator)
  ans
  
}

attr(`UniformRandomGenerator__SWIG_1`, 'returnType') = '_p_UniformRandomGenerator'
class(`UniformRandomGenerator__SWIG_1`) = c("SWIGFunction", class('UniformRandomGenerator__SWIG_1'))

`UniformRandomGenerator` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- UniformRandomGenerator__SWIG_1; 
  } else if (argc == 1) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]]))) {
      f <- UniformRandomGenerator__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for UniformRandomGenerator with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of UniformRandomGenerator__next

`UniformRandomGenerator__next` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_UniformRandomGenerator__next', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_SampleT_double_t";
  
  ans
  
}

attr(`UniformRandomGenerator__next`, 'returnType') = '_p_SampleT_double_t'
attr(`UniformRandomGenerator__next`, "inputTypes") = c('_p_UniformRandomGenerator')
class(`UniformRandomGenerator__next`) = c("SWIGFunction", class('UniformRandomGenerator__next'))

# Start of UniformRandomGenerator_nextValue

`UniformRandomGenerator_nextValue` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_UniformRandomGenerator_nextValue', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`UniformRandomGenerator_nextValue`, 'returnType') = 'numeric'
attr(`UniformRandomGenerator_nextValue`, "inputTypes") = c('_p_UniformRandomGenerator')
class(`UniformRandomGenerator_nextValue`) = c("SWIGFunction", class('UniformRandomGenerator_nextValue'))

# Start of delete_UniformRandomGenerator

`delete_UniformRandomGenerator` = function(self)
{
  ;.Call('R_swig_delete_UniformRandomGenerator', self, PACKAGE='QuantLib');
  
}

attr(`delete_UniformRandomGenerator`, 'returnType') = 'void'
attr(`delete_UniformRandomGenerator`, "inputTypes") = c('_p_UniformRandomGenerator')
class(`delete_UniformRandomGenerator`) = c("SWIGFunction", class('delete_UniformRandomGenerator'))

# Start of accessor method for UniformRandomGenerator
setMethod('$', '_p_UniformRandomGenerator', function(x, name)

{
  accessorFuns = list('_next' = UniformRandomGenerator__next, 'nextValue' = UniformRandomGenerator_nextValue);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for UniformRandomGenerator
setMethod('delete', '_p_UniformRandomGenerator', function(obj) {delete_UniformRandomGenerator(obj)})
# Start of new_CentralLimitLecuyerGaussianRng

`CentralLimitLecuyerGaussianRng` = function(rng)
{
  ;ans = .Call('R_swig_new_CentralLimitLecuyerGaussianRng', rng, PACKAGE='QuantLib');
  class(ans) <- "_p_CLGaussianRngT_LecuyerUniformRng_t";
  
  reg.finalizer(ans, delete_CentralLimitLecuyerGaussianRng)
  ans
  
}

attr(`CentralLimitLecuyerGaussianRng`, 'returnType') = '_p_CLGaussianRngT_LecuyerUniformRng_t'
attr(`CentralLimitLecuyerGaussianRng`, "inputTypes") = c('_p_LecuyerUniformRng')
class(`CentralLimitLecuyerGaussianRng`) = c("SWIGFunction", class('CentralLimitLecuyerGaussianRng'))

# Start of CentralLimitLecuyerGaussianRng__next

`CentralLimitLecuyerGaussianRng__next` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_CentralLimitLecuyerGaussianRng__next', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_SampleT_double_t";
  
  ans
  
}

attr(`CentralLimitLecuyerGaussianRng__next`, 'returnType') = '_p_SampleT_double_t'
attr(`CentralLimitLecuyerGaussianRng__next`, "inputTypes") = c('_p_CLGaussianRngT_LecuyerUniformRng_t')
class(`CentralLimitLecuyerGaussianRng__next`) = c("SWIGFunction", class('CentralLimitLecuyerGaussianRng__next'))

# Start of delete_CentralLimitLecuyerGaussianRng

`delete_CentralLimitLecuyerGaussianRng` = function(self)
{
  ;.Call('R_swig_delete_CentralLimitLecuyerGaussianRng', self, PACKAGE='QuantLib');
  
}

attr(`delete_CentralLimitLecuyerGaussianRng`, 'returnType') = 'void'
attr(`delete_CentralLimitLecuyerGaussianRng`, "inputTypes") = c('_p_CLGaussianRngT_LecuyerUniformRng_t')
class(`delete_CentralLimitLecuyerGaussianRng`) = c("SWIGFunction", class('delete_CentralLimitLecuyerGaussianRng'))

# Start of accessor method for CLGaussianRng<(LecuyerUniformRng)>
setMethod('$', '_p_CLGaussianRngT_LecuyerUniformRng_t', function(x, name)

{
  accessorFuns = list('_next' = CentralLimitLecuyerGaussianRng__next);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for CLGaussianRng<(LecuyerUniformRng)>
setMethod('delete', '_p_CLGaussianRngT_LecuyerUniformRng_t', function(obj) {delete_CLGaussianRngT_LecuyerUniformRng_t(obj)})
# Start of new_CentralLimitKnuthGaussianRng

`CentralLimitKnuthGaussianRng` = function(rng)
{
  ;ans = .Call('R_swig_new_CentralLimitKnuthGaussianRng', rng, PACKAGE='QuantLib');
  class(ans) <- "_p_CLGaussianRngT_KnuthUniformRng_t";
  
  reg.finalizer(ans, delete_CentralLimitKnuthGaussianRng)
  ans
  
}

attr(`CentralLimitKnuthGaussianRng`, 'returnType') = '_p_CLGaussianRngT_KnuthUniformRng_t'
attr(`CentralLimitKnuthGaussianRng`, "inputTypes") = c('_p_KnuthUniformRng')
class(`CentralLimitKnuthGaussianRng`) = c("SWIGFunction", class('CentralLimitKnuthGaussianRng'))

# Start of CentralLimitKnuthGaussianRng__next

`CentralLimitKnuthGaussianRng__next` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_CentralLimitKnuthGaussianRng__next', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_SampleT_double_t";
  
  ans
  
}

attr(`CentralLimitKnuthGaussianRng__next`, 'returnType') = '_p_SampleT_double_t'
attr(`CentralLimitKnuthGaussianRng__next`, "inputTypes") = c('_p_CLGaussianRngT_KnuthUniformRng_t')
class(`CentralLimitKnuthGaussianRng__next`) = c("SWIGFunction", class('CentralLimitKnuthGaussianRng__next'))

# Start of delete_CentralLimitKnuthGaussianRng

`delete_CentralLimitKnuthGaussianRng` = function(self)
{
  ;.Call('R_swig_delete_CentralLimitKnuthGaussianRng', self, PACKAGE='QuantLib');
  
}

attr(`delete_CentralLimitKnuthGaussianRng`, 'returnType') = 'void'
attr(`delete_CentralLimitKnuthGaussianRng`, "inputTypes") = c('_p_CLGaussianRngT_KnuthUniformRng_t')
class(`delete_CentralLimitKnuthGaussianRng`) = c("SWIGFunction", class('delete_CentralLimitKnuthGaussianRng'))

# Start of accessor method for CLGaussianRng<(KnuthUniformRng)>
setMethod('$', '_p_CLGaussianRngT_KnuthUniformRng_t', function(x, name)

{
  accessorFuns = list('_next' = CentralLimitKnuthGaussianRng__next);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for CLGaussianRng<(KnuthUniformRng)>
setMethod('delete', '_p_CLGaussianRngT_KnuthUniformRng_t', function(obj) {delete_CLGaussianRngT_KnuthUniformRng_t(obj)})
# Start of new_CentralLimitMersenneTwisterGaussianRng

`CentralLimitMersenneTwisterGaussianRng` = function(rng)
{
  ;ans = .Call('R_swig_new_CentralLimitMersenneTwisterGaussianRng', rng, PACKAGE='QuantLib');
  class(ans) <- "_p_CLGaussianRngT_MersenneTwisterUniformRng_t";
  
  reg.finalizer(ans, delete_CentralLimitMersenneTwisterGaussianRng)
  ans
  
}

attr(`CentralLimitMersenneTwisterGaussianRng`, 'returnType') = '_p_CLGaussianRngT_MersenneTwisterUniformRng_t'
attr(`CentralLimitMersenneTwisterGaussianRng`, "inputTypes") = c('_p_MersenneTwisterUniformRng')
class(`CentralLimitMersenneTwisterGaussianRng`) = c("SWIGFunction", class('CentralLimitMersenneTwisterGaussianRng'))

# Start of CentralLimitMersenneTwisterGaussianRng__next

`CentralLimitMersenneTwisterGaussianRng__next` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_CentralLimitMersenneTwisterGaussianRng__next', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_SampleT_double_t";
  
  ans
  
}

attr(`CentralLimitMersenneTwisterGaussianRng__next`, 'returnType') = '_p_SampleT_double_t'
attr(`CentralLimitMersenneTwisterGaussianRng__next`, "inputTypes") = c('_p_CLGaussianRngT_MersenneTwisterUniformRng_t')
class(`CentralLimitMersenneTwisterGaussianRng__next`) = c("SWIGFunction", class('CentralLimitMersenneTwisterGaussianRng__next'))

# Start of delete_CentralLimitMersenneTwisterGaussianRng

`delete_CentralLimitMersenneTwisterGaussianRng` = function(self)
{
  ;.Call('R_swig_delete_CentralLimitMersenneTwisterGaussianRng', self, PACKAGE='QuantLib');
  
}

attr(`delete_CentralLimitMersenneTwisterGaussianRng`, 'returnType') = 'void'
attr(`delete_CentralLimitMersenneTwisterGaussianRng`, "inputTypes") = c('_p_CLGaussianRngT_MersenneTwisterUniformRng_t')
class(`delete_CentralLimitMersenneTwisterGaussianRng`) = c("SWIGFunction", class('delete_CentralLimitMersenneTwisterGaussianRng'))

# Start of accessor method for CLGaussianRng<(MersenneTwisterUniformRng)>
setMethod('$', '_p_CLGaussianRngT_MersenneTwisterUniformRng_t', function(x, name)

{
  accessorFuns = list('_next' = CentralLimitMersenneTwisterGaussianRng__next);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for CLGaussianRng<(MersenneTwisterUniformRng)>
setMethod('delete', '_p_CLGaussianRngT_MersenneTwisterUniformRng_t', function(obj) {delete_CLGaussianRngT_MersenneTwisterUniformRng_t(obj)})
# Start of new_BoxMullerLecuyerGaussianRng

`BoxMullerLecuyerGaussianRng` = function(rng)
{
  ;ans = .Call('R_swig_new_BoxMullerLecuyerGaussianRng', rng, PACKAGE='QuantLib');
  class(ans) <- "_p_BoxMullerGaussianRngT_LecuyerUniformRng_t";
  
  reg.finalizer(ans, delete_BoxMullerLecuyerGaussianRng)
  ans
  
}

attr(`BoxMullerLecuyerGaussianRng`, 'returnType') = '_p_BoxMullerGaussianRngT_LecuyerUniformRng_t'
attr(`BoxMullerLecuyerGaussianRng`, "inputTypes") = c('_p_LecuyerUniformRng')
class(`BoxMullerLecuyerGaussianRng`) = c("SWIGFunction", class('BoxMullerLecuyerGaussianRng'))

# Start of BoxMullerLecuyerGaussianRng__next

`BoxMullerLecuyerGaussianRng__next` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_BoxMullerLecuyerGaussianRng__next', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_SampleT_double_t";
  
  ans
  
}

attr(`BoxMullerLecuyerGaussianRng__next`, 'returnType') = '_p_SampleT_double_t'
attr(`BoxMullerLecuyerGaussianRng__next`, "inputTypes") = c('_p_BoxMullerGaussianRngT_LecuyerUniformRng_t')
class(`BoxMullerLecuyerGaussianRng__next`) = c("SWIGFunction", class('BoxMullerLecuyerGaussianRng__next'))

# Start of delete_BoxMullerLecuyerGaussianRng

`delete_BoxMullerLecuyerGaussianRng` = function(self)
{
  ;.Call('R_swig_delete_BoxMullerLecuyerGaussianRng', self, PACKAGE='QuantLib');
  
}

attr(`delete_BoxMullerLecuyerGaussianRng`, 'returnType') = 'void'
attr(`delete_BoxMullerLecuyerGaussianRng`, "inputTypes") = c('_p_BoxMullerGaussianRngT_LecuyerUniformRng_t')
class(`delete_BoxMullerLecuyerGaussianRng`) = c("SWIGFunction", class('delete_BoxMullerLecuyerGaussianRng'))

# Start of accessor method for BoxMullerGaussianRng<(LecuyerUniformRng)>
setMethod('$', '_p_BoxMullerGaussianRngT_LecuyerUniformRng_t', function(x, name)

{
  accessorFuns = list('_next' = BoxMullerLecuyerGaussianRng__next);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for BoxMullerGaussianRng<(LecuyerUniformRng)>
setMethod('delete', '_p_BoxMullerGaussianRngT_LecuyerUniformRng_t', function(obj) {delete_BoxMullerGaussianRngT_LecuyerUniformRng_t(obj)})
# Start of new_BoxMullerKnuthGaussianRng

`BoxMullerKnuthGaussianRng` = function(rng)
{
  ;ans = .Call('R_swig_new_BoxMullerKnuthGaussianRng', rng, PACKAGE='QuantLib');
  class(ans) <- "_p_BoxMullerGaussianRngT_KnuthUniformRng_t";
  
  reg.finalizer(ans, delete_BoxMullerKnuthGaussianRng)
  ans
  
}

attr(`BoxMullerKnuthGaussianRng`, 'returnType') = '_p_BoxMullerGaussianRngT_KnuthUniformRng_t'
attr(`BoxMullerKnuthGaussianRng`, "inputTypes") = c('_p_KnuthUniformRng')
class(`BoxMullerKnuthGaussianRng`) = c("SWIGFunction", class('BoxMullerKnuthGaussianRng'))

# Start of BoxMullerKnuthGaussianRng__next

`BoxMullerKnuthGaussianRng__next` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_BoxMullerKnuthGaussianRng__next', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_SampleT_double_t";
  
  ans
  
}

attr(`BoxMullerKnuthGaussianRng__next`, 'returnType') = '_p_SampleT_double_t'
attr(`BoxMullerKnuthGaussianRng__next`, "inputTypes") = c('_p_BoxMullerGaussianRngT_KnuthUniformRng_t')
class(`BoxMullerKnuthGaussianRng__next`) = c("SWIGFunction", class('BoxMullerKnuthGaussianRng__next'))

# Start of delete_BoxMullerKnuthGaussianRng

`delete_BoxMullerKnuthGaussianRng` = function(self)
{
  ;.Call('R_swig_delete_BoxMullerKnuthGaussianRng', self, PACKAGE='QuantLib');
  
}

attr(`delete_BoxMullerKnuthGaussianRng`, 'returnType') = 'void'
attr(`delete_BoxMullerKnuthGaussianRng`, "inputTypes") = c('_p_BoxMullerGaussianRngT_KnuthUniformRng_t')
class(`delete_BoxMullerKnuthGaussianRng`) = c("SWIGFunction", class('delete_BoxMullerKnuthGaussianRng'))

# Start of accessor method for BoxMullerGaussianRng<(KnuthUniformRng)>
setMethod('$', '_p_BoxMullerGaussianRngT_KnuthUniformRng_t', function(x, name)

{
  accessorFuns = list('_next' = BoxMullerKnuthGaussianRng__next);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for BoxMullerGaussianRng<(KnuthUniformRng)>
setMethod('delete', '_p_BoxMullerGaussianRngT_KnuthUniformRng_t', function(obj) {delete_BoxMullerGaussianRngT_KnuthUniformRng_t(obj)})
# Start of new_BoxMullerMersenneTwisterGaussianRng

`BoxMullerMersenneTwisterGaussianRng` = function(rng)
{
  ;ans = .Call('R_swig_new_BoxMullerMersenneTwisterGaussianRng', rng, PACKAGE='QuantLib');
  class(ans) <- "_p_BoxMullerGaussianRngT_MersenneTwisterUniformRng_t";
  
  reg.finalizer(ans, delete_BoxMullerMersenneTwisterGaussianRng)
  ans
  
}

attr(`BoxMullerMersenneTwisterGaussianRng`, 'returnType') = '_p_BoxMullerGaussianRngT_MersenneTwisterUniformRng_t'
attr(`BoxMullerMersenneTwisterGaussianRng`, "inputTypes") = c('_p_MersenneTwisterUniformRng')
class(`BoxMullerMersenneTwisterGaussianRng`) = c("SWIGFunction", class('BoxMullerMersenneTwisterGaussianRng'))

# Start of BoxMullerMersenneTwisterGaussianRng__next

`BoxMullerMersenneTwisterGaussianRng__next` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_BoxMullerMersenneTwisterGaussianRng__next', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_SampleT_double_t";
  
  ans
  
}

attr(`BoxMullerMersenneTwisterGaussianRng__next`, 'returnType') = '_p_SampleT_double_t'
attr(`BoxMullerMersenneTwisterGaussianRng__next`, "inputTypes") = c('_p_BoxMullerGaussianRngT_MersenneTwisterUniformRng_t')
class(`BoxMullerMersenneTwisterGaussianRng__next`) = c("SWIGFunction", class('BoxMullerMersenneTwisterGaussianRng__next'))

# Start of delete_BoxMullerMersenneTwisterGaussianRng

`delete_BoxMullerMersenneTwisterGaussianRng` = function(self)
{
  ;.Call('R_swig_delete_BoxMullerMersenneTwisterGaussianRng', self, PACKAGE='QuantLib');
  
}

attr(`delete_BoxMullerMersenneTwisterGaussianRng`, 'returnType') = 'void'
attr(`delete_BoxMullerMersenneTwisterGaussianRng`, "inputTypes") = c('_p_BoxMullerGaussianRngT_MersenneTwisterUniformRng_t')
class(`delete_BoxMullerMersenneTwisterGaussianRng`) = c("SWIGFunction", class('delete_BoxMullerMersenneTwisterGaussianRng'))

# Start of accessor method for BoxMullerGaussianRng<(MersenneTwisterUniformRng)>
setMethod('$', '_p_BoxMullerGaussianRngT_MersenneTwisterUniformRng_t', function(x, name)

{
  accessorFuns = list('_next' = BoxMullerMersenneTwisterGaussianRng__next);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for BoxMullerGaussianRng<(MersenneTwisterUniformRng)>
setMethod('delete', '_p_BoxMullerGaussianRngT_MersenneTwisterUniformRng_t', function(obj) {delete_BoxMullerGaussianRngT_MersenneTwisterUniformRng_t(obj)})
# Start of new_MoroInvCumulativeLecuyerGaussianRng

`MoroInvCumulativeLecuyerGaussianRng` = function(rng)
{
  ;ans = .Call('R_swig_new_MoroInvCumulativeLecuyerGaussianRng', rng, PACKAGE='QuantLib');
  class(ans) <- "_p_InverseCumulativeRngT_LecuyerUniformRng_MoroInverseCumulativeNormal_t";
  
  reg.finalizer(ans, delete_MoroInvCumulativeLecuyerGaussianRng)
  ans
  
}

attr(`MoroInvCumulativeLecuyerGaussianRng`, 'returnType') = '_p_InverseCumulativeRngT_LecuyerUniformRng_MoroInverseCumulativeNormal_t'
attr(`MoroInvCumulativeLecuyerGaussianRng`, "inputTypes") = c('_p_LecuyerUniformRng')
class(`MoroInvCumulativeLecuyerGaussianRng`) = c("SWIGFunction", class('MoroInvCumulativeLecuyerGaussianRng'))

# Start of MoroInvCumulativeLecuyerGaussianRng__next

`MoroInvCumulativeLecuyerGaussianRng__next` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_MoroInvCumulativeLecuyerGaussianRng__next', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_SampleT_double_t";
  
  ans
  
}

attr(`MoroInvCumulativeLecuyerGaussianRng__next`, 'returnType') = '_p_SampleT_double_t'
attr(`MoroInvCumulativeLecuyerGaussianRng__next`, "inputTypes") = c('_p_InverseCumulativeRngT_LecuyerUniformRng_MoroInverseCumulativeNormal_t')
class(`MoroInvCumulativeLecuyerGaussianRng__next`) = c("SWIGFunction", class('MoroInvCumulativeLecuyerGaussianRng__next'))

# Start of delete_MoroInvCumulativeLecuyerGaussianRng

`delete_MoroInvCumulativeLecuyerGaussianRng` = function(self)
{
  ;.Call('R_swig_delete_MoroInvCumulativeLecuyerGaussianRng', self, PACKAGE='QuantLib');
  
}

attr(`delete_MoroInvCumulativeLecuyerGaussianRng`, 'returnType') = 'void'
attr(`delete_MoroInvCumulativeLecuyerGaussianRng`, "inputTypes") = c('_p_InverseCumulativeRngT_LecuyerUniformRng_MoroInverseCumulativeNormal_t')
class(`delete_MoroInvCumulativeLecuyerGaussianRng`) = c("SWIGFunction", class('delete_MoroInvCumulativeLecuyerGaussianRng'))

# Start of accessor method for InverseCumulativeRng<(LecuyerUniformRng,MoroInverseCumulativeNormal)>
setMethod('$', '_p_InverseCumulativeRngT_LecuyerUniformRng_MoroInverseCumulativeNormal_t', function(x, name)

{
  accessorFuns = list('_next' = MoroInvCumulativeLecuyerGaussianRng__next);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for InverseCumulativeRng<(LecuyerUniformRng,MoroInverseCumulativeNormal)>
setMethod('delete', '_p_InverseCumulativeRngT_LecuyerUniformRng_MoroInverseCumulativeNormal_t', function(obj) {delete_InverseCumulativeRngT_LecuyerUniformRng_MoroInverseCumulativeNormal_t(obj)})
# Start of new_MoroInvCumulativeKnuthGaussianRng

`MoroInvCumulativeKnuthGaussianRng` = function(rng)
{
  ;ans = .Call('R_swig_new_MoroInvCumulativeKnuthGaussianRng', rng, PACKAGE='QuantLib');
  class(ans) <- "_p_InverseCumulativeRngT_KnuthUniformRng_MoroInverseCumulativeNormal_t";
  
  reg.finalizer(ans, delete_MoroInvCumulativeKnuthGaussianRng)
  ans
  
}

attr(`MoroInvCumulativeKnuthGaussianRng`, 'returnType') = '_p_InverseCumulativeRngT_KnuthUniformRng_MoroInverseCumulativeNormal_t'
attr(`MoroInvCumulativeKnuthGaussianRng`, "inputTypes") = c('_p_KnuthUniformRng')
class(`MoroInvCumulativeKnuthGaussianRng`) = c("SWIGFunction", class('MoroInvCumulativeKnuthGaussianRng'))

# Start of MoroInvCumulativeKnuthGaussianRng__next

`MoroInvCumulativeKnuthGaussianRng__next` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_MoroInvCumulativeKnuthGaussianRng__next', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_SampleT_double_t";
  
  ans
  
}

attr(`MoroInvCumulativeKnuthGaussianRng__next`, 'returnType') = '_p_SampleT_double_t'
attr(`MoroInvCumulativeKnuthGaussianRng__next`, "inputTypes") = c('_p_InverseCumulativeRngT_KnuthUniformRng_MoroInverseCumulativeNormal_t')
class(`MoroInvCumulativeKnuthGaussianRng__next`) = c("SWIGFunction", class('MoroInvCumulativeKnuthGaussianRng__next'))

# Start of delete_MoroInvCumulativeKnuthGaussianRng

`delete_MoroInvCumulativeKnuthGaussianRng` = function(self)
{
  ;.Call('R_swig_delete_MoroInvCumulativeKnuthGaussianRng', self, PACKAGE='QuantLib');
  
}

attr(`delete_MoroInvCumulativeKnuthGaussianRng`, 'returnType') = 'void'
attr(`delete_MoroInvCumulativeKnuthGaussianRng`, "inputTypes") = c('_p_InverseCumulativeRngT_KnuthUniformRng_MoroInverseCumulativeNormal_t')
class(`delete_MoroInvCumulativeKnuthGaussianRng`) = c("SWIGFunction", class('delete_MoroInvCumulativeKnuthGaussianRng'))

# Start of accessor method for InverseCumulativeRng<(KnuthUniformRng,MoroInverseCumulativeNormal)>
setMethod('$', '_p_InverseCumulativeRngT_KnuthUniformRng_MoroInverseCumulativeNormal_t', function(x, name)

{
  accessorFuns = list('_next' = MoroInvCumulativeKnuthGaussianRng__next);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for InverseCumulativeRng<(KnuthUniformRng,MoroInverseCumulativeNormal)>
setMethod('delete', '_p_InverseCumulativeRngT_KnuthUniformRng_MoroInverseCumulativeNormal_t', function(obj) {delete_InverseCumulativeRngT_KnuthUniformRng_MoroInverseCumulativeNormal_t(obj)})
# Start of new_MoroInvCumulativeMersenneTwisterGaussianRng

`MoroInvCumulativeMersenneTwisterGaussianRng` = function(rng)
{
  ;ans = .Call('R_swig_new_MoroInvCumulativeMersenneTwisterGaussianRng', rng, PACKAGE='QuantLib');
  class(ans) <- "_p_InverseCumulativeRngT_MersenneTwisterUniformRng_MoroInverseCumulativeNormal_t";
  
  reg.finalizer(ans, delete_MoroInvCumulativeMersenneTwisterGaussianRng)
  ans
  
}

attr(`MoroInvCumulativeMersenneTwisterGaussianRng`, 'returnType') = '_p_InverseCumulativeRngT_MersenneTwisterUniformRng_MoroInverseCumulativeNormal_t'
attr(`MoroInvCumulativeMersenneTwisterGaussianRng`, "inputTypes") = c('_p_MersenneTwisterUniformRng')
class(`MoroInvCumulativeMersenneTwisterGaussianRng`) = c("SWIGFunction", class('MoroInvCumulativeMersenneTwisterGaussianRng'))

# Start of MoroInvCumulativeMersenneTwisterGaussianRng__next

`MoroInvCumulativeMersenneTwisterGaussianRng__next` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_MoroInvCumulativeMersenneTwisterGaussianRng__next', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_SampleT_double_t";
  
  ans
  
}

attr(`MoroInvCumulativeMersenneTwisterGaussianRng__next`, 'returnType') = '_p_SampleT_double_t'
attr(`MoroInvCumulativeMersenneTwisterGaussianRng__next`, "inputTypes") = c('_p_InverseCumulativeRngT_MersenneTwisterUniformRng_MoroInverseCumulativeNormal_t')
class(`MoroInvCumulativeMersenneTwisterGaussianRng__next`) = c("SWIGFunction", class('MoroInvCumulativeMersenneTwisterGaussianRng__next'))

# Start of delete_MoroInvCumulativeMersenneTwisterGaussianRng

`delete_MoroInvCumulativeMersenneTwisterGaussianRng` = function(self)
{
  ;.Call('R_swig_delete_MoroInvCumulativeMersenneTwisterGaussianRng', self, PACKAGE='QuantLib');
  
}

attr(`delete_MoroInvCumulativeMersenneTwisterGaussianRng`, 'returnType') = 'void'
attr(`delete_MoroInvCumulativeMersenneTwisterGaussianRng`, "inputTypes") = c('_p_InverseCumulativeRngT_MersenneTwisterUniformRng_MoroInverseCumulativeNormal_t')
class(`delete_MoroInvCumulativeMersenneTwisterGaussianRng`) = c("SWIGFunction", class('delete_MoroInvCumulativeMersenneTwisterGaussianRng'))

# Start of accessor method for InverseCumulativeRng<(MersenneTwisterUniformRng,MoroInverseCumulativeNormal)>
setMethod('$', '_p_InverseCumulativeRngT_MersenneTwisterUniformRng_MoroInverseCumulativeNormal_t', function(x, name)

{
  accessorFuns = list('_next' = MoroInvCumulativeMersenneTwisterGaussianRng__next);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for InverseCumulativeRng<(MersenneTwisterUniformRng,MoroInverseCumulativeNormal)>
setMethod('delete', '_p_InverseCumulativeRngT_MersenneTwisterUniformRng_MoroInverseCumulativeNormal_t', function(obj) {delete_InverseCumulativeRngT_MersenneTwisterUniformRng_MoroInverseCumulativeNormal_t(obj)})
# Start of new_InvCumulativeLecuyerGaussianRng

`InvCumulativeLecuyerGaussianRng` = function(rng)
{
  ;ans = .Call('R_swig_new_InvCumulativeLecuyerGaussianRng', rng, PACKAGE='QuantLib');
  class(ans) <- "_p_InverseCumulativeRngT_LecuyerUniformRng_InverseCumulativeNormal_t";
  
  reg.finalizer(ans, delete_InvCumulativeLecuyerGaussianRng)
  ans
  
}

attr(`InvCumulativeLecuyerGaussianRng`, 'returnType') = '_p_InverseCumulativeRngT_LecuyerUniformRng_InverseCumulativeNormal_t'
attr(`InvCumulativeLecuyerGaussianRng`, "inputTypes") = c('_p_LecuyerUniformRng')
class(`InvCumulativeLecuyerGaussianRng`) = c("SWIGFunction", class('InvCumulativeLecuyerGaussianRng'))

# Start of InvCumulativeLecuyerGaussianRng__next

`InvCumulativeLecuyerGaussianRng__next` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_InvCumulativeLecuyerGaussianRng__next', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_SampleT_double_t";
  
  ans
  
}

attr(`InvCumulativeLecuyerGaussianRng__next`, 'returnType') = '_p_SampleT_double_t'
attr(`InvCumulativeLecuyerGaussianRng__next`, "inputTypes") = c('_p_InverseCumulativeRngT_LecuyerUniformRng_InverseCumulativeNormal_t')
class(`InvCumulativeLecuyerGaussianRng__next`) = c("SWIGFunction", class('InvCumulativeLecuyerGaussianRng__next'))

# Start of delete_InvCumulativeLecuyerGaussianRng

`delete_InvCumulativeLecuyerGaussianRng` = function(self)
{
  ;.Call('R_swig_delete_InvCumulativeLecuyerGaussianRng', self, PACKAGE='QuantLib');
  
}

attr(`delete_InvCumulativeLecuyerGaussianRng`, 'returnType') = 'void'
attr(`delete_InvCumulativeLecuyerGaussianRng`, "inputTypes") = c('_p_InverseCumulativeRngT_LecuyerUniformRng_InverseCumulativeNormal_t')
class(`delete_InvCumulativeLecuyerGaussianRng`) = c("SWIGFunction", class('delete_InvCumulativeLecuyerGaussianRng'))

# Start of accessor method for InverseCumulativeRng<(LecuyerUniformRng,InverseCumulativeNormal)>
setMethod('$', '_p_InverseCumulativeRngT_LecuyerUniformRng_InverseCumulativeNormal_t', function(x, name)

{
  accessorFuns = list('_next' = InvCumulativeLecuyerGaussianRng__next);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for InverseCumulativeRng<(LecuyerUniformRng,InverseCumulativeNormal)>
setMethod('delete', '_p_InverseCumulativeRngT_LecuyerUniformRng_InverseCumulativeNormal_t', function(obj) {delete_InverseCumulativeRngT_LecuyerUniformRng_InverseCumulativeNormal_t(obj)})
# Start of new_InvCumulativeKnuthGaussianRng

`InvCumulativeKnuthGaussianRng` = function(rng)
{
  ;ans = .Call('R_swig_new_InvCumulativeKnuthGaussianRng', rng, PACKAGE='QuantLib');
  class(ans) <- "_p_InverseCumulativeRngT_KnuthUniformRng_InverseCumulativeNormal_t";
  
  reg.finalizer(ans, delete_InvCumulativeKnuthGaussianRng)
  ans
  
}

attr(`InvCumulativeKnuthGaussianRng`, 'returnType') = '_p_InverseCumulativeRngT_KnuthUniformRng_InverseCumulativeNormal_t'
attr(`InvCumulativeKnuthGaussianRng`, "inputTypes") = c('_p_KnuthUniformRng')
class(`InvCumulativeKnuthGaussianRng`) = c("SWIGFunction", class('InvCumulativeKnuthGaussianRng'))

# Start of InvCumulativeKnuthGaussianRng__next

`InvCumulativeKnuthGaussianRng__next` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_InvCumulativeKnuthGaussianRng__next', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_SampleT_double_t";
  
  ans
  
}

attr(`InvCumulativeKnuthGaussianRng__next`, 'returnType') = '_p_SampleT_double_t'
attr(`InvCumulativeKnuthGaussianRng__next`, "inputTypes") = c('_p_InverseCumulativeRngT_KnuthUniformRng_InverseCumulativeNormal_t')
class(`InvCumulativeKnuthGaussianRng__next`) = c("SWIGFunction", class('InvCumulativeKnuthGaussianRng__next'))

# Start of delete_InvCumulativeKnuthGaussianRng

`delete_InvCumulativeKnuthGaussianRng` = function(self)
{
  ;.Call('R_swig_delete_InvCumulativeKnuthGaussianRng', self, PACKAGE='QuantLib');
  
}

attr(`delete_InvCumulativeKnuthGaussianRng`, 'returnType') = 'void'
attr(`delete_InvCumulativeKnuthGaussianRng`, "inputTypes") = c('_p_InverseCumulativeRngT_KnuthUniformRng_InverseCumulativeNormal_t')
class(`delete_InvCumulativeKnuthGaussianRng`) = c("SWIGFunction", class('delete_InvCumulativeKnuthGaussianRng'))

# Start of accessor method for InverseCumulativeRng<(KnuthUniformRng,InverseCumulativeNormal)>
setMethod('$', '_p_InverseCumulativeRngT_KnuthUniformRng_InverseCumulativeNormal_t', function(x, name)

{
  accessorFuns = list('_next' = InvCumulativeKnuthGaussianRng__next);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for InverseCumulativeRng<(KnuthUniformRng,InverseCumulativeNormal)>
setMethod('delete', '_p_InverseCumulativeRngT_KnuthUniformRng_InverseCumulativeNormal_t', function(obj) {delete_InverseCumulativeRngT_KnuthUniformRng_InverseCumulativeNormal_t(obj)})
# Start of new_InvCumulativeMersenneTwisterGaussianRng

`InvCumulativeMersenneTwisterGaussianRng` = function(rng)
{
  ;ans = .Call('R_swig_new_InvCumulativeMersenneTwisterGaussianRng', rng, PACKAGE='QuantLib');
  class(ans) <- "_p_InverseCumulativeRngT_MersenneTwisterUniformRng_InverseCumulativeNormal_t";
  
  reg.finalizer(ans, delete_InvCumulativeMersenneTwisterGaussianRng)
  ans
  
}

attr(`InvCumulativeMersenneTwisterGaussianRng`, 'returnType') = '_p_InverseCumulativeRngT_MersenneTwisterUniformRng_InverseCumulativeNormal_t'
attr(`InvCumulativeMersenneTwisterGaussianRng`, "inputTypes") = c('_p_MersenneTwisterUniformRng')
class(`InvCumulativeMersenneTwisterGaussianRng`) = c("SWIGFunction", class('InvCumulativeMersenneTwisterGaussianRng'))

# Start of InvCumulativeMersenneTwisterGaussianRng__next

`InvCumulativeMersenneTwisterGaussianRng__next` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_InvCumulativeMersenneTwisterGaussianRng__next', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_SampleT_double_t";
  
  ans
  
}

attr(`InvCumulativeMersenneTwisterGaussianRng__next`, 'returnType') = '_p_SampleT_double_t'
attr(`InvCumulativeMersenneTwisterGaussianRng__next`, "inputTypes") = c('_p_InverseCumulativeRngT_MersenneTwisterUniformRng_InverseCumulativeNormal_t')
class(`InvCumulativeMersenneTwisterGaussianRng__next`) = c("SWIGFunction", class('InvCumulativeMersenneTwisterGaussianRng__next'))

# Start of delete_InvCumulativeMersenneTwisterGaussianRng

`delete_InvCumulativeMersenneTwisterGaussianRng` = function(self)
{
  ;.Call('R_swig_delete_InvCumulativeMersenneTwisterGaussianRng', self, PACKAGE='QuantLib');
  
}

attr(`delete_InvCumulativeMersenneTwisterGaussianRng`, 'returnType') = 'void'
attr(`delete_InvCumulativeMersenneTwisterGaussianRng`, "inputTypes") = c('_p_InverseCumulativeRngT_MersenneTwisterUniformRng_InverseCumulativeNormal_t')
class(`delete_InvCumulativeMersenneTwisterGaussianRng`) = c("SWIGFunction", class('delete_InvCumulativeMersenneTwisterGaussianRng'))

# Start of accessor method for InverseCumulativeRng<(MersenneTwisterUniformRng,InverseCumulativeNormal)>
setMethod('$', '_p_InverseCumulativeRngT_MersenneTwisterUniformRng_InverseCumulativeNormal_t', function(x, name)

{
  accessorFuns = list('_next' = InvCumulativeMersenneTwisterGaussianRng__next);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for InverseCumulativeRng<(MersenneTwisterUniformRng,InverseCumulativeNormal)>
setMethod('delete', '_p_InverseCumulativeRngT_MersenneTwisterUniformRng_InverseCumulativeNormal_t', function(obj) {delete_InverseCumulativeRngT_MersenneTwisterUniformRng_InverseCumulativeNormal_t(obj)})
# Start of new_GaussianRandomGenerator

`GaussianRandomGenerator` = function(rng)
{
  ;ans = .Call('R_swig_new_GaussianRandomGenerator', rng, PACKAGE='QuantLib');
  class(ans) <- "_p_GaussianRandomGenerator";
  
  reg.finalizer(ans, delete_GaussianRandomGenerator)
  ans
  
}

attr(`GaussianRandomGenerator`, 'returnType') = '_p_GaussianRandomGenerator'
attr(`GaussianRandomGenerator`, "inputTypes") = c('_p_UniformRandomGenerator')
class(`GaussianRandomGenerator`) = c("SWIGFunction", class('GaussianRandomGenerator'))

# Start of GaussianRandomGenerator__next

`GaussianRandomGenerator__next` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_GaussianRandomGenerator__next', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_SampleT_double_t";
  
  ans
  
}

attr(`GaussianRandomGenerator__next`, 'returnType') = '_p_SampleT_double_t'
attr(`GaussianRandomGenerator__next`, "inputTypes") = c('_p_GaussianRandomGenerator')
class(`GaussianRandomGenerator__next`) = c("SWIGFunction", class('GaussianRandomGenerator__next'))

# Start of GaussianRandomGenerator_nextValue

`GaussianRandomGenerator_nextValue` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_GaussianRandomGenerator_nextValue', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`GaussianRandomGenerator_nextValue`, 'returnType') = 'numeric'
attr(`GaussianRandomGenerator_nextValue`, "inputTypes") = c('_p_GaussianRandomGenerator')
class(`GaussianRandomGenerator_nextValue`) = c("SWIGFunction", class('GaussianRandomGenerator_nextValue'))

# Start of delete_GaussianRandomGenerator

`delete_GaussianRandomGenerator` = function(self)
{
  ;.Call('R_swig_delete_GaussianRandomGenerator', self, PACKAGE='QuantLib');
  
}

attr(`delete_GaussianRandomGenerator`, 'returnType') = 'void'
attr(`delete_GaussianRandomGenerator`, "inputTypes") = c('_p_GaussianRandomGenerator')
class(`delete_GaussianRandomGenerator`) = c("SWIGFunction", class('delete_GaussianRandomGenerator'))

# Start of accessor method for GaussianRandomGenerator
setMethod('$', '_p_GaussianRandomGenerator', function(x, name)

{
  accessorFuns = list('_next' = GaussianRandomGenerator__next, 'nextValue' = GaussianRandomGenerator_nextValue);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for GaussianRandomGenerator
setMethod('delete', '_p_GaussianRandomGenerator', function(obj) {delete_GaussianRandomGenerator(obj)})
# Start of new_HaltonRsg

`HaltonRsg` = function(dimensionality)
{
  if(length(dimensionality) > 1) {
    warning("using only the first element of dimensionality");
  };
  
  ;ans = .Call('R_swig_new_HaltonRsg', dimensionality, PACKAGE='QuantLib');
  class(ans) <- "_p_HaltonRsg";
  
  reg.finalizer(ans, delete_HaltonRsg)
  ans
  
}

attr(`HaltonRsg`, 'returnType') = '_p_HaltonRsg'
attr(`HaltonRsg`, "inputTypes") = c('integer')
class(`HaltonRsg`) = c("SWIGFunction", class('HaltonRsg'))

# Start of HaltonRsg_nextSequence

`HaltonRsg_nextSequence` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_HaltonRsg_nextSequence', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_SampleT_std__vectorT_double_std__allocatorT_double_t_t_t";
  
  ans
  
}

attr(`HaltonRsg_nextSequence`, 'returnType') = '_p_SampleT_std__vectorT_double_std__allocatorT_double_t_t_t'
attr(`HaltonRsg_nextSequence`, "inputTypes") = c('_p_HaltonRsg')
class(`HaltonRsg_nextSequence`) = c("SWIGFunction", class('HaltonRsg_nextSequence'))

# Start of HaltonRsg_dimension

`HaltonRsg_dimension` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_HaltonRsg_dimension', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__size_t";
  
  ans
  
}

attr(`HaltonRsg_dimension`, 'returnType') = 'integer'
attr(`HaltonRsg_dimension`, "inputTypes") = c('_p_HaltonRsg')
class(`HaltonRsg_dimension`) = c("SWIGFunction", class('HaltonRsg_dimension'))

# Start of delete_HaltonRsg

`delete_HaltonRsg` = function(self)
{
  ;.Call('R_swig_delete_HaltonRsg', self, PACKAGE='QuantLib');
  
}

attr(`delete_HaltonRsg`, 'returnType') = 'void'
attr(`delete_HaltonRsg`, "inputTypes") = c('_p_HaltonRsg')
class(`delete_HaltonRsg`) = c("SWIGFunction", class('delete_HaltonRsg'))

# Start of accessor method for HaltonRsg
setMethod('$', '_p_HaltonRsg', function(x, name)

{
  accessorFuns = list('nextSequence' = HaltonRsg_nextSequence, 'dimension' = HaltonRsg_dimension);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for HaltonRsg
setMethod('delete', '_p_HaltonRsg', function(obj) {delete_HaltonRsg(obj)})
# Start of new_SobolRsg

`SobolRsg__SWIG_0` = function(dimensionality, seed)
{
  if(length(dimensionality) > 1) {
    warning("using only the first element of dimensionality");
  };
  
  seed = as.integer(seed); 
  
  if(length(seed) > 1) {
    warning("using only the first element of seed");
  };
  
  ;ans = .Call('R_swig_new_SobolRsg__SWIG_0', dimensionality, seed, PACKAGE='QuantLib');
  class(ans) <- "_p_SobolRsg";
  
  reg.finalizer(ans, delete_SobolRsg)
  ans
  
}

attr(`SobolRsg__SWIG_0`, 'returnType') = '_p_SobolRsg'
attr(`SobolRsg__SWIG_0`, "inputTypes") = c('integer', 'integer')
class(`SobolRsg__SWIG_0`) = c("SWIGFunction", class('SobolRsg__SWIG_0'))

# Start of new_SobolRsg

`SobolRsg__SWIG_1` = function(dimensionality)
{
  if(length(dimensionality) > 1) {
    warning("using only the first element of dimensionality");
  };
  
  ;ans = .Call('R_swig_new_SobolRsg__SWIG_1', dimensionality, PACKAGE='QuantLib');
  class(ans) <- "_p_SobolRsg";
  
  reg.finalizer(ans, delete_SobolRsg)
  ans
  
}

attr(`SobolRsg__SWIG_1`, 'returnType') = '_p_SobolRsg'
attr(`SobolRsg__SWIG_1`, "inputTypes") = c('integer')
class(`SobolRsg__SWIG_1`) = c("SWIGFunction", class('SobolRsg__SWIG_1'))

`SobolRsg` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]]))) {
      f <- SobolRsg__SWIG_1; 
    }
  } else if (argc == 2) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && (is.integer(argv[[2]]) || is.numeric(argv[[2]]))) {
      f <- SobolRsg__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for SobolRsg with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of SobolRsg_nextSequence

`SobolRsg_nextSequence` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_SobolRsg_nextSequence', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_SampleT_std__vectorT_double_std__allocatorT_double_t_t_t";
  
  ans
  
}

attr(`SobolRsg_nextSequence`, 'returnType') = '_p_SampleT_std__vectorT_double_std__allocatorT_double_t_t_t'
attr(`SobolRsg_nextSequence`, "inputTypes") = c('_p_SobolRsg')
class(`SobolRsg_nextSequence`) = c("SWIGFunction", class('SobolRsg_nextSequence'))

# Start of SobolRsg_dimension

`SobolRsg_dimension` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_SobolRsg_dimension', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__size_t";
  
  ans
  
}

attr(`SobolRsg_dimension`, 'returnType') = 'integer'
attr(`SobolRsg_dimension`, "inputTypes") = c('_p_SobolRsg')
class(`SobolRsg_dimension`) = c("SWIGFunction", class('SobolRsg_dimension'))

# Start of delete_SobolRsg

`delete_SobolRsg` = function(self)
{
  ;.Call('R_swig_delete_SobolRsg', self, PACKAGE='QuantLib');
  
}

attr(`delete_SobolRsg`, 'returnType') = 'void'
attr(`delete_SobolRsg`, "inputTypes") = c('_p_SobolRsg')
class(`delete_SobolRsg`) = c("SWIGFunction", class('delete_SobolRsg'))

# Start of accessor method for SobolRsg
setMethod('$', '_p_SobolRsg', function(x, name)

{
  accessorFuns = list('nextSequence' = SobolRsg_nextSequence, 'dimension' = SobolRsg_dimension);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for SobolRsg
setMethod('delete', '_p_SobolRsg', function(obj) {delete_SobolRsg(obj)})
# Start of new_LecuyerUniformRsg

`LecuyerUniformRsg` = function(dimensionality, rng)
{
  if(length(dimensionality) > 1) {
    warning("using only the first element of dimensionality");
  };
  
  
  ;ans = .Call('R_swig_new_LecuyerUniformRsg', dimensionality, rng, PACKAGE='QuantLib');
  class(ans) <- "_p_RandomSequenceGeneratorT_LecuyerUniformRng_t";
  
  reg.finalizer(ans, delete_LecuyerUniformRsg)
  ans
  
}

attr(`LecuyerUniformRsg`, 'returnType') = '_p_RandomSequenceGeneratorT_LecuyerUniformRng_t'
attr(`LecuyerUniformRsg`, "inputTypes") = c('integer', '_p_LecuyerUniformRng')
class(`LecuyerUniformRsg`) = c("SWIGFunction", class('LecuyerUniformRsg'))

# Start of LecuyerUniformRsg_nextSequence

`LecuyerUniformRsg_nextSequence` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_LecuyerUniformRsg_nextSequence', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_SampleT_std__vectorT_double_std__allocatorT_double_t_t_t";
  
  ans
  
}

attr(`LecuyerUniformRsg_nextSequence`, 'returnType') = '_p_SampleT_std__vectorT_double_std__allocatorT_double_t_t_t'
attr(`LecuyerUniformRsg_nextSequence`, "inputTypes") = c('_p_RandomSequenceGeneratorT_LecuyerUniformRng_t')
class(`LecuyerUniformRsg_nextSequence`) = c("SWIGFunction", class('LecuyerUniformRsg_nextSequence'))

# Start of LecuyerUniformRsg_dimension

`LecuyerUniformRsg_dimension` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_LecuyerUniformRsg_dimension', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__size_t";
  
  ans
  
}

attr(`LecuyerUniformRsg_dimension`, 'returnType') = 'integer'
attr(`LecuyerUniformRsg_dimension`, "inputTypes") = c('_p_RandomSequenceGeneratorT_LecuyerUniformRng_t')
class(`LecuyerUniformRsg_dimension`) = c("SWIGFunction", class('LecuyerUniformRsg_dimension'))

# Start of delete_LecuyerUniformRsg

`delete_LecuyerUniformRsg` = function(self)
{
  ;.Call('R_swig_delete_LecuyerUniformRsg', self, PACKAGE='QuantLib');
  
}

attr(`delete_LecuyerUniformRsg`, 'returnType') = 'void'
attr(`delete_LecuyerUniformRsg`, "inputTypes") = c('_p_RandomSequenceGeneratorT_LecuyerUniformRng_t')
class(`delete_LecuyerUniformRsg`) = c("SWIGFunction", class('delete_LecuyerUniformRsg'))

# Start of accessor method for RandomSequenceGenerator<(LecuyerUniformRng)>
setMethod('$', '_p_RandomSequenceGeneratorT_LecuyerUniformRng_t', function(x, name)

{
  accessorFuns = list('nextSequence' = LecuyerUniformRsg_nextSequence, 'dimension' = LecuyerUniformRsg_dimension);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for RandomSequenceGenerator<(LecuyerUniformRng)>
setMethod('delete', '_p_RandomSequenceGeneratorT_LecuyerUniformRng_t', function(obj) {delete_RandomSequenceGeneratorT_LecuyerUniformRng_t(obj)})
# Start of new_KnuthUniformRsg

`KnuthUniformRsg` = function(dimensionality, rng)
{
  if(length(dimensionality) > 1) {
    warning("using only the first element of dimensionality");
  };
  
  
  ;ans = .Call('R_swig_new_KnuthUniformRsg', dimensionality, rng, PACKAGE='QuantLib');
  class(ans) <- "_p_RandomSequenceGeneratorT_KnuthUniformRng_t";
  
  reg.finalizer(ans, delete_KnuthUniformRsg)
  ans
  
}

attr(`KnuthUniformRsg`, 'returnType') = '_p_RandomSequenceGeneratorT_KnuthUniformRng_t'
attr(`KnuthUniformRsg`, "inputTypes") = c('integer', '_p_KnuthUniformRng')
class(`KnuthUniformRsg`) = c("SWIGFunction", class('KnuthUniformRsg'))

# Start of KnuthUniformRsg_nextSequence

`KnuthUniformRsg_nextSequence` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_KnuthUniformRsg_nextSequence', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_SampleT_std__vectorT_double_std__allocatorT_double_t_t_t";
  
  ans
  
}

attr(`KnuthUniformRsg_nextSequence`, 'returnType') = '_p_SampleT_std__vectorT_double_std__allocatorT_double_t_t_t'
attr(`KnuthUniformRsg_nextSequence`, "inputTypes") = c('_p_RandomSequenceGeneratorT_KnuthUniformRng_t')
class(`KnuthUniformRsg_nextSequence`) = c("SWIGFunction", class('KnuthUniformRsg_nextSequence'))

# Start of KnuthUniformRsg_dimension

`KnuthUniformRsg_dimension` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_KnuthUniformRsg_dimension', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__size_t";
  
  ans
  
}

attr(`KnuthUniformRsg_dimension`, 'returnType') = 'integer'
attr(`KnuthUniformRsg_dimension`, "inputTypes") = c('_p_RandomSequenceGeneratorT_KnuthUniformRng_t')
class(`KnuthUniformRsg_dimension`) = c("SWIGFunction", class('KnuthUniformRsg_dimension'))

# Start of delete_KnuthUniformRsg

`delete_KnuthUniformRsg` = function(self)
{
  ;.Call('R_swig_delete_KnuthUniformRsg', self, PACKAGE='QuantLib');
  
}

attr(`delete_KnuthUniformRsg`, 'returnType') = 'void'
attr(`delete_KnuthUniformRsg`, "inputTypes") = c('_p_RandomSequenceGeneratorT_KnuthUniformRng_t')
class(`delete_KnuthUniformRsg`) = c("SWIGFunction", class('delete_KnuthUniformRsg'))

# Start of accessor method for RandomSequenceGenerator<(KnuthUniformRng)>
setMethod('$', '_p_RandomSequenceGeneratorT_KnuthUniformRng_t', function(x, name)

{
  accessorFuns = list('nextSequence' = KnuthUniformRsg_nextSequence, 'dimension' = KnuthUniformRsg_dimension);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for RandomSequenceGenerator<(KnuthUniformRng)>
setMethod('delete', '_p_RandomSequenceGeneratorT_KnuthUniformRng_t', function(obj) {delete_RandomSequenceGeneratorT_KnuthUniformRng_t(obj)})
# Start of new_MersenneTwisterUniformRsg

`MersenneTwisterUniformRsg` = function(dimensionality, rng)
{
  if(length(dimensionality) > 1) {
    warning("using only the first element of dimensionality");
  };
  
  
  ;ans = .Call('R_swig_new_MersenneTwisterUniformRsg', dimensionality, rng, PACKAGE='QuantLib');
  class(ans) <- "_p_RandomSequenceGeneratorT_MersenneTwisterUniformRng_t";
  
  reg.finalizer(ans, delete_MersenneTwisterUniformRsg)
  ans
  
}

attr(`MersenneTwisterUniformRsg`, 'returnType') = '_p_RandomSequenceGeneratorT_MersenneTwisterUniformRng_t'
attr(`MersenneTwisterUniformRsg`, "inputTypes") = c('integer', '_p_MersenneTwisterUniformRng')
class(`MersenneTwisterUniformRsg`) = c("SWIGFunction", class('MersenneTwisterUniformRsg'))

# Start of MersenneTwisterUniformRsg_nextSequence

`MersenneTwisterUniformRsg_nextSequence` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_MersenneTwisterUniformRsg_nextSequence', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_SampleT_std__vectorT_double_std__allocatorT_double_t_t_t";
  
  ans
  
}

attr(`MersenneTwisterUniformRsg_nextSequence`, 'returnType') = '_p_SampleT_std__vectorT_double_std__allocatorT_double_t_t_t'
attr(`MersenneTwisterUniformRsg_nextSequence`, "inputTypes") = c('_p_RandomSequenceGeneratorT_MersenneTwisterUniformRng_t')
class(`MersenneTwisterUniformRsg_nextSequence`) = c("SWIGFunction", class('MersenneTwisterUniformRsg_nextSequence'))

# Start of MersenneTwisterUniformRsg_dimension

`MersenneTwisterUniformRsg_dimension` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_MersenneTwisterUniformRsg_dimension', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__size_t";
  
  ans
  
}

attr(`MersenneTwisterUniformRsg_dimension`, 'returnType') = 'integer'
attr(`MersenneTwisterUniformRsg_dimension`, "inputTypes") = c('_p_RandomSequenceGeneratorT_MersenneTwisterUniformRng_t')
class(`MersenneTwisterUniformRsg_dimension`) = c("SWIGFunction", class('MersenneTwisterUniformRsg_dimension'))

# Start of delete_MersenneTwisterUniformRsg

`delete_MersenneTwisterUniformRsg` = function(self)
{
  ;.Call('R_swig_delete_MersenneTwisterUniformRsg', self, PACKAGE='QuantLib');
  
}

attr(`delete_MersenneTwisterUniformRsg`, 'returnType') = 'void'
attr(`delete_MersenneTwisterUniformRsg`, "inputTypes") = c('_p_RandomSequenceGeneratorT_MersenneTwisterUniformRng_t')
class(`delete_MersenneTwisterUniformRsg`) = c("SWIGFunction", class('delete_MersenneTwisterUniformRsg'))

# Start of accessor method for RandomSequenceGenerator<(MersenneTwisterUniformRng)>
setMethod('$', '_p_RandomSequenceGeneratorT_MersenneTwisterUniformRng_t', function(x, name)

{
  accessorFuns = list('nextSequence' = MersenneTwisterUniformRsg_nextSequence, 'dimension' = MersenneTwisterUniformRsg_dimension);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for RandomSequenceGenerator<(MersenneTwisterUniformRng)>
setMethod('delete', '_p_RandomSequenceGeneratorT_MersenneTwisterUniformRng_t', function(obj) {delete_RandomSequenceGeneratorT_MersenneTwisterUniformRng_t(obj)})
# Start of new_UniformRandomSequenceGenerator

`UniformRandomSequenceGenerator` = function(dimensionality, rng)
{
  if(length(dimensionality) > 1) {
    warning("using only the first element of dimensionality");
  };
  
  
  ;ans = .Call('R_swig_new_UniformRandomSequenceGenerator', dimensionality, rng, PACKAGE='QuantLib');
  class(ans) <- "_p_UniformRandomSequenceGenerator";
  
  reg.finalizer(ans, delete_UniformRandomSequenceGenerator)
  ans
  
}

attr(`UniformRandomSequenceGenerator`, 'returnType') = '_p_UniformRandomSequenceGenerator'
attr(`UniformRandomSequenceGenerator`, "inputTypes") = c('integer', '_p_UniformRandomGenerator')
class(`UniformRandomSequenceGenerator`) = c("SWIGFunction", class('UniformRandomSequenceGenerator'))

# Start of UniformRandomSequenceGenerator_nextSequence

`UniformRandomSequenceGenerator_nextSequence` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_UniformRandomSequenceGenerator_nextSequence', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_SampleT_std__vectorT_double_std__allocatorT_double_t_t_t";
  
  ans
  
}

attr(`UniformRandomSequenceGenerator_nextSequence`, 'returnType') = '_p_SampleT_std__vectorT_double_std__allocatorT_double_t_t_t'
attr(`UniformRandomSequenceGenerator_nextSequence`, "inputTypes") = c('_p_UniformRandomSequenceGenerator')
class(`UniformRandomSequenceGenerator_nextSequence`) = c("SWIGFunction", class('UniformRandomSequenceGenerator_nextSequence'))

# Start of UniformRandomSequenceGenerator_dimension

`UniformRandomSequenceGenerator_dimension` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_UniformRandomSequenceGenerator_dimension', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__size_t";
  
  ans
  
}

attr(`UniformRandomSequenceGenerator_dimension`, 'returnType') = 'integer'
attr(`UniformRandomSequenceGenerator_dimension`, "inputTypes") = c('_p_UniformRandomSequenceGenerator')
class(`UniformRandomSequenceGenerator_dimension`) = c("SWIGFunction", class('UniformRandomSequenceGenerator_dimension'))

# Start of delete_UniformRandomSequenceGenerator

`delete_UniformRandomSequenceGenerator` = function(self)
{
  ;.Call('R_swig_delete_UniformRandomSequenceGenerator', self, PACKAGE='QuantLib');
  
}

attr(`delete_UniformRandomSequenceGenerator`, 'returnType') = 'void'
attr(`delete_UniformRandomSequenceGenerator`, "inputTypes") = c('_p_UniformRandomSequenceGenerator')
class(`delete_UniformRandomSequenceGenerator`) = c("SWIGFunction", class('delete_UniformRandomSequenceGenerator'))

# Start of accessor method for UniformRandomSequenceGenerator
setMethod('$', '_p_UniformRandomSequenceGenerator', function(x, name)

{
  accessorFuns = list('nextSequence' = UniformRandomSequenceGenerator_nextSequence, 'dimension' = UniformRandomSequenceGenerator_dimension);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for UniformRandomSequenceGenerator
setMethod('delete', '_p_UniformRandomSequenceGenerator', function(obj) {delete_UniformRandomSequenceGenerator(obj)})
# Start of new_UniformLowDiscrepancySequenceGenerator

`UniformLowDiscrepancySequenceGenerator` = function(dimensionality)
{
  if(length(dimensionality) > 1) {
    warning("using only the first element of dimensionality");
  };
  
  ;ans = .Call('R_swig_new_UniformLowDiscrepancySequenceGenerator', dimensionality, PACKAGE='QuantLib');
  class(ans) <- "_p_UniformLowDiscrepancySequenceGenerator";
  
  reg.finalizer(ans, delete_UniformLowDiscrepancySequenceGenerator)
  ans
  
}

attr(`UniformLowDiscrepancySequenceGenerator`, 'returnType') = '_p_UniformLowDiscrepancySequenceGenerator'
attr(`UniformLowDiscrepancySequenceGenerator`, "inputTypes") = c('integer')
class(`UniformLowDiscrepancySequenceGenerator`) = c("SWIGFunction", class('UniformLowDiscrepancySequenceGenerator'))

# Start of UniformLowDiscrepancySequenceGenerator_nextSequence

`UniformLowDiscrepancySequenceGenerator_nextSequence` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_UniformLowDiscrepancySequenceGenerator_nextSequence', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_SampleT_std__vectorT_double_std__allocatorT_double_t_t_t";
  
  ans
  
}

attr(`UniformLowDiscrepancySequenceGenerator_nextSequence`, 'returnType') = '_p_SampleT_std__vectorT_double_std__allocatorT_double_t_t_t'
attr(`UniformLowDiscrepancySequenceGenerator_nextSequence`, "inputTypes") = c('_p_UniformLowDiscrepancySequenceGenerator')
class(`UniformLowDiscrepancySequenceGenerator_nextSequence`) = c("SWIGFunction", class('UniformLowDiscrepancySequenceGenerator_nextSequence'))

# Start of UniformLowDiscrepancySequenceGenerator_dimension

`UniformLowDiscrepancySequenceGenerator_dimension` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_UniformLowDiscrepancySequenceGenerator_dimension', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__size_t";
  
  ans
  
}

attr(`UniformLowDiscrepancySequenceGenerator_dimension`, 'returnType') = 'integer'
attr(`UniformLowDiscrepancySequenceGenerator_dimension`, "inputTypes") = c('_p_UniformLowDiscrepancySequenceGenerator')
class(`UniformLowDiscrepancySequenceGenerator_dimension`) = c("SWIGFunction", class('UniformLowDiscrepancySequenceGenerator_dimension'))

# Start of delete_UniformLowDiscrepancySequenceGenerator

`delete_UniformLowDiscrepancySequenceGenerator` = function(self)
{
  ;.Call('R_swig_delete_UniformLowDiscrepancySequenceGenerator', self, PACKAGE='QuantLib');
  
}

attr(`delete_UniformLowDiscrepancySequenceGenerator`, 'returnType') = 'void'
attr(`delete_UniformLowDiscrepancySequenceGenerator`, "inputTypes") = c('_p_UniformLowDiscrepancySequenceGenerator')
class(`delete_UniformLowDiscrepancySequenceGenerator`) = c("SWIGFunction", class('delete_UniformLowDiscrepancySequenceGenerator'))

# Start of accessor method for UniformLowDiscrepancySequenceGenerator
setMethod('$', '_p_UniformLowDiscrepancySequenceGenerator', function(x, name)

{
  accessorFuns = list('nextSequence' = UniformLowDiscrepancySequenceGenerator_nextSequence, 'dimension' = UniformLowDiscrepancySequenceGenerator_dimension);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for UniformLowDiscrepancySequenceGenerator
setMethod('delete', '_p_UniformLowDiscrepancySequenceGenerator', function(obj) {delete_UniformLowDiscrepancySequenceGenerator(obj)})
# Start of new_MoroInvCumulativeLecuyerGaussianRsg

`MoroInvCumulativeLecuyerGaussianRsg` = function(uniformSequenceGenerator)
{
  ;ans = .Call('R_swig_new_MoroInvCumulativeLecuyerGaussianRsg', uniformSequenceGenerator, PACKAGE='QuantLib');
  class(ans) <- "_p_InverseCumulativeRsgT_RandomSequenceGeneratorT_LecuyerUniformRng_t_MoroInverseCumulativeNormal_t";
  
  reg.finalizer(ans, delete_MoroInvCumulativeLecuyerGaussianRsg)
  ans
  
}

attr(`MoroInvCumulativeLecuyerGaussianRsg`, 'returnType') = '_p_InverseCumulativeRsgT_RandomSequenceGeneratorT_LecuyerUniformRng_t_MoroInverseCumulativeNormal_t'
attr(`MoroInvCumulativeLecuyerGaussianRsg`, "inputTypes") = c('_p_RandomSequenceGeneratorT_LecuyerUniformRng_t')
class(`MoroInvCumulativeLecuyerGaussianRsg`) = c("SWIGFunction", class('MoroInvCumulativeLecuyerGaussianRsg'))

# Start of MoroInvCumulativeLecuyerGaussianRsg_nextSequence

`MoroInvCumulativeLecuyerGaussianRsg_nextSequence` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_MoroInvCumulativeLecuyerGaussianRsg_nextSequence', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_SampleT_std__vectorT_double_std__allocatorT_double_t_t_t";
  
  ans
  
}

attr(`MoroInvCumulativeLecuyerGaussianRsg_nextSequence`, 'returnType') = '_p_SampleT_std__vectorT_double_std__allocatorT_double_t_t_t'
attr(`MoroInvCumulativeLecuyerGaussianRsg_nextSequence`, "inputTypes") = c('_p_InverseCumulativeRsgT_RandomSequenceGeneratorT_LecuyerUniformRng_t_MoroInverseCumulativeNormal_t')
class(`MoroInvCumulativeLecuyerGaussianRsg_nextSequence`) = c("SWIGFunction", class('MoroInvCumulativeLecuyerGaussianRsg_nextSequence'))

# Start of MoroInvCumulativeLecuyerGaussianRsg_dimension

`MoroInvCumulativeLecuyerGaussianRsg_dimension` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_MoroInvCumulativeLecuyerGaussianRsg_dimension', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__size_t";
  
  ans
  
}

attr(`MoroInvCumulativeLecuyerGaussianRsg_dimension`, 'returnType') = 'integer'
attr(`MoroInvCumulativeLecuyerGaussianRsg_dimension`, "inputTypes") = c('_p_InverseCumulativeRsgT_RandomSequenceGeneratorT_LecuyerUniformRng_t_MoroInverseCumulativeNormal_t')
class(`MoroInvCumulativeLecuyerGaussianRsg_dimension`) = c("SWIGFunction", class('MoroInvCumulativeLecuyerGaussianRsg_dimension'))

# Start of delete_MoroInvCumulativeLecuyerGaussianRsg

`delete_MoroInvCumulativeLecuyerGaussianRsg` = function(self)
{
  ;.Call('R_swig_delete_MoroInvCumulativeLecuyerGaussianRsg', self, PACKAGE='QuantLib');
  
}

attr(`delete_MoroInvCumulativeLecuyerGaussianRsg`, 'returnType') = 'void'
attr(`delete_MoroInvCumulativeLecuyerGaussianRsg`, "inputTypes") = c('_p_InverseCumulativeRsgT_RandomSequenceGeneratorT_LecuyerUniformRng_t_MoroInverseCumulativeNormal_t')
class(`delete_MoroInvCumulativeLecuyerGaussianRsg`) = c("SWIGFunction", class('delete_MoroInvCumulativeLecuyerGaussianRsg'))

# Start of accessor method for InverseCumulativeRsg<(RandomSequenceGenerator<(LecuyerUniformRng)>,MoroInverseCumulativeNormal)>
setMethod('$', '_p_InverseCumulativeRsgT_RandomSequenceGeneratorT_LecuyerUniformRng_t_MoroInverseCumulativeNormal_t', function(x, name)

{
  accessorFuns = list('nextSequence' = MoroInvCumulativeLecuyerGaussianRsg_nextSequence, 'dimension' = MoroInvCumulativeLecuyerGaussianRsg_dimension);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for InverseCumulativeRsg<(RandomSequenceGenerator<(LecuyerUniformRng)>,MoroInverseCumulativeNormal)>
setMethod('delete', '_p_InverseCumulativeRsgT_RandomSequenceGeneratorT_LecuyerUniformRng_t_MoroInverseCumulativeNormal_t', function(obj) {delete_InverseCumulativeRsgT_RandomSequenceGeneratorT_LecuyerUniformRng_t_MoroInverseCumulativeNormal_t(obj)})
# Start of new_MoroInvCumulativeKnuthGaussianRsg

`MoroInvCumulativeKnuthGaussianRsg` = function(uniformSequenceGenerator)
{
  ;ans = .Call('R_swig_new_MoroInvCumulativeKnuthGaussianRsg', uniformSequenceGenerator, PACKAGE='QuantLib');
  class(ans) <- "_p_InverseCumulativeRsgT_RandomSequenceGeneratorT_KnuthUniformRng_t_MoroInverseCumulativeNormal_t";
  
  reg.finalizer(ans, delete_MoroInvCumulativeKnuthGaussianRsg)
  ans
  
}

attr(`MoroInvCumulativeKnuthGaussianRsg`, 'returnType') = '_p_InverseCumulativeRsgT_RandomSequenceGeneratorT_KnuthUniformRng_t_MoroInverseCumulativeNormal_t'
attr(`MoroInvCumulativeKnuthGaussianRsg`, "inputTypes") = c('_p_RandomSequenceGeneratorT_KnuthUniformRng_t')
class(`MoroInvCumulativeKnuthGaussianRsg`) = c("SWIGFunction", class('MoroInvCumulativeKnuthGaussianRsg'))

# Start of MoroInvCumulativeKnuthGaussianRsg_nextSequence

`MoroInvCumulativeKnuthGaussianRsg_nextSequence` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_MoroInvCumulativeKnuthGaussianRsg_nextSequence', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_SampleT_std__vectorT_double_std__allocatorT_double_t_t_t";
  
  ans
  
}

attr(`MoroInvCumulativeKnuthGaussianRsg_nextSequence`, 'returnType') = '_p_SampleT_std__vectorT_double_std__allocatorT_double_t_t_t'
attr(`MoroInvCumulativeKnuthGaussianRsg_nextSequence`, "inputTypes") = c('_p_InverseCumulativeRsgT_RandomSequenceGeneratorT_KnuthUniformRng_t_MoroInverseCumulativeNormal_t')
class(`MoroInvCumulativeKnuthGaussianRsg_nextSequence`) = c("SWIGFunction", class('MoroInvCumulativeKnuthGaussianRsg_nextSequence'))

# Start of MoroInvCumulativeKnuthGaussianRsg_dimension

`MoroInvCumulativeKnuthGaussianRsg_dimension` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_MoroInvCumulativeKnuthGaussianRsg_dimension', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__size_t";
  
  ans
  
}

attr(`MoroInvCumulativeKnuthGaussianRsg_dimension`, 'returnType') = 'integer'
attr(`MoroInvCumulativeKnuthGaussianRsg_dimension`, "inputTypes") = c('_p_InverseCumulativeRsgT_RandomSequenceGeneratorT_KnuthUniformRng_t_MoroInverseCumulativeNormal_t')
class(`MoroInvCumulativeKnuthGaussianRsg_dimension`) = c("SWIGFunction", class('MoroInvCumulativeKnuthGaussianRsg_dimension'))

# Start of delete_MoroInvCumulativeKnuthGaussianRsg

`delete_MoroInvCumulativeKnuthGaussianRsg` = function(self)
{
  ;.Call('R_swig_delete_MoroInvCumulativeKnuthGaussianRsg', self, PACKAGE='QuantLib');
  
}

attr(`delete_MoroInvCumulativeKnuthGaussianRsg`, 'returnType') = 'void'
attr(`delete_MoroInvCumulativeKnuthGaussianRsg`, "inputTypes") = c('_p_InverseCumulativeRsgT_RandomSequenceGeneratorT_KnuthUniformRng_t_MoroInverseCumulativeNormal_t')
class(`delete_MoroInvCumulativeKnuthGaussianRsg`) = c("SWIGFunction", class('delete_MoroInvCumulativeKnuthGaussianRsg'))

# Start of accessor method for InverseCumulativeRsg<(RandomSequenceGenerator<(KnuthUniformRng)>,MoroInverseCumulativeNormal)>
setMethod('$', '_p_InverseCumulativeRsgT_RandomSequenceGeneratorT_KnuthUniformRng_t_MoroInverseCumulativeNormal_t', function(x, name)

{
  accessorFuns = list('nextSequence' = MoroInvCumulativeKnuthGaussianRsg_nextSequence, 'dimension' = MoroInvCumulativeKnuthGaussianRsg_dimension);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for InverseCumulativeRsg<(RandomSequenceGenerator<(KnuthUniformRng)>,MoroInverseCumulativeNormal)>
setMethod('delete', '_p_InverseCumulativeRsgT_RandomSequenceGeneratorT_KnuthUniformRng_t_MoroInverseCumulativeNormal_t', function(obj) {delete_InverseCumulativeRsgT_RandomSequenceGeneratorT_KnuthUniformRng_t_MoroInverseCumulativeNormal_t(obj)})
# Start of new_MoroInvCumulativeMersenneTwisterGaussianRsg

`MoroInvCumulativeMersenneTwisterGaussianRsg` = function(uniformSequenceGenerator)
{
  ;ans = .Call('R_swig_new_MoroInvCumulativeMersenneTwisterGaussianRsg', uniformSequenceGenerator, PACKAGE='QuantLib');
  class(ans) <- "_p_InverseCumulativeRsgT_RandomSequenceGeneratorT_MersenneTwisterUniformRng_t_MoroInverseCumulativeNormal_t";
  
  reg.finalizer(ans, delete_MoroInvCumulativeMersenneTwisterGaussianRsg)
  ans
  
}

attr(`MoroInvCumulativeMersenneTwisterGaussianRsg`, 'returnType') = '_p_InverseCumulativeRsgT_RandomSequenceGeneratorT_MersenneTwisterUniformRng_t_MoroInverseCumulativeNormal_t'
attr(`MoroInvCumulativeMersenneTwisterGaussianRsg`, "inputTypes") = c('_p_RandomSequenceGeneratorT_MersenneTwisterUniformRng_t')
class(`MoroInvCumulativeMersenneTwisterGaussianRsg`) = c("SWIGFunction", class('MoroInvCumulativeMersenneTwisterGaussianRsg'))

# Start of MoroInvCumulativeMersenneTwisterGaussianRsg_nextSequence

`MoroInvCumulativeMersenneTwisterGaussianRsg_nextSequence` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_MoroInvCumulativeMersenneTwisterGaussianRsg_nextSequence', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_SampleT_std__vectorT_double_std__allocatorT_double_t_t_t";
  
  ans
  
}

attr(`MoroInvCumulativeMersenneTwisterGaussianRsg_nextSequence`, 'returnType') = '_p_SampleT_std__vectorT_double_std__allocatorT_double_t_t_t'
attr(`MoroInvCumulativeMersenneTwisterGaussianRsg_nextSequence`, "inputTypes") = c('_p_InverseCumulativeRsgT_RandomSequenceGeneratorT_MersenneTwisterUniformRng_t_MoroInverseCumulativeNormal_t')
class(`MoroInvCumulativeMersenneTwisterGaussianRsg_nextSequence`) = c("SWIGFunction", class('MoroInvCumulativeMersenneTwisterGaussianRsg_nextSequence'))

# Start of MoroInvCumulativeMersenneTwisterGaussianRsg_dimension

`MoroInvCumulativeMersenneTwisterGaussianRsg_dimension` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_MoroInvCumulativeMersenneTwisterGaussianRsg_dimension', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__size_t";
  
  ans
  
}

attr(`MoroInvCumulativeMersenneTwisterGaussianRsg_dimension`, 'returnType') = 'integer'
attr(`MoroInvCumulativeMersenneTwisterGaussianRsg_dimension`, "inputTypes") = c('_p_InverseCumulativeRsgT_RandomSequenceGeneratorT_MersenneTwisterUniformRng_t_MoroInverseCumulativeNormal_t')
class(`MoroInvCumulativeMersenneTwisterGaussianRsg_dimension`) = c("SWIGFunction", class('MoroInvCumulativeMersenneTwisterGaussianRsg_dimension'))

# Start of delete_MoroInvCumulativeMersenneTwisterGaussianRsg

`delete_MoroInvCumulativeMersenneTwisterGaussianRsg` = function(self)
{
  ;.Call('R_swig_delete_MoroInvCumulativeMersenneTwisterGaussianRsg', self, PACKAGE='QuantLib');
  
}

attr(`delete_MoroInvCumulativeMersenneTwisterGaussianRsg`, 'returnType') = 'void'
attr(`delete_MoroInvCumulativeMersenneTwisterGaussianRsg`, "inputTypes") = c('_p_InverseCumulativeRsgT_RandomSequenceGeneratorT_MersenneTwisterUniformRng_t_MoroInverseCumulativeNormal_t')
class(`delete_MoroInvCumulativeMersenneTwisterGaussianRsg`) = c("SWIGFunction", class('delete_MoroInvCumulativeMersenneTwisterGaussianRsg'))

# Start of accessor method for InverseCumulativeRsg<(RandomSequenceGenerator<(MersenneTwisterUniformRng)>,MoroInverseCumulativeNormal)>
setMethod('$', '_p_InverseCumulativeRsgT_RandomSequenceGeneratorT_MersenneTwisterUniformRng_t_MoroInverseCumulativeNormal_t', function(x, name)

{
  accessorFuns = list('nextSequence' = MoroInvCumulativeMersenneTwisterGaussianRsg_nextSequence, 'dimension' = MoroInvCumulativeMersenneTwisterGaussianRsg_dimension);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for InverseCumulativeRsg<(RandomSequenceGenerator<(MersenneTwisterUniformRng)>,MoroInverseCumulativeNormal)>
setMethod('delete', '_p_InverseCumulativeRsgT_RandomSequenceGeneratorT_MersenneTwisterUniformRng_t_MoroInverseCumulativeNormal_t', function(obj) {delete_InverseCumulativeRsgT_RandomSequenceGeneratorT_MersenneTwisterUniformRng_t_MoroInverseCumulativeNormal_t(obj)})
# Start of new_MoroInvCumulativeHaltonGaussianRsg

`MoroInvCumulativeHaltonGaussianRsg` = function(uniformSequenceGenerator)
{
  ;ans = .Call('R_swig_new_MoroInvCumulativeHaltonGaussianRsg', uniformSequenceGenerator, PACKAGE='QuantLib');
  class(ans) <- "_p_InverseCumulativeRsgT_HaltonRsg_MoroInverseCumulativeNormal_t";
  
  reg.finalizer(ans, delete_MoroInvCumulativeHaltonGaussianRsg)
  ans
  
}

attr(`MoroInvCumulativeHaltonGaussianRsg`, 'returnType') = '_p_InverseCumulativeRsgT_HaltonRsg_MoroInverseCumulativeNormal_t'
attr(`MoroInvCumulativeHaltonGaussianRsg`, "inputTypes") = c('_p_HaltonRsg')
class(`MoroInvCumulativeHaltonGaussianRsg`) = c("SWIGFunction", class('MoroInvCumulativeHaltonGaussianRsg'))

# Start of MoroInvCumulativeHaltonGaussianRsg_nextSequence

`MoroInvCumulativeHaltonGaussianRsg_nextSequence` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_MoroInvCumulativeHaltonGaussianRsg_nextSequence', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_SampleT_std__vectorT_double_std__allocatorT_double_t_t_t";
  
  ans
  
}

attr(`MoroInvCumulativeHaltonGaussianRsg_nextSequence`, 'returnType') = '_p_SampleT_std__vectorT_double_std__allocatorT_double_t_t_t'
attr(`MoroInvCumulativeHaltonGaussianRsg_nextSequence`, "inputTypes") = c('_p_InverseCumulativeRsgT_HaltonRsg_MoroInverseCumulativeNormal_t')
class(`MoroInvCumulativeHaltonGaussianRsg_nextSequence`) = c("SWIGFunction", class('MoroInvCumulativeHaltonGaussianRsg_nextSequence'))

# Start of MoroInvCumulativeHaltonGaussianRsg_dimension

`MoroInvCumulativeHaltonGaussianRsg_dimension` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_MoroInvCumulativeHaltonGaussianRsg_dimension', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__size_t";
  
  ans
  
}

attr(`MoroInvCumulativeHaltonGaussianRsg_dimension`, 'returnType') = 'integer'
attr(`MoroInvCumulativeHaltonGaussianRsg_dimension`, "inputTypes") = c('_p_InverseCumulativeRsgT_HaltonRsg_MoroInverseCumulativeNormal_t')
class(`MoroInvCumulativeHaltonGaussianRsg_dimension`) = c("SWIGFunction", class('MoroInvCumulativeHaltonGaussianRsg_dimension'))

# Start of delete_MoroInvCumulativeHaltonGaussianRsg

`delete_MoroInvCumulativeHaltonGaussianRsg` = function(self)
{
  ;.Call('R_swig_delete_MoroInvCumulativeHaltonGaussianRsg', self, PACKAGE='QuantLib');
  
}

attr(`delete_MoroInvCumulativeHaltonGaussianRsg`, 'returnType') = 'void'
attr(`delete_MoroInvCumulativeHaltonGaussianRsg`, "inputTypes") = c('_p_InverseCumulativeRsgT_HaltonRsg_MoroInverseCumulativeNormal_t')
class(`delete_MoroInvCumulativeHaltonGaussianRsg`) = c("SWIGFunction", class('delete_MoroInvCumulativeHaltonGaussianRsg'))

# Start of accessor method for InverseCumulativeRsg<(HaltonRsg,MoroInverseCumulativeNormal)>
setMethod('$', '_p_InverseCumulativeRsgT_HaltonRsg_MoroInverseCumulativeNormal_t', function(x, name)

{
  accessorFuns = list('nextSequence' = MoroInvCumulativeHaltonGaussianRsg_nextSequence, 'dimension' = MoroInvCumulativeHaltonGaussianRsg_dimension);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for InverseCumulativeRsg<(HaltonRsg,MoroInverseCumulativeNormal)>
setMethod('delete', '_p_InverseCumulativeRsgT_HaltonRsg_MoroInverseCumulativeNormal_t', function(obj) {delete_InverseCumulativeRsgT_HaltonRsg_MoroInverseCumulativeNormal_t(obj)})
# Start of new_InvCumulativeLecuyerGaussianRsg

`InvCumulativeLecuyerGaussianRsg` = function(uniformSequenceGenerator)
{
  ;ans = .Call('R_swig_new_InvCumulativeLecuyerGaussianRsg', uniformSequenceGenerator, PACKAGE='QuantLib');
  class(ans) <- "_p_InverseCumulativeRsgT_RandomSequenceGeneratorT_LecuyerUniformRng_t_InverseCumulativeNormal_t";
  
  reg.finalizer(ans, delete_InvCumulativeLecuyerGaussianRsg)
  ans
  
}

attr(`InvCumulativeLecuyerGaussianRsg`, 'returnType') = '_p_InverseCumulativeRsgT_RandomSequenceGeneratorT_LecuyerUniformRng_t_InverseCumulativeNormal_t'
attr(`InvCumulativeLecuyerGaussianRsg`, "inputTypes") = c('_p_RandomSequenceGeneratorT_LecuyerUniformRng_t')
class(`InvCumulativeLecuyerGaussianRsg`) = c("SWIGFunction", class('InvCumulativeLecuyerGaussianRsg'))

# Start of InvCumulativeLecuyerGaussianRsg_nextSequence

`InvCumulativeLecuyerGaussianRsg_nextSequence` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_InvCumulativeLecuyerGaussianRsg_nextSequence', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_SampleT_std__vectorT_double_std__allocatorT_double_t_t_t";
  
  ans
  
}

attr(`InvCumulativeLecuyerGaussianRsg_nextSequence`, 'returnType') = '_p_SampleT_std__vectorT_double_std__allocatorT_double_t_t_t'
attr(`InvCumulativeLecuyerGaussianRsg_nextSequence`, "inputTypes") = c('_p_InverseCumulativeRsgT_RandomSequenceGeneratorT_LecuyerUniformRng_t_InverseCumulativeNormal_t')
class(`InvCumulativeLecuyerGaussianRsg_nextSequence`) = c("SWIGFunction", class('InvCumulativeLecuyerGaussianRsg_nextSequence'))

# Start of InvCumulativeLecuyerGaussianRsg_dimension

`InvCumulativeLecuyerGaussianRsg_dimension` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_InvCumulativeLecuyerGaussianRsg_dimension', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__size_t";
  
  ans
  
}

attr(`InvCumulativeLecuyerGaussianRsg_dimension`, 'returnType') = 'integer'
attr(`InvCumulativeLecuyerGaussianRsg_dimension`, "inputTypes") = c('_p_InverseCumulativeRsgT_RandomSequenceGeneratorT_LecuyerUniformRng_t_InverseCumulativeNormal_t')
class(`InvCumulativeLecuyerGaussianRsg_dimension`) = c("SWIGFunction", class('InvCumulativeLecuyerGaussianRsg_dimension'))

# Start of delete_InvCumulativeLecuyerGaussianRsg

`delete_InvCumulativeLecuyerGaussianRsg` = function(self)
{
  ;.Call('R_swig_delete_InvCumulativeLecuyerGaussianRsg', self, PACKAGE='QuantLib');
  
}

attr(`delete_InvCumulativeLecuyerGaussianRsg`, 'returnType') = 'void'
attr(`delete_InvCumulativeLecuyerGaussianRsg`, "inputTypes") = c('_p_InverseCumulativeRsgT_RandomSequenceGeneratorT_LecuyerUniformRng_t_InverseCumulativeNormal_t')
class(`delete_InvCumulativeLecuyerGaussianRsg`) = c("SWIGFunction", class('delete_InvCumulativeLecuyerGaussianRsg'))

# Start of accessor method for InverseCumulativeRsg<(RandomSequenceGenerator<(LecuyerUniformRng)>,InverseCumulativeNormal)>
setMethod('$', '_p_InverseCumulativeRsgT_RandomSequenceGeneratorT_LecuyerUniformRng_t_InverseCumulativeNormal_t', function(x, name)

{
  accessorFuns = list('nextSequence' = InvCumulativeLecuyerGaussianRsg_nextSequence, 'dimension' = InvCumulativeLecuyerGaussianRsg_dimension);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for InverseCumulativeRsg<(RandomSequenceGenerator<(LecuyerUniformRng)>,InverseCumulativeNormal)>
setMethod('delete', '_p_InverseCumulativeRsgT_RandomSequenceGeneratorT_LecuyerUniformRng_t_InverseCumulativeNormal_t', function(obj) {delete_InverseCumulativeRsgT_RandomSequenceGeneratorT_LecuyerUniformRng_t_InverseCumulativeNormal_t(obj)})
# Start of new_InvCumulativeKnuthGaussianRsg

`InvCumulativeKnuthGaussianRsg` = function(uniformSequenceGenerator)
{
  ;ans = .Call('R_swig_new_InvCumulativeKnuthGaussianRsg', uniformSequenceGenerator, PACKAGE='QuantLib');
  class(ans) <- "_p_InverseCumulativeRsgT_RandomSequenceGeneratorT_KnuthUniformRng_t_InverseCumulativeNormal_t";
  
  reg.finalizer(ans, delete_InvCumulativeKnuthGaussianRsg)
  ans
  
}

attr(`InvCumulativeKnuthGaussianRsg`, 'returnType') = '_p_InverseCumulativeRsgT_RandomSequenceGeneratorT_KnuthUniformRng_t_InverseCumulativeNormal_t'
attr(`InvCumulativeKnuthGaussianRsg`, "inputTypes") = c('_p_RandomSequenceGeneratorT_KnuthUniformRng_t')
class(`InvCumulativeKnuthGaussianRsg`) = c("SWIGFunction", class('InvCumulativeKnuthGaussianRsg'))

# Start of InvCumulativeKnuthGaussianRsg_nextSequence

`InvCumulativeKnuthGaussianRsg_nextSequence` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_InvCumulativeKnuthGaussianRsg_nextSequence', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_SampleT_std__vectorT_double_std__allocatorT_double_t_t_t";
  
  ans
  
}

attr(`InvCumulativeKnuthGaussianRsg_nextSequence`, 'returnType') = '_p_SampleT_std__vectorT_double_std__allocatorT_double_t_t_t'
attr(`InvCumulativeKnuthGaussianRsg_nextSequence`, "inputTypes") = c('_p_InverseCumulativeRsgT_RandomSequenceGeneratorT_KnuthUniformRng_t_InverseCumulativeNormal_t')
class(`InvCumulativeKnuthGaussianRsg_nextSequence`) = c("SWIGFunction", class('InvCumulativeKnuthGaussianRsg_nextSequence'))

# Start of InvCumulativeKnuthGaussianRsg_dimension

`InvCumulativeKnuthGaussianRsg_dimension` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_InvCumulativeKnuthGaussianRsg_dimension', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__size_t";
  
  ans
  
}

attr(`InvCumulativeKnuthGaussianRsg_dimension`, 'returnType') = 'integer'
attr(`InvCumulativeKnuthGaussianRsg_dimension`, "inputTypes") = c('_p_InverseCumulativeRsgT_RandomSequenceGeneratorT_KnuthUniformRng_t_InverseCumulativeNormal_t')
class(`InvCumulativeKnuthGaussianRsg_dimension`) = c("SWIGFunction", class('InvCumulativeKnuthGaussianRsg_dimension'))

# Start of delete_InvCumulativeKnuthGaussianRsg

`delete_InvCumulativeKnuthGaussianRsg` = function(self)
{
  ;.Call('R_swig_delete_InvCumulativeKnuthGaussianRsg', self, PACKAGE='QuantLib');
  
}

attr(`delete_InvCumulativeKnuthGaussianRsg`, 'returnType') = 'void'
attr(`delete_InvCumulativeKnuthGaussianRsg`, "inputTypes") = c('_p_InverseCumulativeRsgT_RandomSequenceGeneratorT_KnuthUniformRng_t_InverseCumulativeNormal_t')
class(`delete_InvCumulativeKnuthGaussianRsg`) = c("SWIGFunction", class('delete_InvCumulativeKnuthGaussianRsg'))

# Start of accessor method for InverseCumulativeRsg<(RandomSequenceGenerator<(KnuthUniformRng)>,InverseCumulativeNormal)>
setMethod('$', '_p_InverseCumulativeRsgT_RandomSequenceGeneratorT_KnuthUniformRng_t_InverseCumulativeNormal_t', function(x, name)

{
  accessorFuns = list('nextSequence' = InvCumulativeKnuthGaussianRsg_nextSequence, 'dimension' = InvCumulativeKnuthGaussianRsg_dimension);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for InverseCumulativeRsg<(RandomSequenceGenerator<(KnuthUniformRng)>,InverseCumulativeNormal)>
setMethod('delete', '_p_InverseCumulativeRsgT_RandomSequenceGeneratorT_KnuthUniformRng_t_InverseCumulativeNormal_t', function(obj) {delete_InverseCumulativeRsgT_RandomSequenceGeneratorT_KnuthUniformRng_t_InverseCumulativeNormal_t(obj)})
# Start of new_InvCumulativeMersenneTwisterGaussianRsg

`InvCumulativeMersenneTwisterGaussianRsg` = function(uniformSequenceGenerator)
{
  ;ans = .Call('R_swig_new_InvCumulativeMersenneTwisterGaussianRsg', uniformSequenceGenerator, PACKAGE='QuantLib');
  class(ans) <- "_p_InverseCumulativeRsgT_RandomSequenceGeneratorT_MersenneTwisterUniformRng_t_InverseCumulativeNormal_t";
  
  reg.finalizer(ans, delete_InvCumulativeMersenneTwisterGaussianRsg)
  ans
  
}

attr(`InvCumulativeMersenneTwisterGaussianRsg`, 'returnType') = '_p_InverseCumulativeRsgT_RandomSequenceGeneratorT_MersenneTwisterUniformRng_t_InverseCumulativeNormal_t'
attr(`InvCumulativeMersenneTwisterGaussianRsg`, "inputTypes") = c('_p_RandomSequenceGeneratorT_MersenneTwisterUniformRng_t')
class(`InvCumulativeMersenneTwisterGaussianRsg`) = c("SWIGFunction", class('InvCumulativeMersenneTwisterGaussianRsg'))

# Start of InvCumulativeMersenneTwisterGaussianRsg_nextSequence

`InvCumulativeMersenneTwisterGaussianRsg_nextSequence` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_InvCumulativeMersenneTwisterGaussianRsg_nextSequence', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_SampleT_std__vectorT_double_std__allocatorT_double_t_t_t";
  
  ans
  
}

attr(`InvCumulativeMersenneTwisterGaussianRsg_nextSequence`, 'returnType') = '_p_SampleT_std__vectorT_double_std__allocatorT_double_t_t_t'
attr(`InvCumulativeMersenneTwisterGaussianRsg_nextSequence`, "inputTypes") = c('_p_InverseCumulativeRsgT_RandomSequenceGeneratorT_MersenneTwisterUniformRng_t_InverseCumulativeNormal_t')
class(`InvCumulativeMersenneTwisterGaussianRsg_nextSequence`) = c("SWIGFunction", class('InvCumulativeMersenneTwisterGaussianRsg_nextSequence'))

# Start of InvCumulativeMersenneTwisterGaussianRsg_dimension

`InvCumulativeMersenneTwisterGaussianRsg_dimension` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_InvCumulativeMersenneTwisterGaussianRsg_dimension', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__size_t";
  
  ans
  
}

attr(`InvCumulativeMersenneTwisterGaussianRsg_dimension`, 'returnType') = 'integer'
attr(`InvCumulativeMersenneTwisterGaussianRsg_dimension`, "inputTypes") = c('_p_InverseCumulativeRsgT_RandomSequenceGeneratorT_MersenneTwisterUniformRng_t_InverseCumulativeNormal_t')
class(`InvCumulativeMersenneTwisterGaussianRsg_dimension`) = c("SWIGFunction", class('InvCumulativeMersenneTwisterGaussianRsg_dimension'))

# Start of delete_InvCumulativeMersenneTwisterGaussianRsg

`delete_InvCumulativeMersenneTwisterGaussianRsg` = function(self)
{
  ;.Call('R_swig_delete_InvCumulativeMersenneTwisterGaussianRsg', self, PACKAGE='QuantLib');
  
}

attr(`delete_InvCumulativeMersenneTwisterGaussianRsg`, 'returnType') = 'void'
attr(`delete_InvCumulativeMersenneTwisterGaussianRsg`, "inputTypes") = c('_p_InverseCumulativeRsgT_RandomSequenceGeneratorT_MersenneTwisterUniformRng_t_InverseCumulativeNormal_t')
class(`delete_InvCumulativeMersenneTwisterGaussianRsg`) = c("SWIGFunction", class('delete_InvCumulativeMersenneTwisterGaussianRsg'))

# Start of accessor method for InverseCumulativeRsg<(RandomSequenceGenerator<(MersenneTwisterUniformRng)>,InverseCumulativeNormal)>
setMethod('$', '_p_InverseCumulativeRsgT_RandomSequenceGeneratorT_MersenneTwisterUniformRng_t_InverseCumulativeNormal_t', function(x, name)

{
  accessorFuns = list('nextSequence' = InvCumulativeMersenneTwisterGaussianRsg_nextSequence, 'dimension' = InvCumulativeMersenneTwisterGaussianRsg_dimension);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for InverseCumulativeRsg<(RandomSequenceGenerator<(MersenneTwisterUniformRng)>,InverseCumulativeNormal)>
setMethod('delete', '_p_InverseCumulativeRsgT_RandomSequenceGeneratorT_MersenneTwisterUniformRng_t_InverseCumulativeNormal_t', function(obj) {delete_InverseCumulativeRsgT_RandomSequenceGeneratorT_MersenneTwisterUniformRng_t_InverseCumulativeNormal_t(obj)})
# Start of new_InvCumulativeHaltonGaussianRsg

`InvCumulativeHaltonGaussianRsg` = function(uniformSequenceGenerator)
{
  ;ans = .Call('R_swig_new_InvCumulativeHaltonGaussianRsg', uniformSequenceGenerator, PACKAGE='QuantLib');
  class(ans) <- "_p_InverseCumulativeRsgT_HaltonRsg_InverseCumulativeNormal_t";
  
  reg.finalizer(ans, delete_InvCumulativeHaltonGaussianRsg)
  ans
  
}

attr(`InvCumulativeHaltonGaussianRsg`, 'returnType') = '_p_InverseCumulativeRsgT_HaltonRsg_InverseCumulativeNormal_t'
attr(`InvCumulativeHaltonGaussianRsg`, "inputTypes") = c('_p_HaltonRsg')
class(`InvCumulativeHaltonGaussianRsg`) = c("SWIGFunction", class('InvCumulativeHaltonGaussianRsg'))

# Start of InvCumulativeHaltonGaussianRsg_nextSequence

`InvCumulativeHaltonGaussianRsg_nextSequence` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_InvCumulativeHaltonGaussianRsg_nextSequence', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_SampleT_std__vectorT_double_std__allocatorT_double_t_t_t";
  
  ans
  
}

attr(`InvCumulativeHaltonGaussianRsg_nextSequence`, 'returnType') = '_p_SampleT_std__vectorT_double_std__allocatorT_double_t_t_t'
attr(`InvCumulativeHaltonGaussianRsg_nextSequence`, "inputTypes") = c('_p_InverseCumulativeRsgT_HaltonRsg_InverseCumulativeNormal_t')
class(`InvCumulativeHaltonGaussianRsg_nextSequence`) = c("SWIGFunction", class('InvCumulativeHaltonGaussianRsg_nextSequence'))

# Start of InvCumulativeHaltonGaussianRsg_dimension

`InvCumulativeHaltonGaussianRsg_dimension` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_InvCumulativeHaltonGaussianRsg_dimension', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__size_t";
  
  ans
  
}

attr(`InvCumulativeHaltonGaussianRsg_dimension`, 'returnType') = 'integer'
attr(`InvCumulativeHaltonGaussianRsg_dimension`, "inputTypes") = c('_p_InverseCumulativeRsgT_HaltonRsg_InverseCumulativeNormal_t')
class(`InvCumulativeHaltonGaussianRsg_dimension`) = c("SWIGFunction", class('InvCumulativeHaltonGaussianRsg_dimension'))

# Start of delete_InvCumulativeHaltonGaussianRsg

`delete_InvCumulativeHaltonGaussianRsg` = function(self)
{
  ;.Call('R_swig_delete_InvCumulativeHaltonGaussianRsg', self, PACKAGE='QuantLib');
  
}

attr(`delete_InvCumulativeHaltonGaussianRsg`, 'returnType') = 'void'
attr(`delete_InvCumulativeHaltonGaussianRsg`, "inputTypes") = c('_p_InverseCumulativeRsgT_HaltonRsg_InverseCumulativeNormal_t')
class(`delete_InvCumulativeHaltonGaussianRsg`) = c("SWIGFunction", class('delete_InvCumulativeHaltonGaussianRsg'))

# Start of accessor method for InverseCumulativeRsg<(HaltonRsg,InverseCumulativeNormal)>
setMethod('$', '_p_InverseCumulativeRsgT_HaltonRsg_InverseCumulativeNormal_t', function(x, name)

{
  accessorFuns = list('nextSequence' = InvCumulativeHaltonGaussianRsg_nextSequence, 'dimension' = InvCumulativeHaltonGaussianRsg_dimension);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for InverseCumulativeRsg<(HaltonRsg,InverseCumulativeNormal)>
setMethod('delete', '_p_InverseCumulativeRsgT_HaltonRsg_InverseCumulativeNormal_t', function(obj) {delete_InverseCumulativeRsgT_HaltonRsg_InverseCumulativeNormal_t(obj)})
# Start of new_GaussianRandomSequenceGenerator

`GaussianRandomSequenceGenerator` = function(uniformSequenceGenerator)
{
  ;ans = .Call('R_swig_new_GaussianRandomSequenceGenerator', uniformSequenceGenerator, PACKAGE='QuantLib');
  class(ans) <- "_p_GaussianRandomSequenceGenerator";
  
  reg.finalizer(ans, delete_GaussianRandomSequenceGenerator)
  ans
  
}

attr(`GaussianRandomSequenceGenerator`, 'returnType') = '_p_GaussianRandomSequenceGenerator'
attr(`GaussianRandomSequenceGenerator`, "inputTypes") = c('_p_UniformRandomSequenceGenerator')
class(`GaussianRandomSequenceGenerator`) = c("SWIGFunction", class('GaussianRandomSequenceGenerator'))

# Start of GaussianRandomSequenceGenerator_nextSequence

`GaussianRandomSequenceGenerator_nextSequence` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_GaussianRandomSequenceGenerator_nextSequence', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_SampleT_std__vectorT_double_std__allocatorT_double_t_t_t";
  
  ans
  
}

attr(`GaussianRandomSequenceGenerator_nextSequence`, 'returnType') = '_p_SampleT_std__vectorT_double_std__allocatorT_double_t_t_t'
attr(`GaussianRandomSequenceGenerator_nextSequence`, "inputTypes") = c('_p_GaussianRandomSequenceGenerator')
class(`GaussianRandomSequenceGenerator_nextSequence`) = c("SWIGFunction", class('GaussianRandomSequenceGenerator_nextSequence'))

# Start of GaussianRandomSequenceGenerator_dimension

`GaussianRandomSequenceGenerator_dimension` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_GaussianRandomSequenceGenerator_dimension', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__size_t";
  
  ans
  
}

attr(`GaussianRandomSequenceGenerator_dimension`, 'returnType') = 'integer'
attr(`GaussianRandomSequenceGenerator_dimension`, "inputTypes") = c('_p_GaussianRandomSequenceGenerator')
class(`GaussianRandomSequenceGenerator_dimension`) = c("SWIGFunction", class('GaussianRandomSequenceGenerator_dimension'))

# Start of delete_GaussianRandomSequenceGenerator

`delete_GaussianRandomSequenceGenerator` = function(self)
{
  ;.Call('R_swig_delete_GaussianRandomSequenceGenerator', self, PACKAGE='QuantLib');
  
}

attr(`delete_GaussianRandomSequenceGenerator`, 'returnType') = 'void'
attr(`delete_GaussianRandomSequenceGenerator`, "inputTypes") = c('_p_GaussianRandomSequenceGenerator')
class(`delete_GaussianRandomSequenceGenerator`) = c("SWIGFunction", class('delete_GaussianRandomSequenceGenerator'))

# Start of accessor method for GaussianRandomSequenceGenerator
setMethod('$', '_p_GaussianRandomSequenceGenerator', function(x, name)

{
  accessorFuns = list('nextSequence' = GaussianRandomSequenceGenerator_nextSequence, 'dimension' = GaussianRandomSequenceGenerator_dimension);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for GaussianRandomSequenceGenerator
setMethod('delete', '_p_GaussianRandomSequenceGenerator', function(obj) {delete_GaussianRandomSequenceGenerator(obj)})
# Start of new_GaussianLowDiscrepancySequenceGenerator

`GaussianLowDiscrepancySequenceGenerator` = function(u)
{
  ;ans = .Call('R_swig_new_GaussianLowDiscrepancySequenceGenerator', u, PACKAGE='QuantLib');
  class(ans) <- "_p_GaussianLowDiscrepancySequenceGenerator";
  
  reg.finalizer(ans, delete_GaussianLowDiscrepancySequenceGenerator)
  ans
  
}

attr(`GaussianLowDiscrepancySequenceGenerator`, 'returnType') = '_p_GaussianLowDiscrepancySequenceGenerator'
attr(`GaussianLowDiscrepancySequenceGenerator`, "inputTypes") = c('_p_UniformLowDiscrepancySequenceGenerator')
class(`GaussianLowDiscrepancySequenceGenerator`) = c("SWIGFunction", class('GaussianLowDiscrepancySequenceGenerator'))

# Start of GaussianLowDiscrepancySequenceGenerator_nextSequence

`GaussianLowDiscrepancySequenceGenerator_nextSequence` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_GaussianLowDiscrepancySequenceGenerator_nextSequence', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_SampleT_std__vectorT_double_std__allocatorT_double_t_t_t";
  
  ans
  
}

attr(`GaussianLowDiscrepancySequenceGenerator_nextSequence`, 'returnType') = '_p_SampleT_std__vectorT_double_std__allocatorT_double_t_t_t'
attr(`GaussianLowDiscrepancySequenceGenerator_nextSequence`, "inputTypes") = c('_p_GaussianLowDiscrepancySequenceGenerator')
class(`GaussianLowDiscrepancySequenceGenerator_nextSequence`) = c("SWIGFunction", class('GaussianLowDiscrepancySequenceGenerator_nextSequence'))

# Start of GaussianLowDiscrepancySequenceGenerator_dimension

`GaussianLowDiscrepancySequenceGenerator_dimension` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_GaussianLowDiscrepancySequenceGenerator_dimension', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__size_t";
  
  ans
  
}

attr(`GaussianLowDiscrepancySequenceGenerator_dimension`, 'returnType') = 'integer'
attr(`GaussianLowDiscrepancySequenceGenerator_dimension`, "inputTypes") = c('_p_GaussianLowDiscrepancySequenceGenerator')
class(`GaussianLowDiscrepancySequenceGenerator_dimension`) = c("SWIGFunction", class('GaussianLowDiscrepancySequenceGenerator_dimension'))

# Start of delete_GaussianLowDiscrepancySequenceGenerator

`delete_GaussianLowDiscrepancySequenceGenerator` = function(self)
{
  ;.Call('R_swig_delete_GaussianLowDiscrepancySequenceGenerator', self, PACKAGE='QuantLib');
  
}

attr(`delete_GaussianLowDiscrepancySequenceGenerator`, 'returnType') = 'void'
attr(`delete_GaussianLowDiscrepancySequenceGenerator`, "inputTypes") = c('_p_GaussianLowDiscrepancySequenceGenerator')
class(`delete_GaussianLowDiscrepancySequenceGenerator`) = c("SWIGFunction", class('delete_GaussianLowDiscrepancySequenceGenerator'))

# Start of accessor method for GaussianLowDiscrepancySequenceGenerator
setMethod('$', '_p_GaussianLowDiscrepancySequenceGenerator', function(x, name)

{
  accessorFuns = list('nextSequence' = GaussianLowDiscrepancySequenceGenerator_nextSequence, 'dimension' = GaussianLowDiscrepancySequenceGenerator_dimension);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for GaussianLowDiscrepancySequenceGenerator
setMethod('delete', '_p_GaussianLowDiscrepancySequenceGenerator', function(obj) {delete_GaussianLowDiscrepancySequenceGenerator(obj)})
# Start of getCovariance

`getCovariance` = function(volatilities, correlations, .copy = FALSE)
{
  ;ans = .Call('R_swig_getCovariance', volatilities, correlations, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Matrix";
  
  ans
  
}

attr(`getCovariance`, 'returnType') = '_p_Matrix'
attr(`getCovariance`, "inputTypes") = c('_p_Array', '_p_Matrix')
class(`getCovariance`) = c("SWIGFunction", class('getCovariance'))

# Start of Path_length

`Path_length` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_Path_length', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__size_t";
  
  ans
  
}

attr(`Path_length`, 'returnType') = 'integer'
attr(`Path_length`, "inputTypes") = c('_p_Path')
class(`Path_length`) = c("SWIGFunction", class('Path_length'))

# Start of Path_value

`Path_value` = function(self, i, .copy = FALSE)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_Path_value', self, i, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Path_value`, 'returnType') = 'numeric'
attr(`Path_value`, "inputTypes") = c('_p_Path', 'integer')
class(`Path_value`) = c("SWIGFunction", class('Path_value'))

# Start of Path_front

`Path_front` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Path_front', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Path_front`, 'returnType') = 'numeric'
attr(`Path_front`, "inputTypes") = c('_p_Path')
class(`Path_front`) = c("SWIGFunction", class('Path_front'))

# Start of Path_back

`Path_back` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Path_back', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Path_back`, 'returnType') = 'numeric'
attr(`Path_back`, "inputTypes") = c('_p_Path')
class(`Path_back`) = c("SWIGFunction", class('Path_back'))

# Start of Path_time

`Path_time` = function(self, i, .copy = FALSE)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_Path_time', self, i, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Path_time`, 'returnType') = 'numeric'
attr(`Path_time`, "inputTypes") = c('_p_Path', 'integer')
class(`Path_time`) = c("SWIGFunction", class('Path_time'))

# Start of delete_Path

`delete_Path` = function(self)
{
  ;.Call('R_swig_delete_Path', self, PACKAGE='QuantLib');
  
}

attr(`delete_Path`, 'returnType') = 'void'
attr(`delete_Path`, "inputTypes") = c('_p_Path')
class(`delete_Path`) = c("SWIGFunction", class('delete_Path'))

# Start of accessor method for Path
setMethod('$', '_p_Path', function(x, name)

{
  accessorFuns = list('length' = Path_length, 'value' = Path_value, 'front' = Path_front, 'back' = Path_back, 'time' = Path_time);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for Path
setMethod('delete', '_p_Path', function(obj) {delete_Path(obj)})
# Start of SamplePath_value

`SamplePath_value` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_SamplePath_value', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Path";
  
  ans
  
}

attr(`SamplePath_value`, 'returnType') = '_p_Path'
attr(`SamplePath_value`, "inputTypes") = c('_p_SampleT_Path_t')
class(`SamplePath_value`) = c("SWIGFunction", class('SamplePath_value'))

# Start of SamplePath_weight

`SamplePath_weight` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_SamplePath_weight', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`SamplePath_weight`, 'returnType') = 'numeric'
attr(`SamplePath_weight`, "inputTypes") = c('_p_SampleT_Path_t')
class(`SamplePath_weight`) = c("SWIGFunction", class('SamplePath_weight'))

# Start of delete_SamplePath

`delete_SamplePath` = function(self)
{
  ;.Call('R_swig_delete_SamplePath', self, PACKAGE='QuantLib');
  
}

attr(`delete_SamplePath`, 'returnType') = 'void'
attr(`delete_SamplePath`, "inputTypes") = c('_p_SampleT_Path_t')
class(`delete_SamplePath`) = c("SWIGFunction", class('delete_SamplePath'))

# Start of accessor method for Sample<(Path)>
setMethod('$', '_p_SampleT_Path_t', function(x, name)

{
  accessorFuns = list('value' = SamplePath_value, 'weight' = SamplePath_weight);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for Sample<(Path)>
setMethod('delete', '_p_SampleT_Path_t', function(obj) {delete_SampleT_Path_t(obj)})
# Start of new_GaussianPathGenerator

`GaussianPathGenerator` = function(process, length, steps, rsg, brownianBridge)
{
  if(length(steps) > 1) {
    warning("using only the first element of steps");
  };
  
  
  brownianBridge = as.logical(brownianBridge);
  ;ans = .Call('R_swig_new_GaussianPathGenerator', process, length, steps, rsg, brownianBridge, PACKAGE='QuantLib');
  class(ans) <- "_p_GaussianPathGenerator";
  
  reg.finalizer(ans, delete_GaussianPathGenerator)
  ans
  
}

attr(`GaussianPathGenerator`, 'returnType') = '_p_GaussianPathGenerator'
attr(`GaussianPathGenerator`, "inputTypes") = c('_p_StochasticProcess1DPtr', 'numeric', 'integer', '_p_GaussianRandomSequenceGenerator', 'logical')
class(`GaussianPathGenerator`) = c("SWIGFunction", class('GaussianPathGenerator'))

# Start of GaussianPathGenerator__next

`GaussianPathGenerator__next` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_GaussianPathGenerator__next', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_SampleT_Path_t";
  
  ans
  
}

attr(`GaussianPathGenerator__next`, 'returnType') = '_p_SampleT_Path_t'
attr(`GaussianPathGenerator__next`, "inputTypes") = c('_p_GaussianPathGenerator')
class(`GaussianPathGenerator__next`) = c("SWIGFunction", class('GaussianPathGenerator__next'))

# Start of GaussianPathGenerator_antithetic

`GaussianPathGenerator_antithetic` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_GaussianPathGenerator_antithetic', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_SampleT_Path_t";
  
  ans
  
}

attr(`GaussianPathGenerator_antithetic`, 'returnType') = '_p_SampleT_Path_t'
attr(`GaussianPathGenerator_antithetic`, "inputTypes") = c('_p_GaussianPathGenerator')
class(`GaussianPathGenerator_antithetic`) = c("SWIGFunction", class('GaussianPathGenerator_antithetic'))

# Start of delete_GaussianPathGenerator

`delete_GaussianPathGenerator` = function(self)
{
  ;.Call('R_swig_delete_GaussianPathGenerator', self, PACKAGE='QuantLib');
  
}

attr(`delete_GaussianPathGenerator`, 'returnType') = 'void'
attr(`delete_GaussianPathGenerator`, "inputTypes") = c('_p_GaussianPathGenerator')
class(`delete_GaussianPathGenerator`) = c("SWIGFunction", class('delete_GaussianPathGenerator'))

# Start of accessor method for GaussianPathGenerator
setMethod('$', '_p_GaussianPathGenerator', function(x, name)

{
  accessorFuns = list('_next' = GaussianPathGenerator__next, 'antithetic' = GaussianPathGenerator_antithetic);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for GaussianPathGenerator
setMethod('delete', '_p_GaussianPathGenerator', function(obj) {delete_GaussianPathGenerator(obj)})
# Start of new_GaussianSobolPathGenerator

`GaussianSobolPathGenerator` = function(process, length, steps, rsg, brownianBridge)
{
  if(length(steps) > 1) {
    warning("using only the first element of steps");
  };
  
  
  brownianBridge = as.logical(brownianBridge);
  ;ans = .Call('R_swig_new_GaussianSobolPathGenerator', process, length, steps, rsg, brownianBridge, PACKAGE='QuantLib');
  class(ans) <- "_p_GaussianSobolPathGenerator";
  
  reg.finalizer(ans, delete_GaussianSobolPathGenerator)
  ans
  
}

attr(`GaussianSobolPathGenerator`, 'returnType') = '_p_GaussianSobolPathGenerator'
attr(`GaussianSobolPathGenerator`, "inputTypes") = c('_p_StochasticProcess1DPtr', 'numeric', 'integer', '_p_GaussianLowDiscrepancySequenceGenerator', 'logical')
class(`GaussianSobolPathGenerator`) = c("SWIGFunction", class('GaussianSobolPathGenerator'))

# Start of GaussianSobolPathGenerator__next

`GaussianSobolPathGenerator__next` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_GaussianSobolPathGenerator__next', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_SampleT_Path_t";
  
  ans
  
}

attr(`GaussianSobolPathGenerator__next`, 'returnType') = '_p_SampleT_Path_t'
attr(`GaussianSobolPathGenerator__next`, "inputTypes") = c('_p_GaussianSobolPathGenerator')
class(`GaussianSobolPathGenerator__next`) = c("SWIGFunction", class('GaussianSobolPathGenerator__next'))

# Start of GaussianSobolPathGenerator_antithetic

`GaussianSobolPathGenerator_antithetic` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_GaussianSobolPathGenerator_antithetic', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_SampleT_Path_t";
  
  ans
  
}

attr(`GaussianSobolPathGenerator_antithetic`, 'returnType') = '_p_SampleT_Path_t'
attr(`GaussianSobolPathGenerator_antithetic`, "inputTypes") = c('_p_GaussianSobolPathGenerator')
class(`GaussianSobolPathGenerator_antithetic`) = c("SWIGFunction", class('GaussianSobolPathGenerator_antithetic'))

# Start of delete_GaussianSobolPathGenerator

`delete_GaussianSobolPathGenerator` = function(self)
{
  ;.Call('R_swig_delete_GaussianSobolPathGenerator', self, PACKAGE='QuantLib');
  
}

attr(`delete_GaussianSobolPathGenerator`, 'returnType') = 'void'
attr(`delete_GaussianSobolPathGenerator`, "inputTypes") = c('_p_GaussianSobolPathGenerator')
class(`delete_GaussianSobolPathGenerator`) = c("SWIGFunction", class('delete_GaussianSobolPathGenerator'))

# Start of accessor method for GaussianSobolPathGenerator
setMethod('$', '_p_GaussianSobolPathGenerator', function(x, name)

{
  accessorFuns = list('_next' = GaussianSobolPathGenerator__next, 'antithetic' = GaussianSobolPathGenerator_antithetic);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for GaussianSobolPathGenerator
setMethod('delete', '_p_GaussianSobolPathGenerator', function(obj) {delete_GaussianSobolPathGenerator(obj)})
# Start of MultiPath_pathSize

`MultiPath_pathSize` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_MultiPath_pathSize', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__size_t";
  
  ans
  
}

attr(`MultiPath_pathSize`, 'returnType') = 'integer'
attr(`MultiPath_pathSize`, "inputTypes") = c('_p_MultiPath')
class(`MultiPath_pathSize`) = c("SWIGFunction", class('MultiPath_pathSize'))

# Start of MultiPath_assetNumber

`MultiPath_assetNumber` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_MultiPath_assetNumber', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__size_t";
  
  ans
  
}

attr(`MultiPath_assetNumber`, 'returnType') = 'integer'
attr(`MultiPath_assetNumber`, "inputTypes") = c('_p_MultiPath')
class(`MultiPath_assetNumber`) = c("SWIGFunction", class('MultiPath_assetNumber'))

# Start of delete_MultiPath

`delete_MultiPath` = function(self)
{
  ;.Call('R_swig_delete_MultiPath', self, PACKAGE='QuantLib');
  
}

attr(`delete_MultiPath`, 'returnType') = 'void'
attr(`delete_MultiPath`, "inputTypes") = c('_p_MultiPath')
class(`delete_MultiPath`) = c("SWIGFunction", class('delete_MultiPath'))

# Start of accessor method for MultiPath
setMethod('$', '_p_MultiPath', function(x, name)

{
  accessorFuns = list('pathSize' = MultiPath_pathSize, 'assetNumber' = MultiPath_assetNumber);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for MultiPath
setMethod('delete', '_p_MultiPath', function(obj) {delete_MultiPath(obj)})
# Start of SampleMultiPath_value

`SampleMultiPath_value` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_SampleMultiPath_value', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_MultiPath";
  
  ans
  
}

attr(`SampleMultiPath_value`, 'returnType') = '_p_MultiPath'
attr(`SampleMultiPath_value`, "inputTypes") = c('_p_SampleT_MultiPath_t')
class(`SampleMultiPath_value`) = c("SWIGFunction", class('SampleMultiPath_value'))

# Start of SampleMultiPath_weight

`SampleMultiPath_weight` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_SampleMultiPath_weight', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`SampleMultiPath_weight`, 'returnType') = 'numeric'
attr(`SampleMultiPath_weight`, "inputTypes") = c('_p_SampleT_MultiPath_t')
class(`SampleMultiPath_weight`) = c("SWIGFunction", class('SampleMultiPath_weight'))

# Start of delete_SampleMultiPath

`delete_SampleMultiPath` = function(self)
{
  ;.Call('R_swig_delete_SampleMultiPath', self, PACKAGE='QuantLib');
  
}

attr(`delete_SampleMultiPath`, 'returnType') = 'void'
attr(`delete_SampleMultiPath`, "inputTypes") = c('_p_SampleT_MultiPath_t')
class(`delete_SampleMultiPath`) = c("SWIGFunction", class('delete_SampleMultiPath'))

# Start of accessor method for Sample<(MultiPath)>
setMethod('$', '_p_SampleT_MultiPath_t', function(x, name)

{
  accessorFuns = list('value' = SampleMultiPath_value, 'weight' = SampleMultiPath_weight);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for Sample<(MultiPath)>
setMethod('delete', '_p_SampleT_MultiPath_t', function(obj) {delete_SampleT_MultiPath_t(obj)})
# Start of new_GaussianMultiPathGenerator

`GaussianMultiPathGenerator__SWIG_0` = function(process, times, generator, brownianBridge)
{
  brownianBridge = as.logical(brownianBridge);
  ;ans = .Call('R_swig_new_GaussianMultiPathGenerator__SWIG_0', process, times, generator, brownianBridge, PACKAGE='QuantLib');
  class(ans) <- "_p_GaussianMultiPathGenerator";
  
  reg.finalizer(ans, delete_GaussianMultiPathGenerator)
  ans
  
}

attr(`GaussianMultiPathGenerator__SWIG_0`, 'returnType') = '_p_GaussianMultiPathGenerator'
attr(`GaussianMultiPathGenerator__SWIG_0`, "inputTypes") = c('_p_boost__shared_ptrT_StochasticProcess_t', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_GaussianRandomSequenceGenerator', 'logical')
class(`GaussianMultiPathGenerator__SWIG_0`) = c("SWIGFunction", class('GaussianMultiPathGenerator__SWIG_0'))

# Start of new_GaussianMultiPathGenerator

`GaussianMultiPathGenerator__SWIG_1` = function(process, times, generator)
{
  ;ans = .Call('R_swig_new_GaussianMultiPathGenerator__SWIG_1', process, times, generator, PACKAGE='QuantLib');
  class(ans) <- "_p_GaussianMultiPathGenerator";
  
  reg.finalizer(ans, delete_GaussianMultiPathGenerator)
  ans
  
}

attr(`GaussianMultiPathGenerator__SWIG_1`, 'returnType') = '_p_GaussianMultiPathGenerator'
attr(`GaussianMultiPathGenerator__SWIG_1`, "inputTypes") = c('_p_boost__shared_ptrT_StochasticProcess_t', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_GaussianRandomSequenceGenerator')
class(`GaussianMultiPathGenerator__SWIG_1`) = c("SWIGFunction", class('GaussianMultiPathGenerator__SWIG_1'))

`GaussianMultiPathGenerator` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 3) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_StochasticProcess_t') && extends(argtypes[2], '_p_std__vectorT_double_std__allocatorT_double_t_t') && extends(argtypes[3], '_p_GaussianRandomSequenceGenerator')) {
      f <- GaussianMultiPathGenerator__SWIG_1; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_StochasticProcess_t') && extends(argtypes[2], '_p_std__vectorT_double_std__allocatorT_double_t_t') && extends(argtypes[3], '_p_GaussianRandomSequenceGenerator') && extends(argtypes[4], 'logical')) {
      f <- GaussianMultiPathGenerator__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for GaussianMultiPathGenerator with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of GaussianMultiPathGenerator__next

`GaussianMultiPathGenerator__next` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_GaussianMultiPathGenerator__next', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_SampleT_MultiPath_t";
  
  ans
  
}

attr(`GaussianMultiPathGenerator__next`, 'returnType') = '_p_SampleT_MultiPath_t'
attr(`GaussianMultiPathGenerator__next`, "inputTypes") = c('_p_GaussianMultiPathGenerator')
class(`GaussianMultiPathGenerator__next`) = c("SWIGFunction", class('GaussianMultiPathGenerator__next'))

# Start of delete_GaussianMultiPathGenerator

`delete_GaussianMultiPathGenerator` = function(self)
{
  ;.Call('R_swig_delete_GaussianMultiPathGenerator', self, PACKAGE='QuantLib');
  
}

attr(`delete_GaussianMultiPathGenerator`, 'returnType') = 'void'
attr(`delete_GaussianMultiPathGenerator`, "inputTypes") = c('_p_GaussianMultiPathGenerator')
class(`delete_GaussianMultiPathGenerator`) = c("SWIGFunction", class('delete_GaussianMultiPathGenerator'))

# Start of accessor method for GaussianMultiPathGenerator
setMethod('$', '_p_GaussianMultiPathGenerator', function(x, name)

{
  accessorFuns = list('_next' = GaussianMultiPathGenerator__next);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for GaussianMultiPathGenerator
setMethod('delete', '_p_GaussianMultiPathGenerator', function(obj) {delete_GaussianMultiPathGenerator(obj)})
# Start of BoundaryCondition___deref__

`BoundaryCondition___deref__` = function(self)
{
  ;ans = .Call('R_swig_BoundaryCondition___deref__', self, PACKAGE='QuantLib');
  class(ans) <- "_p_DefaultBoundaryCondition";
  
  ans
  
}

attr(`BoundaryCondition___deref__`, 'returnType') = '_p_DefaultBoundaryCondition'
attr(`BoundaryCondition___deref__`, "inputTypes") = c('_p_boost__shared_ptrT_DefaultBoundaryCondition_t')
class(`BoundaryCondition___deref__`) = c("SWIGFunction", class('BoundaryCondition___deref__'))

# Start of BoundaryCondition_isNull

`BoundaryCondition_isNull` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_BoundaryCondition_isNull', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`BoundaryCondition_isNull`, 'returnType') = 'logical'
attr(`BoundaryCondition_isNull`, "inputTypes") = c('_p_boost__shared_ptrT_DefaultBoundaryCondition_t')
class(`BoundaryCondition_isNull`) = c("SWIGFunction", class('BoundaryCondition_isNull'))

# Start of new_BoundaryCondition

`BoundaryCondition` = function()
{
  ;ans = .Call('R_swig_new_BoundaryCondition', PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_DefaultBoundaryCondition_t";
  
  reg.finalizer(ans, delete_BoundaryCondition)
  ans
  
}

attr(`BoundaryCondition`, 'returnType') = '_p_boost__shared_ptrT_DefaultBoundaryCondition_t'
class(`BoundaryCondition`) = c("SWIGFunction", class('BoundaryCondition'))

# Start of delete_BoundaryCondition

`delete_BoundaryCondition` = function(self)
{
  ;.Call('R_swig_delete_BoundaryCondition', self, PACKAGE='QuantLib');
  
}

attr(`delete_BoundaryCondition`, 'returnType') = 'void'
attr(`delete_BoundaryCondition`, "inputTypes") = c('_p_boost__shared_ptrT_DefaultBoundaryCondition_t')
class(`delete_BoundaryCondition`) = c("SWIGFunction", class('delete_BoundaryCondition'))

# Start of accessor method for boost::shared_ptr<(DefaultBoundaryCondition)>
setMethod('$', '_p_boost__shared_ptrT_DefaultBoundaryCondition_t', function(x, name)

{
  accessorFuns = list('__deref__' = BoundaryCondition___deref__, 'isNull' = BoundaryCondition_isNull);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for boost::shared_ptr<(DefaultBoundaryCondition)>
setMethod('delete', '_p_boost__shared_ptrT_DefaultBoundaryCondition_t', function(obj) {delete_boost__shared_ptrT_DefaultBoundaryCondition_t(obj)})
# Start of new_NeumannBC

`NeumannBC` = function(value, side)
{
  side = enumToInteger(side, "_DefaultBoundaryCondition__Side"); 
  
  if(length(side) > 1) {
    warning("using only the first element of side");
  };
  
  ;ans = .Call('R_swig_new_NeumannBC', value, side, PACKAGE='QuantLib');
  class(ans) <- "_p_NeumannBCPtr";
  
  reg.finalizer(ans, delete_NeumannBC)
  ans
  
}

attr(`NeumannBC`, 'returnType') = '_p_NeumannBCPtr'
attr(`NeumannBC`, "inputTypes") = c('numeric', 'character')
class(`NeumannBC`) = c("SWIGFunction", class('NeumannBC'))

# Start of delete_NeumannBC

`delete_NeumannBC` = function(self)
{
  ;.Call('R_swig_delete_NeumannBC', self, PACKAGE='QuantLib');
  
}

attr(`delete_NeumannBC`, 'returnType') = 'void'
attr(`delete_NeumannBC`, "inputTypes") = c('_p_NeumannBCPtr')
class(`delete_NeumannBC`) = c("SWIGFunction", class('delete_NeumannBC'))

setMethod('delete', '_p_NeumannBCPtr', function(obj) {delete_NeumannBCPtr(obj)})
# Start of new_DirichletBC

`DirichletBC` = function(value, side)
{
  side = enumToInteger(side, "_DefaultBoundaryCondition__Side"); 
  
  if(length(side) > 1) {
    warning("using only the first element of side");
  };
  
  ;ans = .Call('R_swig_new_DirichletBC', value, side, PACKAGE='QuantLib');
  class(ans) <- "_p_DirichletBCPtr";
  
  reg.finalizer(ans, delete_DirichletBC)
  ans
  
}

attr(`DirichletBC`, 'returnType') = '_p_DirichletBCPtr'
attr(`DirichletBC`, "inputTypes") = c('numeric', 'character')
class(`DirichletBC`) = c("SWIGFunction", class('DirichletBC'))

# Start of delete_DirichletBC

`delete_DirichletBC` = function(self)
{
  ;.Call('R_swig_delete_DirichletBC', self, PACKAGE='QuantLib');
  
}

attr(`delete_DirichletBC`, 'returnType') = 'void'
attr(`delete_DirichletBC`, "inputTypes") = c('_p_DirichletBCPtr')
class(`delete_DirichletBC`) = c("SWIGFunction", class('delete_DirichletBC'))

setMethod('delete', '_p_DirichletBCPtr', function(obj) {delete_DirichletBCPtr(obj)})
# Start of new_TridiagonalOperator

`TridiagonalOperator` = function(low, mid, high)
{
  ;ans = .Call('R_swig_new_TridiagonalOperator', low, mid, high, PACKAGE='QuantLib');
  class(ans) <- "_p_TridiagonalOperator";
  
  reg.finalizer(ans, delete_TridiagonalOperator)
  ans
  
}

attr(`TridiagonalOperator`, 'returnType') = '_p_TridiagonalOperator'
attr(`TridiagonalOperator`, "inputTypes") = c('_p_Array', '_p_Array', '_p_Array')
class(`TridiagonalOperator`) = c("SWIGFunction", class('TridiagonalOperator'))

# Start of TridiagonalOperator_solveFor

`TridiagonalOperator_solveFor` = function(self, rhs, .copy = FALSE)
{
  ;ans = .Call('R_swig_TridiagonalOperator_solveFor', self, rhs, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Array";
  
  ans
  
}

attr(`TridiagonalOperator_solveFor`, 'returnType') = '_p_Array'
attr(`TridiagonalOperator_solveFor`, "inputTypes") = c('_p_TridiagonalOperator', '_p_Array')
class(`TridiagonalOperator_solveFor`) = c("SWIGFunction", class('TridiagonalOperator_solveFor'))

# Start of TridiagonalOperator_applyTo

`TridiagonalOperator_applyTo` = function(self, v, .copy = FALSE)
{
  ;ans = .Call('R_swig_TridiagonalOperator_applyTo', self, v, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Array";
  
  ans
  
}

attr(`TridiagonalOperator_applyTo`, 'returnType') = '_p_Array'
attr(`TridiagonalOperator_applyTo`, "inputTypes") = c('_p_TridiagonalOperator', '_p_Array')
class(`TridiagonalOperator_applyTo`) = c("SWIGFunction", class('TridiagonalOperator_applyTo'))

# Start of TridiagonalOperator_size

`TridiagonalOperator_size` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_TridiagonalOperator_size', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__size_t";
  
  ans
  
}

attr(`TridiagonalOperator_size`, 'returnType') = 'integer'
attr(`TridiagonalOperator_size`, "inputTypes") = c('_p_TridiagonalOperator')
class(`TridiagonalOperator_size`) = c("SWIGFunction", class('TridiagonalOperator_size'))

# Start of TridiagonalOperator_setFirstRow

`TridiagonalOperator_setFirstRow` = function(self, s_arg2, s_arg3)
{
  ;.Call('R_swig_TridiagonalOperator_setFirstRow', self, s_arg2, s_arg3, PACKAGE='QuantLib');
  
}

attr(`TridiagonalOperator_setFirstRow`, 'returnType') = 'void'
attr(`TridiagonalOperator_setFirstRow`, "inputTypes") = c('_p_TridiagonalOperator', 'numeric', 'numeric')
class(`TridiagonalOperator_setFirstRow`) = c("SWIGFunction", class('TridiagonalOperator_setFirstRow'))

# Start of TridiagonalOperator_setMidRow

`TridiagonalOperator_setMidRow` = function(self, s_arg2, s_arg3, s_arg4, s_arg5)
{
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  
  
  
  ;.Call('R_swig_TridiagonalOperator_setMidRow', self, s_arg2, s_arg3, s_arg4, s_arg5, PACKAGE='QuantLib');
  
}

attr(`TridiagonalOperator_setMidRow`, 'returnType') = 'void'
attr(`TridiagonalOperator_setMidRow`, "inputTypes") = c('_p_TridiagonalOperator', 'integer', 'numeric', 'numeric', 'numeric')
class(`TridiagonalOperator_setMidRow`) = c("SWIGFunction", class('TridiagonalOperator_setMidRow'))

# Start of TridiagonalOperator_setMidRows

`TridiagonalOperator_setMidRows` = function(self, s_arg2, s_arg3, s_arg4)
{
  ;.Call('R_swig_TridiagonalOperator_setMidRows', self, s_arg2, s_arg3, s_arg4, PACKAGE='QuantLib');
  
}

attr(`TridiagonalOperator_setMidRows`, 'returnType') = 'void'
attr(`TridiagonalOperator_setMidRows`, "inputTypes") = c('_p_TridiagonalOperator', 'numeric', 'numeric', 'numeric')
class(`TridiagonalOperator_setMidRows`) = c("SWIGFunction", class('TridiagonalOperator_setMidRows'))

# Start of TridiagonalOperator_setLastRow

`TridiagonalOperator_setLastRow` = function(self, s_arg2, s_arg3)
{
  ;.Call('R_swig_TridiagonalOperator_setLastRow', self, s_arg2, s_arg3, PACKAGE='QuantLib');
  
}

attr(`TridiagonalOperator_setLastRow`, 'returnType') = 'void'
attr(`TridiagonalOperator_setLastRow`, "inputTypes") = c('_p_TridiagonalOperator', 'numeric', 'numeric')
class(`TridiagonalOperator_setLastRow`) = c("SWIGFunction", class('TridiagonalOperator_setLastRow'))

# Start of TridiagonalOperator_identity

`TridiagonalOperator_identity` = function(size, .copy = FALSE)
{
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_TridiagonalOperator_identity', size, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_TridiagonalOperator";
  
  ans
  
}

attr(`TridiagonalOperator_identity`, 'returnType') = '_p_TridiagonalOperator'
attr(`TridiagonalOperator_identity`, "inputTypes") = c('integer')
class(`TridiagonalOperator_identity`) = c("SWIGFunction", class('TridiagonalOperator_identity'))

# Start of delete_TridiagonalOperator

`delete_TridiagonalOperator` = function(self)
{
  ;.Call('R_swig_delete_TridiagonalOperator', self, PACKAGE='QuantLib');
  
}

attr(`delete_TridiagonalOperator`, 'returnType') = 'void'
attr(`delete_TridiagonalOperator`, "inputTypes") = c('_p_TridiagonalOperator')
class(`delete_TridiagonalOperator`) = c("SWIGFunction", class('delete_TridiagonalOperator'))

# Start of accessor method for TridiagonalOperator
setMethod('$', '_p_TridiagonalOperator', function(x, name)

{
  accessorFuns = list('solveFor' = TridiagonalOperator_solveFor, 'applyTo' = TridiagonalOperator_applyTo, 'size' = TridiagonalOperator_size, 'setFirstRow' = TridiagonalOperator_setFirstRow, 'setMidRow' = TridiagonalOperator_setMidRow, 'setMidRows' = TridiagonalOperator_setMidRows, 'setLastRow' = TridiagonalOperator_setLastRow);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for TridiagonalOperator
setMethod('delete', '_p_TridiagonalOperator', function(obj) {delete_TridiagonalOperator(obj)})
# Start of new_DPlus

`DPlus` = function(gridPoints, h)
{
  if(length(gridPoints) > 1) {
    warning("using only the first element of gridPoints");
  };
  
  
  ;ans = .Call('R_swig_new_DPlus', gridPoints, h, PACKAGE='QuantLib');
  class(ans) <- "_p_DPlus";
  
  reg.finalizer(ans, delete_DPlus)
  ans
  
}

attr(`DPlus`, 'returnType') = '_p_DPlus'
attr(`DPlus`, "inputTypes") = c('integer', 'numeric')
class(`DPlus`) = c("SWIGFunction", class('DPlus'))

# Start of delete_DPlus

`delete_DPlus` = function(self)
{
  ;.Call('R_swig_delete_DPlus', self, PACKAGE='QuantLib');
  
}

attr(`delete_DPlus`, 'returnType') = 'void'
attr(`delete_DPlus`, "inputTypes") = c('_p_DPlus')
class(`delete_DPlus`) = c("SWIGFunction", class('delete_DPlus'))

setMethod('delete', '_p_DPlus', function(obj) {delete_DPlus(obj)})
# Start of new_DMinus

`DMinus` = function(gridPoints, h)
{
  if(length(gridPoints) > 1) {
    warning("using only the first element of gridPoints");
  };
  
  
  ;ans = .Call('R_swig_new_DMinus', gridPoints, h, PACKAGE='QuantLib');
  class(ans) <- "_p_DMinus";
  
  reg.finalizer(ans, delete_DMinus)
  ans
  
}

attr(`DMinus`, 'returnType') = '_p_DMinus'
attr(`DMinus`, "inputTypes") = c('integer', 'numeric')
class(`DMinus`) = c("SWIGFunction", class('DMinus'))

# Start of delete_DMinus

`delete_DMinus` = function(self)
{
  ;.Call('R_swig_delete_DMinus', self, PACKAGE='QuantLib');
  
}

attr(`delete_DMinus`, 'returnType') = 'void'
attr(`delete_DMinus`, "inputTypes") = c('_p_DMinus')
class(`delete_DMinus`) = c("SWIGFunction", class('delete_DMinus'))

setMethod('delete', '_p_DMinus', function(obj) {delete_DMinus(obj)})
# Start of new_DZero

`DZero` = function(gridPoints, h)
{
  if(length(gridPoints) > 1) {
    warning("using only the first element of gridPoints");
  };
  
  
  ;ans = .Call('R_swig_new_DZero', gridPoints, h, PACKAGE='QuantLib');
  class(ans) <- "_p_DZero";
  
  reg.finalizer(ans, delete_DZero)
  ans
  
}

attr(`DZero`, 'returnType') = '_p_DZero'
attr(`DZero`, "inputTypes") = c('integer', 'numeric')
class(`DZero`) = c("SWIGFunction", class('DZero'))

# Start of delete_DZero

`delete_DZero` = function(self)
{
  ;.Call('R_swig_delete_DZero', self, PACKAGE='QuantLib');
  
}

attr(`delete_DZero`, 'returnType') = 'void'
attr(`delete_DZero`, "inputTypes") = c('_p_DZero')
class(`delete_DZero`) = c("SWIGFunction", class('delete_DZero'))

setMethod('delete', '_p_DZero', function(obj) {delete_DZero(obj)})
# Start of new_DPlusDMinus

`DPlusDMinus` = function(gridPoints, h)
{
  if(length(gridPoints) > 1) {
    warning("using only the first element of gridPoints");
  };
  
  
  ;ans = .Call('R_swig_new_DPlusDMinus', gridPoints, h, PACKAGE='QuantLib');
  class(ans) <- "_p_DPlusDMinus";
  
  reg.finalizer(ans, delete_DPlusDMinus)
  ans
  
}

attr(`DPlusDMinus`, 'returnType') = '_p_DPlusDMinus'
attr(`DPlusDMinus`, "inputTypes") = c('integer', 'numeric')
class(`DPlusDMinus`) = c("SWIGFunction", class('DPlusDMinus'))

# Start of delete_DPlusDMinus

`delete_DPlusDMinus` = function(self)
{
  ;.Call('R_swig_delete_DPlusDMinus', self, PACKAGE='QuantLib');
  
}

attr(`delete_DPlusDMinus`, 'returnType') = 'void'
attr(`delete_DPlusDMinus`, "inputTypes") = c('_p_DPlusDMinus')
class(`delete_DPlusDMinus`) = c("SWIGFunction", class('delete_DPlusDMinus'))

setMethod('delete', '_p_DPlusDMinus', function(obj) {delete_DPlusDMinus(obj)})
# Start of new_TimeBasket

`TimeBasket__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_TimeBasket__SWIG_0', PACKAGE='QuantLib');
  class(ans) <- "_p_TimeBasket";
  
  reg.finalizer(ans, delete_TimeBasket)
  ans
  
}

attr(`TimeBasket__SWIG_0`, 'returnType') = '_p_TimeBasket'
class(`TimeBasket__SWIG_0`) = c("SWIGFunction", class('TimeBasket__SWIG_0'))

# Start of new_TimeBasket

`TimeBasket__SWIG_1` = function(s_arg1, s_arg2)
{
  ;ans = .Call('R_swig_new_TimeBasket__SWIG_1', s_arg1, s_arg2, PACKAGE='QuantLib');
  class(ans) <- "_p_TimeBasket";
  
  reg.finalizer(ans, delete_TimeBasket)
  ans
  
}

attr(`TimeBasket__SWIG_1`, 'returnType') = '_p_TimeBasket'
attr(`TimeBasket__SWIG_1`, "inputTypes") = c('_p_std__vectorT_Date_std__allocatorT_Date_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`TimeBasket__SWIG_1`) = c("SWIGFunction", class('TimeBasket__SWIG_1'))

`TimeBasket` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- TimeBasket__SWIG_0; 
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_std__vectorT_Date_std__allocatorT_Date_t_t') && extends(argtypes[2], '_p_std__vectorT_double_std__allocatorT_double_t_t')) {
      f <- TimeBasket__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for TimeBasket with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of TimeBasket_size

`TimeBasket_size` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_TimeBasket_size', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__size_t";
  
  ans
  
}

attr(`TimeBasket_size`, 'returnType') = 'integer'
attr(`TimeBasket_size`, "inputTypes") = c('_p_TimeBasket')
class(`TimeBasket_size`) = c("SWIGFunction", class('TimeBasket_size'))

# Start of TimeBasket_rebin

`TimeBasket_rebin` = function(self, s_arg2, .copy = FALSE)
{
  ;ans = .Call('R_swig_TimeBasket_rebin', self, s_arg2, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_TimeBasket";
  
  ans
  
}

attr(`TimeBasket_rebin`, 'returnType') = '_p_TimeBasket'
attr(`TimeBasket_rebin`, "inputTypes") = c('_p_TimeBasket', '_p_std__vectorT_Date_std__allocatorT_Date_t_t')
class(`TimeBasket_rebin`) = c("SWIGFunction", class('TimeBasket_rebin'))

# Start of delete_TimeBasket

`delete_TimeBasket` = function(self)
{
  ;.Call('R_swig_delete_TimeBasket', self, PACKAGE='QuantLib');
  
}

attr(`delete_TimeBasket`, 'returnType') = 'void'
attr(`delete_TimeBasket`, "inputTypes") = c('_p_TimeBasket')
class(`delete_TimeBasket`) = c("SWIGFunction", class('delete_TimeBasket'))

# Start of accessor method for TimeBasket
setMethod('$', '_p_TimeBasket', function(x, name)

{
  accessorFuns = list('size' = TimeBasket_size, 'rebin' = TimeBasket_rebin);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for TimeBasket
setMethod('delete', '_p_TimeBasket', function(obj) {delete_TimeBasket(obj)})
# Start of new_Swap

`Swap` = function(firstLeg, secondLeg)
{
  ;ans = .Call('R_swig_new_Swap', firstLeg, secondLeg, PACKAGE='QuantLib');
  class(ans) <- "_p_SwapPtr";
  
  reg.finalizer(ans, delete_Swap)
  ans
  
}

attr(`Swap`, 'returnType') = '_p_SwapPtr'
attr(`Swap`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t', '_p_std__vectorT_boost__shared_ptrT_CashFlow_t_std__allocatorT_boost__shared_ptrT_CashFlow_t_t_t')
class(`Swap`) = c("SWIGFunction", class('Swap'))

# Start of Swap_startDate

`Swap_startDate` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_Swap_startDate', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`Swap_startDate`, 'returnType') = '_p_Date'
attr(`Swap_startDate`, "inputTypes") = c('_p_SwapPtr')
class(`Swap_startDate`) = c("SWIGFunction", class('Swap_startDate'))

# Start of Swap_maturityDate

`Swap_maturityDate` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_Swap_maturityDate', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`Swap_maturityDate`, 'returnType') = '_p_Date'
attr(`Swap_maturityDate`, "inputTypes") = c('_p_SwapPtr')
class(`Swap_maturityDate`) = c("SWIGFunction", class('Swap_maturityDate'))

# Start of delete_Swap

`delete_Swap` = function(self)
{
  ;.Call('R_swig_delete_Swap', self, PACKAGE='QuantLib');
  
}

attr(`delete_Swap`, 'returnType') = 'void'
attr(`delete_Swap`, "inputTypes") = c('_p_SwapPtr')
class(`delete_Swap`) = c("SWIGFunction", class('delete_Swap'))

# Start of accessor method for SwapPtr
setMethod('$', '_p_SwapPtr', function(x, name)

{
  accessorFuns = list('startDate' = Swap_startDate, 'maturityDate' = Swap_maturityDate);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for SwapPtr
setMethod('delete', '_p_SwapPtr', function(obj) {delete_SwapPtr(obj)})
# Start of new_VanillaSwap

`VanillaSwap` = function(type, nominal, fixedSchedule, fixedRate, fixedDayCount, floatSchedule, index, spread, floatingDayCount)
{
  type = enumToInteger(type, "_VanillaSwap__Type"); 
  
  if(length(type) > 1) {
    warning("using only the first element of type");
  };
  
  
  
  
  
  
  
  
  
  ;ans = .Call('R_swig_new_VanillaSwap', type, nominal, fixedSchedule, fixedRate, fixedDayCount, floatSchedule, index, spread, floatingDayCount, PACKAGE='QuantLib');
  class(ans) <- "_p_VanillaSwapPtr";
  
  reg.finalizer(ans, delete_VanillaSwap)
  ans
  
}

attr(`VanillaSwap`, 'returnType') = '_p_VanillaSwapPtr'
attr(`VanillaSwap`, "inputTypes") = c('character', 'numeric', '_p_Schedule', 'numeric', '_p_DayCounter', '_p_Schedule', '_p_IborIndexPtr', 'numeric', '_p_DayCounter')
class(`VanillaSwap`) = c("SWIGFunction", class('VanillaSwap'))

# Start of VanillaSwap_fairRate

`VanillaSwap_fairRate` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_VanillaSwap_fairRate', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`VanillaSwap_fairRate`, 'returnType') = 'numeric'
attr(`VanillaSwap_fairRate`, "inputTypes") = c('_p_VanillaSwapPtr')
class(`VanillaSwap_fairRate`) = c("SWIGFunction", class('VanillaSwap_fairRate'))

# Start of VanillaSwap_fairSpread

`VanillaSwap_fairSpread` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_VanillaSwap_fairSpread', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`VanillaSwap_fairSpread`, 'returnType') = 'numeric'
attr(`VanillaSwap_fairSpread`, "inputTypes") = c('_p_VanillaSwapPtr')
class(`VanillaSwap_fairSpread`) = c("SWIGFunction", class('VanillaSwap_fairSpread'))

# Start of VanillaSwap_fixedLegBPS

`VanillaSwap_fixedLegBPS` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_VanillaSwap_fixedLegBPS', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`VanillaSwap_fixedLegBPS`, 'returnType') = 'numeric'
attr(`VanillaSwap_fixedLegBPS`, "inputTypes") = c('_p_VanillaSwapPtr')
class(`VanillaSwap_fixedLegBPS`) = c("SWIGFunction", class('VanillaSwap_fixedLegBPS'))

# Start of VanillaSwap_floatingLegBPS

`VanillaSwap_floatingLegBPS` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_VanillaSwap_floatingLegBPS', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`VanillaSwap_floatingLegBPS`, 'returnType') = 'numeric'
attr(`VanillaSwap_floatingLegBPS`, "inputTypes") = c('_p_VanillaSwapPtr')
class(`VanillaSwap_floatingLegBPS`) = c("SWIGFunction", class('VanillaSwap_floatingLegBPS'))

# Start of delete_VanillaSwap

`delete_VanillaSwap` = function(self)
{
  ;.Call('R_swig_delete_VanillaSwap', self, PACKAGE='QuantLib');
  
}

attr(`delete_VanillaSwap`, 'returnType') = 'void'
attr(`delete_VanillaSwap`, "inputTypes") = c('_p_VanillaSwapPtr')
class(`delete_VanillaSwap`) = c("SWIGFunction", class('delete_VanillaSwap'))

# Start of accessor method for VanillaSwapPtr
setMethod('$', '_p_VanillaSwapPtr', function(x, name)

{
  accessorFuns = list('fairRate' = VanillaSwap_fairRate, 'fairSpread' = VanillaSwap_fairSpread, 'fixedLegBPS' = VanillaSwap_fixedLegBPS, 'floatingLegBPS' = VanillaSwap_floatingLegBPS);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for VanillaSwapPtr
setMethod('delete', '_p_VanillaSwapPtr', function(obj) {delete_VanillaSwapPtr(obj)})
# Start of new_DiscountingSwapEngine

`DiscountingSwapEngine__SWIG_0` = function(discountCurve, settlementDate, npvDate)
{
  ;ans = .Call('R_swig_new_DiscountingSwapEngine__SWIG_0', discountCurve, settlementDate, npvDate, PACKAGE='QuantLib');
  class(ans) <- "_p_DiscountingSwapEnginePtr";
  
  reg.finalizer(ans, delete_DiscountingSwapEngine)
  ans
  
}

attr(`DiscountingSwapEngine__SWIG_0`, 'returnType') = '_p_DiscountingSwapEnginePtr'
attr(`DiscountingSwapEngine__SWIG_0`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t', '_p_Date', '_p_Date')
class(`DiscountingSwapEngine__SWIG_0`) = c("SWIGFunction", class('DiscountingSwapEngine__SWIG_0'))

# Start of new_DiscountingSwapEngine

`DiscountingSwapEngine__SWIG_1` = function(discountCurve, settlementDate)
{
  ;ans = .Call('R_swig_new_DiscountingSwapEngine__SWIG_1', discountCurve, settlementDate, PACKAGE='QuantLib');
  class(ans) <- "_p_DiscountingSwapEnginePtr";
  
  reg.finalizer(ans, delete_DiscountingSwapEngine)
  ans
  
}

attr(`DiscountingSwapEngine__SWIG_1`, 'returnType') = '_p_DiscountingSwapEnginePtr'
attr(`DiscountingSwapEngine__SWIG_1`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t', '_p_Date')
class(`DiscountingSwapEngine__SWIG_1`) = c("SWIGFunction", class('DiscountingSwapEngine__SWIG_1'))

# Start of new_DiscountingSwapEngine

`DiscountingSwapEngine__SWIG_2` = function(discountCurve)
{
  ;ans = .Call('R_swig_new_DiscountingSwapEngine__SWIG_2', discountCurve, PACKAGE='QuantLib');
  class(ans) <- "_p_DiscountingSwapEnginePtr";
  
  reg.finalizer(ans, delete_DiscountingSwapEngine)
  ans
  
}

attr(`DiscountingSwapEngine__SWIG_2`, 'returnType') = '_p_DiscountingSwapEnginePtr'
attr(`DiscountingSwapEngine__SWIG_2`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`DiscountingSwapEngine__SWIG_2`) = c("SWIGFunction", class('DiscountingSwapEngine__SWIG_2'))

# Start of new_DiscountingSwapEngine

`DiscountingSwapEngine__SWIG_3` = function(discountCurve, includeSettlementDateFlows, settlementDate, npvDate)
{
  includeSettlementDateFlows = as.logical(includeSettlementDateFlows);
  
  
  ;ans = .Call('R_swig_new_DiscountingSwapEngine__SWIG_3', discountCurve, includeSettlementDateFlows, settlementDate, npvDate, PACKAGE='QuantLib');
  class(ans) <- "_p_DiscountingSwapEnginePtr";
  
  reg.finalizer(ans, delete_DiscountingSwapEngine)
  ans
  
}

attr(`DiscountingSwapEngine__SWIG_3`, 'returnType') = '_p_DiscountingSwapEnginePtr'
attr(`DiscountingSwapEngine__SWIG_3`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t', 'logical', '_p_Date', '_p_Date')
class(`DiscountingSwapEngine__SWIG_3`) = c("SWIGFunction", class('DiscountingSwapEngine__SWIG_3'))

# Start of new_DiscountingSwapEngine

`DiscountingSwapEngine__SWIG_4` = function(discountCurve, includeSettlementDateFlows, settlementDate)
{
  includeSettlementDateFlows = as.logical(includeSettlementDateFlows);
  
  ;ans = .Call('R_swig_new_DiscountingSwapEngine__SWIG_4', discountCurve, includeSettlementDateFlows, settlementDate, PACKAGE='QuantLib');
  class(ans) <- "_p_DiscountingSwapEnginePtr";
  
  reg.finalizer(ans, delete_DiscountingSwapEngine)
  ans
  
}

attr(`DiscountingSwapEngine__SWIG_4`, 'returnType') = '_p_DiscountingSwapEnginePtr'
attr(`DiscountingSwapEngine__SWIG_4`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t', 'logical', '_p_Date')
class(`DiscountingSwapEngine__SWIG_4`) = c("SWIGFunction", class('DiscountingSwapEngine__SWIG_4'))

# Start of new_DiscountingSwapEngine

`DiscountingSwapEngine__SWIG_5` = function(discountCurve, includeSettlementDateFlows)
{
  includeSettlementDateFlows = as.logical(includeSettlementDateFlows);
  ;ans = .Call('R_swig_new_DiscountingSwapEngine__SWIG_5', discountCurve, includeSettlementDateFlows, PACKAGE='QuantLib');
  class(ans) <- "_p_DiscountingSwapEnginePtr";
  
  reg.finalizer(ans, delete_DiscountingSwapEngine)
  ans
  
}

attr(`DiscountingSwapEngine__SWIG_5`, 'returnType') = '_p_DiscountingSwapEnginePtr'
attr(`DiscountingSwapEngine__SWIG_5`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t', 'logical')
class(`DiscountingSwapEngine__SWIG_5`) = c("SWIGFunction", class('DiscountingSwapEngine__SWIG_5'))

`DiscountingSwapEngine` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 6
  if (argc == 1) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t')) {
      f <- DiscountingSwapEngine__SWIG_2; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t') && extends(argtypes[2], '_p_Date')) {
      f <- DiscountingSwapEngine__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t') && extends(argtypes[2], 'logical')) {
      f <- DiscountingSwapEngine__SWIG_5; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t') && extends(argtypes[2], '_p_Date') && extends(argtypes[3], '_p_Date')) {
      f <- DiscountingSwapEngine__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t') && extends(argtypes[2], 'logical') && extends(argtypes[3], '_p_Date')) {
      f <- DiscountingSwapEngine__SWIG_4; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t') && extends(argtypes[2], 'logical') && extends(argtypes[3], '_p_Date') && extends(argtypes[4], '_p_Date')) {
      f <- DiscountingSwapEngine__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for DiscountingSwapEngine with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_DiscountingSwapEngine

`delete_DiscountingSwapEngine` = function(self)
{
  ;.Call('R_swig_delete_DiscountingSwapEngine', self, PACKAGE='QuantLib');
  
}

attr(`delete_DiscountingSwapEngine`, 'returnType') = 'void'
attr(`delete_DiscountingSwapEngine`, "inputTypes") = c('_p_DiscountingSwapEnginePtr')
class(`delete_DiscountingSwapEngine`) = c("SWIGFunction", class('delete_DiscountingSwapEngine'))

setMethod('delete', '_p_DiscountingSwapEnginePtr', function(obj) {delete_DiscountingSwapEnginePtr(obj)})
# Start of new_AssetSwap

`AssetSwap` = function(payFixedRate, bond, bondCleanPrice, index, spread, floatSchedule, floatingDayCount, parAssetSwap)
{
  payFixedRate = as.logical(payFixedRate);
  
  
  
  
  
  
  parAssetSwap = as.logical(parAssetSwap);
  ;ans = .Call('R_swig_new_AssetSwap', payFixedRate, bond, bondCleanPrice, index, spread, floatSchedule, floatingDayCount, parAssetSwap, PACKAGE='QuantLib');
  class(ans) <- "_p_AssetSwapPtr";
  
  reg.finalizer(ans, delete_AssetSwap)
  ans
  
}

attr(`AssetSwap`, 'returnType') = '_p_AssetSwapPtr'
attr(`AssetSwap`, "inputTypes") = c('logical', '_p_BondPtr', 'numeric', '_p_InterestRateIndexPtr', 'numeric', '_p_Schedule', '_p_DayCounter', 'logical')
class(`AssetSwap`) = c("SWIGFunction", class('AssetSwap'))

# Start of AssetSwap_fairCleanPrice

`AssetSwap_fairCleanPrice` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_AssetSwap_fairCleanPrice', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`AssetSwap_fairCleanPrice`, 'returnType') = 'numeric'
attr(`AssetSwap_fairCleanPrice`, "inputTypes") = c('_p_AssetSwapPtr')
class(`AssetSwap_fairCleanPrice`) = c("SWIGFunction", class('AssetSwap_fairCleanPrice'))

# Start of AssetSwap_fairSpread

`AssetSwap_fairSpread` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_AssetSwap_fairSpread', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`AssetSwap_fairSpread`, 'returnType') = 'numeric'
attr(`AssetSwap_fairSpread`, "inputTypes") = c('_p_AssetSwapPtr')
class(`AssetSwap_fairSpread`) = c("SWIGFunction", class('AssetSwap_fairSpread'))

# Start of delete_AssetSwap

`delete_AssetSwap` = function(self)
{
  ;.Call('R_swig_delete_AssetSwap', self, PACKAGE='QuantLib');
  
}

attr(`delete_AssetSwap`, 'returnType') = 'void'
attr(`delete_AssetSwap`, "inputTypes") = c('_p_AssetSwapPtr')
class(`delete_AssetSwap`) = c("SWIGFunction", class('delete_AssetSwap'))

# Start of accessor method for AssetSwapPtr
setMethod('$', '_p_AssetSwapPtr', function(x, name)

{
  accessorFuns = list('fairCleanPrice' = AssetSwap_fairCleanPrice, 'fairSpread' = AssetSwap_fairSpread);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for AssetSwapPtr
setMethod('delete', '_p_AssetSwapPtr', function(obj) {delete_AssetSwapPtr(obj)})
# Start of RateHelper___deref__

`RateHelper___deref__` = function(self)
{
  ;ans = .Call('R_swig_RateHelper___deref__', self, PACKAGE='QuantLib');
  class(ans) <- "_p_RateHelper";
  
  ans
  
}

attr(`RateHelper___deref__`, 'returnType') = '_p_RateHelper'
attr(`RateHelper___deref__`, "inputTypes") = c('_p_boost__shared_ptrT_RateHelper_t')
class(`RateHelper___deref__`) = c("SWIGFunction", class('RateHelper___deref__'))

# Start of RateHelper_isNull

`RateHelper_isNull` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_RateHelper_isNull', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`RateHelper_isNull`, 'returnType') = 'logical'
attr(`RateHelper_isNull`, "inputTypes") = c('_p_boost__shared_ptrT_RateHelper_t')
class(`RateHelper_isNull`) = c("SWIGFunction", class('RateHelper_isNull'))

# Start of new_RateHelper

`RateHelper` = function()
{
  ;ans = .Call('R_swig_new_RateHelper', PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_RateHelper_t";
  
  reg.finalizer(ans, delete_RateHelper)
  ans
  
}

attr(`RateHelper`, 'returnType') = '_p_boost__shared_ptrT_RateHelper_t'
class(`RateHelper`) = c("SWIGFunction", class('RateHelper'))

# Start of delete_RateHelper

`delete_RateHelper` = function(self)
{
  ;.Call('R_swig_delete_RateHelper', self, PACKAGE='QuantLib');
  
}

attr(`delete_RateHelper`, 'returnType') = 'void'
attr(`delete_RateHelper`, "inputTypes") = c('_p_boost__shared_ptrT_RateHelper_t')
class(`delete_RateHelper`) = c("SWIGFunction", class('delete_RateHelper'))

# Start of RateHelper_quote

`RateHelper_quote` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_RateHelper_quote', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_HandleT_Quote_t";
  
  ans
  
}

attr(`RateHelper_quote`, 'returnType') = '_p_HandleT_Quote_t'
attr(`RateHelper_quote`, "inputTypes") = c('_p_boost__shared_ptrT_RateHelper_t')
class(`RateHelper_quote`) = c("SWIGFunction", class('RateHelper_quote'))

# Start of RateHelper_latestDate

`RateHelper_latestDate` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_RateHelper_latestDate', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`RateHelper_latestDate`, 'returnType') = '_p_Date'
attr(`RateHelper_latestDate`, "inputTypes") = c('_p_boost__shared_ptrT_RateHelper_t')
class(`RateHelper_latestDate`) = c("SWIGFunction", class('RateHelper_latestDate'))

# Start of accessor method for boost::shared_ptr<(RateHelper)>
setMethod('$', '_p_boost__shared_ptrT_RateHelper_t', function(x, name)

{
  accessorFuns = list('__deref__' = RateHelper___deref__, 'isNull' = RateHelper_isNull, 'quote' = RateHelper_quote, 'latestDate' = RateHelper_latestDate);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for boost::shared_ptr<(RateHelper)>
setMethod('delete', '_p_boost__shared_ptrT_RateHelper_t', function(obj) {delete_boost__shared_ptrT_RateHelper_t(obj)})
# Start of new_DepositRateHelper

`DepositRateHelper__SWIG_0` = function(rate, tenor, fixingDays, calendar, convention, endOfMonth, dayCounter)
{
  if(length(fixingDays) > 1) {
    warning("using only the first element of fixingDays");
  };
  
  
  convention = enumToInteger(convention, "_BusinessDayConvention"); 
  
  if(length(convention) > 1) {
    warning("using only the first element of convention");
  };
  
  endOfMonth = as.logical(endOfMonth);
  
  ;ans = .Call('R_swig_new_DepositRateHelper__SWIG_0', rate, tenor, fixingDays, calendar, convention, endOfMonth, dayCounter, PACKAGE='QuantLib');
  class(ans) <- "_p_DepositRateHelperPtr";
  
  reg.finalizer(ans, delete_DepositRateHelper)
  ans
  
}

attr(`DepositRateHelper__SWIG_0`, 'returnType') = '_p_DepositRateHelperPtr'
attr(`DepositRateHelper__SWIG_0`, "inputTypes") = c('_p_HandleT_Quote_t', '_p_Period', 'integer', '_p_Calendar', 'character', 'logical', '_p_DayCounter')
class(`DepositRateHelper__SWIG_0`) = c("SWIGFunction", class('DepositRateHelper__SWIG_0'))

# Start of new_DepositRateHelper

`DepositRateHelper__SWIG_1` = function(rate, tenor, fixingDays, calendar, convention, endOfMonth, dayCounter)
{
  if(length(fixingDays) > 1) {
    warning("using only the first element of fixingDays");
  };
  
  
  convention = enumToInteger(convention, "_BusinessDayConvention"); 
  
  if(length(convention) > 1) {
    warning("using only the first element of convention");
  };
  
  endOfMonth = as.logical(endOfMonth);
  
  ;ans = .Call('R_swig_new_DepositRateHelper__SWIG_1', rate, tenor, fixingDays, calendar, convention, endOfMonth, dayCounter, PACKAGE='QuantLib');
  class(ans) <- "_p_DepositRateHelperPtr";
  
  reg.finalizer(ans, delete_DepositRateHelper)
  ans
  
}

attr(`DepositRateHelper__SWIG_1`, 'returnType') = '_p_DepositRateHelperPtr'
attr(`DepositRateHelper__SWIG_1`, "inputTypes") = c('numeric', '_p_Period', 'integer', '_p_Calendar', 'character', 'logical', '_p_DayCounter')
class(`DepositRateHelper__SWIG_1`) = c("SWIGFunction", class('DepositRateHelper__SWIG_1'))

`DepositRateHelper` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 7) {
    if (extends(argtypes[1], '_p_HandleT_Quote_t') && extends(argtypes[2], '_p_Period') && (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && extends(argtypes[4], '_p_Calendar') && is.character(argv[[5]]) && extends(argtypes[6], 'logical') && extends(argtypes[7], '_p_DayCounter')) {
      f <- DepositRateHelper__SWIG_0; 
    }
    else if (is.numeric(argv[[1]]) && extends(argtypes[2], '_p_Period') && (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && extends(argtypes[4], '_p_Calendar') && is.character(argv[[5]]) && extends(argtypes[6], 'logical') && extends(argtypes[7], '_p_DayCounter')) {
      f <- DepositRateHelper__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for DepositRateHelper with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_DepositRateHelper

`delete_DepositRateHelper` = function(self)
{
  ;.Call('R_swig_delete_DepositRateHelper', self, PACKAGE='QuantLib');
  
}

attr(`delete_DepositRateHelper`, 'returnType') = 'void'
attr(`delete_DepositRateHelper`, "inputTypes") = c('_p_DepositRateHelperPtr')
class(`delete_DepositRateHelper`) = c("SWIGFunction", class('delete_DepositRateHelper'))

setMethod('delete', '_p_DepositRateHelperPtr', function(obj) {delete_DepositRateHelperPtr(obj)})
# Start of new_FraRateHelper

`FraRateHelper__SWIG_0` = function(rate, monthsToStart, monthsToEnd, fixingDays, calendar, convention, endOfMonth, dayCounter)
{
  if(length(monthsToStart) > 1) {
    warning("using only the first element of monthsToStart");
  };
  
  
  
  if(length(monthsToEnd) > 1) {
    warning("using only the first element of monthsToEnd");
  };
  
  
  
  if(length(fixingDays) > 1) {
    warning("using only the first element of fixingDays");
  };
  
  
  convention = enumToInteger(convention, "_BusinessDayConvention"); 
  
  if(length(convention) > 1) {
    warning("using only the first element of convention");
  };
  
  endOfMonth = as.logical(endOfMonth);
  
  ;ans = .Call('R_swig_new_FraRateHelper__SWIG_0', rate, monthsToStart, monthsToEnd, fixingDays, calendar, convention, endOfMonth, dayCounter, PACKAGE='QuantLib');
  class(ans) <- "_p_FraRateHelperPtr";
  
  reg.finalizer(ans, delete_FraRateHelper)
  ans
  
}

attr(`FraRateHelper__SWIG_0`, 'returnType') = '_p_FraRateHelperPtr'
attr(`FraRateHelper__SWIG_0`, "inputTypes") = c('_p_HandleT_Quote_t', 'integer', 'integer', 'integer', '_p_Calendar', 'character', 'logical', '_p_DayCounter')
class(`FraRateHelper__SWIG_0`) = c("SWIGFunction", class('FraRateHelper__SWIG_0'))

# Start of new_FraRateHelper

`FraRateHelper__SWIG_1` = function(rate, monthsToStart, monthsToEnd, fixingDays, calendar, convention, endOfMonth, dayCounter)
{
  if(length(monthsToStart) > 1) {
    warning("using only the first element of monthsToStart");
  };
  
  
  
  if(length(monthsToEnd) > 1) {
    warning("using only the first element of monthsToEnd");
  };
  
  
  
  if(length(fixingDays) > 1) {
    warning("using only the first element of fixingDays");
  };
  
  
  convention = enumToInteger(convention, "_BusinessDayConvention"); 
  
  if(length(convention) > 1) {
    warning("using only the first element of convention");
  };
  
  endOfMonth = as.logical(endOfMonth);
  
  ;ans = .Call('R_swig_new_FraRateHelper__SWIG_1', rate, monthsToStart, monthsToEnd, fixingDays, calendar, convention, endOfMonth, dayCounter, PACKAGE='QuantLib');
  class(ans) <- "_p_FraRateHelperPtr";
  
  reg.finalizer(ans, delete_FraRateHelper)
  ans
  
}

attr(`FraRateHelper__SWIG_1`, 'returnType') = '_p_FraRateHelperPtr'
attr(`FraRateHelper__SWIG_1`, "inputTypes") = c('numeric', 'integer', 'integer', 'integer', '_p_Calendar', 'character', 'logical', '_p_DayCounter')
class(`FraRateHelper__SWIG_1`) = c("SWIGFunction", class('FraRateHelper__SWIG_1'))

`FraRateHelper` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 8) {
    if (extends(argtypes[1], '_p_HandleT_Quote_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && extends(argtypes[5], '_p_Calendar') && is.character(argv[[6]]) && extends(argtypes[7], 'logical') && extends(argtypes[8], '_p_DayCounter')) {
      f <- FraRateHelper__SWIG_0; 
    }
    else if (is.numeric(argv[[1]]) && (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && extends(argtypes[5], '_p_Calendar') && is.character(argv[[6]]) && extends(argtypes[7], 'logical') && extends(argtypes[8], '_p_DayCounter')) {
      f <- FraRateHelper__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for FraRateHelper with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_FraRateHelper

`delete_FraRateHelper` = function(self)
{
  ;.Call('R_swig_delete_FraRateHelper', self, PACKAGE='QuantLib');
  
}

attr(`delete_FraRateHelper`, 'returnType') = 'void'
attr(`delete_FraRateHelper`, "inputTypes") = c('_p_FraRateHelperPtr')
class(`delete_FraRateHelper`) = c("SWIGFunction", class('delete_FraRateHelper'))

setMethod('delete', '_p_FraRateHelperPtr', function(obj) {delete_FraRateHelperPtr(obj)})
# Start of new_FuturesRateHelper

`FuturesRateHelper__SWIG_0` = function(price, immDate, nMonths, calendar, convention, endOfMonth, dayCounter, convexityAdjustment)
{
  if(length(nMonths) > 1) {
    warning("using only the first element of nMonths");
  };
  
  
  convention = enumToInteger(convention, "_BusinessDayConvention"); 
  
  if(length(convention) > 1) {
    warning("using only the first element of convention");
  };
  
  endOfMonth = as.logical(endOfMonth);
  
  
  ;ans = .Call('R_swig_new_FuturesRateHelper__SWIG_0', price, immDate, nMonths, calendar, convention, endOfMonth, dayCounter, convexityAdjustment, PACKAGE='QuantLib');
  class(ans) <- "_p_FuturesRateHelperPtr";
  
  reg.finalizer(ans, delete_FuturesRateHelper)
  ans
  
}

attr(`FuturesRateHelper__SWIG_0`, 'returnType') = '_p_FuturesRateHelperPtr'
attr(`FuturesRateHelper__SWIG_0`, "inputTypes") = c('_p_HandleT_Quote_t', '_p_Date', 'integer', '_p_Calendar', 'character', 'logical', '_p_DayCounter', '_p_HandleT_Quote_t')
class(`FuturesRateHelper__SWIG_0`) = c("SWIGFunction", class('FuturesRateHelper__SWIG_0'))

# Start of new_FuturesRateHelper

`FuturesRateHelper__SWIG_1` = function(price, immDate, nMonths, calendar, convention, endOfMonth, dayCounter, convexityAdjustment)
{
  if(length(nMonths) > 1) {
    warning("using only the first element of nMonths");
  };
  
  
  convention = enumToInteger(convention, "_BusinessDayConvention"); 
  
  if(length(convention) > 1) {
    warning("using only the first element of convention");
  };
  
  endOfMonth = as.logical(endOfMonth);
  
  
  ;ans = .Call('R_swig_new_FuturesRateHelper__SWIG_1', price, immDate, nMonths, calendar, convention, endOfMonth, dayCounter, convexityAdjustment, PACKAGE='QuantLib');
  class(ans) <- "_p_FuturesRateHelperPtr";
  
  reg.finalizer(ans, delete_FuturesRateHelper)
  ans
  
}

attr(`FuturesRateHelper__SWIG_1`, 'returnType') = '_p_FuturesRateHelperPtr'
attr(`FuturesRateHelper__SWIG_1`, "inputTypes") = c('numeric', '_p_Date', 'integer', '_p_Calendar', 'character', 'logical', '_p_DayCounter', 'numeric')
class(`FuturesRateHelper__SWIG_1`) = c("SWIGFunction", class('FuturesRateHelper__SWIG_1'))

# Start of new_FuturesRateHelper

`FuturesRateHelper__SWIG_2` = function(price, immDate, nMonths, calendar, convention, endOfMonth, dayCounter)
{
  if(length(nMonths) > 1) {
    warning("using only the first element of nMonths");
  };
  
  
  convention = enumToInteger(convention, "_BusinessDayConvention"); 
  
  if(length(convention) > 1) {
    warning("using only the first element of convention");
  };
  
  endOfMonth = as.logical(endOfMonth);
  
  ;ans = .Call('R_swig_new_FuturesRateHelper__SWIG_2', price, immDate, nMonths, calendar, convention, endOfMonth, dayCounter, PACKAGE='QuantLib');
  class(ans) <- "_p_FuturesRateHelperPtr";
  
  reg.finalizer(ans, delete_FuturesRateHelper)
  ans
  
}

attr(`FuturesRateHelper__SWIG_2`, 'returnType') = '_p_FuturesRateHelperPtr'
attr(`FuturesRateHelper__SWIG_2`, "inputTypes") = c('numeric', '_p_Date', 'integer', '_p_Calendar', 'character', 'logical', '_p_DayCounter')
class(`FuturesRateHelper__SWIG_2`) = c("SWIGFunction", class('FuturesRateHelper__SWIG_2'))

`FuturesRateHelper` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 7) {
    if (is.numeric(argv[[1]]) && extends(argtypes[2], '_p_Date') && (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && extends(argtypes[4], '_p_Calendar') && is.character(argv[[5]]) && extends(argtypes[6], 'logical') && extends(argtypes[7], '_p_DayCounter')) {
      f <- FuturesRateHelper__SWIG_2; 
    }
  } else if (argc == 8) {
    if (extends(argtypes[1], '_p_HandleT_Quote_t') && extends(argtypes[2], '_p_Date') && (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && extends(argtypes[4], '_p_Calendar') && is.character(argv[[5]]) && extends(argtypes[6], 'logical') && extends(argtypes[7], '_p_DayCounter') && extends(argtypes[8], '_p_HandleT_Quote_t')) {
      f <- FuturesRateHelper__SWIG_0; 
    }
    else if (is.numeric(argv[[1]]) && extends(argtypes[2], '_p_Date') && (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && extends(argtypes[4], '_p_Calendar') && is.character(argv[[5]]) && extends(argtypes[6], 'logical') && extends(argtypes[7], '_p_DayCounter') && is.numeric(argv[[8]])) {
      f <- FuturesRateHelper__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for FuturesRateHelper with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_FuturesRateHelper

`delete_FuturesRateHelper` = function(self)
{
  ;.Call('R_swig_delete_FuturesRateHelper', self, PACKAGE='QuantLib');
  
}

attr(`delete_FuturesRateHelper`, 'returnType') = 'void'
attr(`delete_FuturesRateHelper`, "inputTypes") = c('_p_FuturesRateHelperPtr')
class(`delete_FuturesRateHelper`) = c("SWIGFunction", class('delete_FuturesRateHelper'))

setMethod('delete', '_p_FuturesRateHelperPtr', function(obj) {delete_FuturesRateHelperPtr(obj)})
# Start of new_SwapRateHelper

`SwapRateHelper__SWIG_0` = function(rate, tenor, calendar, fixedFrequency, fixedConvention, fixedDayCount, index, spread, fwdStart)
{
  fixedFrequency = enumToInteger(fixedFrequency, "_Frequency"); 
  
  if(length(fixedFrequency) > 1) {
    warning("using only the first element of fixedFrequency");
  };
  
  fixedConvention = enumToInteger(fixedConvention, "_BusinessDayConvention"); 
  
  if(length(fixedConvention) > 1) {
    warning("using only the first element of fixedConvention");
  };
  
  
  
  
  
  ;ans = .Call('R_swig_new_SwapRateHelper__SWIG_0', rate, tenor, calendar, fixedFrequency, fixedConvention, fixedDayCount, index, spread, fwdStart, PACKAGE='QuantLib');
  class(ans) <- "_p_SwapRateHelperPtr";
  
  reg.finalizer(ans, delete_SwapRateHelper)
  ans
  
}

attr(`SwapRateHelper__SWIG_0`, 'returnType') = '_p_SwapRateHelperPtr'
attr(`SwapRateHelper__SWIG_0`, "inputTypes") = c('_p_HandleT_Quote_t', '_p_Period', '_p_Calendar', 'character', 'character', '_p_DayCounter', '_p_IborIndexPtr', '_p_HandleT_Quote_t', '_p_Period')
class(`SwapRateHelper__SWIG_0`) = c("SWIGFunction", class('SwapRateHelper__SWIG_0'))

# Start of new_SwapRateHelper

`SwapRateHelper__SWIG_1` = function(rate, tenor, calendar, fixedFrequency, fixedConvention, fixedDayCount, index, spread)
{
  fixedFrequency = enumToInteger(fixedFrequency, "_Frequency"); 
  
  if(length(fixedFrequency) > 1) {
    warning("using only the first element of fixedFrequency");
  };
  
  fixedConvention = enumToInteger(fixedConvention, "_BusinessDayConvention"); 
  
  if(length(fixedConvention) > 1) {
    warning("using only the first element of fixedConvention");
  };
  
  
  
  
  ;ans = .Call('R_swig_new_SwapRateHelper__SWIG_1', rate, tenor, calendar, fixedFrequency, fixedConvention, fixedDayCount, index, spread, PACKAGE='QuantLib');
  class(ans) <- "_p_SwapRateHelperPtr";
  
  reg.finalizer(ans, delete_SwapRateHelper)
  ans
  
}

attr(`SwapRateHelper__SWIG_1`, 'returnType') = '_p_SwapRateHelperPtr'
attr(`SwapRateHelper__SWIG_1`, "inputTypes") = c('_p_HandleT_Quote_t', '_p_Period', '_p_Calendar', 'character', 'character', '_p_DayCounter', '_p_IborIndexPtr', '_p_HandleT_Quote_t')
class(`SwapRateHelper__SWIG_1`) = c("SWIGFunction", class('SwapRateHelper__SWIG_1'))

# Start of new_SwapRateHelper

`SwapRateHelper__SWIG_2` = function(rate, tenor, calendar, fixedFrequency, fixedConvention, fixedDayCount, index)
{
  fixedFrequency = enumToInteger(fixedFrequency, "_Frequency"); 
  
  if(length(fixedFrequency) > 1) {
    warning("using only the first element of fixedFrequency");
  };
  
  fixedConvention = enumToInteger(fixedConvention, "_BusinessDayConvention"); 
  
  if(length(fixedConvention) > 1) {
    warning("using only the first element of fixedConvention");
  };
  
  
  
  ;ans = .Call('R_swig_new_SwapRateHelper__SWIG_2', rate, tenor, calendar, fixedFrequency, fixedConvention, fixedDayCount, index, PACKAGE='QuantLib');
  class(ans) <- "_p_SwapRateHelperPtr";
  
  reg.finalizer(ans, delete_SwapRateHelper)
  ans
  
}

attr(`SwapRateHelper__SWIG_2`, 'returnType') = '_p_SwapRateHelperPtr'
attr(`SwapRateHelper__SWIG_2`, "inputTypes") = c('_p_HandleT_Quote_t', '_p_Period', '_p_Calendar', 'character', 'character', '_p_DayCounter', '_p_IborIndexPtr')
class(`SwapRateHelper__SWIG_2`) = c("SWIGFunction", class('SwapRateHelper__SWIG_2'))

# Start of new_SwapRateHelper

`SwapRateHelper__SWIG_3` = function(rate, tenor, calendar, fixedFrequency, fixedConvention, fixedDayCount, index, spread, fwdStart)
{
  fixedFrequency = enumToInteger(fixedFrequency, "_Frequency"); 
  
  if(length(fixedFrequency) > 1) {
    warning("using only the first element of fixedFrequency");
  };
  
  fixedConvention = enumToInteger(fixedConvention, "_BusinessDayConvention"); 
  
  if(length(fixedConvention) > 1) {
    warning("using only the first element of fixedConvention");
  };
  
  
  
  
  
  ;ans = .Call('R_swig_new_SwapRateHelper__SWIG_3', rate, tenor, calendar, fixedFrequency, fixedConvention, fixedDayCount, index, spread, fwdStart, PACKAGE='QuantLib');
  class(ans) <- "_p_SwapRateHelperPtr";
  
  reg.finalizer(ans, delete_SwapRateHelper)
  ans
  
}

attr(`SwapRateHelper__SWIG_3`, 'returnType') = '_p_SwapRateHelperPtr'
attr(`SwapRateHelper__SWIG_3`, "inputTypes") = c('numeric', '_p_Period', '_p_Calendar', 'character', 'character', '_p_DayCounter', '_p_IborIndexPtr', '_p_HandleT_Quote_t', '_p_Period')
class(`SwapRateHelper__SWIG_3`) = c("SWIGFunction", class('SwapRateHelper__SWIG_3'))

# Start of new_SwapRateHelper

`SwapRateHelper__SWIG_4` = function(rate, tenor, calendar, fixedFrequency, fixedConvention, fixedDayCount, index, spread)
{
  fixedFrequency = enumToInteger(fixedFrequency, "_Frequency"); 
  
  if(length(fixedFrequency) > 1) {
    warning("using only the first element of fixedFrequency");
  };
  
  fixedConvention = enumToInteger(fixedConvention, "_BusinessDayConvention"); 
  
  if(length(fixedConvention) > 1) {
    warning("using only the first element of fixedConvention");
  };
  
  
  
  
  ;ans = .Call('R_swig_new_SwapRateHelper__SWIG_4', rate, tenor, calendar, fixedFrequency, fixedConvention, fixedDayCount, index, spread, PACKAGE='QuantLib');
  class(ans) <- "_p_SwapRateHelperPtr";
  
  reg.finalizer(ans, delete_SwapRateHelper)
  ans
  
}

attr(`SwapRateHelper__SWIG_4`, 'returnType') = '_p_SwapRateHelperPtr'
attr(`SwapRateHelper__SWIG_4`, "inputTypes") = c('numeric', '_p_Period', '_p_Calendar', 'character', 'character', '_p_DayCounter', '_p_IborIndexPtr', '_p_HandleT_Quote_t')
class(`SwapRateHelper__SWIG_4`) = c("SWIGFunction", class('SwapRateHelper__SWIG_4'))

# Start of new_SwapRateHelper

`SwapRateHelper__SWIG_5` = function(rate, tenor, calendar, fixedFrequency, fixedConvention, fixedDayCount, index)
{
  fixedFrequency = enumToInteger(fixedFrequency, "_Frequency"); 
  
  if(length(fixedFrequency) > 1) {
    warning("using only the first element of fixedFrequency");
  };
  
  fixedConvention = enumToInteger(fixedConvention, "_BusinessDayConvention"); 
  
  if(length(fixedConvention) > 1) {
    warning("using only the first element of fixedConvention");
  };
  
  
  
  ;ans = .Call('R_swig_new_SwapRateHelper__SWIG_5', rate, tenor, calendar, fixedFrequency, fixedConvention, fixedDayCount, index, PACKAGE='QuantLib');
  class(ans) <- "_p_SwapRateHelperPtr";
  
  reg.finalizer(ans, delete_SwapRateHelper)
  ans
  
}

attr(`SwapRateHelper__SWIG_5`, 'returnType') = '_p_SwapRateHelperPtr'
attr(`SwapRateHelper__SWIG_5`, "inputTypes") = c('numeric', '_p_Period', '_p_Calendar', 'character', 'character', '_p_DayCounter', '_p_IborIndexPtr')
class(`SwapRateHelper__SWIG_5`) = c("SWIGFunction", class('SwapRateHelper__SWIG_5'))

`SwapRateHelper` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 6
  if (argc == 7) {
    if (extends(argtypes[1], '_p_HandleT_Quote_t') && extends(argtypes[2], '_p_Period') && extends(argtypes[3], '_p_Calendar') && is.character(argv[[4]]) && is.character(argv[[5]]) && extends(argtypes[6], '_p_DayCounter') && extends(argtypes[7], '_p_IborIndexPtr')) {
      f <- SwapRateHelper__SWIG_2; 
    }
    else if (is.numeric(argv[[1]]) && extends(argtypes[2], '_p_Period') && extends(argtypes[3], '_p_Calendar') && is.character(argv[[4]]) && is.character(argv[[5]]) && extends(argtypes[6], '_p_DayCounter') && extends(argtypes[7], '_p_IborIndexPtr')) {
      f <- SwapRateHelper__SWIG_5; 
    }
  } else if (argc == 8) {
    if (extends(argtypes[1], '_p_HandleT_Quote_t') && extends(argtypes[2], '_p_Period') && extends(argtypes[3], '_p_Calendar') && is.character(argv[[4]]) && is.character(argv[[5]]) && extends(argtypes[6], '_p_DayCounter') && extends(argtypes[7], '_p_IborIndexPtr') && extends(argtypes[8], '_p_HandleT_Quote_t')) {
      f <- SwapRateHelper__SWIG_1; 
    }
    else if (is.numeric(argv[[1]]) && extends(argtypes[2], '_p_Period') && extends(argtypes[3], '_p_Calendar') && is.character(argv[[4]]) && is.character(argv[[5]]) && extends(argtypes[6], '_p_DayCounter') && extends(argtypes[7], '_p_IborIndexPtr') && extends(argtypes[8], '_p_HandleT_Quote_t')) {
      f <- SwapRateHelper__SWIG_4; 
    }
  } else if (argc == 9) {
    if (extends(argtypes[1], '_p_HandleT_Quote_t') && extends(argtypes[2], '_p_Period') && extends(argtypes[3], '_p_Calendar') && is.character(argv[[4]]) && is.character(argv[[5]]) && extends(argtypes[6], '_p_DayCounter') && extends(argtypes[7], '_p_IborIndexPtr') && extends(argtypes[8], '_p_HandleT_Quote_t') && extends(argtypes[9], '_p_Period')) {
      f <- SwapRateHelper__SWIG_0; 
    }
    else if (is.numeric(argv[[1]]) && extends(argtypes[2], '_p_Period') && extends(argtypes[3], '_p_Calendar') && is.character(argv[[4]]) && is.character(argv[[5]]) && extends(argtypes[6], '_p_DayCounter') && extends(argtypes[7], '_p_IborIndexPtr') && extends(argtypes[8], '_p_HandleT_Quote_t') && extends(argtypes[9], '_p_Period')) {
      f <- SwapRateHelper__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for SwapRateHelper with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of SwapRateHelper_swap

`SwapRateHelper_swap` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_SwapRateHelper_swap', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_VanillaSwapPtr";
  
  ans
  
}

attr(`SwapRateHelper_swap`, 'returnType') = '_p_VanillaSwapPtr'
attr(`SwapRateHelper_swap`, "inputTypes") = c('_p_SwapRateHelperPtr')
class(`SwapRateHelper_swap`) = c("SWIGFunction", class('SwapRateHelper_swap'))

# Start of delete_SwapRateHelper

`delete_SwapRateHelper` = function(self)
{
  ;.Call('R_swig_delete_SwapRateHelper', self, PACKAGE='QuantLib');
  
}

attr(`delete_SwapRateHelper`, 'returnType') = 'void'
attr(`delete_SwapRateHelper`, "inputTypes") = c('_p_SwapRateHelperPtr')
class(`delete_SwapRateHelper`) = c("SWIGFunction", class('delete_SwapRateHelper'))

# Start of accessor method for SwapRateHelperPtr
setMethod('$', '_p_SwapRateHelperPtr', function(x, name)

{
  accessorFuns = list('swap' = SwapRateHelper_swap);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for SwapRateHelperPtr
setMethod('delete', '_p_SwapRateHelperPtr', function(obj) {delete_SwapRateHelperPtr(obj)})
# Start of new_FixedRateBondHelper

`FixedRateBondHelper__SWIG_0` = function(cleanPrice, settlementDays, faceAmount, schedule, coupons, paymentDayCounter, paymentConvention, redemption, issueDate)
{
  if(length(settlementDays) > 1) {
    warning("using only the first element of settlementDays");
  };
  
  
  
  
  
  paymentConvention = enumToInteger(paymentConvention, "_BusinessDayConvention"); 
  
  if(length(paymentConvention) > 1) {
    warning("using only the first element of paymentConvention");
  };
  
  
  
  ;ans = .Call('R_swig_new_FixedRateBondHelper__SWIG_0', cleanPrice, settlementDays, faceAmount, schedule, coupons, paymentDayCounter, paymentConvention, redemption, issueDate, PACKAGE='QuantLib');
  class(ans) <- "_p_FixedRateBondHelperPtr";
  
  reg.finalizer(ans, delete_FixedRateBondHelper)
  ans
  
}

attr(`FixedRateBondHelper__SWIG_0`, 'returnType') = '_p_FixedRateBondHelperPtr'
attr(`FixedRateBondHelper__SWIG_0`, "inputTypes") = c('_p_HandleT_Quote_t', 'integer', 'numeric', '_p_Schedule', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_DayCounter', 'character', 'numeric', '_p_Date')
class(`FixedRateBondHelper__SWIG_0`) = c("SWIGFunction", class('FixedRateBondHelper__SWIG_0'))

# Start of new_FixedRateBondHelper

`FixedRateBondHelper__SWIG_1` = function(cleanPrice, settlementDays, faceAmount, schedule, coupons, paymentDayCounter, paymentConvention, redemption)
{
  if(length(settlementDays) > 1) {
    warning("using only the first element of settlementDays");
  };
  
  
  
  
  
  paymentConvention = enumToInteger(paymentConvention, "_BusinessDayConvention"); 
  
  if(length(paymentConvention) > 1) {
    warning("using only the first element of paymentConvention");
  };
  
  
  ;ans = .Call('R_swig_new_FixedRateBondHelper__SWIG_1', cleanPrice, settlementDays, faceAmount, schedule, coupons, paymentDayCounter, paymentConvention, redemption, PACKAGE='QuantLib');
  class(ans) <- "_p_FixedRateBondHelperPtr";
  
  reg.finalizer(ans, delete_FixedRateBondHelper)
  ans
  
}

attr(`FixedRateBondHelper__SWIG_1`, 'returnType') = '_p_FixedRateBondHelperPtr'
attr(`FixedRateBondHelper__SWIG_1`, "inputTypes") = c('_p_HandleT_Quote_t', 'integer', 'numeric', '_p_Schedule', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_DayCounter', 'character', 'numeric')
class(`FixedRateBondHelper__SWIG_1`) = c("SWIGFunction", class('FixedRateBondHelper__SWIG_1'))

# Start of new_FixedRateBondHelper

`FixedRateBondHelper__SWIG_2` = function(cleanPrice, settlementDays, faceAmount, schedule, coupons, paymentDayCounter, paymentConvention)
{
  if(length(settlementDays) > 1) {
    warning("using only the first element of settlementDays");
  };
  
  
  
  
  
  paymentConvention = enumToInteger(paymentConvention, "_BusinessDayConvention"); 
  
  if(length(paymentConvention) > 1) {
    warning("using only the first element of paymentConvention");
  };
  
  ;ans = .Call('R_swig_new_FixedRateBondHelper__SWIG_2', cleanPrice, settlementDays, faceAmount, schedule, coupons, paymentDayCounter, paymentConvention, PACKAGE='QuantLib');
  class(ans) <- "_p_FixedRateBondHelperPtr";
  
  reg.finalizer(ans, delete_FixedRateBondHelper)
  ans
  
}

attr(`FixedRateBondHelper__SWIG_2`, 'returnType') = '_p_FixedRateBondHelperPtr'
attr(`FixedRateBondHelper__SWIG_2`, "inputTypes") = c('_p_HandleT_Quote_t', 'integer', 'numeric', '_p_Schedule', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_DayCounter', 'character')
class(`FixedRateBondHelper__SWIG_2`) = c("SWIGFunction", class('FixedRateBondHelper__SWIG_2'))

# Start of new_FixedRateBondHelper

`FixedRateBondHelper__SWIG_3` = function(cleanPrice, settlementDays, faceAmount, schedule, coupons, paymentDayCounter)
{
  if(length(settlementDays) > 1) {
    warning("using only the first element of settlementDays");
  };
  
  
  
  
  
  ;ans = .Call('R_swig_new_FixedRateBondHelper__SWIG_3', cleanPrice, settlementDays, faceAmount, schedule, coupons, paymentDayCounter, PACKAGE='QuantLib');
  class(ans) <- "_p_FixedRateBondHelperPtr";
  
  reg.finalizer(ans, delete_FixedRateBondHelper)
  ans
  
}

attr(`FixedRateBondHelper__SWIG_3`, 'returnType') = '_p_FixedRateBondHelperPtr'
attr(`FixedRateBondHelper__SWIG_3`, "inputTypes") = c('_p_HandleT_Quote_t', 'integer', 'numeric', '_p_Schedule', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_DayCounter')
class(`FixedRateBondHelper__SWIG_3`) = c("SWIGFunction", class('FixedRateBondHelper__SWIG_3'))

`FixedRateBondHelper` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 6) {
    if (extends(argtypes[1], '_p_HandleT_Quote_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && is.numeric(argv[[3]]) && extends(argtypes[4], '_p_Schedule') && extends(argtypes[5], '_p_std__vectorT_double_std__allocatorT_double_t_t') && extends(argtypes[6], '_p_DayCounter')) {
      f <- FixedRateBondHelper__SWIG_3; 
    }
  } else if (argc == 7) {
    if (extends(argtypes[1], '_p_HandleT_Quote_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && is.numeric(argv[[3]]) && extends(argtypes[4], '_p_Schedule') && extends(argtypes[5], '_p_std__vectorT_double_std__allocatorT_double_t_t') && extends(argtypes[6], '_p_DayCounter') && is.character(argv[[7]])) {
      f <- FixedRateBondHelper__SWIG_2; 
    }
  } else if (argc == 8) {
    if (extends(argtypes[1], '_p_HandleT_Quote_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && is.numeric(argv[[3]]) && extends(argtypes[4], '_p_Schedule') && extends(argtypes[5], '_p_std__vectorT_double_std__allocatorT_double_t_t') && extends(argtypes[6], '_p_DayCounter') && is.character(argv[[7]]) && is.numeric(argv[[8]])) {
      f <- FixedRateBondHelper__SWIG_1; 
    }
  } else if (argc == 9) {
    if (extends(argtypes[1], '_p_HandleT_Quote_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && is.numeric(argv[[3]]) && extends(argtypes[4], '_p_Schedule') && extends(argtypes[5], '_p_std__vectorT_double_std__allocatorT_double_t_t') && extends(argtypes[6], '_p_DayCounter') && is.character(argv[[7]]) && is.numeric(argv[[8]]) && extends(argtypes[9], '_p_Date')) {
      f <- FixedRateBondHelper__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for FixedRateBondHelper with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of FixedRateBondHelper_bond

`FixedRateBondHelper_bond` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_FixedRateBondHelper_bond', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_FixedRateBondPtr";
  
  ans
  
}

attr(`FixedRateBondHelper_bond`, 'returnType') = '_p_FixedRateBondPtr'
attr(`FixedRateBondHelper_bond`, "inputTypes") = c('_p_FixedRateBondHelperPtr')
class(`FixedRateBondHelper_bond`) = c("SWIGFunction", class('FixedRateBondHelper_bond'))

# Start of delete_FixedRateBondHelper

`delete_FixedRateBondHelper` = function(self)
{
  ;.Call('R_swig_delete_FixedRateBondHelper', self, PACKAGE='QuantLib');
  
}

attr(`delete_FixedRateBondHelper`, 'returnType') = 'void'
attr(`delete_FixedRateBondHelper`, "inputTypes") = c('_p_FixedRateBondHelperPtr')
class(`delete_FixedRateBondHelper`) = c("SWIGFunction", class('delete_FixedRateBondHelper'))

# Start of accessor method for FixedRateBondHelperPtr
setMethod('$', '_p_FixedRateBondHelperPtr', function(x, name)

{
  accessorFuns = list('bond' = FixedRateBondHelper_bond);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for FixedRateBondHelperPtr
setMethod('delete', '_p_FixedRateBondHelperPtr', function(obj) {delete_FixedRateBondHelperPtr(obj)})
# Start of RateHelperVector___nonzero__

`RateHelperVector___nonzero__` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_RateHelperVector___nonzero__', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`RateHelperVector___nonzero__`, 'returnType') = 'logical'
attr(`RateHelperVector___nonzero__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t')
class(`RateHelperVector___nonzero__`) = c("SWIGFunction", class('RateHelperVector___nonzero__'))

# Start of RateHelperVector___len__

`RateHelperVector___len__` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_RateHelperVector___len__', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`RateHelperVector___len__`, 'returnType') = 'integer'
attr(`RateHelperVector___len__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t')
class(`RateHelperVector___len__`) = c("SWIGFunction", class('RateHelperVector___len__'))

# Start of RateHelperVector_pop

`RateHelperVector_pop` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_RateHelperVector_pop', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_RateHelper_t";
  
  ans
  
}

attr(`RateHelperVector_pop`, 'returnType') = '_p_boost__shared_ptrT_RateHelper_t'
attr(`RateHelperVector_pop`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t')
class(`RateHelperVector_pop`) = c("SWIGFunction", class('RateHelperVector_pop'))

# Start of RateHelperVector___getslice__

`RateHelperVector___getslice__` = function(self, i, j)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;ans = .Call('R_swig_RateHelperVector___getslice__', self, i, j, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t";
  
  ans
  
}

attr(`RateHelperVector___getslice__`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t'
attr(`RateHelperVector___getslice__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t', 'integer', 'integer')
class(`RateHelperVector___getslice__`) = c("SWIGFunction", class('RateHelperVector___getslice__'))

# Start of RateHelperVector___setslice__

`RateHelperVector___setslice__` = function(self, i, j, v)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  
  ;.Call('R_swig_RateHelperVector___setslice__', self, i, j, v, PACKAGE='QuantLib');
  
}

attr(`RateHelperVector___setslice__`, 'returnType') = 'void'
attr(`RateHelperVector___setslice__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t', 'integer', 'integer', '_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t')
class(`RateHelperVector___setslice__`) = c("SWIGFunction", class('RateHelperVector___setslice__'))

# Start of RateHelperVector___delslice__

`RateHelperVector___delslice__` = function(self, i, j)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_RateHelperVector___delslice__', self, i, j, PACKAGE='QuantLib');
  
}

attr(`RateHelperVector___delslice__`, 'returnType') = 'void'
attr(`RateHelperVector___delslice__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t', 'integer', 'integer')
class(`RateHelperVector___delslice__`) = c("SWIGFunction", class('RateHelperVector___delslice__'))

# Start of RateHelperVector___delitem__

`RateHelperVector___delitem__` = function(self, i)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_RateHelperVector___delitem__', self, i, PACKAGE='QuantLib');
  
}

attr(`RateHelperVector___delitem__`, 'returnType') = 'void'
attr(`RateHelperVector___delitem__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t', 'integer')
class(`RateHelperVector___delitem__`) = c("SWIGFunction", class('RateHelperVector___delitem__'))

# Start of RateHelperVector___getitem__

`RateHelperVector___getitem__` = function(self, i, .copy = FALSE)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;ans = .Call('R_swig_RateHelperVector___getitem__', self, i, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_RateHelper_t";
  
  ans
  
}

attr(`RateHelperVector___getitem__`, 'returnType') = '_p_boost__shared_ptrT_RateHelper_t'
attr(`RateHelperVector___getitem__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t', 'integer')
class(`RateHelperVector___getitem__`) = c("SWIGFunction", class('RateHelperVector___getitem__'))

# Start of RateHelperVector___setitem__

`RateHelperVector___setitem__` = function(self, i, x)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  ;.Call('R_swig_RateHelperVector___setitem__', self, i, x, PACKAGE='QuantLib');
  
}

attr(`RateHelperVector___setitem__`, 'returnType') = 'void'
attr(`RateHelperVector___setitem__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t', 'integer', '_p_boost__shared_ptrT_RateHelper_t')
class(`RateHelperVector___setitem__`) = c("SWIGFunction", class('RateHelperVector___setitem__'))

# Start of RateHelperVector_append

`RateHelperVector_append` = function(self, x)
{
  ;.Call('R_swig_RateHelperVector_append', self, x, PACKAGE='QuantLib');
  
}

attr(`RateHelperVector_append`, 'returnType') = 'void'
attr(`RateHelperVector_append`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t', '_p_boost__shared_ptrT_RateHelper_t')
class(`RateHelperVector_append`) = c("SWIGFunction", class('RateHelperVector_append'))

# Start of new_RateHelperVector

`RateHelperVector__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_RateHelperVector__SWIG_0', PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t";
  
  reg.finalizer(ans, delete_RateHelperVector)
  ans
  
}

attr(`RateHelperVector__SWIG_0`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t'
class(`RateHelperVector__SWIG_0`) = c("SWIGFunction", class('RateHelperVector__SWIG_0'))

# Start of new_RateHelperVector

`RateHelperVector__SWIG_1` = function(s_arg1)
{
  ;ans = .Call('R_swig_new_RateHelperVector__SWIG_1', s_arg1, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t";
  
  reg.finalizer(ans, delete_RateHelperVector)
  ans
  
}

attr(`RateHelperVector__SWIG_1`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t'
attr(`RateHelperVector__SWIG_1`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t')
class(`RateHelperVector__SWIG_1`) = c("SWIGFunction", class('RateHelperVector__SWIG_1'))

# Start of RateHelperVector_empty

`RateHelperVector_empty` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_RateHelperVector_empty', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`RateHelperVector_empty`, 'returnType') = 'logical'
attr(`RateHelperVector_empty`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t')
class(`RateHelperVector_empty`) = c("SWIGFunction", class('RateHelperVector_empty'))

# Start of RateHelperVector_size

`RateHelperVector_size` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_RateHelperVector_size', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`RateHelperVector_size`, 'returnType') = 'integer'
attr(`RateHelperVector_size`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t')
class(`RateHelperVector_size`) = c("SWIGFunction", class('RateHelperVector_size'))

# Start of RateHelperVector_clear

`RateHelperVector_clear` = function(self)
{
  ;.Call('R_swig_RateHelperVector_clear', self, PACKAGE='QuantLib');
  
}

attr(`RateHelperVector_clear`, 'returnType') = 'void'
attr(`RateHelperVector_clear`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t')
class(`RateHelperVector_clear`) = c("SWIGFunction", class('RateHelperVector_clear'))

# Start of RateHelperVector_swap

`RateHelperVector_swap` = function(self, v)
{
  ;.Call('R_swig_RateHelperVector_swap', self, v, PACKAGE='QuantLib');
  
}

attr(`RateHelperVector_swap`, 'returnType') = 'void'
attr(`RateHelperVector_swap`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t', '_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t')
class(`RateHelperVector_swap`) = c("SWIGFunction", class('RateHelperVector_swap'))

# Start of RateHelperVector_get_allocator

`RateHelperVector_get_allocator` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_RateHelperVector_get_allocator', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__allocatorT_boost__shared_ptrT_RateHelper_t_t";
  
  ans
  
}

attr(`RateHelperVector_get_allocator`, 'returnType') = '_p_std__allocatorT_boost__shared_ptrT_RateHelper_t_t'
attr(`RateHelperVector_get_allocator`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t')
class(`RateHelperVector_get_allocator`) = c("SWIGFunction", class('RateHelperVector_get_allocator'))

# Start of new_RateHelperVector

`RateHelperVector__SWIG_2` = function(size)
{
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_new_RateHelperVector__SWIG_2', size, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t";
  
  reg.finalizer(ans, delete_RateHelperVector)
  ans
  
}

attr(`RateHelperVector__SWIG_2`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t'
attr(`RateHelperVector__SWIG_2`, "inputTypes") = c('integer')
class(`RateHelperVector__SWIG_2`) = c("SWIGFunction", class('RateHelperVector__SWIG_2'))

# Start of RateHelperVector_pop_back

`RateHelperVector_pop_back` = function(self)
{
  ;.Call('R_swig_RateHelperVector_pop_back', self, PACKAGE='QuantLib');
  
}

attr(`RateHelperVector_pop_back`, 'returnType') = 'void'
attr(`RateHelperVector_pop_back`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t')
class(`RateHelperVector_pop_back`) = c("SWIGFunction", class('RateHelperVector_pop_back'))

# Start of RateHelperVector_resize

`RateHelperVector_resize__SWIG_0` = function(self, new_size)
{
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_RateHelperVector_resize__SWIG_0', self, new_size, PACKAGE='QuantLib');
  
}

attr(`RateHelperVector_resize__SWIG_0`, 'returnType') = 'void'
attr(`RateHelperVector_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t', 'integer')
class(`RateHelperVector_resize__SWIG_0`) = c("SWIGFunction", class('RateHelperVector_resize__SWIG_0'))

# Start of new_RateHelperVector

`RateHelperVector__SWIG_3` = function(size, value)
{
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  
  ;ans = .Call('R_swig_new_RateHelperVector__SWIG_3', size, value, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t";
  
  reg.finalizer(ans, delete_RateHelperVector)
  ans
  
}

attr(`RateHelperVector__SWIG_3`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t'
attr(`RateHelperVector__SWIG_3`, "inputTypes") = c('integer', '_p_boost__shared_ptrT_RateHelper_t')
class(`RateHelperVector__SWIG_3`) = c("SWIGFunction", class('RateHelperVector__SWIG_3'))

`RateHelperVector` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- RateHelperVector__SWIG_0; 
  } else if (argc == 1) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]]))) {
      f <- RateHelperVector__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t')) {
      f <- RateHelperVector__SWIG_1; 
    }
  } else if (argc == 2) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && extends(argtypes[2], '_p_boost__shared_ptrT_RateHelper_t')) {
      f <- RateHelperVector__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for RateHelperVector with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of RateHelperVector_push_back

`RateHelperVector_push_back` = function(self, x)
{
  ;.Call('R_swig_RateHelperVector_push_back', self, x, PACKAGE='QuantLib');
  
}

attr(`RateHelperVector_push_back`, 'returnType') = 'void'
attr(`RateHelperVector_push_back`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t', '_p_boost__shared_ptrT_RateHelper_t')
class(`RateHelperVector_push_back`) = c("SWIGFunction", class('RateHelperVector_push_back'))

# Start of RateHelperVector_front

`RateHelperVector_front` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_RateHelperVector_front', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_RateHelper_t";
  
  ans
  
}

attr(`RateHelperVector_front`, 'returnType') = '_p_boost__shared_ptrT_RateHelper_t'
attr(`RateHelperVector_front`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t')
class(`RateHelperVector_front`) = c("SWIGFunction", class('RateHelperVector_front'))

# Start of RateHelperVector_back

`RateHelperVector_back` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_RateHelperVector_back', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_RateHelper_t";
  
  ans
  
}

attr(`RateHelperVector_back`, 'returnType') = '_p_boost__shared_ptrT_RateHelper_t'
attr(`RateHelperVector_back`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t')
class(`RateHelperVector_back`) = c("SWIGFunction", class('RateHelperVector_back'))

# Start of RateHelperVector_assign

`RateHelperVector_assign` = function(self, n, x)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  
  ;.Call('R_swig_RateHelperVector_assign', self, n, x, PACKAGE='QuantLib');
  
}

attr(`RateHelperVector_assign`, 'returnType') = 'void'
attr(`RateHelperVector_assign`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t', 'integer', '_p_boost__shared_ptrT_RateHelper_t')
class(`RateHelperVector_assign`) = c("SWIGFunction", class('RateHelperVector_assign'))

# Start of RateHelperVector_resize

`RateHelperVector_resize__SWIG_1` = function(self, new_size, x)
{
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  
  ;.Call('R_swig_RateHelperVector_resize__SWIG_1', self, new_size, x, PACKAGE='QuantLib');
  
}

attr(`RateHelperVector_resize__SWIG_1`, 'returnType') = 'void'
attr(`RateHelperVector_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t', 'integer', '_p_boost__shared_ptrT_RateHelper_t')
class(`RateHelperVector_resize__SWIG_1`) = c("SWIGFunction", class('RateHelperVector_resize__SWIG_1'))

`RateHelperVector_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]]))) {
      f <- RateHelperVector_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && extends(argtypes[3], '_p_boost__shared_ptrT_RateHelper_t')) {
      f <- RateHelperVector_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for RateHelperVector_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of RateHelperVector_reserve

`RateHelperVector_reserve` = function(self, n)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_RateHelperVector_reserve', self, n, PACKAGE='QuantLib');
  
}

attr(`RateHelperVector_reserve`, 'returnType') = 'void'
attr(`RateHelperVector_reserve`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t', 'integer')
class(`RateHelperVector_reserve`) = c("SWIGFunction", class('RateHelperVector_reserve'))

# Start of RateHelperVector_capacity

`RateHelperVector_capacity` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_RateHelperVector_capacity', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`RateHelperVector_capacity`, 'returnType') = 'integer'
attr(`RateHelperVector_capacity`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t')
class(`RateHelperVector_capacity`) = c("SWIGFunction", class('RateHelperVector_capacity'))

# Start of delete_RateHelperVector

`delete_RateHelperVector` = function(self)
{
  ;.Call('R_swig_delete_RateHelperVector', self, PACKAGE='QuantLib');
  
}

attr(`delete_RateHelperVector`, 'returnType') = 'void'
attr(`delete_RateHelperVector`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t')
class(`delete_RateHelperVector`) = c("SWIGFunction", class('delete_RateHelperVector'))

# Start of accessor method for std::vector<(boost::shared_ptr<(RateHelper)>)>
setMethod('$', '_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = RateHelperVector___nonzero__, '__len__' = RateHelperVector___len__, 'pop' = RateHelperVector_pop, '__getslice__' = RateHelperVector___getslice__, '__setslice__' = RateHelperVector___setslice__, '__delslice__' = RateHelperVector___delslice__, '__delitem__' = RateHelperVector___delitem__, '__getitem__' = RateHelperVector___getitem__, '__setitem__' = RateHelperVector___setitem__, 'append' = RateHelperVector_append, 'empty' = RateHelperVector_empty, 'size' = RateHelperVector_size, 'clear' = RateHelperVector_clear, 'swap' = RateHelperVector_swap, 'get_allocator' = RateHelperVector_get_allocator, 'pop_back' = RateHelperVector_pop_back, 'resize' = RateHelperVector_resize, 'push_back' = RateHelperVector_push_back, 'front' = RateHelperVector_front, 'back' = RateHelperVector_back, 'assign' = RateHelperVector_assign, 'reserve' = RateHelperVector_reserve, 'capacity' = RateHelperVector_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for std::vector<(boost::shared_ptr<(RateHelper)>)>
setMethod('delete', '_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t', function(obj) {delete_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t(obj)})
# Start of new_Discount

`Discount` = function()
{
  ;ans = .Call('R_swig_new_Discount', PACKAGE='QuantLib');
  class(ans) <- "_p_Discount";
  
  reg.finalizer(ans, delete_Discount)
  ans
  
}

attr(`Discount`, 'returnType') = '_p_Discount'
class(`Discount`) = c("SWIGFunction", class('Discount'))

# Start of delete_Discount

`delete_Discount` = function(self)
{
  ;.Call('R_swig_delete_Discount', self, PACKAGE='QuantLib');
  
}

attr(`delete_Discount`, 'returnType') = 'void'
attr(`delete_Discount`, "inputTypes") = c('_p_Discount')
class(`delete_Discount`) = c("SWIGFunction", class('delete_Discount'))

setMethod('delete', '_p_Discount', function(obj) {delete_Discount(obj)})
# Start definition of copy functions & methods for Discount
CopyToR_Discount = function(value, obj = new("Discount"))
{
  obj;
}



CopyToC_Discount = function(value, obj)
{
  obj
}



# Start definition of copy methods for Discount
setMethod('copyToR', '_p_Discount', CopyToR_Discount);
setMethod('copyToC', 'Discount', CopyToC_Discount);

# End definition of copy methods for Discount
# End definition of copy functions & methods for Discount
# Start of new_ZeroYield

`ZeroYield` = function()
{
  ;ans = .Call('R_swig_new_ZeroYield', PACKAGE='QuantLib');
  class(ans) <- "_p_ZeroYield";
  
  reg.finalizer(ans, delete_ZeroYield)
  ans
  
}

attr(`ZeroYield`, 'returnType') = '_p_ZeroYield'
class(`ZeroYield`) = c("SWIGFunction", class('ZeroYield'))

# Start of delete_ZeroYield

`delete_ZeroYield` = function(self)
{
  ;.Call('R_swig_delete_ZeroYield', self, PACKAGE='QuantLib');
  
}

attr(`delete_ZeroYield`, 'returnType') = 'void'
attr(`delete_ZeroYield`, "inputTypes") = c('_p_ZeroYield')
class(`delete_ZeroYield`) = c("SWIGFunction", class('delete_ZeroYield'))

setMethod('delete', '_p_ZeroYield', function(obj) {delete_ZeroYield(obj)})
# Start definition of copy functions & methods for ZeroYield
CopyToR_ZeroYield = function(value, obj = new("ZeroYield"))
{
  obj;
}



CopyToC_ZeroYield = function(value, obj)
{
  obj
}



# Start definition of copy methods for ZeroYield
setMethod('copyToR', '_p_ZeroYield', CopyToR_ZeroYield);
setMethod('copyToC', 'ZeroYield', CopyToC_ZeroYield);

# End definition of copy methods for ZeroYield
# End definition of copy functions & methods for ZeroYield
# Start of new_ForwardRate

`ForwardRate` = function()
{
  ;ans = .Call('R_swig_new_ForwardRate', PACKAGE='QuantLib');
  class(ans) <- "_p_ForwardRate";
  
  reg.finalizer(ans, delete_ForwardRate)
  ans
  
}

attr(`ForwardRate`, 'returnType') = '_p_ForwardRate'
class(`ForwardRate`) = c("SWIGFunction", class('ForwardRate'))

# Start of delete_ForwardRate

`delete_ForwardRate` = function(self)
{
  ;.Call('R_swig_delete_ForwardRate', self, PACKAGE='QuantLib');
  
}

attr(`delete_ForwardRate`, 'returnType') = 'void'
attr(`delete_ForwardRate`, "inputTypes") = c('_p_ForwardRate')
class(`delete_ForwardRate`) = c("SWIGFunction", class('delete_ForwardRate'))

setMethod('delete', '_p_ForwardRate', function(obj) {delete_ForwardRate(obj)})
# Start definition of copy functions & methods for ForwardRate
CopyToR_ForwardRate = function(value, obj = new("ForwardRate"))
{
  obj;
}



CopyToC_ForwardRate = function(value, obj)
{
  obj
}



# Start definition of copy methods for ForwardRate
setMethod('copyToR', '_p_ForwardRate', CopyToR_ForwardRate);
setMethod('copyToC', 'ForwardRate', CopyToC_ForwardRate);

# End definition of copy methods for ForwardRate
# End definition of copy functions & methods for ForwardRate
# Start of new_PiecewiseFlatForward

`PiecewiseFlatForward__SWIG_0` = function(referenceDate, instruments, dayCounter, jumps, jumpDates, accuracy, i)
{
  ;ans = .Call('R_swig_new_PiecewiseFlatForward__SWIG_0', referenceDate, instruments, dayCounter, jumps, jumpDates, accuracy, i, PACKAGE='QuantLib');
  class(ans) <- "_p_PiecewiseFlatForwardPtr";
  
  reg.finalizer(ans, delete_PiecewiseFlatForward)
  ans
  
}

attr(`PiecewiseFlatForward__SWIG_0`, 'returnType') = '_p_PiecewiseFlatForwardPtr'
attr(`PiecewiseFlatForward__SWIG_0`, "inputTypes") = c('_p_Date', '_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t', '_p_DayCounter', '_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t', '_p_std__vectorT_Date_std__allocatorT_Date_t_t', 'numeric', '_p_BackwardFlat')
class(`PiecewiseFlatForward__SWIG_0`) = c("SWIGFunction", class('PiecewiseFlatForward__SWIG_0'))

# Start of new_PiecewiseFlatForward

`PiecewiseFlatForward__SWIG_1` = function(referenceDate, instruments, dayCounter, jumps, jumpDates, accuracy)
{
  ;ans = .Call('R_swig_new_PiecewiseFlatForward__SWIG_1', referenceDate, instruments, dayCounter, jumps, jumpDates, accuracy, PACKAGE='QuantLib');
  class(ans) <- "_p_PiecewiseFlatForwardPtr";
  
  reg.finalizer(ans, delete_PiecewiseFlatForward)
  ans
  
}

attr(`PiecewiseFlatForward__SWIG_1`, 'returnType') = '_p_PiecewiseFlatForwardPtr'
attr(`PiecewiseFlatForward__SWIG_1`, "inputTypes") = c('_p_Date', '_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t', '_p_DayCounter', '_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t', '_p_std__vectorT_Date_std__allocatorT_Date_t_t', 'numeric')
class(`PiecewiseFlatForward__SWIG_1`) = c("SWIGFunction", class('PiecewiseFlatForward__SWIG_1'))

# Start of new_PiecewiseFlatForward

`PiecewiseFlatForward__SWIG_2` = function(referenceDate, instruments, dayCounter, jumps, jumpDates)
{
  ;ans = .Call('R_swig_new_PiecewiseFlatForward__SWIG_2', referenceDate, instruments, dayCounter, jumps, jumpDates, PACKAGE='QuantLib');
  class(ans) <- "_p_PiecewiseFlatForwardPtr";
  
  reg.finalizer(ans, delete_PiecewiseFlatForward)
  ans
  
}

attr(`PiecewiseFlatForward__SWIG_2`, 'returnType') = '_p_PiecewiseFlatForwardPtr'
attr(`PiecewiseFlatForward__SWIG_2`, "inputTypes") = c('_p_Date', '_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t', '_p_DayCounter', '_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t', '_p_std__vectorT_Date_std__allocatorT_Date_t_t')
class(`PiecewiseFlatForward__SWIG_2`) = c("SWIGFunction", class('PiecewiseFlatForward__SWIG_2'))

# Start of new_PiecewiseFlatForward

`PiecewiseFlatForward__SWIG_3` = function(referenceDate, instruments, dayCounter, jumps)
{
  ;ans = .Call('R_swig_new_PiecewiseFlatForward__SWIG_3', referenceDate, instruments, dayCounter, jumps, PACKAGE='QuantLib');
  class(ans) <- "_p_PiecewiseFlatForwardPtr";
  
  reg.finalizer(ans, delete_PiecewiseFlatForward)
  ans
  
}

attr(`PiecewiseFlatForward__SWIG_3`, 'returnType') = '_p_PiecewiseFlatForwardPtr'
attr(`PiecewiseFlatForward__SWIG_3`, "inputTypes") = c('_p_Date', '_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t', '_p_DayCounter', '_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t')
class(`PiecewiseFlatForward__SWIG_3`) = c("SWIGFunction", class('PiecewiseFlatForward__SWIG_3'))

# Start of new_PiecewiseFlatForward

`PiecewiseFlatForward__SWIG_4` = function(referenceDate, instruments, dayCounter)
{
  ;ans = .Call('R_swig_new_PiecewiseFlatForward__SWIG_4', referenceDate, instruments, dayCounter, PACKAGE='QuantLib');
  class(ans) <- "_p_PiecewiseFlatForwardPtr";
  
  reg.finalizer(ans, delete_PiecewiseFlatForward)
  ans
  
}

attr(`PiecewiseFlatForward__SWIG_4`, 'returnType') = '_p_PiecewiseFlatForwardPtr'
attr(`PiecewiseFlatForward__SWIG_4`, "inputTypes") = c('_p_Date', '_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t', '_p_DayCounter')
class(`PiecewiseFlatForward__SWIG_4`) = c("SWIGFunction", class('PiecewiseFlatForward__SWIG_4'))

# Start of new_PiecewiseFlatForward

`PiecewiseFlatForward__SWIG_5` = function(settlementDays, calendar, instruments, dayCounter, jumps, jumpDates, accuracy, i)
{
  settlementDays = as.integer(settlementDays); 
  
  if(length(settlementDays) > 1) {
    warning("using only the first element of settlementDays");
  };
  
  
  
  
  
  
  
  
  ;ans = .Call('R_swig_new_PiecewiseFlatForward__SWIG_5', settlementDays, calendar, instruments, dayCounter, jumps, jumpDates, accuracy, i, PACKAGE='QuantLib');
  class(ans) <- "_p_PiecewiseFlatForwardPtr";
  
  reg.finalizer(ans, delete_PiecewiseFlatForward)
  ans
  
}

attr(`PiecewiseFlatForward__SWIG_5`, 'returnType') = '_p_PiecewiseFlatForwardPtr'
attr(`PiecewiseFlatForward__SWIG_5`, "inputTypes") = c('integer', '_p_Calendar', '_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t', '_p_DayCounter', '_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t', '_p_std__vectorT_Date_std__allocatorT_Date_t_t', 'numeric', '_p_BackwardFlat')
class(`PiecewiseFlatForward__SWIG_5`) = c("SWIGFunction", class('PiecewiseFlatForward__SWIG_5'))

# Start of new_PiecewiseFlatForward

`PiecewiseFlatForward__SWIG_6` = function(settlementDays, calendar, instruments, dayCounter, jumps, jumpDates, accuracy)
{
  settlementDays = as.integer(settlementDays); 
  
  if(length(settlementDays) > 1) {
    warning("using only the first element of settlementDays");
  };
  
  
  
  
  
  
  
  ;ans = .Call('R_swig_new_PiecewiseFlatForward__SWIG_6', settlementDays, calendar, instruments, dayCounter, jumps, jumpDates, accuracy, PACKAGE='QuantLib');
  class(ans) <- "_p_PiecewiseFlatForwardPtr";
  
  reg.finalizer(ans, delete_PiecewiseFlatForward)
  ans
  
}

attr(`PiecewiseFlatForward__SWIG_6`, 'returnType') = '_p_PiecewiseFlatForwardPtr'
attr(`PiecewiseFlatForward__SWIG_6`, "inputTypes") = c('integer', '_p_Calendar', '_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t', '_p_DayCounter', '_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t', '_p_std__vectorT_Date_std__allocatorT_Date_t_t', 'numeric')
class(`PiecewiseFlatForward__SWIG_6`) = c("SWIGFunction", class('PiecewiseFlatForward__SWIG_6'))

# Start of new_PiecewiseFlatForward

`PiecewiseFlatForward__SWIG_7` = function(settlementDays, calendar, instruments, dayCounter, jumps, jumpDates)
{
  settlementDays = as.integer(settlementDays); 
  
  if(length(settlementDays) > 1) {
    warning("using only the first element of settlementDays");
  };
  
  
  
  
  
  
  ;ans = .Call('R_swig_new_PiecewiseFlatForward__SWIG_7', settlementDays, calendar, instruments, dayCounter, jumps, jumpDates, PACKAGE='QuantLib');
  class(ans) <- "_p_PiecewiseFlatForwardPtr";
  
  reg.finalizer(ans, delete_PiecewiseFlatForward)
  ans
  
}

attr(`PiecewiseFlatForward__SWIG_7`, 'returnType') = '_p_PiecewiseFlatForwardPtr'
attr(`PiecewiseFlatForward__SWIG_7`, "inputTypes") = c('integer', '_p_Calendar', '_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t', '_p_DayCounter', '_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t', '_p_std__vectorT_Date_std__allocatorT_Date_t_t')
class(`PiecewiseFlatForward__SWIG_7`) = c("SWIGFunction", class('PiecewiseFlatForward__SWIG_7'))

# Start of new_PiecewiseFlatForward

`PiecewiseFlatForward__SWIG_8` = function(settlementDays, calendar, instruments, dayCounter, jumps)
{
  settlementDays = as.integer(settlementDays); 
  
  if(length(settlementDays) > 1) {
    warning("using only the first element of settlementDays");
  };
  
  
  
  
  
  ;ans = .Call('R_swig_new_PiecewiseFlatForward__SWIG_8', settlementDays, calendar, instruments, dayCounter, jumps, PACKAGE='QuantLib');
  class(ans) <- "_p_PiecewiseFlatForwardPtr";
  
  reg.finalizer(ans, delete_PiecewiseFlatForward)
  ans
  
}

attr(`PiecewiseFlatForward__SWIG_8`, 'returnType') = '_p_PiecewiseFlatForwardPtr'
attr(`PiecewiseFlatForward__SWIG_8`, "inputTypes") = c('integer', '_p_Calendar', '_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t', '_p_DayCounter', '_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t')
class(`PiecewiseFlatForward__SWIG_8`) = c("SWIGFunction", class('PiecewiseFlatForward__SWIG_8'))

# Start of new_PiecewiseFlatForward

`PiecewiseFlatForward__SWIG_9` = function(settlementDays, calendar, instruments, dayCounter)
{
  settlementDays = as.integer(settlementDays); 
  
  if(length(settlementDays) > 1) {
    warning("using only the first element of settlementDays");
  };
  
  
  
  
  ;ans = .Call('R_swig_new_PiecewiseFlatForward__SWIG_9', settlementDays, calendar, instruments, dayCounter, PACKAGE='QuantLib');
  class(ans) <- "_p_PiecewiseFlatForwardPtr";
  
  reg.finalizer(ans, delete_PiecewiseFlatForward)
  ans
  
}

attr(`PiecewiseFlatForward__SWIG_9`, 'returnType') = '_p_PiecewiseFlatForwardPtr'
attr(`PiecewiseFlatForward__SWIG_9`, "inputTypes") = c('integer', '_p_Calendar', '_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t', '_p_DayCounter')
class(`PiecewiseFlatForward__SWIG_9`) = c("SWIGFunction", class('PiecewiseFlatForward__SWIG_9'))

`PiecewiseFlatForward` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 10
  if (argc == 3) {
    if (extends(argtypes[1], '_p_Date') && extends(argtypes[2], '_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t') && extends(argtypes[3], '_p_DayCounter')) {
      f <- PiecewiseFlatForward__SWIG_4; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_Date') && extends(argtypes[2], '_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t') && extends(argtypes[3], '_p_DayCounter') && extends(argtypes[4], '_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t')) {
      f <- PiecewiseFlatForward__SWIG_3; 
    }
    else if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && extends(argtypes[2], '_p_Calendar') && extends(argtypes[3], '_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t') && extends(argtypes[4], '_p_DayCounter')) {
      f <- PiecewiseFlatForward__SWIG_9; 
    }
  } else if (argc == 5) {
    if (extends(argtypes[1], '_p_Date') && extends(argtypes[2], '_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t') && extends(argtypes[3], '_p_DayCounter') && extends(argtypes[4], '_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t') && extends(argtypes[5], '_p_std__vectorT_Date_std__allocatorT_Date_t_t')) {
      f <- PiecewiseFlatForward__SWIG_2; 
    }
    else if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && extends(argtypes[2], '_p_Calendar') && extends(argtypes[3], '_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t') && extends(argtypes[4], '_p_DayCounter') && extends(argtypes[5], '_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t')) {
      f <- PiecewiseFlatForward__SWIG_8; 
    }
  } else if (argc == 6) {
    if (extends(argtypes[1], '_p_Date') && extends(argtypes[2], '_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t') && extends(argtypes[3], '_p_DayCounter') && extends(argtypes[4], '_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t') && extends(argtypes[5], '_p_std__vectorT_Date_std__allocatorT_Date_t_t') && is.numeric(argv[[6]])) {
      f <- PiecewiseFlatForward__SWIG_1; 
    }
    else if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && extends(argtypes[2], '_p_Calendar') && extends(argtypes[3], '_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t') && extends(argtypes[4], '_p_DayCounter') && extends(argtypes[5], '_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t') && extends(argtypes[6], '_p_std__vectorT_Date_std__allocatorT_Date_t_t')) {
      f <- PiecewiseFlatForward__SWIG_7; 
    }
  } else if (argc == 7) {
    if (extends(argtypes[1], '_p_Date') && extends(argtypes[2], '_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t') && extends(argtypes[3], '_p_DayCounter') && extends(argtypes[4], '_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t') && extends(argtypes[5], '_p_std__vectorT_Date_std__allocatorT_Date_t_t') && is.numeric(argv[[6]]) && extends(argtypes[7], '_p_BackwardFlat')) {
      f <- PiecewiseFlatForward__SWIG_0; 
    }
    else if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && extends(argtypes[2], '_p_Calendar') && extends(argtypes[3], '_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t') && extends(argtypes[4], '_p_DayCounter') && extends(argtypes[5], '_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t') && extends(argtypes[6], '_p_std__vectorT_Date_std__allocatorT_Date_t_t') && is.numeric(argv[[7]])) {
      f <- PiecewiseFlatForward__SWIG_6; 
    }
  } else if (argc == 8) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && extends(argtypes[2], '_p_Calendar') && extends(argtypes[3], '_p_std__vectorT_boost__shared_ptrT_RateHelper_t_std__allocatorT_boost__shared_ptrT_RateHelper_t_t_t') && extends(argtypes[4], '_p_DayCounter') && extends(argtypes[5], '_p_std__vectorT_HandleT_Quote_t_std__allocatorT_HandleT_Quote_t_t_t') && extends(argtypes[6], '_p_std__vectorT_Date_std__allocatorT_Date_t_t') && is.numeric(argv[[7]]) && extends(argtypes[8], '_p_BackwardFlat')) {
      f <- PiecewiseFlatForward__SWIG_5; 
    }
  } else {
    stop("cannot find overloaded function for PiecewiseFlatForward with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of PiecewiseFlatForward_dates

`PiecewiseFlatForward_dates` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_PiecewiseFlatForward_dates', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_Date_std__allocatorT_Date_t_t";
  
  ans
  
}

attr(`PiecewiseFlatForward_dates`, 'returnType') = '_p_std__vectorT_Date_std__allocatorT_Date_t_t'
attr(`PiecewiseFlatForward_dates`, "inputTypes") = c('_p_PiecewiseFlatForwardPtr')
class(`PiecewiseFlatForward_dates`) = c("SWIGFunction", class('PiecewiseFlatForward_dates'))

# Start of PiecewiseFlatForward_times

`PiecewiseFlatForward_times` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_PiecewiseFlatForward_times', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_double_std__allocatorT_double_t_t";
  
  ans
  
}

attr(`PiecewiseFlatForward_times`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`PiecewiseFlatForward_times`, "inputTypes") = c('_p_PiecewiseFlatForwardPtr')
class(`PiecewiseFlatForward_times`) = c("SWIGFunction", class('PiecewiseFlatForward_times'))

# Start of delete_PiecewiseFlatForward

`delete_PiecewiseFlatForward` = function(self)
{
  ;.Call('R_swig_delete_PiecewiseFlatForward', self, PACKAGE='QuantLib');
  
}

attr(`delete_PiecewiseFlatForward`, 'returnType') = 'void'
attr(`delete_PiecewiseFlatForward`, "inputTypes") = c('_p_PiecewiseFlatForwardPtr')
class(`delete_PiecewiseFlatForward`) = c("SWIGFunction", class('delete_PiecewiseFlatForward'))

# Start of accessor method for PiecewiseFlatForwardPtr
setMethod('$', '_p_PiecewiseFlatForwardPtr', function(x, name)

{
  accessorFuns = list('dates' = PiecewiseFlatForward_dates, 'times' = PiecewiseFlatForward_times);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for PiecewiseFlatForwardPtr
setMethod('delete', '_p_PiecewiseFlatForwardPtr', function(obj) {delete_PiecewiseFlatForwardPtr(obj)})
# Start of new_SampledCurve

`SampledCurve__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_SampledCurve__SWIG_0', PACKAGE='QuantLib');
  class(ans) <- "_p_SampledCurve";
  
  reg.finalizer(ans, delete_SampledCurve)
  ans
  
}

attr(`SampledCurve__SWIG_0`, 'returnType') = '_p_SampledCurve'
class(`SampledCurve__SWIG_0`) = c("SWIGFunction", class('SampledCurve__SWIG_0'))

# Start of new_SampledCurve

`SampledCurve__SWIG_1` = function(s_arg1)
{
  ;ans = .Call('R_swig_new_SampledCurve__SWIG_1', s_arg1, PACKAGE='QuantLib');
  class(ans) <- "_p_SampledCurve";
  
  reg.finalizer(ans, delete_SampledCurve)
  ans
  
}

attr(`SampledCurve__SWIG_1`, 'returnType') = '_p_SampledCurve'
attr(`SampledCurve__SWIG_1`, "inputTypes") = c('_p_Array')
class(`SampledCurve__SWIG_1`) = c("SWIGFunction", class('SampledCurve__SWIG_1'))

`SampledCurve` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- SampledCurve__SWIG_0; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_Array')) {
      f <- SampledCurve__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for SampledCurve with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of SampledCurve_grid

`SampledCurve_grid` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_SampledCurve_grid', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Array";
  
  ans
  
}

attr(`SampledCurve_grid`, 'returnType') = '_p_Array'
attr(`SampledCurve_grid`, "inputTypes") = c('_p_SampledCurve')
class(`SampledCurve_grid`) = c("SWIGFunction", class('SampledCurve_grid'))

# Start of SampledCurve_values

`SampledCurve_values` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_SampledCurve_values', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Array";
  
  ans
  
}

attr(`SampledCurve_values`, 'returnType') = '_p_Array'
attr(`SampledCurve_values`, "inputTypes") = c('_p_SampledCurve')
class(`SampledCurve_values`) = c("SWIGFunction", class('SampledCurve_values'))

# Start of SampledCurve_gridValue

`SampledCurve_gridValue` = function(self, i, .copy = FALSE)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_SampledCurve_gridValue', self, i, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`SampledCurve_gridValue`, 'returnType') = 'numeric'
attr(`SampledCurve_gridValue`, "inputTypes") = c('_p_SampledCurve', 'integer')
class(`SampledCurve_gridValue`) = c("SWIGFunction", class('SampledCurve_gridValue'))

# Start of SampledCurve_value

`SampledCurve_value` = function(self, i, .copy = FALSE)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_SampledCurve_value', self, i, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`SampledCurve_value`, 'returnType') = 'numeric'
attr(`SampledCurve_value`, "inputTypes") = c('_p_SampledCurve', 'integer')
class(`SampledCurve_value`) = c("SWIGFunction", class('SampledCurve_value'))

# Start of SampledCurve_size

`SampledCurve_size` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_SampledCurve_size', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__size_t";
  
  ans
  
}

attr(`SampledCurve_size`, 'returnType') = 'integer'
attr(`SampledCurve_size`, "inputTypes") = c('_p_SampledCurve')
class(`SampledCurve_size`) = c("SWIGFunction", class('SampledCurve_size'))

# Start of SampledCurve_empty

`SampledCurve_empty` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_SampledCurve_empty', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`SampledCurve_empty`, 'returnType') = 'logical'
attr(`SampledCurve_empty`, "inputTypes") = c('_p_SampledCurve')
class(`SampledCurve_empty`) = c("SWIGFunction", class('SampledCurve_empty'))

# Start of SampledCurve_setGrid

`SampledCurve_setGrid` = function(self, s_arg2)
{
  ;.Call('R_swig_SampledCurve_setGrid', self, s_arg2, PACKAGE='QuantLib');
  
}

attr(`SampledCurve_setGrid`, 'returnType') = 'void'
attr(`SampledCurve_setGrid`, "inputTypes") = c('_p_SampledCurve', '_p_Array')
class(`SampledCurve_setGrid`) = c("SWIGFunction", class('SampledCurve_setGrid'))

# Start of SampledCurve_setValues

`SampledCurve_setValues` = function(self, s_arg2)
{
  ;.Call('R_swig_SampledCurve_setValues', self, s_arg2, PACKAGE='QuantLib');
  
}

attr(`SampledCurve_setValues`, 'returnType') = 'void'
attr(`SampledCurve_setValues`, "inputTypes") = c('_p_SampledCurve', '_p_Array')
class(`SampledCurve_setValues`) = c("SWIGFunction", class('SampledCurve_setValues'))

# Start of SampledCurve_swap

`SampledCurve_swap` = function(self, s_arg2)
{
  ;.Call('R_swig_SampledCurve_swap', self, s_arg2, PACKAGE='QuantLib');
  
}

attr(`SampledCurve_swap`, 'returnType') = 'void'
attr(`SampledCurve_swap`, "inputTypes") = c('_p_SampledCurve', '_p_SampledCurve')
class(`SampledCurve_swap`) = c("SWIGFunction", class('SampledCurve_swap'))

# Start of SampledCurve_setLogGrid

`SampledCurve_setLogGrid` = function(self, min, max)
{
  ;.Call('R_swig_SampledCurve_setLogGrid', self, min, max, PACKAGE='QuantLib');
  
}

attr(`SampledCurve_setLogGrid`, 'returnType') = 'void'
attr(`SampledCurve_setLogGrid`, "inputTypes") = c('_p_SampledCurve', 'numeric', 'numeric')
class(`SampledCurve_setLogGrid`) = c("SWIGFunction", class('SampledCurve_setLogGrid'))

# Start of SampledCurve_regridLogGrid

`SampledCurve_regridLogGrid` = function(self, min, max)
{
  ;.Call('R_swig_SampledCurve_regridLogGrid', self, min, max, PACKAGE='QuantLib');
  
}

attr(`SampledCurve_regridLogGrid`, 'returnType') = 'void'
attr(`SampledCurve_regridLogGrid`, "inputTypes") = c('_p_SampledCurve', 'numeric', 'numeric')
class(`SampledCurve_regridLogGrid`) = c("SWIGFunction", class('SampledCurve_regridLogGrid'))

# Start of SampledCurve_shiftGrid

`SampledCurve_shiftGrid` = function(self, s)
{
  ;.Call('R_swig_SampledCurve_shiftGrid', self, s, PACKAGE='QuantLib');
  
}

attr(`SampledCurve_shiftGrid`, 'returnType') = 'void'
attr(`SampledCurve_shiftGrid`, "inputTypes") = c('_p_SampledCurve', 'numeric')
class(`SampledCurve_shiftGrid`) = c("SWIGFunction", class('SampledCurve_shiftGrid'))

# Start of SampledCurve_scaleGrid

`SampledCurve_scaleGrid` = function(self, s)
{
  ;.Call('R_swig_SampledCurve_scaleGrid', self, s, PACKAGE='QuantLib');
  
}

attr(`SampledCurve_scaleGrid`, 'returnType') = 'void'
attr(`SampledCurve_scaleGrid`, "inputTypes") = c('_p_SampledCurve', 'numeric')
class(`SampledCurve_scaleGrid`) = c("SWIGFunction", class('SampledCurve_scaleGrid'))

# Start of SampledCurve_regrid

`SampledCurve_regrid` = function(self, s_arg2)
{
  ;.Call('R_swig_SampledCurve_regrid', self, s_arg2, PACKAGE='QuantLib');
  
}

attr(`SampledCurve_regrid`, 'returnType') = 'void'
attr(`SampledCurve_regrid`, "inputTypes") = c('_p_SampledCurve', '_p_Array')
class(`SampledCurve_regrid`) = c("SWIGFunction", class('SampledCurve_regrid'))

# Start of delete_SampledCurve

`delete_SampledCurve` = function(self)
{
  ;.Call('R_swig_delete_SampledCurve', self, PACKAGE='QuantLib');
  
}

attr(`delete_SampledCurve`, 'returnType') = 'void'
attr(`delete_SampledCurve`, "inputTypes") = c('_p_SampledCurve')
class(`delete_SampledCurve`) = c("SWIGFunction", class('delete_SampledCurve'))

# Start of accessor method for SampledCurve
setMethod('$', '_p_SampledCurve', function(x, name)

{
  accessorFuns = list('grid' = SampledCurve_grid, 'values' = SampledCurve_values, 'gridValue' = SampledCurve_gridValue, 'value' = SampledCurve_value, 'size' = SampledCurve_size, 'empty' = SampledCurve_empty, 'setGrid' = SampledCurve_setGrid, 'setValues' = SampledCurve_setValues, 'swap' = SampledCurve_swap, 'setLogGrid' = SampledCurve_setLogGrid, 'regridLogGrid' = SampledCurve_regridLogGrid, 'shiftGrid' = SampledCurve_shiftGrid, 'scaleGrid' = SampledCurve_scaleGrid, 'regrid' = SampledCurve_regrid);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for SampledCurve
setMethod('delete', '_p_SampledCurve', function(obj) {delete_SampledCurve(obj)})
# Start of Settings_instance

`Settings_instance` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_Settings_instance', as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Settings";
  
  ans
  
}

attr(`Settings_instance`, 'returnType') = '_p_Settings'
class(`Settings_instance`) = c("SWIGFunction", class('Settings_instance'))

# Start of Settings_getEvaluationDate

`Settings_getEvaluationDate` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_Settings_getEvaluationDate', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Date";
  
  ans
  
}

attr(`Settings_getEvaluationDate`, 'returnType') = '_p_Date'
attr(`Settings_getEvaluationDate`, "inputTypes") = c('_p_Settings')
class(`Settings_getEvaluationDate`) = c("SWIGFunction", class('Settings_getEvaluationDate'))

# Start of Settings_setEvaluationDate

`Settings_setEvaluationDate` = function(self, d)
{
  ;.Call('R_swig_Settings_setEvaluationDate', self, d, PACKAGE='QuantLib');
  
}

attr(`Settings_setEvaluationDate`, 'returnType') = 'void'
attr(`Settings_setEvaluationDate`, "inputTypes") = c('_p_Settings', '_p_Date')
class(`Settings_setEvaluationDate`) = c("SWIGFunction", class('Settings_setEvaluationDate'))

# Start of Settings_includeReferenceDateCashFlows

`Settings_includeReferenceDateCashFlows` = function(self, b)
{
  b = as.logical(b);
  ;.Call('R_swig_Settings_includeReferenceDateCashFlows', self, b, PACKAGE='QuantLib');
  
}

attr(`Settings_includeReferenceDateCashFlows`, 'returnType') = 'void'
attr(`Settings_includeReferenceDateCashFlows`, "inputTypes") = c('_p_Settings', 'logical')
class(`Settings_includeReferenceDateCashFlows`) = c("SWIGFunction", class('Settings_includeReferenceDateCashFlows'))

# Start of Settings_includeTodaysCashFlows

`Settings_includeTodaysCashFlows` = function(self, b)
{
  b = as.logical(b);
  ;.Call('R_swig_Settings_includeTodaysCashFlows', self, b, PACKAGE='QuantLib');
  
}

attr(`Settings_includeTodaysCashFlows`, 'returnType') = 'void'
attr(`Settings_includeTodaysCashFlows`, "inputTypes") = c('_p_Settings', 'logical')
class(`Settings_includeTodaysCashFlows`) = c("SWIGFunction", class('Settings_includeTodaysCashFlows'))

# Start of delete_Settings

`delete_Settings` = function(self)
{
  ;.Call('R_swig_delete_Settings', self, PACKAGE='QuantLib');
  
}

attr(`delete_Settings`, 'returnType') = 'void'
attr(`delete_Settings`, "inputTypes") = c('_p_Settings')
class(`delete_Settings`) = c("SWIGFunction", class('delete_Settings'))

# Start of accessor method for Settings
setMethod('$', '_p_Settings', function(x, name)

{
  accessorFuns = list('getEvaluationDate' = Settings_getEvaluationDate, 'setEvaluationDate' = Settings_setEvaluationDate, 'includeReferenceDateCashFlows' = Settings_includeReferenceDateCashFlows, 'includeTodaysCashFlows' = Settings_includeTodaysCashFlows);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for Settings
setMethod('delete', '_p_Settings', function(obj) {delete_Settings(obj)})
# Start of CalibrationHelper___deref__

`CalibrationHelper___deref__` = function(self)
{
  ;ans = .Call('R_swig_CalibrationHelper___deref__', self, PACKAGE='QuantLib');
  class(ans) <- "_p_CalibrationHelper";
  
  ans
  
}

attr(`CalibrationHelper___deref__`, 'returnType') = '_p_CalibrationHelper'
attr(`CalibrationHelper___deref__`, "inputTypes") = c('_p_boost__shared_ptrT_CalibrationHelper_t')
class(`CalibrationHelper___deref__`) = c("SWIGFunction", class('CalibrationHelper___deref__'))

# Start of CalibrationHelper_isNull

`CalibrationHelper_isNull` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_CalibrationHelper_isNull', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CalibrationHelper_isNull`, 'returnType') = 'logical'
attr(`CalibrationHelper_isNull`, "inputTypes") = c('_p_boost__shared_ptrT_CalibrationHelper_t')
class(`CalibrationHelper_isNull`) = c("SWIGFunction", class('CalibrationHelper_isNull'))

# Start of new_CalibrationHelper

`CalibrationHelper` = function()
{
  ;ans = .Call('R_swig_new_CalibrationHelper', PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_CalibrationHelper_t";
  
  reg.finalizer(ans, delete_CalibrationHelper)
  ans
  
}

attr(`CalibrationHelper`, 'returnType') = '_p_boost__shared_ptrT_CalibrationHelper_t'
class(`CalibrationHelper`) = c("SWIGFunction", class('CalibrationHelper'))

# Start of delete_CalibrationHelper

`delete_CalibrationHelper` = function(self)
{
  ;.Call('R_swig_delete_CalibrationHelper', self, PACKAGE='QuantLib');
  
}

attr(`delete_CalibrationHelper`, 'returnType') = 'void'
attr(`delete_CalibrationHelper`, "inputTypes") = c('_p_boost__shared_ptrT_CalibrationHelper_t')
class(`delete_CalibrationHelper`) = c("SWIGFunction", class('delete_CalibrationHelper'))

# Start of CalibrationHelper_setPricingEngine

`CalibrationHelper_setPricingEngine` = function(self, engine)
{
  ;.Call('R_swig_CalibrationHelper_setPricingEngine', self, engine, PACKAGE='QuantLib');
  
}

attr(`CalibrationHelper_setPricingEngine`, 'returnType') = 'void'
attr(`CalibrationHelper_setPricingEngine`, "inputTypes") = c('_p_boost__shared_ptrT_CalibrationHelper_t', '_p_boost__shared_ptrT_PricingEngine_t')
class(`CalibrationHelper_setPricingEngine`) = c("SWIGFunction", class('CalibrationHelper_setPricingEngine'))

# Start of CalibrationHelper_marketValue

`CalibrationHelper_marketValue` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_CalibrationHelper_marketValue', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CalibrationHelper_marketValue`, 'returnType') = 'numeric'
attr(`CalibrationHelper_marketValue`, "inputTypes") = c('_p_boost__shared_ptrT_CalibrationHelper_t')
class(`CalibrationHelper_marketValue`) = c("SWIGFunction", class('CalibrationHelper_marketValue'))

# Start of CalibrationHelper_modelValue

`CalibrationHelper_modelValue` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_CalibrationHelper_modelValue', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CalibrationHelper_modelValue`, 'returnType') = 'numeric'
attr(`CalibrationHelper_modelValue`, "inputTypes") = c('_p_boost__shared_ptrT_CalibrationHelper_t')
class(`CalibrationHelper_modelValue`) = c("SWIGFunction", class('CalibrationHelper_modelValue'))

# Start of CalibrationHelper_impliedVolatility

`CalibrationHelper_impliedVolatility` = function(self, targetValue, accuracy, maxEvaluations, minVol, maxVol, .copy = FALSE)
{
  if(length(maxEvaluations) > 1) {
    warning("using only the first element of maxEvaluations");
  };
  
  
  
  ;.Call('R_swig_CalibrationHelper_impliedVolatility', self, targetValue, accuracy, maxEvaluations, minVol, maxVol, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CalibrationHelper_impliedVolatility`, 'returnType') = 'numeric'
attr(`CalibrationHelper_impliedVolatility`, "inputTypes") = c('_p_boost__shared_ptrT_CalibrationHelper_t', 'numeric', 'numeric', 'integer', 'numeric', 'numeric')
class(`CalibrationHelper_impliedVolatility`) = c("SWIGFunction", class('CalibrationHelper_impliedVolatility'))

# Start of CalibrationHelper_blackPrice

`CalibrationHelper_blackPrice` = function(self, volatility, .copy = FALSE)
{
  ;.Call('R_swig_CalibrationHelper_blackPrice', self, volatility, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CalibrationHelper_blackPrice`, 'returnType') = 'numeric'
attr(`CalibrationHelper_blackPrice`, "inputTypes") = c('_p_boost__shared_ptrT_CalibrationHelper_t', 'numeric')
class(`CalibrationHelper_blackPrice`) = c("SWIGFunction", class('CalibrationHelper_blackPrice'))

# Start of accessor method for boost::shared_ptr<(CalibrationHelper)>
setMethod('$', '_p_boost__shared_ptrT_CalibrationHelper_t', function(x, name)

{
  accessorFuns = list('__deref__' = CalibrationHelper___deref__, 'isNull' = CalibrationHelper_isNull, 'setPricingEngine' = CalibrationHelper_setPricingEngine, 'marketValue' = CalibrationHelper_marketValue, 'modelValue' = CalibrationHelper_modelValue, 'impliedVolatility' = CalibrationHelper_impliedVolatility, 'blackPrice' = CalibrationHelper_blackPrice);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for boost::shared_ptr<(CalibrationHelper)>
setMethod('delete', '_p_boost__shared_ptrT_CalibrationHelper_t', function(obj) {delete_boost__shared_ptrT_CalibrationHelper_t(obj)})
# Start of new_SwaptionHelper

`SwaptionHelper__SWIG_0` = function(maturity, length, volatility, index, fixedLegTenor, fixedLegDayCounter, floatingLegDayCounter, termStructure, errorType)
{
  errorType = enumToInteger(errorType, "_CalibrationHelper__CalibrationErrorType"); 
  
  if(length(errorType) > 1) {
    warning("using only the first element of errorType");
  };
  
  ;ans = .Call('R_swig_new_SwaptionHelper__SWIG_0', maturity, length, volatility, index, fixedLegTenor, fixedLegDayCounter, floatingLegDayCounter, termStructure, errorType, PACKAGE='QuantLib');
  class(ans) <- "_p_SwaptionHelperPtr";
  
  reg.finalizer(ans, delete_SwaptionHelper)
  ans
  
}

attr(`SwaptionHelper__SWIG_0`, 'returnType') = '_p_SwaptionHelperPtr'
attr(`SwaptionHelper__SWIG_0`, "inputTypes") = c('_p_Period', '_p_Period', '_p_HandleT_Quote_t', '_p_IborIndexPtr', '_p_Period', '_p_DayCounter', '_p_DayCounter', '_p_HandleT_YieldTermStructure_t', 'character')
class(`SwaptionHelper__SWIG_0`) = c("SWIGFunction", class('SwaptionHelper__SWIG_0'))

# Start of new_SwaptionHelper

`SwaptionHelper__SWIG_1` = function(maturity, length, volatility, index, fixedLegTenor, fixedLegDayCounter, floatingLegDayCounter, termStructure)
{
  ;ans = .Call('R_swig_new_SwaptionHelper__SWIG_1', maturity, length, volatility, index, fixedLegTenor, fixedLegDayCounter, floatingLegDayCounter, termStructure, PACKAGE='QuantLib');
  class(ans) <- "_p_SwaptionHelperPtr";
  
  reg.finalizer(ans, delete_SwaptionHelper)
  ans
  
}

attr(`SwaptionHelper__SWIG_1`, 'returnType') = '_p_SwaptionHelperPtr'
attr(`SwaptionHelper__SWIG_1`, "inputTypes") = c('_p_Period', '_p_Period', '_p_HandleT_Quote_t', '_p_IborIndexPtr', '_p_Period', '_p_DayCounter', '_p_DayCounter', '_p_HandleT_YieldTermStructure_t')
class(`SwaptionHelper__SWIG_1`) = c("SWIGFunction", class('SwaptionHelper__SWIG_1'))

`SwaptionHelper` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 8) {
    if (extends(argtypes[1], '_p_Period') && extends(argtypes[2], '_p_Period') && extends(argtypes[3], '_p_HandleT_Quote_t') && extends(argtypes[4], '_p_IborIndexPtr') && extends(argtypes[5], '_p_Period') && extends(argtypes[6], '_p_DayCounter') && extends(argtypes[7], '_p_DayCounter') && extends(argtypes[8], '_p_HandleT_YieldTermStructure_t')) {
      f <- SwaptionHelper__SWIG_1; 
    }
  } else if (argc == 9) {
    if (extends(argtypes[1], '_p_Period') && extends(argtypes[2], '_p_Period') && extends(argtypes[3], '_p_HandleT_Quote_t') && extends(argtypes[4], '_p_IborIndexPtr') && extends(argtypes[5], '_p_Period') && extends(argtypes[6], '_p_DayCounter') && extends(argtypes[7], '_p_DayCounter') && extends(argtypes[8], '_p_HandleT_YieldTermStructure_t') && is.character(argv[[9]])) {
      f <- SwaptionHelper__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for SwaptionHelper with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of SwaptionHelper_times

`SwaptionHelper_times` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_SwaptionHelper_times', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_double_std__allocatorT_double_t_t";
  
  ans
  
}

attr(`SwaptionHelper_times`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`SwaptionHelper_times`, "inputTypes") = c('_p_SwaptionHelperPtr')
class(`SwaptionHelper_times`) = c("SWIGFunction", class('SwaptionHelper_times'))

# Start of delete_SwaptionHelper

`delete_SwaptionHelper` = function(self)
{
  ;.Call('R_swig_delete_SwaptionHelper', self, PACKAGE='QuantLib');
  
}

attr(`delete_SwaptionHelper`, 'returnType') = 'void'
attr(`delete_SwaptionHelper`, "inputTypes") = c('_p_SwaptionHelperPtr')
class(`delete_SwaptionHelper`) = c("SWIGFunction", class('delete_SwaptionHelper'))

# Start of accessor method for SwaptionHelperPtr
setMethod('$', '_p_SwaptionHelperPtr', function(x, name)

{
  accessorFuns = list('times' = SwaptionHelper_times);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for SwaptionHelperPtr
setMethod('delete', '_p_SwaptionHelperPtr', function(obj) {delete_SwaptionHelperPtr(obj)})
# Start of new_CapHelper

`CapHelper__SWIG_0` = function(length, volatility, index, fixedLegFrequency, fixedLegDayCounter, includeFirstSwaplet, termStructure, errorType)
{
  fixedLegFrequency = enumToInteger(fixedLegFrequency, "_Frequency"); 
  
  if(length(fixedLegFrequency) > 1) {
    warning("using only the first element of fixedLegFrequency");
  };
  
  
  includeFirstSwaplet = as.logical(includeFirstSwaplet);
  
  errorType = enumToInteger(errorType, "_CalibrationHelper__CalibrationErrorType"); 
  
  if(length(errorType) > 1) {
    warning("using only the first element of errorType");
  };
  
  ;ans = .Call('R_swig_new_CapHelper__SWIG_0', length, volatility, index, fixedLegFrequency, fixedLegDayCounter, includeFirstSwaplet, termStructure, errorType, PACKAGE='QuantLib');
  class(ans) <- "_p_CapHelperPtr";
  
  reg.finalizer(ans, delete_CapHelper)
  ans
  
}

attr(`CapHelper__SWIG_0`, 'returnType') = '_p_CapHelperPtr'
attr(`CapHelper__SWIG_0`, "inputTypes") = c('_p_Period', '_p_HandleT_Quote_t', '_p_IborIndexPtr', 'character', '_p_DayCounter', 'logical', '_p_HandleT_YieldTermStructure_t', 'character')
class(`CapHelper__SWIG_0`) = c("SWIGFunction", class('CapHelper__SWIG_0'))

# Start of new_CapHelper

`CapHelper__SWIG_1` = function(length, volatility, index, fixedLegFrequency, fixedLegDayCounter, includeFirstSwaplet, termStructure)
{
  fixedLegFrequency = enumToInteger(fixedLegFrequency, "_Frequency"); 
  
  if(length(fixedLegFrequency) > 1) {
    warning("using only the first element of fixedLegFrequency");
  };
  
  
  includeFirstSwaplet = as.logical(includeFirstSwaplet);
  
  ;ans = .Call('R_swig_new_CapHelper__SWIG_1', length, volatility, index, fixedLegFrequency, fixedLegDayCounter, includeFirstSwaplet, termStructure, PACKAGE='QuantLib');
  class(ans) <- "_p_CapHelperPtr";
  
  reg.finalizer(ans, delete_CapHelper)
  ans
  
}

attr(`CapHelper__SWIG_1`, 'returnType') = '_p_CapHelperPtr'
attr(`CapHelper__SWIG_1`, "inputTypes") = c('_p_Period', '_p_HandleT_Quote_t', '_p_IborIndexPtr', 'character', '_p_DayCounter', 'logical', '_p_HandleT_YieldTermStructure_t')
class(`CapHelper__SWIG_1`) = c("SWIGFunction", class('CapHelper__SWIG_1'))

`CapHelper` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 7) {
    if (extends(argtypes[1], '_p_Period') && extends(argtypes[2], '_p_HandleT_Quote_t') && extends(argtypes[3], '_p_IborIndexPtr') && is.character(argv[[4]]) && extends(argtypes[5], '_p_DayCounter') && extends(argtypes[6], 'logical') && extends(argtypes[7], '_p_HandleT_YieldTermStructure_t')) {
      f <- CapHelper__SWIG_1; 
    }
  } else if (argc == 8) {
    if (extends(argtypes[1], '_p_Period') && extends(argtypes[2], '_p_HandleT_Quote_t') && extends(argtypes[3], '_p_IborIndexPtr') && is.character(argv[[4]]) && extends(argtypes[5], '_p_DayCounter') && extends(argtypes[6], 'logical') && extends(argtypes[7], '_p_HandleT_YieldTermStructure_t') && is.character(argv[[8]])) {
      f <- CapHelper__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for CapHelper with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of CapHelper_times

`CapHelper_times` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_CapHelper_times', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_double_std__allocatorT_double_t_t";
  
  ans
  
}

attr(`CapHelper_times`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`CapHelper_times`, "inputTypes") = c('_p_CapHelperPtr')
class(`CapHelper_times`) = c("SWIGFunction", class('CapHelper_times'))

# Start of delete_CapHelper

`delete_CapHelper` = function(self)
{
  ;.Call('R_swig_delete_CapHelper', self, PACKAGE='QuantLib');
  
}

attr(`delete_CapHelper`, 'returnType') = 'void'
attr(`delete_CapHelper`, "inputTypes") = c('_p_CapHelperPtr')
class(`delete_CapHelper`) = c("SWIGFunction", class('delete_CapHelper'))

# Start of accessor method for CapHelperPtr
setMethod('$', '_p_CapHelperPtr', function(x, name)

{
  accessorFuns = list('times' = CapHelper_times);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for CapHelperPtr
setMethod('delete', '_p_CapHelperPtr', function(obj) {delete_CapHelperPtr(obj)})
# Start of CalibrationHelperVector___nonzero__

`CalibrationHelperVector___nonzero__` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_CalibrationHelperVector___nonzero__', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CalibrationHelperVector___nonzero__`, 'returnType') = 'logical'
attr(`CalibrationHelperVector___nonzero__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CalibrationHelper_t_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t_t')
class(`CalibrationHelperVector___nonzero__`) = c("SWIGFunction", class('CalibrationHelperVector___nonzero__'))

# Start of CalibrationHelperVector___len__

`CalibrationHelperVector___len__` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_CalibrationHelperVector___len__', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`CalibrationHelperVector___len__`, 'returnType') = 'integer'
attr(`CalibrationHelperVector___len__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CalibrationHelper_t_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t_t')
class(`CalibrationHelperVector___len__`) = c("SWIGFunction", class('CalibrationHelperVector___len__'))

# Start of CalibrationHelperVector_pop

`CalibrationHelperVector_pop` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_CalibrationHelperVector_pop', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_CalibrationHelper_t";
  
  ans
  
}

attr(`CalibrationHelperVector_pop`, 'returnType') = '_p_boost__shared_ptrT_CalibrationHelper_t'
attr(`CalibrationHelperVector_pop`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CalibrationHelper_t_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t_t')
class(`CalibrationHelperVector_pop`) = c("SWIGFunction", class('CalibrationHelperVector_pop'))

# Start of CalibrationHelperVector___getslice__

`CalibrationHelperVector___getslice__` = function(self, i, j)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;ans = .Call('R_swig_CalibrationHelperVector___getslice__', self, i, j, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_CalibrationHelper_t_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t_t";
  
  ans
  
}

attr(`CalibrationHelperVector___getslice__`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_CalibrationHelper_t_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t_t'
attr(`CalibrationHelperVector___getslice__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CalibrationHelper_t_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t_t', 'integer', 'integer')
class(`CalibrationHelperVector___getslice__`) = c("SWIGFunction", class('CalibrationHelperVector___getslice__'))

# Start of CalibrationHelperVector___setslice__

`CalibrationHelperVector___setslice__` = function(self, i, j, v)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  
  ;.Call('R_swig_CalibrationHelperVector___setslice__', self, i, j, v, PACKAGE='QuantLib');
  
}

attr(`CalibrationHelperVector___setslice__`, 'returnType') = 'void'
attr(`CalibrationHelperVector___setslice__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CalibrationHelper_t_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t_t', 'integer', 'integer', '_p_std__vectorT_boost__shared_ptrT_CalibrationHelper_t_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t_t')
class(`CalibrationHelperVector___setslice__`) = c("SWIGFunction", class('CalibrationHelperVector___setslice__'))

# Start of CalibrationHelperVector___delslice__

`CalibrationHelperVector___delslice__` = function(self, i, j)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_CalibrationHelperVector___delslice__', self, i, j, PACKAGE='QuantLib');
  
}

attr(`CalibrationHelperVector___delslice__`, 'returnType') = 'void'
attr(`CalibrationHelperVector___delslice__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CalibrationHelper_t_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t_t', 'integer', 'integer')
class(`CalibrationHelperVector___delslice__`) = c("SWIGFunction", class('CalibrationHelperVector___delslice__'))

# Start of CalibrationHelperVector___delitem__

`CalibrationHelperVector___delitem__` = function(self, i)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_CalibrationHelperVector___delitem__', self, i, PACKAGE='QuantLib');
  
}

attr(`CalibrationHelperVector___delitem__`, 'returnType') = 'void'
attr(`CalibrationHelperVector___delitem__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CalibrationHelper_t_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t_t', 'integer')
class(`CalibrationHelperVector___delitem__`) = c("SWIGFunction", class('CalibrationHelperVector___delitem__'))

# Start of CalibrationHelperVector___getitem__

`CalibrationHelperVector___getitem__` = function(self, i, .copy = FALSE)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;ans = .Call('R_swig_CalibrationHelperVector___getitem__', self, i, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_CalibrationHelper_t";
  
  ans
  
}

attr(`CalibrationHelperVector___getitem__`, 'returnType') = '_p_boost__shared_ptrT_CalibrationHelper_t'
attr(`CalibrationHelperVector___getitem__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CalibrationHelper_t_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t_t', 'integer')
class(`CalibrationHelperVector___getitem__`) = c("SWIGFunction", class('CalibrationHelperVector___getitem__'))

# Start of CalibrationHelperVector___setitem__

`CalibrationHelperVector___setitem__` = function(self, i, x)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  ;.Call('R_swig_CalibrationHelperVector___setitem__', self, i, x, PACKAGE='QuantLib');
  
}

attr(`CalibrationHelperVector___setitem__`, 'returnType') = 'void'
attr(`CalibrationHelperVector___setitem__`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CalibrationHelper_t_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t_t', 'integer', '_p_boost__shared_ptrT_CalibrationHelper_t')
class(`CalibrationHelperVector___setitem__`) = c("SWIGFunction", class('CalibrationHelperVector___setitem__'))

# Start of CalibrationHelperVector_append

`CalibrationHelperVector_append` = function(self, x)
{
  ;.Call('R_swig_CalibrationHelperVector_append', self, x, PACKAGE='QuantLib');
  
}

attr(`CalibrationHelperVector_append`, 'returnType') = 'void'
attr(`CalibrationHelperVector_append`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CalibrationHelper_t_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t_t', '_p_boost__shared_ptrT_CalibrationHelper_t')
class(`CalibrationHelperVector_append`) = c("SWIGFunction", class('CalibrationHelperVector_append'))

# Start of new_CalibrationHelperVector

`CalibrationHelperVector__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_CalibrationHelperVector__SWIG_0', PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_CalibrationHelper_t_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t_t";
  
  reg.finalizer(ans, delete_CalibrationHelperVector)
  ans
  
}

attr(`CalibrationHelperVector__SWIG_0`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_CalibrationHelper_t_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t_t'
class(`CalibrationHelperVector__SWIG_0`) = c("SWIGFunction", class('CalibrationHelperVector__SWIG_0'))

# Start of new_CalibrationHelperVector

`CalibrationHelperVector__SWIG_1` = function(s_arg1)
{
  ;ans = .Call('R_swig_new_CalibrationHelperVector__SWIG_1', s_arg1, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_CalibrationHelper_t_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t_t";
  
  reg.finalizer(ans, delete_CalibrationHelperVector)
  ans
  
}

attr(`CalibrationHelperVector__SWIG_1`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_CalibrationHelper_t_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t_t'
attr(`CalibrationHelperVector__SWIG_1`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CalibrationHelper_t_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t_t')
class(`CalibrationHelperVector__SWIG_1`) = c("SWIGFunction", class('CalibrationHelperVector__SWIG_1'))

# Start of CalibrationHelperVector_empty

`CalibrationHelperVector_empty` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_CalibrationHelperVector_empty', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CalibrationHelperVector_empty`, 'returnType') = 'logical'
attr(`CalibrationHelperVector_empty`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CalibrationHelper_t_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t_t')
class(`CalibrationHelperVector_empty`) = c("SWIGFunction", class('CalibrationHelperVector_empty'))

# Start of CalibrationHelperVector_size

`CalibrationHelperVector_size` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_CalibrationHelperVector_size', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`CalibrationHelperVector_size`, 'returnType') = 'integer'
attr(`CalibrationHelperVector_size`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CalibrationHelper_t_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t_t')
class(`CalibrationHelperVector_size`) = c("SWIGFunction", class('CalibrationHelperVector_size'))

# Start of CalibrationHelperVector_clear

`CalibrationHelperVector_clear` = function(self)
{
  ;.Call('R_swig_CalibrationHelperVector_clear', self, PACKAGE='QuantLib');
  
}

attr(`CalibrationHelperVector_clear`, 'returnType') = 'void'
attr(`CalibrationHelperVector_clear`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CalibrationHelper_t_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t_t')
class(`CalibrationHelperVector_clear`) = c("SWIGFunction", class('CalibrationHelperVector_clear'))

# Start of CalibrationHelperVector_swap

`CalibrationHelperVector_swap` = function(self, v)
{
  ;.Call('R_swig_CalibrationHelperVector_swap', self, v, PACKAGE='QuantLib');
  
}

attr(`CalibrationHelperVector_swap`, 'returnType') = 'void'
attr(`CalibrationHelperVector_swap`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CalibrationHelper_t_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t_t', '_p_std__vectorT_boost__shared_ptrT_CalibrationHelper_t_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t_t')
class(`CalibrationHelperVector_swap`) = c("SWIGFunction", class('CalibrationHelperVector_swap'))

# Start of CalibrationHelperVector_get_allocator

`CalibrationHelperVector_get_allocator` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_CalibrationHelperVector_get_allocator', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t";
  
  ans
  
}

attr(`CalibrationHelperVector_get_allocator`, 'returnType') = '_p_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t'
attr(`CalibrationHelperVector_get_allocator`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CalibrationHelper_t_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t_t')
class(`CalibrationHelperVector_get_allocator`) = c("SWIGFunction", class('CalibrationHelperVector_get_allocator'))

# Start of new_CalibrationHelperVector

`CalibrationHelperVector__SWIG_2` = function(size)
{
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_new_CalibrationHelperVector__SWIG_2', size, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_CalibrationHelper_t_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t_t";
  
  reg.finalizer(ans, delete_CalibrationHelperVector)
  ans
  
}

attr(`CalibrationHelperVector__SWIG_2`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_CalibrationHelper_t_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t_t'
attr(`CalibrationHelperVector__SWIG_2`, "inputTypes") = c('integer')
class(`CalibrationHelperVector__SWIG_2`) = c("SWIGFunction", class('CalibrationHelperVector__SWIG_2'))

# Start of CalibrationHelperVector_pop_back

`CalibrationHelperVector_pop_back` = function(self)
{
  ;.Call('R_swig_CalibrationHelperVector_pop_back', self, PACKAGE='QuantLib');
  
}

attr(`CalibrationHelperVector_pop_back`, 'returnType') = 'void'
attr(`CalibrationHelperVector_pop_back`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CalibrationHelper_t_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t_t')
class(`CalibrationHelperVector_pop_back`) = c("SWIGFunction", class('CalibrationHelperVector_pop_back'))

# Start of CalibrationHelperVector_resize

`CalibrationHelperVector_resize__SWIG_0` = function(self, new_size)
{
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_CalibrationHelperVector_resize__SWIG_0', self, new_size, PACKAGE='QuantLib');
  
}

attr(`CalibrationHelperVector_resize__SWIG_0`, 'returnType') = 'void'
attr(`CalibrationHelperVector_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CalibrationHelper_t_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t_t', 'integer')
class(`CalibrationHelperVector_resize__SWIG_0`) = c("SWIGFunction", class('CalibrationHelperVector_resize__SWIG_0'))

# Start of new_CalibrationHelperVector

`CalibrationHelperVector__SWIG_3` = function(size, value)
{
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  
  ;ans = .Call('R_swig_new_CalibrationHelperVector__SWIG_3', size, value, PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_boost__shared_ptrT_CalibrationHelper_t_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t_t";
  
  reg.finalizer(ans, delete_CalibrationHelperVector)
  ans
  
}

attr(`CalibrationHelperVector__SWIG_3`, 'returnType') = '_p_std__vectorT_boost__shared_ptrT_CalibrationHelper_t_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t_t'
attr(`CalibrationHelperVector__SWIG_3`, "inputTypes") = c('integer', '_p_boost__shared_ptrT_CalibrationHelper_t')
class(`CalibrationHelperVector__SWIG_3`) = c("SWIGFunction", class('CalibrationHelperVector__SWIG_3'))

`CalibrationHelperVector` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- CalibrationHelperVector__SWIG_0; 
  } else if (argc == 1) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]]))) {
      f <- CalibrationHelperVector__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_CalibrationHelper_t_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t_t')) {
      f <- CalibrationHelperVector__SWIG_1; 
    }
  } else if (argc == 2) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && extends(argtypes[2], '_p_boost__shared_ptrT_CalibrationHelper_t')) {
      f <- CalibrationHelperVector__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for CalibrationHelperVector with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of CalibrationHelperVector_push_back

`CalibrationHelperVector_push_back` = function(self, x)
{
  ;.Call('R_swig_CalibrationHelperVector_push_back', self, x, PACKAGE='QuantLib');
  
}

attr(`CalibrationHelperVector_push_back`, 'returnType') = 'void'
attr(`CalibrationHelperVector_push_back`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CalibrationHelper_t_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t_t', '_p_boost__shared_ptrT_CalibrationHelper_t')
class(`CalibrationHelperVector_push_back`) = c("SWIGFunction", class('CalibrationHelperVector_push_back'))

# Start of CalibrationHelperVector_front

`CalibrationHelperVector_front` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_CalibrationHelperVector_front', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_CalibrationHelper_t";
  
  ans
  
}

attr(`CalibrationHelperVector_front`, 'returnType') = '_p_boost__shared_ptrT_CalibrationHelper_t'
attr(`CalibrationHelperVector_front`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CalibrationHelper_t_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t_t')
class(`CalibrationHelperVector_front`) = c("SWIGFunction", class('CalibrationHelperVector_front'))

# Start of CalibrationHelperVector_back

`CalibrationHelperVector_back` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_CalibrationHelperVector_back', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_CalibrationHelper_t";
  
  ans
  
}

attr(`CalibrationHelperVector_back`, 'returnType') = '_p_boost__shared_ptrT_CalibrationHelper_t'
attr(`CalibrationHelperVector_back`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CalibrationHelper_t_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t_t')
class(`CalibrationHelperVector_back`) = c("SWIGFunction", class('CalibrationHelperVector_back'))

# Start of CalibrationHelperVector_assign

`CalibrationHelperVector_assign` = function(self, n, x)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  
  ;.Call('R_swig_CalibrationHelperVector_assign', self, n, x, PACKAGE='QuantLib');
  
}

attr(`CalibrationHelperVector_assign`, 'returnType') = 'void'
attr(`CalibrationHelperVector_assign`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CalibrationHelper_t_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t_t', 'integer', '_p_boost__shared_ptrT_CalibrationHelper_t')
class(`CalibrationHelperVector_assign`) = c("SWIGFunction", class('CalibrationHelperVector_assign'))

# Start of CalibrationHelperVector_resize

`CalibrationHelperVector_resize__SWIG_1` = function(self, new_size, x)
{
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  
  ;.Call('R_swig_CalibrationHelperVector_resize__SWIG_1', self, new_size, x, PACKAGE='QuantLib');
  
}

attr(`CalibrationHelperVector_resize__SWIG_1`, 'returnType') = 'void'
attr(`CalibrationHelperVector_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CalibrationHelper_t_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t_t', 'integer', '_p_boost__shared_ptrT_CalibrationHelper_t')
class(`CalibrationHelperVector_resize__SWIG_1`) = c("SWIGFunction", class('CalibrationHelperVector_resize__SWIG_1'))

`CalibrationHelperVector_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_CalibrationHelper_t_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]]))) {
      f <- CalibrationHelperVector_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_std__vectorT_boost__shared_ptrT_CalibrationHelper_t_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && extends(argtypes[3], '_p_boost__shared_ptrT_CalibrationHelper_t')) {
      f <- CalibrationHelperVector_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for CalibrationHelperVector_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of CalibrationHelperVector_reserve

`CalibrationHelperVector_reserve` = function(self, n)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_CalibrationHelperVector_reserve', self, n, PACKAGE='QuantLib');
  
}

attr(`CalibrationHelperVector_reserve`, 'returnType') = 'void'
attr(`CalibrationHelperVector_reserve`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CalibrationHelper_t_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t_t', 'integer')
class(`CalibrationHelperVector_reserve`) = c("SWIGFunction", class('CalibrationHelperVector_reserve'))

# Start of CalibrationHelperVector_capacity

`CalibrationHelperVector_capacity` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_CalibrationHelperVector_capacity', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`CalibrationHelperVector_capacity`, 'returnType') = 'integer'
attr(`CalibrationHelperVector_capacity`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CalibrationHelper_t_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t_t')
class(`CalibrationHelperVector_capacity`) = c("SWIGFunction", class('CalibrationHelperVector_capacity'))

# Start of delete_CalibrationHelperVector

`delete_CalibrationHelperVector` = function(self)
{
  ;.Call('R_swig_delete_CalibrationHelperVector', self, PACKAGE='QuantLib');
  
}

attr(`delete_CalibrationHelperVector`, 'returnType') = 'void'
attr(`delete_CalibrationHelperVector`, "inputTypes") = c('_p_std__vectorT_boost__shared_ptrT_CalibrationHelper_t_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t_t')
class(`delete_CalibrationHelperVector`) = c("SWIGFunction", class('delete_CalibrationHelperVector'))

# Start of accessor method for std::vector<(boost::shared_ptr<(CalibrationHelper)>)>
setMethod('$', '_p_std__vectorT_boost__shared_ptrT_CalibrationHelper_t_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = CalibrationHelperVector___nonzero__, '__len__' = CalibrationHelperVector___len__, 'pop' = CalibrationHelperVector_pop, '__getslice__' = CalibrationHelperVector___getslice__, '__setslice__' = CalibrationHelperVector___setslice__, '__delslice__' = CalibrationHelperVector___delslice__, '__delitem__' = CalibrationHelperVector___delitem__, '__getitem__' = CalibrationHelperVector___getitem__, '__setitem__' = CalibrationHelperVector___setitem__, 'append' = CalibrationHelperVector_append, 'empty' = CalibrationHelperVector_empty, 'size' = CalibrationHelperVector_size, 'clear' = CalibrationHelperVector_clear, 'swap' = CalibrationHelperVector_swap, 'get_allocator' = CalibrationHelperVector_get_allocator, 'pop_back' = CalibrationHelperVector_pop_back, 'resize' = CalibrationHelperVector_resize, 'push_back' = CalibrationHelperVector_push_back, 'front' = CalibrationHelperVector_front, 'back' = CalibrationHelperVector_back, 'assign' = CalibrationHelperVector_assign, 'reserve' = CalibrationHelperVector_reserve, 'capacity' = CalibrationHelperVector_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for std::vector<(boost::shared_ptr<(CalibrationHelper)>)>
setMethod('delete', '_p_std__vectorT_boost__shared_ptrT_CalibrationHelper_t_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t_t', function(obj) {delete_std__vectorT_boost__shared_ptrT_CalibrationHelper_t_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t_t(obj)})
# Start of ShortRateModel___deref__

`ShortRateModel___deref__` = function(self)
{
  ;ans = .Call('R_swig_ShortRateModel___deref__', self, PACKAGE='QuantLib');
  class(ans) <- "_p_ShortRateModel";
  
  ans
  
}

attr(`ShortRateModel___deref__`, 'returnType') = '_p_ShortRateModel'
attr(`ShortRateModel___deref__`, "inputTypes") = c('_p_boost__shared_ptrT_ShortRateModel_t')
class(`ShortRateModel___deref__`) = c("SWIGFunction", class('ShortRateModel___deref__'))

# Start of ShortRateModel_isNull

`ShortRateModel_isNull` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_ShortRateModel_isNull', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`ShortRateModel_isNull`, 'returnType') = 'logical'
attr(`ShortRateModel_isNull`, "inputTypes") = c('_p_boost__shared_ptrT_ShortRateModel_t')
class(`ShortRateModel_isNull`) = c("SWIGFunction", class('ShortRateModel_isNull'))

# Start of ShortRateModel_asObservable

`ShortRateModel_asObservable` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_ShortRateModel_asObservable', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_Observable_t";
  
  ans
  
}

attr(`ShortRateModel_asObservable`, 'returnType') = '_p_boost__shared_ptrT_Observable_t'
attr(`ShortRateModel_asObservable`, "inputTypes") = c('_p_boost__shared_ptrT_ShortRateModel_t')
class(`ShortRateModel_asObservable`) = c("SWIGFunction", class('ShortRateModel_asObservable'))

# Start of new_ShortRateModel

`ShortRateModel` = function()
{
  ;ans = .Call('R_swig_new_ShortRateModel', PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_ShortRateModel_t";
  
  reg.finalizer(ans, delete_ShortRateModel)
  ans
  
}

attr(`ShortRateModel`, 'returnType') = '_p_boost__shared_ptrT_ShortRateModel_t'
class(`ShortRateModel`) = c("SWIGFunction", class('ShortRateModel'))

# Start of delete_ShortRateModel

`delete_ShortRateModel` = function(self)
{
  ;.Call('R_swig_delete_ShortRateModel', self, PACKAGE='QuantLib');
  
}

attr(`delete_ShortRateModel`, 'returnType') = 'void'
attr(`delete_ShortRateModel`, "inputTypes") = c('_p_boost__shared_ptrT_ShortRateModel_t')
class(`delete_ShortRateModel`) = c("SWIGFunction", class('delete_ShortRateModel'))

# Start of ShortRateModel_params

`ShortRateModel_params` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_ShortRateModel_params', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Array";
  
  ans
  
}

attr(`ShortRateModel_params`, 'returnType') = '_p_Array'
attr(`ShortRateModel_params`, "inputTypes") = c('_p_boost__shared_ptrT_ShortRateModel_t')
class(`ShortRateModel_params`) = c("SWIGFunction", class('ShortRateModel_params'))

# Start of ShortRateModel_calibrate

`ShortRateModel_calibrate__SWIG_0` = function(self, s_arg2, s_arg3, s_arg4, constraint, weights)
{
  ;.Call('R_swig_ShortRateModel_calibrate__SWIG_0', self, s_arg2, s_arg3, s_arg4, constraint, weights, PACKAGE='QuantLib');
  
}

attr(`ShortRateModel_calibrate__SWIG_0`, 'returnType') = 'void'
attr(`ShortRateModel_calibrate__SWIG_0`, "inputTypes") = c('_p_boost__shared_ptrT_ShortRateModel_t', '_p_std__vectorT_boost__shared_ptrT_CalibrationHelper_t_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t_t', '_p_OptimizationMethod', '_p_EndCriteria', '_p_Constraint', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`ShortRateModel_calibrate__SWIG_0`) = c("SWIGFunction", class('ShortRateModel_calibrate__SWIG_0'))

# Start of ShortRateModel_calibrate

`ShortRateModel_calibrate__SWIG_1` = function(self, s_arg2, s_arg3, s_arg4, constraint)
{
  ;.Call('R_swig_ShortRateModel_calibrate__SWIG_1', self, s_arg2, s_arg3, s_arg4, constraint, PACKAGE='QuantLib');
  
}

attr(`ShortRateModel_calibrate__SWIG_1`, 'returnType') = 'void'
attr(`ShortRateModel_calibrate__SWIG_1`, "inputTypes") = c('_p_boost__shared_ptrT_ShortRateModel_t', '_p_std__vectorT_boost__shared_ptrT_CalibrationHelper_t_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t_t', '_p_OptimizationMethod', '_p_EndCriteria', '_p_Constraint')
class(`ShortRateModel_calibrate__SWIG_1`) = c("SWIGFunction", class('ShortRateModel_calibrate__SWIG_1'))

# Start of ShortRateModel_calibrate

`ShortRateModel_calibrate__SWIG_2` = function(self, s_arg2, s_arg3, s_arg4)
{
  ;.Call('R_swig_ShortRateModel_calibrate__SWIG_2', self, s_arg2, s_arg3, s_arg4, PACKAGE='QuantLib');
  
}

attr(`ShortRateModel_calibrate__SWIG_2`, 'returnType') = 'void'
attr(`ShortRateModel_calibrate__SWIG_2`, "inputTypes") = c('_p_boost__shared_ptrT_ShortRateModel_t', '_p_std__vectorT_boost__shared_ptrT_CalibrationHelper_t_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t_t', '_p_OptimizationMethod', '_p_EndCriteria')
class(`ShortRateModel_calibrate__SWIG_2`) = c("SWIGFunction", class('ShortRateModel_calibrate__SWIG_2'))

`ShortRateModel_calibrate` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 4) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_ShortRateModel_t') && extends(argtypes[2], '_p_std__vectorT_boost__shared_ptrT_CalibrationHelper_t_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t_t') && extends(argtypes[3], '_p_OptimizationMethod') && extends(argtypes[4], '_p_EndCriteria')) {
      f <- ShortRateModel_calibrate__SWIG_2; 
    }
  } else if (argc == 5) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_ShortRateModel_t') && extends(argtypes[2], '_p_std__vectorT_boost__shared_ptrT_CalibrationHelper_t_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t_t') && extends(argtypes[3], '_p_OptimizationMethod') && extends(argtypes[4], '_p_EndCriteria') && extends(argtypes[5], '_p_Constraint')) {
      f <- ShortRateModel_calibrate__SWIG_1; 
    }
  } else if (argc == 6) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_ShortRateModel_t') && extends(argtypes[2], '_p_std__vectorT_boost__shared_ptrT_CalibrationHelper_t_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t_t') && extends(argtypes[3], '_p_OptimizationMethod') && extends(argtypes[4], '_p_EndCriteria') && extends(argtypes[5], '_p_Constraint') && extends(argtypes[6], '_p_std__vectorT_double_std__allocatorT_double_t_t')) {
      f <- ShortRateModel_calibrate__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for ShortRateModel_calibrate with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of accessor method for boost::shared_ptr<(ShortRateModel)>
setMethod('$', '_p_boost__shared_ptrT_ShortRateModel_t', function(x, name)

{
  accessorFuns = list('__deref__' = ShortRateModel___deref__, 'isNull' = ShortRateModel_isNull, 'asObservable' = ShortRateModel_asObservable, 'params' = ShortRateModel_params, 'calibrate' = ShortRateModel_calibrate);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for boost::shared_ptr<(ShortRateModel)>
setMethod('delete', '_p_boost__shared_ptrT_ShortRateModel_t', function(obj) {delete_boost__shared_ptrT_ShortRateModel_t(obj)})
# Start of new_ShortRateModelHandle

`ShortRateModelHandle__SWIG_0` = function(s_arg1)
{
  ;ans = .Call('R_swig_new_ShortRateModelHandle__SWIG_0', s_arg1, PACKAGE='QuantLib');
  class(ans) <- "_p_HandleT_ShortRateModel_t";
  
  reg.finalizer(ans, delete_ShortRateModelHandle)
  ans
  
}

attr(`ShortRateModelHandle__SWIG_0`, 'returnType') = '_p_HandleT_ShortRateModel_t'
attr(`ShortRateModelHandle__SWIG_0`, "inputTypes") = c('_p_boost__shared_ptrT_ShortRateModel_t')
class(`ShortRateModelHandle__SWIG_0`) = c("SWIGFunction", class('ShortRateModelHandle__SWIG_0'))

# Start of new_ShortRateModelHandle

`ShortRateModelHandle__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_ShortRateModelHandle__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_HandleT_ShortRateModel_t";
  
  reg.finalizer(ans, delete_ShortRateModelHandle)
  ans
  
}

attr(`ShortRateModelHandle__SWIG_1`, 'returnType') = '_p_HandleT_ShortRateModel_t'
class(`ShortRateModelHandle__SWIG_1`) = c("SWIGFunction", class('ShortRateModelHandle__SWIG_1'))

`ShortRateModelHandle` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- ShortRateModelHandle__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_ShortRateModel_t')) {
      f <- ShortRateModelHandle__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for ShortRateModelHandle with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of ShortRateModelHandle___deref__

`ShortRateModelHandle___deref__` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_ShortRateModelHandle___deref__', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_ShortRateModel_t";
  
  ans
  
}

attr(`ShortRateModelHandle___deref__`, 'returnType') = '_p_boost__shared_ptrT_ShortRateModel_t'
attr(`ShortRateModelHandle___deref__`, "inputTypes") = c('_p_HandleT_ShortRateModel_t')
class(`ShortRateModelHandle___deref__`) = c("SWIGFunction", class('ShortRateModelHandle___deref__'))

# Start of ShortRateModelHandle_empty

`ShortRateModelHandle_empty` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_ShortRateModelHandle_empty', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`ShortRateModelHandle_empty`, 'returnType') = 'logical'
attr(`ShortRateModelHandle_empty`, "inputTypes") = c('_p_HandleT_ShortRateModel_t')
class(`ShortRateModelHandle_empty`) = c("SWIGFunction", class('ShortRateModelHandle_empty'))

# Start of ShortRateModelHandle_asObservable

`ShortRateModelHandle_asObservable` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_ShortRateModelHandle_asObservable', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_Observable_t";
  
  ans
  
}

attr(`ShortRateModelHandle_asObservable`, 'returnType') = '_p_boost__shared_ptrT_Observable_t'
attr(`ShortRateModelHandle_asObservable`, "inputTypes") = c('_p_HandleT_ShortRateModel_t')
class(`ShortRateModelHandle_asObservable`) = c("SWIGFunction", class('ShortRateModelHandle_asObservable'))

# Start of delete_ShortRateModelHandle

`delete_ShortRateModelHandle` = function(self)
{
  ;.Call('R_swig_delete_ShortRateModelHandle', self, PACKAGE='QuantLib');
  
}

attr(`delete_ShortRateModelHandle`, 'returnType') = 'void'
attr(`delete_ShortRateModelHandle`, "inputTypes") = c('_p_HandleT_ShortRateModel_t')
class(`delete_ShortRateModelHandle`) = c("SWIGFunction", class('delete_ShortRateModelHandle'))

# Start of ShortRateModelHandle_params

`ShortRateModelHandle_params` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_ShortRateModelHandle_params', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Array";
  
  ans
  
}

attr(`ShortRateModelHandle_params`, 'returnType') = '_p_Array'
attr(`ShortRateModelHandle_params`, "inputTypes") = c('_p_HandleT_ShortRateModel_t')
class(`ShortRateModelHandle_params`) = c("SWIGFunction", class('ShortRateModelHandle_params'))

# Start of ShortRateModelHandle_calibrate

`ShortRateModelHandle_calibrate__SWIG_0` = function(self, s_arg2, s_arg3, s_arg4, constraint, weights)
{
  ;.Call('R_swig_ShortRateModelHandle_calibrate__SWIG_0', self, s_arg2, s_arg3, s_arg4, constraint, weights, PACKAGE='QuantLib');
  
}

attr(`ShortRateModelHandle_calibrate__SWIG_0`, 'returnType') = 'void'
attr(`ShortRateModelHandle_calibrate__SWIG_0`, "inputTypes") = c('_p_HandleT_ShortRateModel_t', '_p_std__vectorT_boost__shared_ptrT_CalibrationHelper_t_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t_t', '_p_OptimizationMethod', '_p_EndCriteria', '_p_Constraint', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`ShortRateModelHandle_calibrate__SWIG_0`) = c("SWIGFunction", class('ShortRateModelHandle_calibrate__SWIG_0'))

# Start of ShortRateModelHandle_calibrate

`ShortRateModelHandle_calibrate__SWIG_1` = function(self, s_arg2, s_arg3, s_arg4, constraint)
{
  ;.Call('R_swig_ShortRateModelHandle_calibrate__SWIG_1', self, s_arg2, s_arg3, s_arg4, constraint, PACKAGE='QuantLib');
  
}

attr(`ShortRateModelHandle_calibrate__SWIG_1`, 'returnType') = 'void'
attr(`ShortRateModelHandle_calibrate__SWIG_1`, "inputTypes") = c('_p_HandleT_ShortRateModel_t', '_p_std__vectorT_boost__shared_ptrT_CalibrationHelper_t_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t_t', '_p_OptimizationMethod', '_p_EndCriteria', '_p_Constraint')
class(`ShortRateModelHandle_calibrate__SWIG_1`) = c("SWIGFunction", class('ShortRateModelHandle_calibrate__SWIG_1'))

# Start of ShortRateModelHandle_calibrate

`ShortRateModelHandle_calibrate__SWIG_2` = function(self, s_arg2, s_arg3, s_arg4)
{
  ;.Call('R_swig_ShortRateModelHandle_calibrate__SWIG_2', self, s_arg2, s_arg3, s_arg4, PACKAGE='QuantLib');
  
}

attr(`ShortRateModelHandle_calibrate__SWIG_2`, 'returnType') = 'void'
attr(`ShortRateModelHandle_calibrate__SWIG_2`, "inputTypes") = c('_p_HandleT_ShortRateModel_t', '_p_std__vectorT_boost__shared_ptrT_CalibrationHelper_t_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t_t', '_p_OptimizationMethod', '_p_EndCriteria')
class(`ShortRateModelHandle_calibrate__SWIG_2`) = c("SWIGFunction", class('ShortRateModelHandle_calibrate__SWIG_2'))

`ShortRateModelHandle_calibrate` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 4) {
    if (extends(argtypes[1], '_p_HandleT_ShortRateModel_t') && extends(argtypes[2], '_p_std__vectorT_boost__shared_ptrT_CalibrationHelper_t_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t_t') && extends(argtypes[3], '_p_OptimizationMethod') && extends(argtypes[4], '_p_EndCriteria')) {
      f <- ShortRateModelHandle_calibrate__SWIG_2; 
    }
  } else if (argc == 5) {
    if (extends(argtypes[1], '_p_HandleT_ShortRateModel_t') && extends(argtypes[2], '_p_std__vectorT_boost__shared_ptrT_CalibrationHelper_t_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t_t') && extends(argtypes[3], '_p_OptimizationMethod') && extends(argtypes[4], '_p_EndCriteria') && extends(argtypes[5], '_p_Constraint')) {
      f <- ShortRateModelHandle_calibrate__SWIG_1; 
    }
  } else if (argc == 6) {
    if (extends(argtypes[1], '_p_HandleT_ShortRateModel_t') && extends(argtypes[2], '_p_std__vectorT_boost__shared_ptrT_CalibrationHelper_t_std__allocatorT_boost__shared_ptrT_CalibrationHelper_t_t_t') && extends(argtypes[3], '_p_OptimizationMethod') && extends(argtypes[4], '_p_EndCriteria') && extends(argtypes[5], '_p_Constraint') && extends(argtypes[6], '_p_std__vectorT_double_std__allocatorT_double_t_t')) {
      f <- ShortRateModelHandle_calibrate__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for ShortRateModelHandle_calibrate with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of accessor method for Handle<(ShortRateModel)>
setMethod('$', '_p_HandleT_ShortRateModel_t', function(x, name)

{
  accessorFuns = list('__deref__' = ShortRateModelHandle___deref__, 'empty' = ShortRateModelHandle_empty, 'asObservable' = ShortRateModelHandle_asObservable, 'params' = ShortRateModelHandle_params, 'calibrate' = ShortRateModelHandle_calibrate);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for Handle<(ShortRateModel)>
setMethod('delete', '_p_HandleT_ShortRateModel_t', function(obj) {delete_HandleT_ShortRateModel_t(obj)})
# Start of new_RelinkableShortRateModelHandle

`RelinkableShortRateModelHandle__SWIG_0` = function(s_arg1)
{
  ;ans = .Call('R_swig_new_RelinkableShortRateModelHandle__SWIG_0', s_arg1, PACKAGE='QuantLib');
  class(ans) <- "_p_RelinkableHandleT_ShortRateModel_t";
  
  reg.finalizer(ans, delete_RelinkableShortRateModelHandle)
  ans
  
}

attr(`RelinkableShortRateModelHandle__SWIG_0`, 'returnType') = '_p_RelinkableHandleT_ShortRateModel_t'
attr(`RelinkableShortRateModelHandle__SWIG_0`, "inputTypes") = c('_p_boost__shared_ptrT_ShortRateModel_t')
class(`RelinkableShortRateModelHandle__SWIG_0`) = c("SWIGFunction", class('RelinkableShortRateModelHandle__SWIG_0'))

# Start of new_RelinkableShortRateModelHandle

`RelinkableShortRateModelHandle__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_RelinkableShortRateModelHandle__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_RelinkableHandleT_ShortRateModel_t";
  
  reg.finalizer(ans, delete_RelinkableShortRateModelHandle)
  ans
  
}

attr(`RelinkableShortRateModelHandle__SWIG_1`, 'returnType') = '_p_RelinkableHandleT_ShortRateModel_t'
class(`RelinkableShortRateModelHandle__SWIG_1`) = c("SWIGFunction", class('RelinkableShortRateModelHandle__SWIG_1'))

`RelinkableShortRateModelHandle` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- RelinkableShortRateModelHandle__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_ShortRateModel_t')) {
      f <- RelinkableShortRateModelHandle__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for RelinkableShortRateModelHandle with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of RelinkableShortRateModelHandle_linkTo

`RelinkableShortRateModelHandle_linkTo` = function(self, s_arg2)
{
  ;.Call('R_swig_RelinkableShortRateModelHandle_linkTo', self, s_arg2, PACKAGE='QuantLib');
  
}

attr(`RelinkableShortRateModelHandle_linkTo`, 'returnType') = 'void'
attr(`RelinkableShortRateModelHandle_linkTo`, "inputTypes") = c('_p_RelinkableHandleT_ShortRateModel_t', '_p_boost__shared_ptrT_ShortRateModel_t')
class(`RelinkableShortRateModelHandle_linkTo`) = c("SWIGFunction", class('RelinkableShortRateModelHandle_linkTo'))

# Start of delete_RelinkableShortRateModelHandle

`delete_RelinkableShortRateModelHandle` = function(self)
{
  ;.Call('R_swig_delete_RelinkableShortRateModelHandle', self, PACKAGE='QuantLib');
  
}

attr(`delete_RelinkableShortRateModelHandle`, 'returnType') = 'void'
attr(`delete_RelinkableShortRateModelHandle`, "inputTypes") = c('_p_RelinkableHandleT_ShortRateModel_t')
class(`delete_RelinkableShortRateModelHandle`) = c("SWIGFunction", class('delete_RelinkableShortRateModelHandle'))

# Start of accessor method for RelinkableHandle<(ShortRateModel)>
setMethod('$', '_p_RelinkableHandleT_ShortRateModel_t', function(x, name)

{
  accessorFuns = list('linkTo' = RelinkableShortRateModelHandle_linkTo);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for RelinkableHandle<(ShortRateModel)>
setMethod('delete', '_p_RelinkableHandleT_ShortRateModel_t', function(obj) {delete_RelinkableHandleT_ShortRateModel_t(obj)})
# Start of new_Vasicek

`Vasicek__SWIG_0` = function(r0, a, b, sigma, lambda)
{
  ;ans = .Call('R_swig_new_Vasicek__SWIG_0', r0, a, b, sigma, lambda, PACKAGE='QuantLib');
  class(ans) <- "_p_VasicekPtr";
  
  reg.finalizer(ans, delete_Vasicek)
  ans
  
}

attr(`Vasicek__SWIG_0`, 'returnType') = '_p_VasicekPtr'
attr(`Vasicek__SWIG_0`, "inputTypes") = c('numeric', 'numeric', 'numeric', 'numeric', 'numeric')
class(`Vasicek__SWIG_0`) = c("SWIGFunction", class('Vasicek__SWIG_0'))

# Start of new_Vasicek

`Vasicek__SWIG_1` = function(r0, a, b, sigma)
{
  ;ans = .Call('R_swig_new_Vasicek__SWIG_1', r0, a, b, sigma, PACKAGE='QuantLib');
  class(ans) <- "_p_VasicekPtr";
  
  reg.finalizer(ans, delete_Vasicek)
  ans
  
}

attr(`Vasicek__SWIG_1`, 'returnType') = '_p_VasicekPtr'
attr(`Vasicek__SWIG_1`, "inputTypes") = c('numeric', 'numeric', 'numeric', 'numeric')
class(`Vasicek__SWIG_1`) = c("SWIGFunction", class('Vasicek__SWIG_1'))

# Start of new_Vasicek

`Vasicek__SWIG_2` = function(r0, a, b)
{
  ;ans = .Call('R_swig_new_Vasicek__SWIG_2', r0, a, b, PACKAGE='QuantLib');
  class(ans) <- "_p_VasicekPtr";
  
  reg.finalizer(ans, delete_Vasicek)
  ans
  
}

attr(`Vasicek__SWIG_2`, 'returnType') = '_p_VasicekPtr'
attr(`Vasicek__SWIG_2`, "inputTypes") = c('numeric', 'numeric', 'numeric')
class(`Vasicek__SWIG_2`) = c("SWIGFunction", class('Vasicek__SWIG_2'))

# Start of new_Vasicek

`Vasicek__SWIG_3` = function(r0, a)
{
  ;ans = .Call('R_swig_new_Vasicek__SWIG_3', r0, a, PACKAGE='QuantLib');
  class(ans) <- "_p_VasicekPtr";
  
  reg.finalizer(ans, delete_Vasicek)
  ans
  
}

attr(`Vasicek__SWIG_3`, 'returnType') = '_p_VasicekPtr'
attr(`Vasicek__SWIG_3`, "inputTypes") = c('numeric', 'numeric')
class(`Vasicek__SWIG_3`) = c("SWIGFunction", class('Vasicek__SWIG_3'))

# Start of new_Vasicek

`Vasicek__SWIG_4` = function(r0)
{
  ;ans = .Call('R_swig_new_Vasicek__SWIG_4', r0, PACKAGE='QuantLib');
  class(ans) <- "_p_VasicekPtr";
  
  reg.finalizer(ans, delete_Vasicek)
  ans
  
}

attr(`Vasicek__SWIG_4`, 'returnType') = '_p_VasicekPtr'
attr(`Vasicek__SWIG_4`, "inputTypes") = c('numeric')
class(`Vasicek__SWIG_4`) = c("SWIGFunction", class('Vasicek__SWIG_4'))

# Start of new_Vasicek

`Vasicek__SWIG_5` = function()
{
  ;ans = .Call('R_swig_new_Vasicek__SWIG_5', PACKAGE='QuantLib');
  class(ans) <- "_p_VasicekPtr";
  
  reg.finalizer(ans, delete_Vasicek)
  ans
  
}

attr(`Vasicek__SWIG_5`, 'returnType') = '_p_VasicekPtr'
class(`Vasicek__SWIG_5`) = c("SWIGFunction", class('Vasicek__SWIG_5'))

`Vasicek` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 6
  if (argc == 0) {
    f <- Vasicek__SWIG_5; 
  } else if (argc == 1) {
    if (is.numeric(argv[[1]])) {
      f <- Vasicek__SWIG_4; 
    }
  } else if (argc == 2) {
    if (is.numeric(argv[[1]]) && is.numeric(argv[[2]])) {
      f <- Vasicek__SWIG_3; 
    }
  } else if (argc == 3) {
    if (is.numeric(argv[[1]]) && is.numeric(argv[[2]]) && is.numeric(argv[[3]])) {
      f <- Vasicek__SWIG_2; 
    }
  } else if (argc == 4) {
    if (is.numeric(argv[[1]]) && is.numeric(argv[[2]]) && is.numeric(argv[[3]]) && is.numeric(argv[[4]])) {
      f <- Vasicek__SWIG_1; 
    }
  } else if (argc == 5) {
    if (is.numeric(argv[[1]]) && is.numeric(argv[[2]]) && is.numeric(argv[[3]]) && is.numeric(argv[[4]]) && is.numeric(argv[[5]])) {
      f <- Vasicek__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Vasicek with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of Vasicek_discount

`Vasicek_discount` = function(self, t, .copy = FALSE)
{
  ;.Call('R_swig_Vasicek_discount', self, t, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Vasicek_discount`, 'returnType') = 'numeric'
attr(`Vasicek_discount`, "inputTypes") = c('_p_VasicekPtr', 'numeric')
class(`Vasicek_discount`) = c("SWIGFunction", class('Vasicek_discount'))

# Start of delete_Vasicek

`delete_Vasicek` = function(self)
{
  ;.Call('R_swig_delete_Vasicek', self, PACKAGE='QuantLib');
  
}

attr(`delete_Vasicek`, 'returnType') = 'void'
attr(`delete_Vasicek`, "inputTypes") = c('_p_VasicekPtr')
class(`delete_Vasicek`) = c("SWIGFunction", class('delete_Vasicek'))

# Start of accessor method for VasicekPtr
setMethod('$', '_p_VasicekPtr', function(x, name)

{
  accessorFuns = list('discount' = Vasicek_discount);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for VasicekPtr
setMethod('delete', '_p_VasicekPtr', function(obj) {delete_VasicekPtr(obj)})
# Start of new_HullWhite

`HullWhite__SWIG_0` = function(termStructure, a, sigma)
{
  ;ans = .Call('R_swig_new_HullWhite__SWIG_0', termStructure, a, sigma, PACKAGE='QuantLib');
  class(ans) <- "_p_HullWhitePtr";
  
  reg.finalizer(ans, delete_HullWhite)
  ans
  
}

attr(`HullWhite__SWIG_0`, 'returnType') = '_p_HullWhitePtr'
attr(`HullWhite__SWIG_0`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t', 'numeric', 'numeric')
class(`HullWhite__SWIG_0`) = c("SWIGFunction", class('HullWhite__SWIG_0'))

# Start of new_HullWhite

`HullWhite__SWIG_1` = function(termStructure, a)
{
  ;ans = .Call('R_swig_new_HullWhite__SWIG_1', termStructure, a, PACKAGE='QuantLib');
  class(ans) <- "_p_HullWhitePtr";
  
  reg.finalizer(ans, delete_HullWhite)
  ans
  
}

attr(`HullWhite__SWIG_1`, 'returnType') = '_p_HullWhitePtr'
attr(`HullWhite__SWIG_1`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t', 'numeric')
class(`HullWhite__SWIG_1`) = c("SWIGFunction", class('HullWhite__SWIG_1'))

# Start of new_HullWhite

`HullWhite__SWIG_2` = function(termStructure)
{
  ;ans = .Call('R_swig_new_HullWhite__SWIG_2', termStructure, PACKAGE='QuantLib');
  class(ans) <- "_p_HullWhitePtr";
  
  reg.finalizer(ans, delete_HullWhite)
  ans
  
}

attr(`HullWhite__SWIG_2`, 'returnType') = '_p_HullWhitePtr'
attr(`HullWhite__SWIG_2`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`HullWhite__SWIG_2`) = c("SWIGFunction", class('HullWhite__SWIG_2'))

`HullWhite` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 1) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t')) {
      f <- HullWhite__SWIG_2; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t') && is.numeric(argv[[2]])) {
      f <- HullWhite__SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t') && is.numeric(argv[[2]]) && is.numeric(argv[[3]])) {
      f <- HullWhite__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for HullWhite with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of HullWhite_discount

`HullWhite_discount` = function(self, t, .copy = FALSE)
{
  ;.Call('R_swig_HullWhite_discount', self, t, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`HullWhite_discount`, 'returnType') = 'numeric'
attr(`HullWhite_discount`, "inputTypes") = c('_p_HullWhitePtr', 'numeric')
class(`HullWhite_discount`) = c("SWIGFunction", class('HullWhite_discount'))

# Start of delete_HullWhite

`delete_HullWhite` = function(self)
{
  ;.Call('R_swig_delete_HullWhite', self, PACKAGE='QuantLib');
  
}

attr(`delete_HullWhite`, 'returnType') = 'void'
attr(`delete_HullWhite`, "inputTypes") = c('_p_HullWhitePtr')
class(`delete_HullWhite`) = c("SWIGFunction", class('delete_HullWhite'))

# Start of accessor method for HullWhitePtr
setMethod('$', '_p_HullWhitePtr', function(x, name)

{
  accessorFuns = list('discount' = HullWhite_discount);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for HullWhitePtr
setMethod('delete', '_p_HullWhitePtr', function(obj) {delete_HullWhitePtr(obj)})
# Start of new_BlackKarasinski

`BlackKarasinski__SWIG_0` = function(termStructure, a, sigma)
{
  ;ans = .Call('R_swig_new_BlackKarasinski__SWIG_0', termStructure, a, sigma, PACKAGE='QuantLib');
  class(ans) <- "_p_BlackKarasinskiPtr";
  
  reg.finalizer(ans, delete_BlackKarasinski)
  ans
  
}

attr(`BlackKarasinski__SWIG_0`, 'returnType') = '_p_BlackKarasinskiPtr'
attr(`BlackKarasinski__SWIG_0`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t', 'numeric', 'numeric')
class(`BlackKarasinski__SWIG_0`) = c("SWIGFunction", class('BlackKarasinski__SWIG_0'))

# Start of new_BlackKarasinski

`BlackKarasinski__SWIG_1` = function(termStructure, a)
{
  ;ans = .Call('R_swig_new_BlackKarasinski__SWIG_1', termStructure, a, PACKAGE='QuantLib');
  class(ans) <- "_p_BlackKarasinskiPtr";
  
  reg.finalizer(ans, delete_BlackKarasinski)
  ans
  
}

attr(`BlackKarasinski__SWIG_1`, 'returnType') = '_p_BlackKarasinskiPtr'
attr(`BlackKarasinski__SWIG_1`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t', 'numeric')
class(`BlackKarasinski__SWIG_1`) = c("SWIGFunction", class('BlackKarasinski__SWIG_1'))

# Start of new_BlackKarasinski

`BlackKarasinski__SWIG_2` = function(termStructure)
{
  ;ans = .Call('R_swig_new_BlackKarasinski__SWIG_2', termStructure, PACKAGE='QuantLib');
  class(ans) <- "_p_BlackKarasinskiPtr";
  
  reg.finalizer(ans, delete_BlackKarasinski)
  ans
  
}

attr(`BlackKarasinski__SWIG_2`, 'returnType') = '_p_BlackKarasinskiPtr'
attr(`BlackKarasinski__SWIG_2`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`BlackKarasinski__SWIG_2`) = c("SWIGFunction", class('BlackKarasinski__SWIG_2'))

`BlackKarasinski` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 1) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t')) {
      f <- BlackKarasinski__SWIG_2; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t') && is.numeric(argv[[2]])) {
      f <- BlackKarasinski__SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t') && is.numeric(argv[[2]]) && is.numeric(argv[[3]])) {
      f <- BlackKarasinski__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for BlackKarasinski with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_BlackKarasinski

`delete_BlackKarasinski` = function(self)
{
  ;.Call('R_swig_delete_BlackKarasinski', self, PACKAGE='QuantLib');
  
}

attr(`delete_BlackKarasinski`, 'returnType') = 'void'
attr(`delete_BlackKarasinski`, "inputTypes") = c('_p_BlackKarasinskiPtr')
class(`delete_BlackKarasinski`) = c("SWIGFunction", class('delete_BlackKarasinski'))

setMethod('delete', '_p_BlackKarasinskiPtr', function(obj) {delete_BlackKarasinskiPtr(obj)})
# Start of new_G2

`G2__SWIG_0` = function(termStructure, a, sigma, b, eta, rho)
{
  ;ans = .Call('R_swig_new_G2__SWIG_0', termStructure, a, sigma, b, eta, rho, PACKAGE='QuantLib');
  class(ans) <- "_p_G2Ptr";
  
  reg.finalizer(ans, delete_G2)
  ans
  
}

attr(`G2__SWIG_0`, 'returnType') = '_p_G2Ptr'
attr(`G2__SWIG_0`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t', 'numeric', 'numeric', 'numeric', 'numeric', 'numeric')
class(`G2__SWIG_0`) = c("SWIGFunction", class('G2__SWIG_0'))

# Start of new_G2

`G2__SWIG_1` = function(termStructure, a, sigma, b, eta)
{
  ;ans = .Call('R_swig_new_G2__SWIG_1', termStructure, a, sigma, b, eta, PACKAGE='QuantLib');
  class(ans) <- "_p_G2Ptr";
  
  reg.finalizer(ans, delete_G2)
  ans
  
}

attr(`G2__SWIG_1`, 'returnType') = '_p_G2Ptr'
attr(`G2__SWIG_1`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t', 'numeric', 'numeric', 'numeric', 'numeric')
class(`G2__SWIG_1`) = c("SWIGFunction", class('G2__SWIG_1'))

# Start of new_G2

`G2__SWIG_2` = function(termStructure, a, sigma, b)
{
  ;ans = .Call('R_swig_new_G2__SWIG_2', termStructure, a, sigma, b, PACKAGE='QuantLib');
  class(ans) <- "_p_G2Ptr";
  
  reg.finalizer(ans, delete_G2)
  ans
  
}

attr(`G2__SWIG_2`, 'returnType') = '_p_G2Ptr'
attr(`G2__SWIG_2`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t', 'numeric', 'numeric', 'numeric')
class(`G2__SWIG_2`) = c("SWIGFunction", class('G2__SWIG_2'))

# Start of new_G2

`G2__SWIG_3` = function(termStructure, a, sigma)
{
  ;ans = .Call('R_swig_new_G2__SWIG_3', termStructure, a, sigma, PACKAGE='QuantLib');
  class(ans) <- "_p_G2Ptr";
  
  reg.finalizer(ans, delete_G2)
  ans
  
}

attr(`G2__SWIG_3`, 'returnType') = '_p_G2Ptr'
attr(`G2__SWIG_3`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t', 'numeric', 'numeric')
class(`G2__SWIG_3`) = c("SWIGFunction", class('G2__SWIG_3'))

# Start of new_G2

`G2__SWIG_4` = function(termStructure, a)
{
  ;ans = .Call('R_swig_new_G2__SWIG_4', termStructure, a, PACKAGE='QuantLib');
  class(ans) <- "_p_G2Ptr";
  
  reg.finalizer(ans, delete_G2)
  ans
  
}

attr(`G2__SWIG_4`, 'returnType') = '_p_G2Ptr'
attr(`G2__SWIG_4`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t', 'numeric')
class(`G2__SWIG_4`) = c("SWIGFunction", class('G2__SWIG_4'))

# Start of new_G2

`G2__SWIG_5` = function(termStructure)
{
  ;ans = .Call('R_swig_new_G2__SWIG_5', termStructure, PACKAGE='QuantLib');
  class(ans) <- "_p_G2Ptr";
  
  reg.finalizer(ans, delete_G2)
  ans
  
}

attr(`G2__SWIG_5`, 'returnType') = '_p_G2Ptr'
attr(`G2__SWIG_5`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t')
class(`G2__SWIG_5`) = c("SWIGFunction", class('G2__SWIG_5'))

`G2` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 6
  if (argc == 1) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t')) {
      f <- G2__SWIG_5; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t') && is.numeric(argv[[2]])) {
      f <- G2__SWIG_4; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t') && is.numeric(argv[[2]]) && is.numeric(argv[[3]])) {
      f <- G2__SWIG_3; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t') && is.numeric(argv[[2]]) && is.numeric(argv[[3]]) && is.numeric(argv[[4]])) {
      f <- G2__SWIG_2; 
    }
  } else if (argc == 5) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t') && is.numeric(argv[[2]]) && is.numeric(argv[[3]]) && is.numeric(argv[[4]]) && is.numeric(argv[[5]])) {
      f <- G2__SWIG_1; 
    }
  } else if (argc == 6) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t') && is.numeric(argv[[2]]) && is.numeric(argv[[3]]) && is.numeric(argv[[4]]) && is.numeric(argv[[5]]) && is.numeric(argv[[6]])) {
      f <- G2__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for G2 with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of G2_discount

`G2_discount` = function(self, t, .copy = FALSE)
{
  ;.Call('R_swig_G2_discount', self, t, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`G2_discount`, 'returnType') = 'numeric'
attr(`G2_discount`, "inputTypes") = c('_p_G2Ptr', 'numeric')
class(`G2_discount`) = c("SWIGFunction", class('G2_discount'))

# Start of delete_G2

`delete_G2` = function(self)
{
  ;.Call('R_swig_delete_G2', self, PACKAGE='QuantLib');
  
}

attr(`delete_G2`, 'returnType') = 'void'
attr(`delete_G2`, "inputTypes") = c('_p_G2Ptr')
class(`delete_G2`) = c("SWIGFunction", class('delete_G2'))

# Start of accessor method for G2Ptr
setMethod('$', '_p_G2Ptr', function(x, name)

{
  accessorFuns = list('discount' = G2_discount);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for G2Ptr
setMethod('delete', '_p_G2Ptr', function(obj) {delete_G2Ptr(obj)})
# Start of new_JamshidianSwaptionEngine

`JamshidianSwaptionEngine__SWIG_0` = function(model, termStructure)
{
  ;ans = .Call('R_swig_new_JamshidianSwaptionEngine__SWIG_0', model, termStructure, PACKAGE='QuantLib');
  class(ans) <- "_p_JamshidianSwaptionEnginePtr";
  
  reg.finalizer(ans, delete_JamshidianSwaptionEngine)
  ans
  
}

attr(`JamshidianSwaptionEngine__SWIG_0`, 'returnType') = '_p_JamshidianSwaptionEnginePtr'
attr(`JamshidianSwaptionEngine__SWIG_0`, "inputTypes") = c('_p_boost__shared_ptrT_ShortRateModel_t', '_p_HandleT_YieldTermStructure_t')
class(`JamshidianSwaptionEngine__SWIG_0`) = c("SWIGFunction", class('JamshidianSwaptionEngine__SWIG_0'))

# Start of new_JamshidianSwaptionEngine

`JamshidianSwaptionEngine__SWIG_1` = function(model)
{
  ;ans = .Call('R_swig_new_JamshidianSwaptionEngine__SWIG_1', model, PACKAGE='QuantLib');
  class(ans) <- "_p_JamshidianSwaptionEnginePtr";
  
  reg.finalizer(ans, delete_JamshidianSwaptionEngine)
  ans
  
}

attr(`JamshidianSwaptionEngine__SWIG_1`, 'returnType') = '_p_JamshidianSwaptionEnginePtr'
attr(`JamshidianSwaptionEngine__SWIG_1`, "inputTypes") = c('_p_boost__shared_ptrT_ShortRateModel_t')
class(`JamshidianSwaptionEngine__SWIG_1`) = c("SWIGFunction", class('JamshidianSwaptionEngine__SWIG_1'))

`JamshidianSwaptionEngine` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_ShortRateModel_t')) {
      f <- JamshidianSwaptionEngine__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_ShortRateModel_t') && extends(argtypes[2], '_p_HandleT_YieldTermStructure_t')) {
      f <- JamshidianSwaptionEngine__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for JamshidianSwaptionEngine with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_JamshidianSwaptionEngine

`delete_JamshidianSwaptionEngine` = function(self)
{
  ;.Call('R_swig_delete_JamshidianSwaptionEngine', self, PACKAGE='QuantLib');
  
}

attr(`delete_JamshidianSwaptionEngine`, 'returnType') = 'void'
attr(`delete_JamshidianSwaptionEngine`, "inputTypes") = c('_p_JamshidianSwaptionEnginePtr')
class(`delete_JamshidianSwaptionEngine`) = c("SWIGFunction", class('delete_JamshidianSwaptionEngine'))

setMethod('delete', '_p_JamshidianSwaptionEnginePtr', function(obj) {delete_JamshidianSwaptionEnginePtr(obj)})
# Start of new_TreeSwaptionEngine

`TreeSwaptionEngine__SWIG_0` = function(model, timeSteps, termStructure)
{
  if(length(timeSteps) > 1) {
    warning("using only the first element of timeSteps");
  };
  
  
  ;ans = .Call('R_swig_new_TreeSwaptionEngine__SWIG_0', model, timeSteps, termStructure, PACKAGE='QuantLib');
  class(ans) <- "_p_TreeSwaptionEnginePtr";
  
  reg.finalizer(ans, delete_TreeSwaptionEngine)
  ans
  
}

attr(`TreeSwaptionEngine__SWIG_0`, 'returnType') = '_p_TreeSwaptionEnginePtr'
attr(`TreeSwaptionEngine__SWIG_0`, "inputTypes") = c('_p_boost__shared_ptrT_ShortRateModel_t', 'integer', '_p_HandleT_YieldTermStructure_t')
class(`TreeSwaptionEngine__SWIG_0`) = c("SWIGFunction", class('TreeSwaptionEngine__SWIG_0'))

# Start of new_TreeSwaptionEngine

`TreeSwaptionEngine__SWIG_1` = function(model, timeSteps)
{
  if(length(timeSteps) > 1) {
    warning("using only the first element of timeSteps");
  };
  
  ;ans = .Call('R_swig_new_TreeSwaptionEngine__SWIG_1', model, timeSteps, PACKAGE='QuantLib');
  class(ans) <- "_p_TreeSwaptionEnginePtr";
  
  reg.finalizer(ans, delete_TreeSwaptionEngine)
  ans
  
}

attr(`TreeSwaptionEngine__SWIG_1`, 'returnType') = '_p_TreeSwaptionEnginePtr'
attr(`TreeSwaptionEngine__SWIG_1`, "inputTypes") = c('_p_boost__shared_ptrT_ShortRateModel_t', 'integer')
class(`TreeSwaptionEngine__SWIG_1`) = c("SWIGFunction", class('TreeSwaptionEngine__SWIG_1'))

# Start of new_TreeSwaptionEngine

`TreeSwaptionEngine__SWIG_2` = function(model, grid, termStructure)
{
  ;ans = .Call('R_swig_new_TreeSwaptionEngine__SWIG_2', model, grid, termStructure, PACKAGE='QuantLib');
  class(ans) <- "_p_TreeSwaptionEnginePtr";
  
  reg.finalizer(ans, delete_TreeSwaptionEngine)
  ans
  
}

attr(`TreeSwaptionEngine__SWIG_2`, 'returnType') = '_p_TreeSwaptionEnginePtr'
attr(`TreeSwaptionEngine__SWIG_2`, "inputTypes") = c('_p_boost__shared_ptrT_ShortRateModel_t', '_p_TimeGrid', '_p_HandleT_YieldTermStructure_t')
class(`TreeSwaptionEngine__SWIG_2`) = c("SWIGFunction", class('TreeSwaptionEngine__SWIG_2'))

# Start of new_TreeSwaptionEngine

`TreeSwaptionEngine__SWIG_3` = function(model, grid)
{
  ;ans = .Call('R_swig_new_TreeSwaptionEngine__SWIG_3', model, grid, PACKAGE='QuantLib');
  class(ans) <- "_p_TreeSwaptionEnginePtr";
  
  reg.finalizer(ans, delete_TreeSwaptionEngine)
  ans
  
}

attr(`TreeSwaptionEngine__SWIG_3`, 'returnType') = '_p_TreeSwaptionEnginePtr'
attr(`TreeSwaptionEngine__SWIG_3`, "inputTypes") = c('_p_boost__shared_ptrT_ShortRateModel_t', '_p_TimeGrid')
class(`TreeSwaptionEngine__SWIG_3`) = c("SWIGFunction", class('TreeSwaptionEngine__SWIG_3'))

# Start of new_TreeSwaptionEngine

`TreeSwaptionEngine__SWIG_4` = function(model, timeSteps, termStructure)
{
  if(length(timeSteps) > 1) {
    warning("using only the first element of timeSteps");
  };
  
  
  ;ans = .Call('R_swig_new_TreeSwaptionEngine__SWIG_4', model, timeSteps, termStructure, PACKAGE='QuantLib');
  class(ans) <- "_p_TreeSwaptionEnginePtr";
  
  reg.finalizer(ans, delete_TreeSwaptionEngine)
  ans
  
}

attr(`TreeSwaptionEngine__SWIG_4`, 'returnType') = '_p_TreeSwaptionEnginePtr'
attr(`TreeSwaptionEngine__SWIG_4`, "inputTypes") = c('_p_HandleT_ShortRateModel_t', 'integer', '_p_HandleT_YieldTermStructure_t')
class(`TreeSwaptionEngine__SWIG_4`) = c("SWIGFunction", class('TreeSwaptionEngine__SWIG_4'))

# Start of new_TreeSwaptionEngine

`TreeSwaptionEngine__SWIG_5` = function(model, timeSteps)
{
  if(length(timeSteps) > 1) {
    warning("using only the first element of timeSteps");
  };
  
  ;ans = .Call('R_swig_new_TreeSwaptionEngine__SWIG_5', model, timeSteps, PACKAGE='QuantLib');
  class(ans) <- "_p_TreeSwaptionEnginePtr";
  
  reg.finalizer(ans, delete_TreeSwaptionEngine)
  ans
  
}

attr(`TreeSwaptionEngine__SWIG_5`, 'returnType') = '_p_TreeSwaptionEnginePtr'
attr(`TreeSwaptionEngine__SWIG_5`, "inputTypes") = c('_p_HandleT_ShortRateModel_t', 'integer')
class(`TreeSwaptionEngine__SWIG_5`) = c("SWIGFunction", class('TreeSwaptionEngine__SWIG_5'))

`TreeSwaptionEngine` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 6
  if (argc == 2) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_ShortRateModel_t') && extends(argtypes[2], '_p_TimeGrid')) {
      f <- TreeSwaptionEngine__SWIG_3; 
    }
    else if (extends(argtypes[1], '_p_boost__shared_ptrT_ShortRateModel_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]]))) {
      f <- TreeSwaptionEngine__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_HandleT_ShortRateModel_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]]))) {
      f <- TreeSwaptionEngine__SWIG_5; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_ShortRateModel_t') && extends(argtypes[2], '_p_TimeGrid') && extends(argtypes[3], '_p_HandleT_YieldTermStructure_t')) {
      f <- TreeSwaptionEngine__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_HandleT_ShortRateModel_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && extends(argtypes[3], '_p_HandleT_YieldTermStructure_t')) {
      f <- TreeSwaptionEngine__SWIG_4; 
    }
    else if (extends(argtypes[1], '_p_boost__shared_ptrT_ShortRateModel_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && extends(argtypes[3], '_p_HandleT_YieldTermStructure_t')) {
      f <- TreeSwaptionEngine__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for TreeSwaptionEngine with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_TreeSwaptionEngine

`delete_TreeSwaptionEngine` = function(self)
{
  ;.Call('R_swig_delete_TreeSwaptionEngine', self, PACKAGE='QuantLib');
  
}

attr(`delete_TreeSwaptionEngine`, 'returnType') = 'void'
attr(`delete_TreeSwaptionEngine`, "inputTypes") = c('_p_TreeSwaptionEnginePtr')
class(`delete_TreeSwaptionEngine`) = c("SWIGFunction", class('delete_TreeSwaptionEngine'))

setMethod('delete', '_p_TreeSwaptionEnginePtr', function(obj) {delete_TreeSwaptionEnginePtr(obj)})
# Start of new_AnalyticCapFloorEngine

`AnalyticCapFloorEngine__SWIG_0` = function(model, termStructure)
{
  ;ans = .Call('R_swig_new_AnalyticCapFloorEngine__SWIG_0', model, termStructure, PACKAGE='QuantLib');
  class(ans) <- "_p_AnalyticCapFloorEnginePtr";
  
  reg.finalizer(ans, delete_AnalyticCapFloorEngine)
  ans
  
}

attr(`AnalyticCapFloorEngine__SWIG_0`, 'returnType') = '_p_AnalyticCapFloorEnginePtr'
attr(`AnalyticCapFloorEngine__SWIG_0`, "inputTypes") = c('_p_boost__shared_ptrT_ShortRateModel_t', '_p_HandleT_YieldTermStructure_t')
class(`AnalyticCapFloorEngine__SWIG_0`) = c("SWIGFunction", class('AnalyticCapFloorEngine__SWIG_0'))

# Start of new_AnalyticCapFloorEngine

`AnalyticCapFloorEngine__SWIG_1` = function(model)
{
  ;ans = .Call('R_swig_new_AnalyticCapFloorEngine__SWIG_1', model, PACKAGE='QuantLib');
  class(ans) <- "_p_AnalyticCapFloorEnginePtr";
  
  reg.finalizer(ans, delete_AnalyticCapFloorEngine)
  ans
  
}

attr(`AnalyticCapFloorEngine__SWIG_1`, 'returnType') = '_p_AnalyticCapFloorEnginePtr'
attr(`AnalyticCapFloorEngine__SWIG_1`, "inputTypes") = c('_p_boost__shared_ptrT_ShortRateModel_t')
class(`AnalyticCapFloorEngine__SWIG_1`) = c("SWIGFunction", class('AnalyticCapFloorEngine__SWIG_1'))

`AnalyticCapFloorEngine` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_ShortRateModel_t')) {
      f <- AnalyticCapFloorEngine__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_ShortRateModel_t') && extends(argtypes[2], '_p_HandleT_YieldTermStructure_t')) {
      f <- AnalyticCapFloorEngine__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for AnalyticCapFloorEngine with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_AnalyticCapFloorEngine

`delete_AnalyticCapFloorEngine` = function(self)
{
  ;.Call('R_swig_delete_AnalyticCapFloorEngine', self, PACKAGE='QuantLib');
  
}

attr(`delete_AnalyticCapFloorEngine`, 'returnType') = 'void'
attr(`delete_AnalyticCapFloorEngine`, "inputTypes") = c('_p_AnalyticCapFloorEnginePtr')
class(`delete_AnalyticCapFloorEngine`) = c("SWIGFunction", class('delete_AnalyticCapFloorEngine'))

setMethod('delete', '_p_AnalyticCapFloorEnginePtr', function(obj) {delete_AnalyticCapFloorEnginePtr(obj)})
# Start of new_TreeCapFloorEngine

`TreeCapFloorEngine__SWIG_0` = function(model, timeSteps, termStructure)
{
  if(length(timeSteps) > 1) {
    warning("using only the first element of timeSteps");
  };
  
  
  ;ans = .Call('R_swig_new_TreeCapFloorEngine__SWIG_0', model, timeSteps, termStructure, PACKAGE='QuantLib');
  class(ans) <- "_p_TreeCapFloorEnginePtr";
  
  reg.finalizer(ans, delete_TreeCapFloorEngine)
  ans
  
}

attr(`TreeCapFloorEngine__SWIG_0`, 'returnType') = '_p_TreeCapFloorEnginePtr'
attr(`TreeCapFloorEngine__SWIG_0`, "inputTypes") = c('_p_boost__shared_ptrT_ShortRateModel_t', 'integer', '_p_HandleT_YieldTermStructure_t')
class(`TreeCapFloorEngine__SWIG_0`) = c("SWIGFunction", class('TreeCapFloorEngine__SWIG_0'))

# Start of new_TreeCapFloorEngine

`TreeCapFloorEngine__SWIG_1` = function(model, timeSteps)
{
  if(length(timeSteps) > 1) {
    warning("using only the first element of timeSteps");
  };
  
  ;ans = .Call('R_swig_new_TreeCapFloorEngine__SWIG_1', model, timeSteps, PACKAGE='QuantLib');
  class(ans) <- "_p_TreeCapFloorEnginePtr";
  
  reg.finalizer(ans, delete_TreeCapFloorEngine)
  ans
  
}

attr(`TreeCapFloorEngine__SWIG_1`, 'returnType') = '_p_TreeCapFloorEnginePtr'
attr(`TreeCapFloorEngine__SWIG_1`, "inputTypes") = c('_p_boost__shared_ptrT_ShortRateModel_t', 'integer')
class(`TreeCapFloorEngine__SWIG_1`) = c("SWIGFunction", class('TreeCapFloorEngine__SWIG_1'))

# Start of new_TreeCapFloorEngine

`TreeCapFloorEngine__SWIG_2` = function(model, grid, termStructure)
{
  ;ans = .Call('R_swig_new_TreeCapFloorEngine__SWIG_2', model, grid, termStructure, PACKAGE='QuantLib');
  class(ans) <- "_p_TreeCapFloorEnginePtr";
  
  reg.finalizer(ans, delete_TreeCapFloorEngine)
  ans
  
}

attr(`TreeCapFloorEngine__SWIG_2`, 'returnType') = '_p_TreeCapFloorEnginePtr'
attr(`TreeCapFloorEngine__SWIG_2`, "inputTypes") = c('_p_boost__shared_ptrT_ShortRateModel_t', '_p_TimeGrid', '_p_HandleT_YieldTermStructure_t')
class(`TreeCapFloorEngine__SWIG_2`) = c("SWIGFunction", class('TreeCapFloorEngine__SWIG_2'))

# Start of new_TreeCapFloorEngine

`TreeCapFloorEngine__SWIG_3` = function(model, grid)
{
  ;ans = .Call('R_swig_new_TreeCapFloorEngine__SWIG_3', model, grid, PACKAGE='QuantLib');
  class(ans) <- "_p_TreeCapFloorEnginePtr";
  
  reg.finalizer(ans, delete_TreeCapFloorEngine)
  ans
  
}

attr(`TreeCapFloorEngine__SWIG_3`, 'returnType') = '_p_TreeCapFloorEnginePtr'
attr(`TreeCapFloorEngine__SWIG_3`, "inputTypes") = c('_p_boost__shared_ptrT_ShortRateModel_t', '_p_TimeGrid')
class(`TreeCapFloorEngine__SWIG_3`) = c("SWIGFunction", class('TreeCapFloorEngine__SWIG_3'))

`TreeCapFloorEngine` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 2) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_ShortRateModel_t') && extends(argtypes[2], '_p_TimeGrid')) {
      f <- TreeCapFloorEngine__SWIG_3; 
    }
    else if (extends(argtypes[1], '_p_boost__shared_ptrT_ShortRateModel_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]]))) {
      f <- TreeCapFloorEngine__SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_ShortRateModel_t') && extends(argtypes[2], '_p_TimeGrid') && extends(argtypes[3], '_p_HandleT_YieldTermStructure_t')) {
      f <- TreeCapFloorEngine__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_boost__shared_ptrT_ShortRateModel_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && extends(argtypes[3], '_p_HandleT_YieldTermStructure_t')) {
      f <- TreeCapFloorEngine__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for TreeCapFloorEngine with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_TreeCapFloorEngine

`delete_TreeCapFloorEngine` = function(self)
{
  ;.Call('R_swig_delete_TreeCapFloorEngine', self, PACKAGE='QuantLib');
  
}

attr(`delete_TreeCapFloorEngine`, 'returnType') = 'void'
attr(`delete_TreeCapFloorEngine`, "inputTypes") = c('_p_TreeCapFloorEnginePtr')
class(`delete_TreeCapFloorEngine`) = c("SWIGFunction", class('delete_TreeCapFloorEngine'))

setMethod('delete', '_p_TreeCapFloorEnginePtr', function(obj) {delete_TreeCapFloorEnginePtr(obj)})
# Start of new_G2SwaptionEngine

`G2SwaptionEngine` = function(model, range, intervals)
{
  if(length(intervals) > 1) {
    warning("using only the first element of intervals");
  };
  
  ;ans = .Call('R_swig_new_G2SwaptionEngine', model, range, intervals, PACKAGE='QuantLib');
  class(ans) <- "_p_G2SwaptionEnginePtr";
  
  reg.finalizer(ans, delete_G2SwaptionEngine)
  ans
  
}

attr(`G2SwaptionEngine`, 'returnType') = '_p_G2SwaptionEnginePtr'
attr(`G2SwaptionEngine`, "inputTypes") = c('_p_boost__shared_ptrT_ShortRateModel_t', 'numeric', 'integer')
class(`G2SwaptionEngine`) = c("SWIGFunction", class('G2SwaptionEngine'))

# Start of delete_G2SwaptionEngine

`delete_G2SwaptionEngine` = function(self)
{
  ;.Call('R_swig_delete_G2SwaptionEngine', self, PACKAGE='QuantLib');
  
}

attr(`delete_G2SwaptionEngine`, 'returnType') = 'void'
attr(`delete_G2SwaptionEngine`, "inputTypes") = c('_p_G2SwaptionEnginePtr')
class(`delete_G2SwaptionEngine`) = c("SWIGFunction", class('delete_G2SwaptionEngine'))

setMethod('delete', '_p_G2SwaptionEnginePtr', function(obj) {delete_G2SwaptionEnginePtr(obj)})
# Start of Statistics_samples

`Statistics_samples` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_Statistics_samples', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__size_t";
  
  ans
  
}

attr(`Statistics_samples`, 'returnType') = 'integer'
attr(`Statistics_samples`, "inputTypes") = c('_p_Statistics')
class(`Statistics_samples`) = c("SWIGFunction", class('Statistics_samples'))

# Start of Statistics_weightSum

`Statistics_weightSum` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Statistics_weightSum', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Statistics_weightSum`, 'returnType') = 'numeric'
attr(`Statistics_weightSum`, "inputTypes") = c('_p_Statistics')
class(`Statistics_weightSum`) = c("SWIGFunction", class('Statistics_weightSum'))

# Start of Statistics_mean

`Statistics_mean` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Statistics_mean', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Statistics_mean`, 'returnType') = 'numeric'
attr(`Statistics_mean`, "inputTypes") = c('_p_Statistics')
class(`Statistics_mean`) = c("SWIGFunction", class('Statistics_mean'))

# Start of Statistics_variance

`Statistics_variance` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Statistics_variance', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Statistics_variance`, 'returnType') = 'numeric'
attr(`Statistics_variance`, "inputTypes") = c('_p_Statistics')
class(`Statistics_variance`) = c("SWIGFunction", class('Statistics_variance'))

# Start of Statistics_standardDeviation

`Statistics_standardDeviation` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Statistics_standardDeviation', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Statistics_standardDeviation`, 'returnType') = 'numeric'
attr(`Statistics_standardDeviation`, "inputTypes") = c('_p_Statistics')
class(`Statistics_standardDeviation`) = c("SWIGFunction", class('Statistics_standardDeviation'))

# Start of Statistics_errorEstimate

`Statistics_errorEstimate` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Statistics_errorEstimate', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Statistics_errorEstimate`, 'returnType') = 'numeric'
attr(`Statistics_errorEstimate`, "inputTypes") = c('_p_Statistics')
class(`Statistics_errorEstimate`) = c("SWIGFunction", class('Statistics_errorEstimate'))

# Start of Statistics_skewness

`Statistics_skewness` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Statistics_skewness', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Statistics_skewness`, 'returnType') = 'numeric'
attr(`Statistics_skewness`, "inputTypes") = c('_p_Statistics')
class(`Statistics_skewness`) = c("SWIGFunction", class('Statistics_skewness'))

# Start of Statistics_kurtosis

`Statistics_kurtosis` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Statistics_kurtosis', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Statistics_kurtosis`, 'returnType') = 'numeric'
attr(`Statistics_kurtosis`, "inputTypes") = c('_p_Statistics')
class(`Statistics_kurtosis`) = c("SWIGFunction", class('Statistics_kurtosis'))

# Start of Statistics_min

`Statistics_min` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Statistics_min', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Statistics_min`, 'returnType') = 'numeric'
attr(`Statistics_min`, "inputTypes") = c('_p_Statistics')
class(`Statistics_min`) = c("SWIGFunction", class('Statistics_min'))

# Start of Statistics_max

`Statistics_max` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Statistics_max', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Statistics_max`, 'returnType') = 'numeric'
attr(`Statistics_max`, "inputTypes") = c('_p_Statistics')
class(`Statistics_max`) = c("SWIGFunction", class('Statistics_max'))

# Start of Statistics_reset

`Statistics_reset` = function(self)
{
  ;.Call('R_swig_Statistics_reset', self, PACKAGE='QuantLib');
  
}

attr(`Statistics_reset`, 'returnType') = 'void'
attr(`Statistics_reset`, "inputTypes") = c('_p_Statistics')
class(`Statistics_reset`) = c("SWIGFunction", class('Statistics_reset'))

# Start of Statistics_add

`Statistics_add__SWIG_0` = function(self, value, weight)
{
  ;.Call('R_swig_Statistics_add__SWIG_0', self, value, weight, PACKAGE='QuantLib');
  
}

attr(`Statistics_add__SWIG_0`, 'returnType') = 'void'
attr(`Statistics_add__SWIG_0`, "inputTypes") = c('_p_Statistics', 'numeric', 'numeric')
class(`Statistics_add__SWIG_0`) = c("SWIGFunction", class('Statistics_add__SWIG_0'))

# Start of Statistics_add

`Statistics_add__SWIG_1` = function(self, value)
{
  ;.Call('R_swig_Statistics_add__SWIG_1', self, value, PACKAGE='QuantLib');
  
}

attr(`Statistics_add__SWIG_1`, 'returnType') = 'void'
attr(`Statistics_add__SWIG_1`, "inputTypes") = c('_p_Statistics', 'numeric')
class(`Statistics_add__SWIG_1`) = c("SWIGFunction", class('Statistics_add__SWIG_1'))

# Start of Statistics_add

`Statistics_add__SWIG_2` = function(self, values)
{
  ;.Call('R_swig_Statistics_add__SWIG_2', self, values, PACKAGE='QuantLib');
  
}

attr(`Statistics_add__SWIG_2`, 'returnType') = 'void'
attr(`Statistics_add__SWIG_2`, "inputTypes") = c('_p_Statistics', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`Statistics_add__SWIG_2`) = c("SWIGFunction", class('Statistics_add__SWIG_2'))

# Start of Statistics_add

`Statistics_add__SWIG_3` = function(self, values, weights)
{
  ;.Call('R_swig_Statistics_add__SWIG_3', self, values, weights, PACKAGE='QuantLib');
  
}

attr(`Statistics_add__SWIG_3`, 'returnType') = 'void'
attr(`Statistics_add__SWIG_3`, "inputTypes") = c('_p_Statistics', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`Statistics_add__SWIG_3`) = c("SWIGFunction", class('Statistics_add__SWIG_3'))

`Statistics_add` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 2) {
    if (extends(argtypes[1], '_p_Statistics') && is.numeric(argv[[2]])) {
      f <- Statistics_add__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_Statistics') && extends(argtypes[2], '_p_std__vectorT_double_std__allocatorT_double_t_t')) {
      f <- Statistics_add__SWIG_2; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_Statistics') && is.numeric(argv[[2]]) && is.numeric(argv[[3]])) {
      f <- Statistics_add__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_Statistics') && extends(argtypes[2], '_p_std__vectorT_double_std__allocatorT_double_t_t') && extends(argtypes[3], '_p_std__vectorT_double_std__allocatorT_double_t_t')) {
      f <- Statistics_add__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for Statistics_add with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of new_Statistics

`Statistics` = function()
{
  ;ans = .Call('R_swig_new_Statistics', PACKAGE='QuantLib');
  class(ans) <- "_p_Statistics";
  
  reg.finalizer(ans, delete_Statistics)
  ans
  
}

attr(`Statistics`, 'returnType') = '_p_Statistics'
class(`Statistics`) = c("SWIGFunction", class('Statistics'))

# Start of delete_Statistics

`delete_Statistics` = function(self)
{
  ;.Call('R_swig_delete_Statistics', self, PACKAGE='QuantLib');
  
}

attr(`delete_Statistics`, 'returnType') = 'void'
attr(`delete_Statistics`, "inputTypes") = c('_p_Statistics')
class(`delete_Statistics`) = c("SWIGFunction", class('delete_Statistics'))

# Start of accessor method for Statistics
setMethod('$', '_p_Statistics', function(x, name)

{
  accessorFuns = list('samples' = Statistics_samples, 'weightSum' = Statistics_weightSum, 'mean' = Statistics_mean, 'variance' = Statistics_variance, 'standardDeviation' = Statistics_standardDeviation, 'errorEstimate' = Statistics_errorEstimate, 'skewness' = Statistics_skewness, 'kurtosis' = Statistics_kurtosis, 'min' = Statistics_min, 'max' = Statistics_max, 'add' = Statistics_add);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for Statistics
# Start of accessor method for Statistics
setMethod('$<-', '_p_Statistics', function(x, name, value)

{
  accessorFuns = list('reset' = Statistics_reset);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_Statistics', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('reset' = Statistics_reset);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for Statistics
setMethod('delete', '_p_Statistics', function(obj) {delete_Statistics(obj)})
# Start of IncrementalStatistics_samples

`IncrementalStatistics_samples` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_IncrementalStatistics_samples', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__size_t";
  
  ans
  
}

attr(`IncrementalStatistics_samples`, 'returnType') = 'integer'
attr(`IncrementalStatistics_samples`, "inputTypes") = c('_p_IncrementalStatistics')
class(`IncrementalStatistics_samples`) = c("SWIGFunction", class('IncrementalStatistics_samples'))

# Start of IncrementalStatistics_weightSum

`IncrementalStatistics_weightSum` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_IncrementalStatistics_weightSum', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`IncrementalStatistics_weightSum`, 'returnType') = 'numeric'
attr(`IncrementalStatistics_weightSum`, "inputTypes") = c('_p_IncrementalStatistics')
class(`IncrementalStatistics_weightSum`) = c("SWIGFunction", class('IncrementalStatistics_weightSum'))

# Start of IncrementalStatistics_mean

`IncrementalStatistics_mean` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_IncrementalStatistics_mean', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`IncrementalStatistics_mean`, 'returnType') = 'numeric'
attr(`IncrementalStatistics_mean`, "inputTypes") = c('_p_IncrementalStatistics')
class(`IncrementalStatistics_mean`) = c("SWIGFunction", class('IncrementalStatistics_mean'))

# Start of IncrementalStatistics_variance

`IncrementalStatistics_variance` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_IncrementalStatistics_variance', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`IncrementalStatistics_variance`, 'returnType') = 'numeric'
attr(`IncrementalStatistics_variance`, "inputTypes") = c('_p_IncrementalStatistics')
class(`IncrementalStatistics_variance`) = c("SWIGFunction", class('IncrementalStatistics_variance'))

# Start of IncrementalStatistics_standardDeviation

`IncrementalStatistics_standardDeviation` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_IncrementalStatistics_standardDeviation', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`IncrementalStatistics_standardDeviation`, 'returnType') = 'numeric'
attr(`IncrementalStatistics_standardDeviation`, "inputTypes") = c('_p_IncrementalStatistics')
class(`IncrementalStatistics_standardDeviation`) = c("SWIGFunction", class('IncrementalStatistics_standardDeviation'))

# Start of IncrementalStatistics_errorEstimate

`IncrementalStatistics_errorEstimate` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_IncrementalStatistics_errorEstimate', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`IncrementalStatistics_errorEstimate`, 'returnType') = 'numeric'
attr(`IncrementalStatistics_errorEstimate`, "inputTypes") = c('_p_IncrementalStatistics')
class(`IncrementalStatistics_errorEstimate`) = c("SWIGFunction", class('IncrementalStatistics_errorEstimate'))

# Start of IncrementalStatistics_skewness

`IncrementalStatistics_skewness` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_IncrementalStatistics_skewness', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`IncrementalStatistics_skewness`, 'returnType') = 'numeric'
attr(`IncrementalStatistics_skewness`, "inputTypes") = c('_p_IncrementalStatistics')
class(`IncrementalStatistics_skewness`) = c("SWIGFunction", class('IncrementalStatistics_skewness'))

# Start of IncrementalStatistics_kurtosis

`IncrementalStatistics_kurtosis` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_IncrementalStatistics_kurtosis', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`IncrementalStatistics_kurtosis`, 'returnType') = 'numeric'
attr(`IncrementalStatistics_kurtosis`, "inputTypes") = c('_p_IncrementalStatistics')
class(`IncrementalStatistics_kurtosis`) = c("SWIGFunction", class('IncrementalStatistics_kurtosis'))

# Start of IncrementalStatistics_min

`IncrementalStatistics_min` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_IncrementalStatistics_min', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`IncrementalStatistics_min`, 'returnType') = 'numeric'
attr(`IncrementalStatistics_min`, "inputTypes") = c('_p_IncrementalStatistics')
class(`IncrementalStatistics_min`) = c("SWIGFunction", class('IncrementalStatistics_min'))

# Start of IncrementalStatistics_max

`IncrementalStatistics_max` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_IncrementalStatistics_max', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`IncrementalStatistics_max`, 'returnType') = 'numeric'
attr(`IncrementalStatistics_max`, "inputTypes") = c('_p_IncrementalStatistics')
class(`IncrementalStatistics_max`) = c("SWIGFunction", class('IncrementalStatistics_max'))

# Start of IncrementalStatistics_reset

`IncrementalStatistics_reset` = function(self)
{
  ;.Call('R_swig_IncrementalStatistics_reset', self, PACKAGE='QuantLib');
  
}

attr(`IncrementalStatistics_reset`, 'returnType') = 'void'
attr(`IncrementalStatistics_reset`, "inputTypes") = c('_p_IncrementalStatistics')
class(`IncrementalStatistics_reset`) = c("SWIGFunction", class('IncrementalStatistics_reset'))

# Start of IncrementalStatistics_add

`IncrementalStatistics_add__SWIG_0` = function(self, value, weight)
{
  ;.Call('R_swig_IncrementalStatistics_add__SWIG_0', self, value, weight, PACKAGE='QuantLib');
  
}

attr(`IncrementalStatistics_add__SWIG_0`, 'returnType') = 'void'
attr(`IncrementalStatistics_add__SWIG_0`, "inputTypes") = c('_p_IncrementalStatistics', 'numeric', 'numeric')
class(`IncrementalStatistics_add__SWIG_0`) = c("SWIGFunction", class('IncrementalStatistics_add__SWIG_0'))

# Start of IncrementalStatistics_add

`IncrementalStatistics_add__SWIG_1` = function(self, value)
{
  ;.Call('R_swig_IncrementalStatistics_add__SWIG_1', self, value, PACKAGE='QuantLib');
  
}

attr(`IncrementalStatistics_add__SWIG_1`, 'returnType') = 'void'
attr(`IncrementalStatistics_add__SWIG_1`, "inputTypes") = c('_p_IncrementalStatistics', 'numeric')
class(`IncrementalStatistics_add__SWIG_1`) = c("SWIGFunction", class('IncrementalStatistics_add__SWIG_1'))

# Start of IncrementalStatistics_add

`IncrementalStatistics_add__SWIG_2` = function(self, values)
{
  ;.Call('R_swig_IncrementalStatistics_add__SWIG_2', self, values, PACKAGE='QuantLib');
  
}

attr(`IncrementalStatistics_add__SWIG_2`, 'returnType') = 'void'
attr(`IncrementalStatistics_add__SWIG_2`, "inputTypes") = c('_p_IncrementalStatistics', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`IncrementalStatistics_add__SWIG_2`) = c("SWIGFunction", class('IncrementalStatistics_add__SWIG_2'))

# Start of IncrementalStatistics_add

`IncrementalStatistics_add__SWIG_3` = function(self, values, weights)
{
  ;.Call('R_swig_IncrementalStatistics_add__SWIG_3', self, values, weights, PACKAGE='QuantLib');
  
}

attr(`IncrementalStatistics_add__SWIG_3`, 'returnType') = 'void'
attr(`IncrementalStatistics_add__SWIG_3`, "inputTypes") = c('_p_IncrementalStatistics', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`IncrementalStatistics_add__SWIG_3`) = c("SWIGFunction", class('IncrementalStatistics_add__SWIG_3'))

`IncrementalStatistics_add` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 2) {
    if (extends(argtypes[1], '_p_IncrementalStatistics') && is.numeric(argv[[2]])) {
      f <- IncrementalStatistics_add__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_IncrementalStatistics') && extends(argtypes[2], '_p_std__vectorT_double_std__allocatorT_double_t_t')) {
      f <- IncrementalStatistics_add__SWIG_2; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_IncrementalStatistics') && is.numeric(argv[[2]]) && is.numeric(argv[[3]])) {
      f <- IncrementalStatistics_add__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_IncrementalStatistics') && extends(argtypes[2], '_p_std__vectorT_double_std__allocatorT_double_t_t') && extends(argtypes[3], '_p_std__vectorT_double_std__allocatorT_double_t_t')) {
      f <- IncrementalStatistics_add__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for IncrementalStatistics_add with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of new_IncrementalStatistics

`IncrementalStatistics` = function()
{
  ;ans = .Call('R_swig_new_IncrementalStatistics', PACKAGE='QuantLib');
  class(ans) <- "_p_IncrementalStatistics";
  
  reg.finalizer(ans, delete_IncrementalStatistics)
  ans
  
}

attr(`IncrementalStatistics`, 'returnType') = '_p_IncrementalStatistics'
class(`IncrementalStatistics`) = c("SWIGFunction", class('IncrementalStatistics'))

# Start of delete_IncrementalStatistics

`delete_IncrementalStatistics` = function(self)
{
  ;.Call('R_swig_delete_IncrementalStatistics', self, PACKAGE='QuantLib');
  
}

attr(`delete_IncrementalStatistics`, 'returnType') = 'void'
attr(`delete_IncrementalStatistics`, "inputTypes") = c('_p_IncrementalStatistics')
class(`delete_IncrementalStatistics`) = c("SWIGFunction", class('delete_IncrementalStatistics'))

# Start of accessor method for IncrementalStatistics
setMethod('$', '_p_IncrementalStatistics', function(x, name)

{
  accessorFuns = list('samples' = IncrementalStatistics_samples, 'weightSum' = IncrementalStatistics_weightSum, 'mean' = IncrementalStatistics_mean, 'variance' = IncrementalStatistics_variance, 'standardDeviation' = IncrementalStatistics_standardDeviation, 'errorEstimate' = IncrementalStatistics_errorEstimate, 'skewness' = IncrementalStatistics_skewness, 'kurtosis' = IncrementalStatistics_kurtosis, 'min' = IncrementalStatistics_min, 'max' = IncrementalStatistics_max, 'add' = IncrementalStatistics_add);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for IncrementalStatistics
# Start of accessor method for IncrementalStatistics
setMethod('$<-', '_p_IncrementalStatistics', function(x, name, value)

{
  accessorFuns = list('reset' = IncrementalStatistics_reset);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_IncrementalStatistics', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('reset' = IncrementalStatistics_reset);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for IncrementalStatistics
setMethod('delete', '_p_IncrementalStatistics', function(obj) {delete_IncrementalStatistics(obj)})
# Start of RiskStatistics_semiVariance

`RiskStatistics_semiVariance` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_RiskStatistics_semiVariance', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`RiskStatistics_semiVariance`, 'returnType') = 'numeric'
attr(`RiskStatistics_semiVariance`, "inputTypes") = c('_p_RiskStatistics')
class(`RiskStatistics_semiVariance`) = c("SWIGFunction", class('RiskStatistics_semiVariance'))

# Start of RiskStatistics_semiDeviation

`RiskStatistics_semiDeviation` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_RiskStatistics_semiDeviation', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`RiskStatistics_semiDeviation`, 'returnType') = 'numeric'
attr(`RiskStatistics_semiDeviation`, "inputTypes") = c('_p_RiskStatistics')
class(`RiskStatistics_semiDeviation`) = c("SWIGFunction", class('RiskStatistics_semiDeviation'))

# Start of RiskStatistics_downsideVariance

`RiskStatistics_downsideVariance` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_RiskStatistics_downsideVariance', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`RiskStatistics_downsideVariance`, 'returnType') = 'numeric'
attr(`RiskStatistics_downsideVariance`, "inputTypes") = c('_p_RiskStatistics')
class(`RiskStatistics_downsideVariance`) = c("SWIGFunction", class('RiskStatistics_downsideVariance'))

# Start of RiskStatistics_downsideDeviation

`RiskStatistics_downsideDeviation` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_RiskStatistics_downsideDeviation', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`RiskStatistics_downsideDeviation`, 'returnType') = 'numeric'
attr(`RiskStatistics_downsideDeviation`, "inputTypes") = c('_p_RiskStatistics')
class(`RiskStatistics_downsideDeviation`) = c("SWIGFunction", class('RiskStatistics_downsideDeviation'))

# Start of RiskStatistics_regret

`RiskStatistics_regret` = function(self, target, .copy = FALSE)
{
  ;.Call('R_swig_RiskStatistics_regret', self, target, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`RiskStatistics_regret`, 'returnType') = 'numeric'
attr(`RiskStatistics_regret`, "inputTypes") = c('_p_RiskStatistics', 'numeric')
class(`RiskStatistics_regret`) = c("SWIGFunction", class('RiskStatistics_regret'))

# Start of RiskStatistics_potentialUpside

`RiskStatistics_potentialUpside` = function(self, percentile, .copy = FALSE)
{
  ;.Call('R_swig_RiskStatistics_potentialUpside', self, percentile, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`RiskStatistics_potentialUpside`, 'returnType') = 'numeric'
attr(`RiskStatistics_potentialUpside`, "inputTypes") = c('_p_RiskStatistics', 'numeric')
class(`RiskStatistics_potentialUpside`) = c("SWIGFunction", class('RiskStatistics_potentialUpside'))

# Start of RiskStatistics_valueAtRisk

`RiskStatistics_valueAtRisk` = function(self, percentile, .copy = FALSE)
{
  ;.Call('R_swig_RiskStatistics_valueAtRisk', self, percentile, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`RiskStatistics_valueAtRisk`, 'returnType') = 'numeric'
attr(`RiskStatistics_valueAtRisk`, "inputTypes") = c('_p_RiskStatistics', 'numeric')
class(`RiskStatistics_valueAtRisk`) = c("SWIGFunction", class('RiskStatistics_valueAtRisk'))

# Start of RiskStatistics_expectedShortfall

`RiskStatistics_expectedShortfall` = function(self, percentile, .copy = FALSE)
{
  ;.Call('R_swig_RiskStatistics_expectedShortfall', self, percentile, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`RiskStatistics_expectedShortfall`, 'returnType') = 'numeric'
attr(`RiskStatistics_expectedShortfall`, "inputTypes") = c('_p_RiskStatistics', 'numeric')
class(`RiskStatistics_expectedShortfall`) = c("SWIGFunction", class('RiskStatistics_expectedShortfall'))

# Start of RiskStatistics_shortfall

`RiskStatistics_shortfall` = function(self, target, .copy = FALSE)
{
  ;.Call('R_swig_RiskStatistics_shortfall', self, target, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`RiskStatistics_shortfall`, 'returnType') = 'numeric'
attr(`RiskStatistics_shortfall`, "inputTypes") = c('_p_RiskStatistics', 'numeric')
class(`RiskStatistics_shortfall`) = c("SWIGFunction", class('RiskStatistics_shortfall'))

# Start of RiskStatistics_averageShortfall

`RiskStatistics_averageShortfall` = function(self, target, .copy = FALSE)
{
  ;.Call('R_swig_RiskStatistics_averageShortfall', self, target, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`RiskStatistics_averageShortfall`, 'returnType') = 'numeric'
attr(`RiskStatistics_averageShortfall`, "inputTypes") = c('_p_RiskStatistics', 'numeric')
class(`RiskStatistics_averageShortfall`) = c("SWIGFunction", class('RiskStatistics_averageShortfall'))

# Start of new_RiskStatistics

`RiskStatistics` = function()
{
  ;ans = .Call('R_swig_new_RiskStatistics', PACKAGE='QuantLib');
  class(ans) <- "_p_RiskStatistics";
  
  reg.finalizer(ans, delete_RiskStatistics)
  ans
  
}

attr(`RiskStatistics`, 'returnType') = '_p_RiskStatistics'
class(`RiskStatistics`) = c("SWIGFunction", class('RiskStatistics'))

# Start of delete_RiskStatistics

`delete_RiskStatistics` = function(self)
{
  ;.Call('R_swig_delete_RiskStatistics', self, PACKAGE='QuantLib');
  
}

attr(`delete_RiskStatistics`, 'returnType') = 'void'
attr(`delete_RiskStatistics`, "inputTypes") = c('_p_RiskStatistics')
class(`delete_RiskStatistics`) = c("SWIGFunction", class('delete_RiskStatistics'))

# Start of accessor method for RiskStatistics
setMethod('$', '_p_RiskStatistics', function(x, name)

{
  accessorFuns = list('semiVariance' = RiskStatistics_semiVariance, 'semiDeviation' = RiskStatistics_semiDeviation, 'downsideVariance' = RiskStatistics_downsideVariance, 'downsideDeviation' = RiskStatistics_downsideDeviation, 'regret' = RiskStatistics_regret, 'potentialUpside' = RiskStatistics_potentialUpside, 'valueAtRisk' = RiskStatistics_valueAtRisk, 'expectedShortfall' = RiskStatistics_expectedShortfall, 'shortfall' = RiskStatistics_shortfall, 'averageShortfall' = RiskStatistics_averageShortfall);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for RiskStatistics
setMethod('delete', '_p_RiskStatistics', function(obj) {delete_RiskStatistics(obj)})
# Start of new_MultipleStatistics

`MultipleStatistics` = function(dimension)
{
  if(length(dimension) > 1) {
    warning("using only the first element of dimension");
  };
  
  ;ans = .Call('R_swig_new_MultipleStatistics', dimension, PACKAGE='QuantLib');
  class(ans) <- "_p_GenericSequenceStatisticsT_Statistics_t";
  
  reg.finalizer(ans, delete_MultipleStatistics)
  ans
  
}

attr(`MultipleStatistics`, 'returnType') = '_p_GenericSequenceStatisticsT_Statistics_t'
attr(`MultipleStatistics`, "inputTypes") = c('integer')
class(`MultipleStatistics`) = c("SWIGFunction", class('MultipleStatistics'))

# Start of MultipleStatistics_size

`MultipleStatistics_size` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_MultipleStatistics_size', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__size_t";
  
  ans
  
}

attr(`MultipleStatistics_size`, 'returnType') = 'integer'
attr(`MultipleStatistics_size`, "inputTypes") = c('_p_GenericSequenceStatisticsT_Statistics_t')
class(`MultipleStatistics_size`) = c("SWIGFunction", class('MultipleStatistics_size'))

# Start of MultipleStatistics_samples

`MultipleStatistics_samples` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_MultipleStatistics_samples', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__size_t";
  
  ans
  
}

attr(`MultipleStatistics_samples`, 'returnType') = 'integer'
attr(`MultipleStatistics_samples`, "inputTypes") = c('_p_GenericSequenceStatisticsT_Statistics_t')
class(`MultipleStatistics_samples`) = c("SWIGFunction", class('MultipleStatistics_samples'))

# Start of MultipleStatistics_weightSum

`MultipleStatistics_weightSum` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_MultipleStatistics_weightSum', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`MultipleStatistics_weightSum`, 'returnType') = 'numeric'
attr(`MultipleStatistics_weightSum`, "inputTypes") = c('_p_GenericSequenceStatisticsT_Statistics_t')
class(`MultipleStatistics_weightSum`) = c("SWIGFunction", class('MultipleStatistics_weightSum'))

# Start of MultipleStatistics_mean

`MultipleStatistics_mean` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_MultipleStatistics_mean', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_double_std__allocatorT_double_t_t";
  
  ans
  
}

attr(`MultipleStatistics_mean`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`MultipleStatistics_mean`, "inputTypes") = c('_p_GenericSequenceStatisticsT_Statistics_t')
class(`MultipleStatistics_mean`) = c("SWIGFunction", class('MultipleStatistics_mean'))

# Start of MultipleStatistics_variance

`MultipleStatistics_variance` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_MultipleStatistics_variance', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_double_std__allocatorT_double_t_t";
  
  ans
  
}

attr(`MultipleStatistics_variance`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`MultipleStatistics_variance`, "inputTypes") = c('_p_GenericSequenceStatisticsT_Statistics_t')
class(`MultipleStatistics_variance`) = c("SWIGFunction", class('MultipleStatistics_variance'))

# Start of MultipleStatistics_standardDeviation

`MultipleStatistics_standardDeviation` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_MultipleStatistics_standardDeviation', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_double_std__allocatorT_double_t_t";
  
  ans
  
}

attr(`MultipleStatistics_standardDeviation`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`MultipleStatistics_standardDeviation`, "inputTypes") = c('_p_GenericSequenceStatisticsT_Statistics_t')
class(`MultipleStatistics_standardDeviation`) = c("SWIGFunction", class('MultipleStatistics_standardDeviation'))

# Start of MultipleStatistics_errorEstimate

`MultipleStatistics_errorEstimate` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_MultipleStatistics_errorEstimate', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_double_std__allocatorT_double_t_t";
  
  ans
  
}

attr(`MultipleStatistics_errorEstimate`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`MultipleStatistics_errorEstimate`, "inputTypes") = c('_p_GenericSequenceStatisticsT_Statistics_t')
class(`MultipleStatistics_errorEstimate`) = c("SWIGFunction", class('MultipleStatistics_errorEstimate'))

# Start of MultipleStatistics_skewness

`MultipleStatistics_skewness` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_MultipleStatistics_skewness', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_double_std__allocatorT_double_t_t";
  
  ans
  
}

attr(`MultipleStatistics_skewness`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`MultipleStatistics_skewness`, "inputTypes") = c('_p_GenericSequenceStatisticsT_Statistics_t')
class(`MultipleStatistics_skewness`) = c("SWIGFunction", class('MultipleStatistics_skewness'))

# Start of MultipleStatistics_kurtosis

`MultipleStatistics_kurtosis` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_MultipleStatistics_kurtosis', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_double_std__allocatorT_double_t_t";
  
  ans
  
}

attr(`MultipleStatistics_kurtosis`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`MultipleStatistics_kurtosis`, "inputTypes") = c('_p_GenericSequenceStatisticsT_Statistics_t')
class(`MultipleStatistics_kurtosis`) = c("SWIGFunction", class('MultipleStatistics_kurtosis'))

# Start of MultipleStatistics_min

`MultipleStatistics_min` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_MultipleStatistics_min', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_double_std__allocatorT_double_t_t";
  
  ans
  
}

attr(`MultipleStatistics_min`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`MultipleStatistics_min`, "inputTypes") = c('_p_GenericSequenceStatisticsT_Statistics_t')
class(`MultipleStatistics_min`) = c("SWIGFunction", class('MultipleStatistics_min'))

# Start of MultipleStatistics_max

`MultipleStatistics_max` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_MultipleStatistics_max', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_double_std__allocatorT_double_t_t";
  
  ans
  
}

attr(`MultipleStatistics_max`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`MultipleStatistics_max`, "inputTypes") = c('_p_GenericSequenceStatisticsT_Statistics_t')
class(`MultipleStatistics_max`) = c("SWIGFunction", class('MultipleStatistics_max'))

# Start of MultipleStatistics_covariance

`MultipleStatistics_covariance` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_MultipleStatistics_covariance', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Matrix";
  
  ans
  
}

attr(`MultipleStatistics_covariance`, 'returnType') = '_p_Matrix'
attr(`MultipleStatistics_covariance`, "inputTypes") = c('_p_GenericSequenceStatisticsT_Statistics_t')
class(`MultipleStatistics_covariance`) = c("SWIGFunction", class('MultipleStatistics_covariance'))

# Start of MultipleStatistics_correlation

`MultipleStatistics_correlation` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_MultipleStatistics_correlation', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Matrix";
  
  ans
  
}

attr(`MultipleStatistics_correlation`, 'returnType') = '_p_Matrix'
attr(`MultipleStatistics_correlation`, "inputTypes") = c('_p_GenericSequenceStatisticsT_Statistics_t')
class(`MultipleStatistics_correlation`) = c("SWIGFunction", class('MultipleStatistics_correlation'))

# Start of MultipleStatistics_reset

`MultipleStatistics_reset` = function(self)
{
  ;.Call('R_swig_MultipleStatistics_reset', self, PACKAGE='QuantLib');
  
}

attr(`MultipleStatistics_reset`, 'returnType') = 'void'
attr(`MultipleStatistics_reset`, "inputTypes") = c('_p_GenericSequenceStatisticsT_Statistics_t')
class(`MultipleStatistics_reset`) = c("SWIGFunction", class('MultipleStatistics_reset'))

# Start of MultipleStatistics_add

`MultipleStatistics_add__SWIG_0` = function(self, value, weight)
{
  ;.Call('R_swig_MultipleStatistics_add__SWIG_0', self, value, weight, PACKAGE='QuantLib');
  
}

attr(`MultipleStatistics_add__SWIG_0`, 'returnType') = 'void'
attr(`MultipleStatistics_add__SWIG_0`, "inputTypes") = c('_p_GenericSequenceStatisticsT_Statistics_t', '_p_std__vectorT_double_std__allocatorT_double_t_t', 'numeric')
class(`MultipleStatistics_add__SWIG_0`) = c("SWIGFunction", class('MultipleStatistics_add__SWIG_0'))

# Start of MultipleStatistics_add

`MultipleStatistics_add__SWIG_1` = function(self, value)
{
  ;.Call('R_swig_MultipleStatistics_add__SWIG_1', self, value, PACKAGE='QuantLib');
  
}

attr(`MultipleStatistics_add__SWIG_1`, 'returnType') = 'void'
attr(`MultipleStatistics_add__SWIG_1`, "inputTypes") = c('_p_GenericSequenceStatisticsT_Statistics_t', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`MultipleStatistics_add__SWIG_1`) = c("SWIGFunction", class('MultipleStatistics_add__SWIG_1'))

# Start of MultipleStatistics_add

`MultipleStatistics_add__SWIG_2` = function(self, value, weight)
{
  ;.Call('R_swig_MultipleStatistics_add__SWIG_2', self, value, weight, PACKAGE='QuantLib');
  
}

attr(`MultipleStatistics_add__SWIG_2`, 'returnType') = 'void'
attr(`MultipleStatistics_add__SWIG_2`, "inputTypes") = c('_p_GenericSequenceStatisticsT_Statistics_t', '_p_Array', 'numeric')
class(`MultipleStatistics_add__SWIG_2`) = c("SWIGFunction", class('MultipleStatistics_add__SWIG_2'))

# Start of MultipleStatistics_add

`MultipleStatistics_add__SWIG_3` = function(self, value)
{
  ;.Call('R_swig_MultipleStatistics_add__SWIG_3', self, value, PACKAGE='QuantLib');
  
}

attr(`MultipleStatistics_add__SWIG_3`, 'returnType') = 'void'
attr(`MultipleStatistics_add__SWIG_3`, "inputTypes") = c('_p_GenericSequenceStatisticsT_Statistics_t', '_p_Array')
class(`MultipleStatistics_add__SWIG_3`) = c("SWIGFunction", class('MultipleStatistics_add__SWIG_3'))

`MultipleStatistics_add` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 2) {
    if (extends(argtypes[1], '_p_GenericSequenceStatisticsT_Statistics_t') && extends(argtypes[2], '_p_Array')) {
      f <- MultipleStatistics_add__SWIG_3; 
    }
    else if (extends(argtypes[1], '_p_GenericSequenceStatisticsT_Statistics_t') && extends(argtypes[2], '_p_std__vectorT_double_std__allocatorT_double_t_t')) {
      f <- MultipleStatistics_add__SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_GenericSequenceStatisticsT_Statistics_t') && extends(argtypes[2], '_p_Array') && is.numeric(argv[[3]])) {
      f <- MultipleStatistics_add__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_GenericSequenceStatisticsT_Statistics_t') && extends(argtypes[2], '_p_std__vectorT_double_std__allocatorT_double_t_t') && is.numeric(argv[[3]])) {
      f <- MultipleStatistics_add__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for MultipleStatistics_add with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_MultipleStatistics

`delete_MultipleStatistics` = function(self)
{
  ;.Call('R_swig_delete_MultipleStatistics', self, PACKAGE='QuantLib');
  
}

attr(`delete_MultipleStatistics`, 'returnType') = 'void'
attr(`delete_MultipleStatistics`, "inputTypes") = c('_p_GenericSequenceStatisticsT_Statistics_t')
class(`delete_MultipleStatistics`) = c("SWIGFunction", class('delete_MultipleStatistics'))

# Start of accessor method for GenericSequenceStatistics<(Statistics)>
setMethod('$', '_p_GenericSequenceStatisticsT_Statistics_t', function(x, name)

{
  accessorFuns = list('size' = MultipleStatistics_size, 'samples' = MultipleStatistics_samples, 'weightSum' = MultipleStatistics_weightSum, 'mean' = MultipleStatistics_mean, 'variance' = MultipleStatistics_variance, 'standardDeviation' = MultipleStatistics_standardDeviation, 'errorEstimate' = MultipleStatistics_errorEstimate, 'skewness' = MultipleStatistics_skewness, 'kurtosis' = MultipleStatistics_kurtosis, 'min' = MultipleStatistics_min, 'max' = MultipleStatistics_max, 'covariance' = MultipleStatistics_covariance, 'correlation' = MultipleStatistics_correlation, 'add' = MultipleStatistics_add);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for GenericSequenceStatistics<(Statistics)>
# Start of accessor method for GenericSequenceStatistics<(Statistics)>
setMethod('$<-', '_p_GenericSequenceStatisticsT_Statistics_t', function(x, name, value)

{
  accessorFuns = list('reset' = MultipleStatistics_reset);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_GenericSequenceStatisticsT_Statistics_t', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('reset' = MultipleStatistics_reset);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for GenericSequenceStatistics<(Statistics)>
setMethod('delete', '_p_GenericSequenceStatisticsT_Statistics_t', function(obj) {delete_GenericSequenceStatisticsT_Statistics_t(obj)})
# Start of new_SequenceStatistics

`SequenceStatistics` = function(dimension)
{
  if(length(dimension) > 1) {
    warning("using only the first element of dimension");
  };
  
  ;ans = .Call('R_swig_new_SequenceStatistics', dimension, PACKAGE='QuantLib');
  class(ans) <- "_p_GenericSequenceStatisticsT_RiskStatistics_t";
  
  reg.finalizer(ans, delete_SequenceStatistics)
  ans
  
}

attr(`SequenceStatistics`, 'returnType') = '_p_GenericSequenceStatisticsT_RiskStatistics_t'
attr(`SequenceStatistics`, "inputTypes") = c('integer')
class(`SequenceStatistics`) = c("SWIGFunction", class('SequenceStatistics'))

# Start of SequenceStatistics_size

`SequenceStatistics_size` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_SequenceStatistics_size', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__size_t";
  
  ans
  
}

attr(`SequenceStatistics_size`, 'returnType') = 'integer'
attr(`SequenceStatistics_size`, "inputTypes") = c('_p_GenericSequenceStatisticsT_RiskStatistics_t')
class(`SequenceStatistics_size`) = c("SWIGFunction", class('SequenceStatistics_size'))

# Start of SequenceStatistics_samples

`SequenceStatistics_samples` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_SequenceStatistics_samples', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__size_t";
  
  ans
  
}

attr(`SequenceStatistics_samples`, 'returnType') = 'integer'
attr(`SequenceStatistics_samples`, "inputTypes") = c('_p_GenericSequenceStatisticsT_RiskStatistics_t')
class(`SequenceStatistics_samples`) = c("SWIGFunction", class('SequenceStatistics_samples'))

# Start of SequenceStatistics_weightSum

`SequenceStatistics_weightSum` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_SequenceStatistics_weightSum', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`SequenceStatistics_weightSum`, 'returnType') = 'numeric'
attr(`SequenceStatistics_weightSum`, "inputTypes") = c('_p_GenericSequenceStatisticsT_RiskStatistics_t')
class(`SequenceStatistics_weightSum`) = c("SWIGFunction", class('SequenceStatistics_weightSum'))

# Start of SequenceStatistics_mean

`SequenceStatistics_mean` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_SequenceStatistics_mean', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_double_std__allocatorT_double_t_t";
  
  ans
  
}

attr(`SequenceStatistics_mean`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`SequenceStatistics_mean`, "inputTypes") = c('_p_GenericSequenceStatisticsT_RiskStatistics_t')
class(`SequenceStatistics_mean`) = c("SWIGFunction", class('SequenceStatistics_mean'))

# Start of SequenceStatistics_variance

`SequenceStatistics_variance` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_SequenceStatistics_variance', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_double_std__allocatorT_double_t_t";
  
  ans
  
}

attr(`SequenceStatistics_variance`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`SequenceStatistics_variance`, "inputTypes") = c('_p_GenericSequenceStatisticsT_RiskStatistics_t')
class(`SequenceStatistics_variance`) = c("SWIGFunction", class('SequenceStatistics_variance'))

# Start of SequenceStatistics_standardDeviation

`SequenceStatistics_standardDeviation` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_SequenceStatistics_standardDeviation', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_double_std__allocatorT_double_t_t";
  
  ans
  
}

attr(`SequenceStatistics_standardDeviation`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`SequenceStatistics_standardDeviation`, "inputTypes") = c('_p_GenericSequenceStatisticsT_RiskStatistics_t')
class(`SequenceStatistics_standardDeviation`) = c("SWIGFunction", class('SequenceStatistics_standardDeviation'))

# Start of SequenceStatistics_errorEstimate

`SequenceStatistics_errorEstimate` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_SequenceStatistics_errorEstimate', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_double_std__allocatorT_double_t_t";
  
  ans
  
}

attr(`SequenceStatistics_errorEstimate`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`SequenceStatistics_errorEstimate`, "inputTypes") = c('_p_GenericSequenceStatisticsT_RiskStatistics_t')
class(`SequenceStatistics_errorEstimate`) = c("SWIGFunction", class('SequenceStatistics_errorEstimate'))

# Start of SequenceStatistics_skewness

`SequenceStatistics_skewness` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_SequenceStatistics_skewness', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_double_std__allocatorT_double_t_t";
  
  ans
  
}

attr(`SequenceStatistics_skewness`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`SequenceStatistics_skewness`, "inputTypes") = c('_p_GenericSequenceStatisticsT_RiskStatistics_t')
class(`SequenceStatistics_skewness`) = c("SWIGFunction", class('SequenceStatistics_skewness'))

# Start of SequenceStatistics_kurtosis

`SequenceStatistics_kurtosis` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_SequenceStatistics_kurtosis', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_double_std__allocatorT_double_t_t";
  
  ans
  
}

attr(`SequenceStatistics_kurtosis`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`SequenceStatistics_kurtosis`, "inputTypes") = c('_p_GenericSequenceStatisticsT_RiskStatistics_t')
class(`SequenceStatistics_kurtosis`) = c("SWIGFunction", class('SequenceStatistics_kurtosis'))

# Start of SequenceStatistics_min

`SequenceStatistics_min` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_SequenceStatistics_min', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_double_std__allocatorT_double_t_t";
  
  ans
  
}

attr(`SequenceStatistics_min`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`SequenceStatistics_min`, "inputTypes") = c('_p_GenericSequenceStatisticsT_RiskStatistics_t')
class(`SequenceStatistics_min`) = c("SWIGFunction", class('SequenceStatistics_min'))

# Start of SequenceStatistics_max

`SequenceStatistics_max` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_SequenceStatistics_max', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_double_std__allocatorT_double_t_t";
  
  ans
  
}

attr(`SequenceStatistics_max`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`SequenceStatistics_max`, "inputTypes") = c('_p_GenericSequenceStatisticsT_RiskStatistics_t')
class(`SequenceStatistics_max`) = c("SWIGFunction", class('SequenceStatistics_max'))

# Start of SequenceStatistics_covariance

`SequenceStatistics_covariance` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_SequenceStatistics_covariance', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Matrix";
  
  ans
  
}

attr(`SequenceStatistics_covariance`, 'returnType') = '_p_Matrix'
attr(`SequenceStatistics_covariance`, "inputTypes") = c('_p_GenericSequenceStatisticsT_RiskStatistics_t')
class(`SequenceStatistics_covariance`) = c("SWIGFunction", class('SequenceStatistics_covariance'))

# Start of SequenceStatistics_correlation

`SequenceStatistics_correlation` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_SequenceStatistics_correlation', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Matrix";
  
  ans
  
}

attr(`SequenceStatistics_correlation`, 'returnType') = '_p_Matrix'
attr(`SequenceStatistics_correlation`, "inputTypes") = c('_p_GenericSequenceStatisticsT_RiskStatistics_t')
class(`SequenceStatistics_correlation`) = c("SWIGFunction", class('SequenceStatistics_correlation'))

# Start of SequenceStatistics_reset

`SequenceStatistics_reset` = function(self)
{
  ;.Call('R_swig_SequenceStatistics_reset', self, PACKAGE='QuantLib');
  
}

attr(`SequenceStatistics_reset`, 'returnType') = 'void'
attr(`SequenceStatistics_reset`, "inputTypes") = c('_p_GenericSequenceStatisticsT_RiskStatistics_t')
class(`SequenceStatistics_reset`) = c("SWIGFunction", class('SequenceStatistics_reset'))

# Start of SequenceStatistics_add

`SequenceStatistics_add__SWIG_0` = function(self, value, weight)
{
  ;.Call('R_swig_SequenceStatistics_add__SWIG_0', self, value, weight, PACKAGE='QuantLib');
  
}

attr(`SequenceStatistics_add__SWIG_0`, 'returnType') = 'void'
attr(`SequenceStatistics_add__SWIG_0`, "inputTypes") = c('_p_GenericSequenceStatisticsT_RiskStatistics_t', '_p_std__vectorT_double_std__allocatorT_double_t_t', 'numeric')
class(`SequenceStatistics_add__SWIG_0`) = c("SWIGFunction", class('SequenceStatistics_add__SWIG_0'))

# Start of SequenceStatistics_add

`SequenceStatistics_add__SWIG_1` = function(self, value)
{
  ;.Call('R_swig_SequenceStatistics_add__SWIG_1', self, value, PACKAGE='QuantLib');
  
}

attr(`SequenceStatistics_add__SWIG_1`, 'returnType') = 'void'
attr(`SequenceStatistics_add__SWIG_1`, "inputTypes") = c('_p_GenericSequenceStatisticsT_RiskStatistics_t', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`SequenceStatistics_add__SWIG_1`) = c("SWIGFunction", class('SequenceStatistics_add__SWIG_1'))

# Start of SequenceStatistics_add

`SequenceStatistics_add__SWIG_2` = function(self, value, weight)
{
  ;.Call('R_swig_SequenceStatistics_add__SWIG_2', self, value, weight, PACKAGE='QuantLib');
  
}

attr(`SequenceStatistics_add__SWIG_2`, 'returnType') = 'void'
attr(`SequenceStatistics_add__SWIG_2`, "inputTypes") = c('_p_GenericSequenceStatisticsT_RiskStatistics_t', '_p_Array', 'numeric')
class(`SequenceStatistics_add__SWIG_2`) = c("SWIGFunction", class('SequenceStatistics_add__SWIG_2'))

# Start of SequenceStatistics_add

`SequenceStatistics_add__SWIG_3` = function(self, value)
{
  ;.Call('R_swig_SequenceStatistics_add__SWIG_3', self, value, PACKAGE='QuantLib');
  
}

attr(`SequenceStatistics_add__SWIG_3`, 'returnType') = 'void'
attr(`SequenceStatistics_add__SWIG_3`, "inputTypes") = c('_p_GenericSequenceStatisticsT_RiskStatistics_t', '_p_Array')
class(`SequenceStatistics_add__SWIG_3`) = c("SWIGFunction", class('SequenceStatistics_add__SWIG_3'))

`SequenceStatistics_add` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 2) {
    if (extends(argtypes[1], '_p_GenericSequenceStatisticsT_RiskStatistics_t') && extends(argtypes[2], '_p_Array')) {
      f <- SequenceStatistics_add__SWIG_3; 
    }
    else if (extends(argtypes[1], '_p_GenericSequenceStatisticsT_RiskStatistics_t') && extends(argtypes[2], '_p_std__vectorT_double_std__allocatorT_double_t_t')) {
      f <- SequenceStatistics_add__SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_GenericSequenceStatisticsT_RiskStatistics_t') && extends(argtypes[2], '_p_Array') && is.numeric(argv[[3]])) {
      f <- SequenceStatistics_add__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_GenericSequenceStatisticsT_RiskStatistics_t') && extends(argtypes[2], '_p_std__vectorT_double_std__allocatorT_double_t_t') && is.numeric(argv[[3]])) {
      f <- SequenceStatistics_add__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for SequenceStatistics_add with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_SequenceStatistics

`delete_SequenceStatistics` = function(self)
{
  ;.Call('R_swig_delete_SequenceStatistics', self, PACKAGE='QuantLib');
  
}

attr(`delete_SequenceStatistics`, 'returnType') = 'void'
attr(`delete_SequenceStatistics`, "inputTypes") = c('_p_GenericSequenceStatisticsT_RiskStatistics_t')
class(`delete_SequenceStatistics`) = c("SWIGFunction", class('delete_SequenceStatistics'))

# Start of accessor method for GenericSequenceStatistics<(RiskStatistics)>
setMethod('$', '_p_GenericSequenceStatisticsT_RiskStatistics_t', function(x, name)

{
  accessorFuns = list('size' = SequenceStatistics_size, 'samples' = SequenceStatistics_samples, 'weightSum' = SequenceStatistics_weightSum, 'mean' = SequenceStatistics_mean, 'variance' = SequenceStatistics_variance, 'standardDeviation' = SequenceStatistics_standardDeviation, 'errorEstimate' = SequenceStatistics_errorEstimate, 'skewness' = SequenceStatistics_skewness, 'kurtosis' = SequenceStatistics_kurtosis, 'min' = SequenceStatistics_min, 'max' = SequenceStatistics_max, 'covariance' = SequenceStatistics_covariance, 'correlation' = SequenceStatistics_correlation, 'add' = SequenceStatistics_add);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for GenericSequenceStatistics<(RiskStatistics)>
# Start of accessor method for GenericSequenceStatistics<(RiskStatistics)>
setMethod('$<-', '_p_GenericSequenceStatisticsT_RiskStatistics_t', function(x, name, value)

{
  accessorFuns = list('reset' = SequenceStatistics_reset);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_GenericSequenceStatisticsT_RiskStatistics_t', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('reset' = SequenceStatistics_reset);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for GenericSequenceStatistics<(RiskStatistics)>
setMethod('delete', '_p_GenericSequenceStatisticsT_RiskStatistics_t', function(obj) {delete_GenericSequenceStatisticsT_RiskStatistics_t(obj)})
# Start of new_MultipleIncrementalStatistics

`MultipleIncrementalStatistics` = function(dimension)
{
  if(length(dimension) > 1) {
    warning("using only the first element of dimension");
  };
  
  ;ans = .Call('R_swig_new_MultipleIncrementalStatistics', dimension, PACKAGE='QuantLib');
  class(ans) <- "_p_GenericSequenceStatisticsT_IncrementalStatistics_t";
  
  reg.finalizer(ans, delete_MultipleIncrementalStatistics)
  ans
  
}

attr(`MultipleIncrementalStatistics`, 'returnType') = '_p_GenericSequenceStatisticsT_IncrementalStatistics_t'
attr(`MultipleIncrementalStatistics`, "inputTypes") = c('integer')
class(`MultipleIncrementalStatistics`) = c("SWIGFunction", class('MultipleIncrementalStatistics'))

# Start of MultipleIncrementalStatistics_size

`MultipleIncrementalStatistics_size` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_MultipleIncrementalStatistics_size', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__size_t";
  
  ans
  
}

attr(`MultipleIncrementalStatistics_size`, 'returnType') = 'integer'
attr(`MultipleIncrementalStatistics_size`, "inputTypes") = c('_p_GenericSequenceStatisticsT_IncrementalStatistics_t')
class(`MultipleIncrementalStatistics_size`) = c("SWIGFunction", class('MultipleIncrementalStatistics_size'))

# Start of MultipleIncrementalStatistics_samples

`MultipleIncrementalStatistics_samples` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_MultipleIncrementalStatistics_samples', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__size_t";
  
  ans
  
}

attr(`MultipleIncrementalStatistics_samples`, 'returnType') = 'integer'
attr(`MultipleIncrementalStatistics_samples`, "inputTypes") = c('_p_GenericSequenceStatisticsT_IncrementalStatistics_t')
class(`MultipleIncrementalStatistics_samples`) = c("SWIGFunction", class('MultipleIncrementalStatistics_samples'))

# Start of MultipleIncrementalStatistics_weightSum

`MultipleIncrementalStatistics_weightSum` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_MultipleIncrementalStatistics_weightSum', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`MultipleIncrementalStatistics_weightSum`, 'returnType') = 'numeric'
attr(`MultipleIncrementalStatistics_weightSum`, "inputTypes") = c('_p_GenericSequenceStatisticsT_IncrementalStatistics_t')
class(`MultipleIncrementalStatistics_weightSum`) = c("SWIGFunction", class('MultipleIncrementalStatistics_weightSum'))

# Start of MultipleIncrementalStatistics_mean

`MultipleIncrementalStatistics_mean` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_MultipleIncrementalStatistics_mean', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_double_std__allocatorT_double_t_t";
  
  ans
  
}

attr(`MultipleIncrementalStatistics_mean`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`MultipleIncrementalStatistics_mean`, "inputTypes") = c('_p_GenericSequenceStatisticsT_IncrementalStatistics_t')
class(`MultipleIncrementalStatistics_mean`) = c("SWIGFunction", class('MultipleIncrementalStatistics_mean'))

# Start of MultipleIncrementalStatistics_variance

`MultipleIncrementalStatistics_variance` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_MultipleIncrementalStatistics_variance', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_double_std__allocatorT_double_t_t";
  
  ans
  
}

attr(`MultipleIncrementalStatistics_variance`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`MultipleIncrementalStatistics_variance`, "inputTypes") = c('_p_GenericSequenceStatisticsT_IncrementalStatistics_t')
class(`MultipleIncrementalStatistics_variance`) = c("SWIGFunction", class('MultipleIncrementalStatistics_variance'))

# Start of MultipleIncrementalStatistics_standardDeviation

`MultipleIncrementalStatistics_standardDeviation` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_MultipleIncrementalStatistics_standardDeviation', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_double_std__allocatorT_double_t_t";
  
  ans
  
}

attr(`MultipleIncrementalStatistics_standardDeviation`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`MultipleIncrementalStatistics_standardDeviation`, "inputTypes") = c('_p_GenericSequenceStatisticsT_IncrementalStatistics_t')
class(`MultipleIncrementalStatistics_standardDeviation`) = c("SWIGFunction", class('MultipleIncrementalStatistics_standardDeviation'))

# Start of MultipleIncrementalStatistics_errorEstimate

`MultipleIncrementalStatistics_errorEstimate` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_MultipleIncrementalStatistics_errorEstimate', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_double_std__allocatorT_double_t_t";
  
  ans
  
}

attr(`MultipleIncrementalStatistics_errorEstimate`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`MultipleIncrementalStatistics_errorEstimate`, "inputTypes") = c('_p_GenericSequenceStatisticsT_IncrementalStatistics_t')
class(`MultipleIncrementalStatistics_errorEstimate`) = c("SWIGFunction", class('MultipleIncrementalStatistics_errorEstimate'))

# Start of MultipleIncrementalStatistics_skewness

`MultipleIncrementalStatistics_skewness` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_MultipleIncrementalStatistics_skewness', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_double_std__allocatorT_double_t_t";
  
  ans
  
}

attr(`MultipleIncrementalStatistics_skewness`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`MultipleIncrementalStatistics_skewness`, "inputTypes") = c('_p_GenericSequenceStatisticsT_IncrementalStatistics_t')
class(`MultipleIncrementalStatistics_skewness`) = c("SWIGFunction", class('MultipleIncrementalStatistics_skewness'))

# Start of MultipleIncrementalStatistics_kurtosis

`MultipleIncrementalStatistics_kurtosis` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_MultipleIncrementalStatistics_kurtosis', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_double_std__allocatorT_double_t_t";
  
  ans
  
}

attr(`MultipleIncrementalStatistics_kurtosis`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`MultipleIncrementalStatistics_kurtosis`, "inputTypes") = c('_p_GenericSequenceStatisticsT_IncrementalStatistics_t')
class(`MultipleIncrementalStatistics_kurtosis`) = c("SWIGFunction", class('MultipleIncrementalStatistics_kurtosis'))

# Start of MultipleIncrementalStatistics_min

`MultipleIncrementalStatistics_min` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_MultipleIncrementalStatistics_min', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_double_std__allocatorT_double_t_t";
  
  ans
  
}

attr(`MultipleIncrementalStatistics_min`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`MultipleIncrementalStatistics_min`, "inputTypes") = c('_p_GenericSequenceStatisticsT_IncrementalStatistics_t')
class(`MultipleIncrementalStatistics_min`) = c("SWIGFunction", class('MultipleIncrementalStatistics_min'))

# Start of MultipleIncrementalStatistics_max

`MultipleIncrementalStatistics_max` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_MultipleIncrementalStatistics_max', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_double_std__allocatorT_double_t_t";
  
  ans
  
}

attr(`MultipleIncrementalStatistics_max`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`MultipleIncrementalStatistics_max`, "inputTypes") = c('_p_GenericSequenceStatisticsT_IncrementalStatistics_t')
class(`MultipleIncrementalStatistics_max`) = c("SWIGFunction", class('MultipleIncrementalStatistics_max'))

# Start of MultipleIncrementalStatistics_covariance

`MultipleIncrementalStatistics_covariance` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_MultipleIncrementalStatistics_covariance', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Matrix";
  
  ans
  
}

attr(`MultipleIncrementalStatistics_covariance`, 'returnType') = '_p_Matrix'
attr(`MultipleIncrementalStatistics_covariance`, "inputTypes") = c('_p_GenericSequenceStatisticsT_IncrementalStatistics_t')
class(`MultipleIncrementalStatistics_covariance`) = c("SWIGFunction", class('MultipleIncrementalStatistics_covariance'))

# Start of MultipleIncrementalStatistics_correlation

`MultipleIncrementalStatistics_correlation` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_MultipleIncrementalStatistics_correlation', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_Matrix";
  
  ans
  
}

attr(`MultipleIncrementalStatistics_correlation`, 'returnType') = '_p_Matrix'
attr(`MultipleIncrementalStatistics_correlation`, "inputTypes") = c('_p_GenericSequenceStatisticsT_IncrementalStatistics_t')
class(`MultipleIncrementalStatistics_correlation`) = c("SWIGFunction", class('MultipleIncrementalStatistics_correlation'))

# Start of MultipleIncrementalStatistics_reset

`MultipleIncrementalStatistics_reset` = function(self)
{
  ;.Call('R_swig_MultipleIncrementalStatistics_reset', self, PACKAGE='QuantLib');
  
}

attr(`MultipleIncrementalStatistics_reset`, 'returnType') = 'void'
attr(`MultipleIncrementalStatistics_reset`, "inputTypes") = c('_p_GenericSequenceStatisticsT_IncrementalStatistics_t')
class(`MultipleIncrementalStatistics_reset`) = c("SWIGFunction", class('MultipleIncrementalStatistics_reset'))

# Start of MultipleIncrementalStatistics_add

`MultipleIncrementalStatistics_add__SWIG_0` = function(self, value, weight)
{
  ;.Call('R_swig_MultipleIncrementalStatistics_add__SWIG_0', self, value, weight, PACKAGE='QuantLib');
  
}

attr(`MultipleIncrementalStatistics_add__SWIG_0`, 'returnType') = 'void'
attr(`MultipleIncrementalStatistics_add__SWIG_0`, "inputTypes") = c('_p_GenericSequenceStatisticsT_IncrementalStatistics_t', '_p_std__vectorT_double_std__allocatorT_double_t_t', 'numeric')
class(`MultipleIncrementalStatistics_add__SWIG_0`) = c("SWIGFunction", class('MultipleIncrementalStatistics_add__SWIG_0'))

# Start of MultipleIncrementalStatistics_add

`MultipleIncrementalStatistics_add__SWIG_1` = function(self, value)
{
  ;.Call('R_swig_MultipleIncrementalStatistics_add__SWIG_1', self, value, PACKAGE='QuantLib');
  
}

attr(`MultipleIncrementalStatistics_add__SWIG_1`, 'returnType') = 'void'
attr(`MultipleIncrementalStatistics_add__SWIG_1`, "inputTypes") = c('_p_GenericSequenceStatisticsT_IncrementalStatistics_t', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`MultipleIncrementalStatistics_add__SWIG_1`) = c("SWIGFunction", class('MultipleIncrementalStatistics_add__SWIG_1'))

# Start of MultipleIncrementalStatistics_add

`MultipleIncrementalStatistics_add__SWIG_2` = function(self, value, weight)
{
  ;.Call('R_swig_MultipleIncrementalStatistics_add__SWIG_2', self, value, weight, PACKAGE='QuantLib');
  
}

attr(`MultipleIncrementalStatistics_add__SWIG_2`, 'returnType') = 'void'
attr(`MultipleIncrementalStatistics_add__SWIG_2`, "inputTypes") = c('_p_GenericSequenceStatisticsT_IncrementalStatistics_t', '_p_Array', 'numeric')
class(`MultipleIncrementalStatistics_add__SWIG_2`) = c("SWIGFunction", class('MultipleIncrementalStatistics_add__SWIG_2'))

# Start of MultipleIncrementalStatistics_add

`MultipleIncrementalStatistics_add__SWIG_3` = function(self, value)
{
  ;.Call('R_swig_MultipleIncrementalStatistics_add__SWIG_3', self, value, PACKAGE='QuantLib');
  
}

attr(`MultipleIncrementalStatistics_add__SWIG_3`, 'returnType') = 'void'
attr(`MultipleIncrementalStatistics_add__SWIG_3`, "inputTypes") = c('_p_GenericSequenceStatisticsT_IncrementalStatistics_t', '_p_Array')
class(`MultipleIncrementalStatistics_add__SWIG_3`) = c("SWIGFunction", class('MultipleIncrementalStatistics_add__SWIG_3'))

`MultipleIncrementalStatistics_add` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 2) {
    if (extends(argtypes[1], '_p_GenericSequenceStatisticsT_IncrementalStatistics_t') && extends(argtypes[2], '_p_Array')) {
      f <- MultipleIncrementalStatistics_add__SWIG_3; 
    }
    else if (extends(argtypes[1], '_p_GenericSequenceStatisticsT_IncrementalStatistics_t') && extends(argtypes[2], '_p_std__vectorT_double_std__allocatorT_double_t_t')) {
      f <- MultipleIncrementalStatistics_add__SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_GenericSequenceStatisticsT_IncrementalStatistics_t') && extends(argtypes[2], '_p_Array') && is.numeric(argv[[3]])) {
      f <- MultipleIncrementalStatistics_add__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_GenericSequenceStatisticsT_IncrementalStatistics_t') && extends(argtypes[2], '_p_std__vectorT_double_std__allocatorT_double_t_t') && is.numeric(argv[[3]])) {
      f <- MultipleIncrementalStatistics_add__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for MultipleIncrementalStatistics_add with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_MultipleIncrementalStatistics

`delete_MultipleIncrementalStatistics` = function(self)
{
  ;.Call('R_swig_delete_MultipleIncrementalStatistics', self, PACKAGE='QuantLib');
  
}

attr(`delete_MultipleIncrementalStatistics`, 'returnType') = 'void'
attr(`delete_MultipleIncrementalStatistics`, "inputTypes") = c('_p_GenericSequenceStatisticsT_IncrementalStatistics_t')
class(`delete_MultipleIncrementalStatistics`) = c("SWIGFunction", class('delete_MultipleIncrementalStatistics'))

# Start of accessor method for GenericSequenceStatistics<(IncrementalStatistics)>
setMethod('$', '_p_GenericSequenceStatisticsT_IncrementalStatistics_t', function(x, name)

{
  accessorFuns = list('size' = MultipleIncrementalStatistics_size, 'samples' = MultipleIncrementalStatistics_samples, 'weightSum' = MultipleIncrementalStatistics_weightSum, 'mean' = MultipleIncrementalStatistics_mean, 'variance' = MultipleIncrementalStatistics_variance, 'standardDeviation' = MultipleIncrementalStatistics_standardDeviation, 'errorEstimate' = MultipleIncrementalStatistics_errorEstimate, 'skewness' = MultipleIncrementalStatistics_skewness, 'kurtosis' = MultipleIncrementalStatistics_kurtosis, 'min' = MultipleIncrementalStatistics_min, 'max' = MultipleIncrementalStatistics_max, 'covariance' = MultipleIncrementalStatistics_covariance, 'correlation' = MultipleIncrementalStatistics_correlation, 'add' = MultipleIncrementalStatistics_add);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for GenericSequenceStatistics<(IncrementalStatistics)>
# Start of accessor method for GenericSequenceStatistics<(IncrementalStatistics)>
setMethod('$<-', '_p_GenericSequenceStatisticsT_IncrementalStatistics_t', function(x, name, value)

{
  accessorFuns = list('reset' = MultipleIncrementalStatistics_reset);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_GenericSequenceStatisticsT_IncrementalStatistics_t', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('reset' = MultipleIncrementalStatistics_reset);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for GenericSequenceStatistics<(IncrementalStatistics)>
setMethod('delete', '_p_GenericSequenceStatisticsT_IncrementalStatistics_t', function(obj) {delete_GenericSequenceStatisticsT_IncrementalStatistics_t(obj)})
# Start of CapFloorTermVolatilityStructure___deref__

`CapFloorTermVolatilityStructure___deref__` = function(self)
{
  ;ans = .Call('R_swig_CapFloorTermVolatilityStructure___deref__', self, PACKAGE='QuantLib');
  class(ans) <- "_p_CapFloorTermVolatilityStructure";
  
  ans
  
}

attr(`CapFloorTermVolatilityStructure___deref__`, 'returnType') = '_p_CapFloorTermVolatilityStructure'
attr(`CapFloorTermVolatilityStructure___deref__`, "inputTypes") = c('_p_boost__shared_ptrT_CapFloorTermVolatilityStructure_t')
class(`CapFloorTermVolatilityStructure___deref__`) = c("SWIGFunction", class('CapFloorTermVolatilityStructure___deref__'))

# Start of CapFloorTermVolatilityStructure_isNull

`CapFloorTermVolatilityStructure_isNull` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_CapFloorTermVolatilityStructure_isNull', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CapFloorTermVolatilityStructure_isNull`, 'returnType') = 'logical'
attr(`CapFloorTermVolatilityStructure_isNull`, "inputTypes") = c('_p_boost__shared_ptrT_CapFloorTermVolatilityStructure_t')
class(`CapFloorTermVolatilityStructure_isNull`) = c("SWIGFunction", class('CapFloorTermVolatilityStructure_isNull'))

# Start of CapFloorTermVolatilityStructure_asObservable

`CapFloorTermVolatilityStructure_asObservable` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_CapFloorTermVolatilityStructure_asObservable', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_Observable_t";
  
  ans
  
}

attr(`CapFloorTermVolatilityStructure_asObservable`, 'returnType') = '_p_boost__shared_ptrT_Observable_t'
attr(`CapFloorTermVolatilityStructure_asObservable`, "inputTypes") = c('_p_boost__shared_ptrT_CapFloorTermVolatilityStructure_t')
class(`CapFloorTermVolatilityStructure_asObservable`) = c("SWIGFunction", class('CapFloorTermVolatilityStructure_asObservable'))

# Start of new_CapFloorTermVolatilityStructure

`CapFloorTermVolatilityStructure` = function()
{
  ;ans = .Call('R_swig_new_CapFloorTermVolatilityStructure', PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_CapFloorTermVolatilityStructure_t";
  
  reg.finalizer(ans, delete_CapFloorTermVolatilityStructure)
  ans
  
}

attr(`CapFloorTermVolatilityStructure`, 'returnType') = '_p_boost__shared_ptrT_CapFloorTermVolatilityStructure_t'
class(`CapFloorTermVolatilityStructure`) = c("SWIGFunction", class('CapFloorTermVolatilityStructure'))

# Start of delete_CapFloorTermVolatilityStructure

`delete_CapFloorTermVolatilityStructure` = function(self)
{
  ;.Call('R_swig_delete_CapFloorTermVolatilityStructure', self, PACKAGE='QuantLib');
  
}

attr(`delete_CapFloorTermVolatilityStructure`, 'returnType') = 'void'
attr(`delete_CapFloorTermVolatilityStructure`, "inputTypes") = c('_p_boost__shared_ptrT_CapFloorTermVolatilityStructure_t')
class(`delete_CapFloorTermVolatilityStructure`) = c("SWIGFunction", class('delete_CapFloorTermVolatilityStructure'))

# Start of CapFloorTermVolatilityStructure_volatility

`CapFloorTermVolatilityStructure_volatility__SWIG_0` = function(self, length, strike, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_CapFloorTermVolatilityStructure_volatility__SWIG_0', self, length, strike, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CapFloorTermVolatilityStructure_volatility__SWIG_0`, 'returnType') = 'numeric'
attr(`CapFloorTermVolatilityStructure_volatility__SWIG_0`, "inputTypes") = c('_p_boost__shared_ptrT_CapFloorTermVolatilityStructure_t', '_p_Period', 'numeric', 'logical')
class(`CapFloorTermVolatilityStructure_volatility__SWIG_0`) = c("SWIGFunction", class('CapFloorTermVolatilityStructure_volatility__SWIG_0'))

# Start of CapFloorTermVolatilityStructure_volatility

`CapFloorTermVolatilityStructure_volatility__SWIG_1` = function(self, length, strike, .copy = FALSE)
{
  ;.Call('R_swig_CapFloorTermVolatilityStructure_volatility__SWIG_1', self, length, strike, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CapFloorTermVolatilityStructure_volatility__SWIG_1`, 'returnType') = 'numeric'
attr(`CapFloorTermVolatilityStructure_volatility__SWIG_1`, "inputTypes") = c('_p_boost__shared_ptrT_CapFloorTermVolatilityStructure_t', '_p_Period', 'numeric')
class(`CapFloorTermVolatilityStructure_volatility__SWIG_1`) = c("SWIGFunction", class('CapFloorTermVolatilityStructure_volatility__SWIG_1'))

# Start of CapFloorTermVolatilityStructure_volatility

`CapFloorTermVolatilityStructure_volatility__SWIG_2` = function(self, end, strike, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_CapFloorTermVolatilityStructure_volatility__SWIG_2', self, end, strike, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CapFloorTermVolatilityStructure_volatility__SWIG_2`, 'returnType') = 'numeric'
attr(`CapFloorTermVolatilityStructure_volatility__SWIG_2`, "inputTypes") = c('_p_boost__shared_ptrT_CapFloorTermVolatilityStructure_t', '_p_Date', 'numeric', 'logical')
class(`CapFloorTermVolatilityStructure_volatility__SWIG_2`) = c("SWIGFunction", class('CapFloorTermVolatilityStructure_volatility__SWIG_2'))

# Start of CapFloorTermVolatilityStructure_volatility

`CapFloorTermVolatilityStructure_volatility__SWIG_3` = function(self, end, strike, .copy = FALSE)
{
  ;.Call('R_swig_CapFloorTermVolatilityStructure_volatility__SWIG_3', self, end, strike, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CapFloorTermVolatilityStructure_volatility__SWIG_3`, 'returnType') = 'numeric'
attr(`CapFloorTermVolatilityStructure_volatility__SWIG_3`, "inputTypes") = c('_p_boost__shared_ptrT_CapFloorTermVolatilityStructure_t', '_p_Date', 'numeric')
class(`CapFloorTermVolatilityStructure_volatility__SWIG_3`) = c("SWIGFunction", class('CapFloorTermVolatilityStructure_volatility__SWIG_3'))

# Start of CapFloorTermVolatilityStructure_volatility

`CapFloorTermVolatilityStructure_volatility__SWIG_4` = function(self, end, strike, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_CapFloorTermVolatilityStructure_volatility__SWIG_4', self, end, strike, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CapFloorTermVolatilityStructure_volatility__SWIG_4`, 'returnType') = 'numeric'
attr(`CapFloorTermVolatilityStructure_volatility__SWIG_4`, "inputTypes") = c('_p_boost__shared_ptrT_CapFloorTermVolatilityStructure_t', 'numeric', 'numeric', 'logical')
class(`CapFloorTermVolatilityStructure_volatility__SWIG_4`) = c("SWIGFunction", class('CapFloorTermVolatilityStructure_volatility__SWIG_4'))

# Start of CapFloorTermVolatilityStructure_volatility

`CapFloorTermVolatilityStructure_volatility__SWIG_5` = function(self, end, strike, .copy = FALSE)
{
  ;.Call('R_swig_CapFloorTermVolatilityStructure_volatility__SWIG_5', self, end, strike, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CapFloorTermVolatilityStructure_volatility__SWIG_5`, 'returnType') = 'numeric'
attr(`CapFloorTermVolatilityStructure_volatility__SWIG_5`, "inputTypes") = c('_p_boost__shared_ptrT_CapFloorTermVolatilityStructure_t', 'numeric', 'numeric')
class(`CapFloorTermVolatilityStructure_volatility__SWIG_5`) = c("SWIGFunction", class('CapFloorTermVolatilityStructure_volatility__SWIG_5'))

`CapFloorTermVolatilityStructure_volatility` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 6
  if (argc == 3) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_CapFloorTermVolatilityStructure_t') && extends(argtypes[2], '_p_Period') && is.numeric(argv[[3]])) {
      f <- CapFloorTermVolatilityStructure_volatility__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_boost__shared_ptrT_CapFloorTermVolatilityStructure_t') && extends(argtypes[2], '_p_Date') && is.numeric(argv[[3]])) {
      f <- CapFloorTermVolatilityStructure_volatility__SWIG_3; 
    }
    else if (extends(argtypes[1], '_p_boost__shared_ptrT_CapFloorTermVolatilityStructure_t') && is.numeric(argv[[2]]) && is.numeric(argv[[3]])) {
      f <- CapFloorTermVolatilityStructure_volatility__SWIG_5; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_CapFloorTermVolatilityStructure_t') && extends(argtypes[2], '_p_Period') && is.numeric(argv[[3]]) && extends(argtypes[4], 'logical')) {
      f <- CapFloorTermVolatilityStructure_volatility__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_boost__shared_ptrT_CapFloorTermVolatilityStructure_t') && extends(argtypes[2], '_p_Date') && is.numeric(argv[[3]]) && extends(argtypes[4], 'logical')) {
      f <- CapFloorTermVolatilityStructure_volatility__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_boost__shared_ptrT_CapFloorTermVolatilityStructure_t') && is.numeric(argv[[2]]) && is.numeric(argv[[3]]) && extends(argtypes[4], 'logical')) {
      f <- CapFloorTermVolatilityStructure_volatility__SWIG_4; 
    }
  } else {
    stop("cannot find overloaded function for CapFloorTermVolatilityStructure_volatility with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of CapFloorTermVolatilityStructure_enableExtrapolation

`CapFloorTermVolatilityStructure_enableExtrapolation` = function(self)
{
  ;.Call('R_swig_CapFloorTermVolatilityStructure_enableExtrapolation', self, PACKAGE='QuantLib');
  
}

attr(`CapFloorTermVolatilityStructure_enableExtrapolation`, 'returnType') = 'void'
attr(`CapFloorTermVolatilityStructure_enableExtrapolation`, "inputTypes") = c('_p_boost__shared_ptrT_CapFloorTermVolatilityStructure_t')
class(`CapFloorTermVolatilityStructure_enableExtrapolation`) = c("SWIGFunction", class('CapFloorTermVolatilityStructure_enableExtrapolation'))

# Start of CapFloorTermVolatilityStructure_disableExtrapolation

`CapFloorTermVolatilityStructure_disableExtrapolation` = function(self)
{
  ;.Call('R_swig_CapFloorTermVolatilityStructure_disableExtrapolation', self, PACKAGE='QuantLib');
  
}

attr(`CapFloorTermVolatilityStructure_disableExtrapolation`, 'returnType') = 'void'
attr(`CapFloorTermVolatilityStructure_disableExtrapolation`, "inputTypes") = c('_p_boost__shared_ptrT_CapFloorTermVolatilityStructure_t')
class(`CapFloorTermVolatilityStructure_disableExtrapolation`) = c("SWIGFunction", class('CapFloorTermVolatilityStructure_disableExtrapolation'))

# Start of CapFloorTermVolatilityStructure_allowsExtrapolation

`CapFloorTermVolatilityStructure_allowsExtrapolation` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_CapFloorTermVolatilityStructure_allowsExtrapolation', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CapFloorTermVolatilityStructure_allowsExtrapolation`, 'returnType') = 'logical'
attr(`CapFloorTermVolatilityStructure_allowsExtrapolation`, "inputTypes") = c('_p_boost__shared_ptrT_CapFloorTermVolatilityStructure_t')
class(`CapFloorTermVolatilityStructure_allowsExtrapolation`) = c("SWIGFunction", class('CapFloorTermVolatilityStructure_allowsExtrapolation'))

# Start of accessor method for boost::shared_ptr<(CapFloorTermVolatilityStructure)>
setMethod('$', '_p_boost__shared_ptrT_CapFloorTermVolatilityStructure_t', function(x, name)

{
  accessorFuns = list('__deref__' = CapFloorTermVolatilityStructure___deref__, 'isNull' = CapFloorTermVolatilityStructure_isNull, 'asObservable' = CapFloorTermVolatilityStructure_asObservable, 'volatility' = CapFloorTermVolatilityStructure_volatility, 'enableExtrapolation' = CapFloorTermVolatilityStructure_enableExtrapolation, 'disableExtrapolation' = CapFloorTermVolatilityStructure_disableExtrapolation, 'allowsExtrapolation' = CapFloorTermVolatilityStructure_allowsExtrapolation);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for boost::shared_ptr<(CapFloorTermVolatilityStructure)>
setMethod('delete', '_p_boost__shared_ptrT_CapFloorTermVolatilityStructure_t', function(obj) {delete_boost__shared_ptrT_CapFloorTermVolatilityStructure_t(obj)})
# Start of new_CapFloorTermVolatilityStructureHandle

`CapFloorTermVolatilityStructureHandle__SWIG_0` = function(s_arg1)
{
  ;ans = .Call('R_swig_new_CapFloorTermVolatilityStructureHandle__SWIG_0', s_arg1, PACKAGE='QuantLib');
  class(ans) <- "_p_HandleT_CapFloorTermVolatilityStructure_t";
  
  reg.finalizer(ans, delete_CapFloorTermVolatilityStructureHandle)
  ans
  
}

attr(`CapFloorTermVolatilityStructureHandle__SWIG_0`, 'returnType') = '_p_HandleT_CapFloorTermVolatilityStructure_t'
attr(`CapFloorTermVolatilityStructureHandle__SWIG_0`, "inputTypes") = c('_p_boost__shared_ptrT_CapFloorTermVolatilityStructure_t')
class(`CapFloorTermVolatilityStructureHandle__SWIG_0`) = c("SWIGFunction", class('CapFloorTermVolatilityStructureHandle__SWIG_0'))

# Start of new_CapFloorTermVolatilityStructureHandle

`CapFloorTermVolatilityStructureHandle__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_CapFloorTermVolatilityStructureHandle__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_HandleT_CapFloorTermVolatilityStructure_t";
  
  reg.finalizer(ans, delete_CapFloorTermVolatilityStructureHandle)
  ans
  
}

attr(`CapFloorTermVolatilityStructureHandle__SWIG_1`, 'returnType') = '_p_HandleT_CapFloorTermVolatilityStructure_t'
class(`CapFloorTermVolatilityStructureHandle__SWIG_1`) = c("SWIGFunction", class('CapFloorTermVolatilityStructureHandle__SWIG_1'))

`CapFloorTermVolatilityStructureHandle` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- CapFloorTermVolatilityStructureHandle__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_CapFloorTermVolatilityStructure_t')) {
      f <- CapFloorTermVolatilityStructureHandle__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for CapFloorTermVolatilityStructureHandle with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of CapFloorTermVolatilityStructureHandle___deref__

`CapFloorTermVolatilityStructureHandle___deref__` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_CapFloorTermVolatilityStructureHandle___deref__', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_CapFloorTermVolatilityStructure_t";
  
  ans
  
}

attr(`CapFloorTermVolatilityStructureHandle___deref__`, 'returnType') = '_p_boost__shared_ptrT_CapFloorTermVolatilityStructure_t'
attr(`CapFloorTermVolatilityStructureHandle___deref__`, "inputTypes") = c('_p_HandleT_CapFloorTermVolatilityStructure_t')
class(`CapFloorTermVolatilityStructureHandle___deref__`) = c("SWIGFunction", class('CapFloorTermVolatilityStructureHandle___deref__'))

# Start of CapFloorTermVolatilityStructureHandle_empty

`CapFloorTermVolatilityStructureHandle_empty` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_CapFloorTermVolatilityStructureHandle_empty', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CapFloorTermVolatilityStructureHandle_empty`, 'returnType') = 'logical'
attr(`CapFloorTermVolatilityStructureHandle_empty`, "inputTypes") = c('_p_HandleT_CapFloorTermVolatilityStructure_t')
class(`CapFloorTermVolatilityStructureHandle_empty`) = c("SWIGFunction", class('CapFloorTermVolatilityStructureHandle_empty'))

# Start of CapFloorTermVolatilityStructureHandle_asObservable

`CapFloorTermVolatilityStructureHandle_asObservable` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_CapFloorTermVolatilityStructureHandle_asObservable', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_Observable_t";
  
  ans
  
}

attr(`CapFloorTermVolatilityStructureHandle_asObservable`, 'returnType') = '_p_boost__shared_ptrT_Observable_t'
attr(`CapFloorTermVolatilityStructureHandle_asObservable`, "inputTypes") = c('_p_HandleT_CapFloorTermVolatilityStructure_t')
class(`CapFloorTermVolatilityStructureHandle_asObservable`) = c("SWIGFunction", class('CapFloorTermVolatilityStructureHandle_asObservable'))

# Start of delete_CapFloorTermVolatilityStructureHandle

`delete_CapFloorTermVolatilityStructureHandle` = function(self)
{
  ;.Call('R_swig_delete_CapFloorTermVolatilityStructureHandle', self, PACKAGE='QuantLib');
  
}

attr(`delete_CapFloorTermVolatilityStructureHandle`, 'returnType') = 'void'
attr(`delete_CapFloorTermVolatilityStructureHandle`, "inputTypes") = c('_p_HandleT_CapFloorTermVolatilityStructure_t')
class(`delete_CapFloorTermVolatilityStructureHandle`) = c("SWIGFunction", class('delete_CapFloorTermVolatilityStructureHandle'))

# Start of CapFloorTermVolatilityStructureHandle_volatility

`CapFloorTermVolatilityStructureHandle_volatility__SWIG_0` = function(self, length, strike, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_CapFloorTermVolatilityStructureHandle_volatility__SWIG_0', self, length, strike, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CapFloorTermVolatilityStructureHandle_volatility__SWIG_0`, 'returnType') = 'numeric'
attr(`CapFloorTermVolatilityStructureHandle_volatility__SWIG_0`, "inputTypes") = c('_p_HandleT_CapFloorTermVolatilityStructure_t', '_p_Period', 'numeric', 'logical')
class(`CapFloorTermVolatilityStructureHandle_volatility__SWIG_0`) = c("SWIGFunction", class('CapFloorTermVolatilityStructureHandle_volatility__SWIG_0'))

# Start of CapFloorTermVolatilityStructureHandle_volatility

`CapFloorTermVolatilityStructureHandle_volatility__SWIG_1` = function(self, length, strike, .copy = FALSE)
{
  ;.Call('R_swig_CapFloorTermVolatilityStructureHandle_volatility__SWIG_1', self, length, strike, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CapFloorTermVolatilityStructureHandle_volatility__SWIG_1`, 'returnType') = 'numeric'
attr(`CapFloorTermVolatilityStructureHandle_volatility__SWIG_1`, "inputTypes") = c('_p_HandleT_CapFloorTermVolatilityStructure_t', '_p_Period', 'numeric')
class(`CapFloorTermVolatilityStructureHandle_volatility__SWIG_1`) = c("SWIGFunction", class('CapFloorTermVolatilityStructureHandle_volatility__SWIG_1'))

# Start of CapFloorTermVolatilityStructureHandle_volatility

`CapFloorTermVolatilityStructureHandle_volatility__SWIG_2` = function(self, end, strike, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_CapFloorTermVolatilityStructureHandle_volatility__SWIG_2', self, end, strike, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CapFloorTermVolatilityStructureHandle_volatility__SWIG_2`, 'returnType') = 'numeric'
attr(`CapFloorTermVolatilityStructureHandle_volatility__SWIG_2`, "inputTypes") = c('_p_HandleT_CapFloorTermVolatilityStructure_t', '_p_Date', 'numeric', 'logical')
class(`CapFloorTermVolatilityStructureHandle_volatility__SWIG_2`) = c("SWIGFunction", class('CapFloorTermVolatilityStructureHandle_volatility__SWIG_2'))

# Start of CapFloorTermVolatilityStructureHandle_volatility

`CapFloorTermVolatilityStructureHandle_volatility__SWIG_3` = function(self, end, strike, .copy = FALSE)
{
  ;.Call('R_swig_CapFloorTermVolatilityStructureHandle_volatility__SWIG_3', self, end, strike, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CapFloorTermVolatilityStructureHandle_volatility__SWIG_3`, 'returnType') = 'numeric'
attr(`CapFloorTermVolatilityStructureHandle_volatility__SWIG_3`, "inputTypes") = c('_p_HandleT_CapFloorTermVolatilityStructure_t', '_p_Date', 'numeric')
class(`CapFloorTermVolatilityStructureHandle_volatility__SWIG_3`) = c("SWIGFunction", class('CapFloorTermVolatilityStructureHandle_volatility__SWIG_3'))

# Start of CapFloorTermVolatilityStructureHandle_volatility

`CapFloorTermVolatilityStructureHandle_volatility__SWIG_4` = function(self, end, strike, extrapolate, .copy = FALSE)
{
  extrapolate = as.logical(extrapolate);
  ;.Call('R_swig_CapFloorTermVolatilityStructureHandle_volatility__SWIG_4', self, end, strike, extrapolate, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CapFloorTermVolatilityStructureHandle_volatility__SWIG_4`, 'returnType') = 'numeric'
attr(`CapFloorTermVolatilityStructureHandle_volatility__SWIG_4`, "inputTypes") = c('_p_HandleT_CapFloorTermVolatilityStructure_t', 'numeric', 'numeric', 'logical')
class(`CapFloorTermVolatilityStructureHandle_volatility__SWIG_4`) = c("SWIGFunction", class('CapFloorTermVolatilityStructureHandle_volatility__SWIG_4'))

# Start of CapFloorTermVolatilityStructureHandle_volatility

`CapFloorTermVolatilityStructureHandle_volatility__SWIG_5` = function(self, end, strike, .copy = FALSE)
{
  ;.Call('R_swig_CapFloorTermVolatilityStructureHandle_volatility__SWIG_5', self, end, strike, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CapFloorTermVolatilityStructureHandle_volatility__SWIG_5`, 'returnType') = 'numeric'
attr(`CapFloorTermVolatilityStructureHandle_volatility__SWIG_5`, "inputTypes") = c('_p_HandleT_CapFloorTermVolatilityStructure_t', 'numeric', 'numeric')
class(`CapFloorTermVolatilityStructureHandle_volatility__SWIG_5`) = c("SWIGFunction", class('CapFloorTermVolatilityStructureHandle_volatility__SWIG_5'))

`CapFloorTermVolatilityStructureHandle_volatility` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 6
  if (argc == 3) {
    if (extends(argtypes[1], '_p_HandleT_CapFloorTermVolatilityStructure_t') && extends(argtypes[2], '_p_Period') && is.numeric(argv[[3]])) {
      f <- CapFloorTermVolatilityStructureHandle_volatility__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_HandleT_CapFloorTermVolatilityStructure_t') && extends(argtypes[2], '_p_Date') && is.numeric(argv[[3]])) {
      f <- CapFloorTermVolatilityStructureHandle_volatility__SWIG_3; 
    }
    else if (extends(argtypes[1], '_p_HandleT_CapFloorTermVolatilityStructure_t') && is.numeric(argv[[2]]) && is.numeric(argv[[3]])) {
      f <- CapFloorTermVolatilityStructureHandle_volatility__SWIG_5; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_HandleT_CapFloorTermVolatilityStructure_t') && extends(argtypes[2], '_p_Period') && is.numeric(argv[[3]]) && extends(argtypes[4], 'logical')) {
      f <- CapFloorTermVolatilityStructureHandle_volatility__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_HandleT_CapFloorTermVolatilityStructure_t') && extends(argtypes[2], '_p_Date') && is.numeric(argv[[3]]) && extends(argtypes[4], 'logical')) {
      f <- CapFloorTermVolatilityStructureHandle_volatility__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_HandleT_CapFloorTermVolatilityStructure_t') && is.numeric(argv[[2]]) && is.numeric(argv[[3]]) && extends(argtypes[4], 'logical')) {
      f <- CapFloorTermVolatilityStructureHandle_volatility__SWIG_4; 
    }
  } else {
    stop("cannot find overloaded function for CapFloorTermVolatilityStructureHandle_volatility with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of CapFloorTermVolatilityStructureHandle_enableExtrapolation

`CapFloorTermVolatilityStructureHandle_enableExtrapolation` = function(self)
{
  ;.Call('R_swig_CapFloorTermVolatilityStructureHandle_enableExtrapolation', self, PACKAGE='QuantLib');
  
}

attr(`CapFloorTermVolatilityStructureHandle_enableExtrapolation`, 'returnType') = 'void'
attr(`CapFloorTermVolatilityStructureHandle_enableExtrapolation`, "inputTypes") = c('_p_HandleT_CapFloorTermVolatilityStructure_t')
class(`CapFloorTermVolatilityStructureHandle_enableExtrapolation`) = c("SWIGFunction", class('CapFloorTermVolatilityStructureHandle_enableExtrapolation'))

# Start of CapFloorTermVolatilityStructureHandle_disableExtrapolation

`CapFloorTermVolatilityStructureHandle_disableExtrapolation` = function(self)
{
  ;.Call('R_swig_CapFloorTermVolatilityStructureHandle_disableExtrapolation', self, PACKAGE='QuantLib');
  
}

attr(`CapFloorTermVolatilityStructureHandle_disableExtrapolation`, 'returnType') = 'void'
attr(`CapFloorTermVolatilityStructureHandle_disableExtrapolation`, "inputTypes") = c('_p_HandleT_CapFloorTermVolatilityStructure_t')
class(`CapFloorTermVolatilityStructureHandle_disableExtrapolation`) = c("SWIGFunction", class('CapFloorTermVolatilityStructureHandle_disableExtrapolation'))

# Start of CapFloorTermVolatilityStructureHandle_allowsExtrapolation

`CapFloorTermVolatilityStructureHandle_allowsExtrapolation` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_CapFloorTermVolatilityStructureHandle_allowsExtrapolation', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`CapFloorTermVolatilityStructureHandle_allowsExtrapolation`, 'returnType') = 'logical'
attr(`CapFloorTermVolatilityStructureHandle_allowsExtrapolation`, "inputTypes") = c('_p_HandleT_CapFloorTermVolatilityStructure_t')
class(`CapFloorTermVolatilityStructureHandle_allowsExtrapolation`) = c("SWIGFunction", class('CapFloorTermVolatilityStructureHandle_allowsExtrapolation'))

# Start of accessor method for Handle<(CapFloorTermVolatilityStructure)>
setMethod('$', '_p_HandleT_CapFloorTermVolatilityStructure_t', function(x, name)

{
  accessorFuns = list('__deref__' = CapFloorTermVolatilityStructureHandle___deref__, 'empty' = CapFloorTermVolatilityStructureHandle_empty, 'asObservable' = CapFloorTermVolatilityStructureHandle_asObservable, 'volatility' = CapFloorTermVolatilityStructureHandle_volatility, 'enableExtrapolation' = CapFloorTermVolatilityStructureHandle_enableExtrapolation, 'disableExtrapolation' = CapFloorTermVolatilityStructureHandle_disableExtrapolation, 'allowsExtrapolation' = CapFloorTermVolatilityStructureHandle_allowsExtrapolation);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for Handle<(CapFloorTermVolatilityStructure)>
setMethod('delete', '_p_HandleT_CapFloorTermVolatilityStructure_t', function(obj) {delete_HandleT_CapFloorTermVolatilityStructure_t(obj)})
# Start of new_RelinkableCapFloorTermVolatilityStructureHandle

`RelinkableCapFloorTermVolatilityStructureHandle__SWIG_0` = function(s_arg1)
{
  ;ans = .Call('R_swig_new_RelinkableCapFloorTermVolatilityStructureHandle__SWIG_0', s_arg1, PACKAGE='QuantLib');
  class(ans) <- "_p_RelinkableHandleT_CapFloorTermVolatilityStructure_t";
  
  reg.finalizer(ans, delete_RelinkableCapFloorTermVolatilityStructureHandle)
  ans
  
}

attr(`RelinkableCapFloorTermVolatilityStructureHandle__SWIG_0`, 'returnType') = '_p_RelinkableHandleT_CapFloorTermVolatilityStructure_t'
attr(`RelinkableCapFloorTermVolatilityStructureHandle__SWIG_0`, "inputTypes") = c('_p_boost__shared_ptrT_CapFloorTermVolatilityStructure_t')
class(`RelinkableCapFloorTermVolatilityStructureHandle__SWIG_0`) = c("SWIGFunction", class('RelinkableCapFloorTermVolatilityStructureHandle__SWIG_0'))

# Start of new_RelinkableCapFloorTermVolatilityStructureHandle

`RelinkableCapFloorTermVolatilityStructureHandle__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_RelinkableCapFloorTermVolatilityStructureHandle__SWIG_1', PACKAGE='QuantLib');
  class(ans) <- "_p_RelinkableHandleT_CapFloorTermVolatilityStructure_t";
  
  reg.finalizer(ans, delete_RelinkableCapFloorTermVolatilityStructureHandle)
  ans
  
}

attr(`RelinkableCapFloorTermVolatilityStructureHandle__SWIG_1`, 'returnType') = '_p_RelinkableHandleT_CapFloorTermVolatilityStructure_t'
class(`RelinkableCapFloorTermVolatilityStructureHandle__SWIG_1`) = c("SWIGFunction", class('RelinkableCapFloorTermVolatilityStructureHandle__SWIG_1'))

`RelinkableCapFloorTermVolatilityStructureHandle` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- RelinkableCapFloorTermVolatilityStructureHandle__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_CapFloorTermVolatilityStructure_t')) {
      f <- RelinkableCapFloorTermVolatilityStructureHandle__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for RelinkableCapFloorTermVolatilityStructureHandle with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of RelinkableCapFloorTermVolatilityStructureHandle_linkTo

`RelinkableCapFloorTermVolatilityStructureHandle_linkTo` = function(self, s_arg2)
{
  ;.Call('R_swig_RelinkableCapFloorTermVolatilityStructureHandle_linkTo', self, s_arg2, PACKAGE='QuantLib');
  
}

attr(`RelinkableCapFloorTermVolatilityStructureHandle_linkTo`, 'returnType') = 'void'
attr(`RelinkableCapFloorTermVolatilityStructureHandle_linkTo`, "inputTypes") = c('_p_RelinkableHandleT_CapFloorTermVolatilityStructure_t', '_p_boost__shared_ptrT_CapFloorTermVolatilityStructure_t')
class(`RelinkableCapFloorTermVolatilityStructureHandle_linkTo`) = c("SWIGFunction", class('RelinkableCapFloorTermVolatilityStructureHandle_linkTo'))

# Start of delete_RelinkableCapFloorTermVolatilityStructureHandle

`delete_RelinkableCapFloorTermVolatilityStructureHandle` = function(self)
{
  ;.Call('R_swig_delete_RelinkableCapFloorTermVolatilityStructureHandle', self, PACKAGE='QuantLib');
  
}

attr(`delete_RelinkableCapFloorTermVolatilityStructureHandle`, 'returnType') = 'void'
attr(`delete_RelinkableCapFloorTermVolatilityStructureHandle`, "inputTypes") = c('_p_RelinkableHandleT_CapFloorTermVolatilityStructure_t')
class(`delete_RelinkableCapFloorTermVolatilityStructureHandle`) = c("SWIGFunction", class('delete_RelinkableCapFloorTermVolatilityStructureHandle'))

# Start of accessor method for RelinkableHandle<(CapFloorTermVolatilityStructure)>
setMethod('$', '_p_RelinkableHandleT_CapFloorTermVolatilityStructure_t', function(x, name)

{
  accessorFuns = list('linkTo' = RelinkableCapFloorTermVolatilityStructureHandle_linkTo);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for RelinkableHandle<(CapFloorTermVolatilityStructure)>
setMethod('delete', '_p_RelinkableHandleT_CapFloorTermVolatilityStructure_t', function(obj) {delete_RelinkableHandleT_CapFloorTermVolatilityStructure_t(obj)})
# Start of new_CapFloorTermVolCurve

`CapFloorTermVolCurve__SWIG_0` = function(referenceDate, calendar, bdc, lengths, vols, dc)
{
  bdc = enumToInteger(bdc, "_BusinessDayConvention"); 
  
  if(length(bdc) > 1) {
    warning("using only the first element of bdc");
  };
  
  
  
  
  ;ans = .Call('R_swig_new_CapFloorTermVolCurve__SWIG_0', referenceDate, calendar, bdc, lengths, vols, dc, PACKAGE='QuantLib');
  class(ans) <- "_p_CapFloorTermVolCurvePtr";
  
  reg.finalizer(ans, delete_CapFloorTermVolCurve)
  ans
  
}

attr(`CapFloorTermVolCurve__SWIG_0`, 'returnType') = '_p_CapFloorTermVolCurvePtr'
attr(`CapFloorTermVolCurve__SWIG_0`, "inputTypes") = c('_p_Date', '_p_Calendar', 'character', '_p_std__vectorT_Period_std__allocatorT_Period_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_DayCounter')
class(`CapFloorTermVolCurve__SWIG_0`) = c("SWIGFunction", class('CapFloorTermVolCurve__SWIG_0'))

# Start of new_CapFloorTermVolCurve

`CapFloorTermVolCurve__SWIG_1` = function(referenceDate, calendar, bdc, lengths, vols)
{
  bdc = enumToInteger(bdc, "_BusinessDayConvention"); 
  
  if(length(bdc) > 1) {
    warning("using only the first element of bdc");
  };
  
  
  
  ;ans = .Call('R_swig_new_CapFloorTermVolCurve__SWIG_1', referenceDate, calendar, bdc, lengths, vols, PACKAGE='QuantLib');
  class(ans) <- "_p_CapFloorTermVolCurvePtr";
  
  reg.finalizer(ans, delete_CapFloorTermVolCurve)
  ans
  
}

attr(`CapFloorTermVolCurve__SWIG_1`, 'returnType') = '_p_CapFloorTermVolCurvePtr'
attr(`CapFloorTermVolCurve__SWIG_1`, "inputTypes") = c('_p_Date', '_p_Calendar', 'character', '_p_std__vectorT_Period_std__allocatorT_Period_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`CapFloorTermVolCurve__SWIG_1`) = c("SWIGFunction", class('CapFloorTermVolCurve__SWIG_1'))

# Start of new_CapFloorTermVolCurve

`CapFloorTermVolCurve__SWIG_2` = function(settlementDays, calendar, bdc, lengths, vols, dc)
{
  if(length(settlementDays) > 1) {
    warning("using only the first element of settlementDays");
  };
  
  
  bdc = enumToInteger(bdc, "_BusinessDayConvention"); 
  
  if(length(bdc) > 1) {
    warning("using only the first element of bdc");
  };
  
  
  
  
  ;ans = .Call('R_swig_new_CapFloorTermVolCurve__SWIG_2', settlementDays, calendar, bdc, lengths, vols, dc, PACKAGE='QuantLib');
  class(ans) <- "_p_CapFloorTermVolCurvePtr";
  
  reg.finalizer(ans, delete_CapFloorTermVolCurve)
  ans
  
}

attr(`CapFloorTermVolCurve__SWIG_2`, 'returnType') = '_p_CapFloorTermVolCurvePtr'
attr(`CapFloorTermVolCurve__SWIG_2`, "inputTypes") = c('integer', '_p_Calendar', 'character', '_p_std__vectorT_Period_std__allocatorT_Period_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_DayCounter')
class(`CapFloorTermVolCurve__SWIG_2`) = c("SWIGFunction", class('CapFloorTermVolCurve__SWIG_2'))

# Start of new_CapFloorTermVolCurve

`CapFloorTermVolCurve__SWIG_3` = function(settlementDays, calendar, bdc, lengths, vols)
{
  if(length(settlementDays) > 1) {
    warning("using only the first element of settlementDays");
  };
  
  
  bdc = enumToInteger(bdc, "_BusinessDayConvention"); 
  
  if(length(bdc) > 1) {
    warning("using only the first element of bdc");
  };
  
  
  
  ;ans = .Call('R_swig_new_CapFloorTermVolCurve__SWIG_3', settlementDays, calendar, bdc, lengths, vols, PACKAGE='QuantLib');
  class(ans) <- "_p_CapFloorTermVolCurvePtr";
  
  reg.finalizer(ans, delete_CapFloorTermVolCurve)
  ans
  
}

attr(`CapFloorTermVolCurve__SWIG_3`, 'returnType') = '_p_CapFloorTermVolCurvePtr'
attr(`CapFloorTermVolCurve__SWIG_3`, "inputTypes") = c('integer', '_p_Calendar', 'character', '_p_std__vectorT_Period_std__allocatorT_Period_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`CapFloorTermVolCurve__SWIG_3`) = c("SWIGFunction", class('CapFloorTermVolCurve__SWIG_3'))

`CapFloorTermVolCurve` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 5) {
    if (extends(argtypes[1], '_p_Date') && extends(argtypes[2], '_p_Calendar') && is.character(argv[[3]]) && extends(argtypes[4], '_p_std__vectorT_Period_std__allocatorT_Period_t_t') && extends(argtypes[5], '_p_std__vectorT_double_std__allocatorT_double_t_t')) {
      f <- CapFloorTermVolCurve__SWIG_1; 
    }
    else if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && extends(argtypes[2], '_p_Calendar') && is.character(argv[[3]]) && extends(argtypes[4], '_p_std__vectorT_Period_std__allocatorT_Period_t_t') && extends(argtypes[5], '_p_std__vectorT_double_std__allocatorT_double_t_t')) {
      f <- CapFloorTermVolCurve__SWIG_3; 
    }
  } else if (argc == 6) {
    if (extends(argtypes[1], '_p_Date') && extends(argtypes[2], '_p_Calendar') && is.character(argv[[3]]) && extends(argtypes[4], '_p_std__vectorT_Period_std__allocatorT_Period_t_t') && extends(argtypes[5], '_p_std__vectorT_double_std__allocatorT_double_t_t') && extends(argtypes[6], '_p_DayCounter')) {
      f <- CapFloorTermVolCurve__SWIG_0; 
    }
    else if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && extends(argtypes[2], '_p_Calendar') && is.character(argv[[3]]) && extends(argtypes[4], '_p_std__vectorT_Period_std__allocatorT_Period_t_t') && extends(argtypes[5], '_p_std__vectorT_double_std__allocatorT_double_t_t') && extends(argtypes[6], '_p_DayCounter')) {
      f <- CapFloorTermVolCurve__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for CapFloorTermVolCurve with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_CapFloorTermVolCurve

`delete_CapFloorTermVolCurve` = function(self)
{
  ;.Call('R_swig_delete_CapFloorTermVolCurve', self, PACKAGE='QuantLib');
  
}

attr(`delete_CapFloorTermVolCurve`, 'returnType') = 'void'
attr(`delete_CapFloorTermVolCurve`, "inputTypes") = c('_p_CapFloorTermVolCurvePtr')
class(`delete_CapFloorTermVolCurve`) = c("SWIGFunction", class('delete_CapFloorTermVolCurve'))

setMethod('delete', '_p_CapFloorTermVolCurvePtr', function(obj) {delete_CapFloorTermVolCurvePtr(obj)})
defineEnumeration('_Settlement__Type',
                    .values = c(
                        'Physical' = 0, 
                        'Cash' = 1
))
# Start of new_Settlement

`Settlement` = function()
{
  ;ans = .Call('R_swig_new_Settlement', PACKAGE='QuantLib');
  class(ans) <- "_p_Settlement";
  
  reg.finalizer(ans, delete_Settlement)
  ans
  
}

attr(`Settlement`, 'returnType') = '_p_Settlement'
class(`Settlement`) = c("SWIGFunction", class('Settlement'))

# Start of delete_Settlement

`delete_Settlement` = function(self)
{
  ;.Call('R_swig_delete_Settlement', self, PACKAGE='QuantLib');
  
}

attr(`delete_Settlement`, 'returnType') = 'void'
attr(`delete_Settlement`, "inputTypes") = c('_p_Settlement')
class(`delete_Settlement`) = c("SWIGFunction", class('delete_Settlement'))

setMethod('delete', '_p_Settlement', function(obj) {delete_Settlement(obj)})
# Start definition of copy functions & methods for Settlement
CopyToR_Settlement = function(value, obj = new("Settlement"))
{
  obj;
}



CopyToC_Settlement = function(value, obj)
{
  obj
}



# Start definition of copy methods for Settlement
setMethod('copyToR', '_p_Settlement', CopyToR_Settlement);
setMethod('copyToC', 'Settlement', CopyToC_Settlement);

# End definition of copy methods for Settlement
# End definition of copy functions & methods for Settlement
# Start of new_Swaption

`Swaption__SWIG_0` = function(simpleSwap, exercise, type)
{
  type = enumToInteger(type, "_Settlement__Type"); 
  
  if(length(type) > 1) {
    warning("using only the first element of type");
  };
  
  ;ans = .Call('R_swig_new_Swaption__SWIG_0', simpleSwap, exercise, type, PACKAGE='QuantLib');
  class(ans) <- "_p_SwaptionPtr";
  
  reg.finalizer(ans, delete_Swaption)
  ans
  
}

attr(`Swaption__SWIG_0`, 'returnType') = '_p_SwaptionPtr'
attr(`Swaption__SWIG_0`, "inputTypes") = c('_p_VanillaSwapPtr', '_p_boost__shared_ptrT_Exercise_t', 'character')
class(`Swaption__SWIG_0`) = c("SWIGFunction", class('Swaption__SWIG_0'))

# Start of new_Swaption

`Swaption__SWIG_1` = function(simpleSwap, exercise)
{
  ;ans = .Call('R_swig_new_Swaption__SWIG_1', simpleSwap, exercise, PACKAGE='QuantLib');
  class(ans) <- "_p_SwaptionPtr";
  
  reg.finalizer(ans, delete_Swaption)
  ans
  
}

attr(`Swaption__SWIG_1`, 'returnType') = '_p_SwaptionPtr'
attr(`Swaption__SWIG_1`, "inputTypes") = c('_p_VanillaSwapPtr', '_p_boost__shared_ptrT_Exercise_t')
class(`Swaption__SWIG_1`) = c("SWIGFunction", class('Swaption__SWIG_1'))

`Swaption` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_VanillaSwapPtr') && extends(argtypes[2], '_p_boost__shared_ptrT_Exercise_t')) {
      f <- Swaption__SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_VanillaSwapPtr') && extends(argtypes[2], '_p_boost__shared_ptrT_Exercise_t') && is.character(argv[[3]])) {
      f <- Swaption__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Swaption with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_Swaption

`delete_Swaption` = function(self)
{
  ;.Call('R_swig_delete_Swaption', self, PACKAGE='QuantLib');
  
}

attr(`delete_Swaption`, 'returnType') = 'void'
attr(`delete_Swaption`, "inputTypes") = c('_p_SwaptionPtr')
class(`delete_Swaption`) = c("SWIGFunction", class('delete_Swaption'))

setMethod('delete', '_p_SwaptionPtr', function(obj) {delete_SwaptionPtr(obj)})
# Start of new_BlackSwaptionEngine

`BlackSwaptionEngine__SWIG_0` = function(discountCurve, vol)
{
  ;ans = .Call('R_swig_new_BlackSwaptionEngine__SWIG_0', discountCurve, vol, PACKAGE='QuantLib');
  class(ans) <- "_p_BlackSwaptionEnginePtr";
  
  reg.finalizer(ans, delete_BlackSwaptionEngine)
  ans
  
}

attr(`BlackSwaptionEngine__SWIG_0`, 'returnType') = '_p_BlackSwaptionEnginePtr'
attr(`BlackSwaptionEngine__SWIG_0`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t', '_p_HandleT_Quote_t')
class(`BlackSwaptionEngine__SWIG_0`) = c("SWIGFunction", class('BlackSwaptionEngine__SWIG_0'))

# Start of new_BlackSwaptionEngine

`BlackSwaptionEngine__SWIG_1` = function(discountCurve, v)
{
  ;ans = .Call('R_swig_new_BlackSwaptionEngine__SWIG_1', discountCurve, v, PACKAGE='QuantLib');
  class(ans) <- "_p_BlackSwaptionEnginePtr";
  
  reg.finalizer(ans, delete_BlackSwaptionEngine)
  ans
  
}

attr(`BlackSwaptionEngine__SWIG_1`, 'returnType') = '_p_BlackSwaptionEnginePtr'
attr(`BlackSwaptionEngine__SWIG_1`, "inputTypes") = c('_p_HandleT_YieldTermStructure_t', '_p_HandleT_SwaptionVolatilityStructure_t')
class(`BlackSwaptionEngine__SWIG_1`) = c("SWIGFunction", class('BlackSwaptionEngine__SWIG_1'))

`BlackSwaptionEngine` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t') && extends(argtypes[2], '_p_HandleT_Quote_t')) {
      f <- BlackSwaptionEngine__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_HandleT_YieldTermStructure_t') && extends(argtypes[2], '_p_HandleT_SwaptionVolatilityStructure_t')) {
      f <- BlackSwaptionEngine__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for BlackSwaptionEngine with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_BlackSwaptionEngine

`delete_BlackSwaptionEngine` = function(self)
{
  ;.Call('R_swig_delete_BlackSwaptionEngine', self, PACKAGE='QuantLib');
  
}

attr(`delete_BlackSwaptionEngine`, 'returnType') = 'void'
attr(`delete_BlackSwaptionEngine`, "inputTypes") = c('_p_BlackSwaptionEnginePtr')
class(`delete_BlackSwaptionEngine`) = c("SWIGFunction", class('delete_BlackSwaptionEngine'))

setMethod('delete', '_p_BlackSwaptionEnginePtr', function(obj) {delete_BlackSwaptionEnginePtr(obj)})
# Start of Surface___deref__

`Surface___deref__` = function(self)
{
  ;ans = .Call('R_swig_Surface___deref__', self, PACKAGE='QuantLib');
  class(ans) <- "_p_Surface";
  
  ans
  
}

attr(`Surface___deref__`, 'returnType') = '_p_Surface'
attr(`Surface___deref__`, "inputTypes") = c('_p_boost__shared_ptrT_Surface_t')
class(`Surface___deref__`) = c("SWIGFunction", class('Surface___deref__'))

# Start of Surface_isNull

`Surface_isNull` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_Surface_isNull', self, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Surface_isNull`, 'returnType') = 'logical'
attr(`Surface_isNull`, "inputTypes") = c('_p_boost__shared_ptrT_Surface_t')
class(`Surface_isNull`) = c("SWIGFunction", class('Surface_isNull'))

# Start of new_Surface

`Surface` = function()
{
  ;ans = .Call('R_swig_new_Surface', PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_Surface_t";
  
  reg.finalizer(ans, delete_Surface)
  ans
  
}

attr(`Surface`, 'returnType') = '_p_boost__shared_ptrT_Surface_t'
class(`Surface`) = c("SWIGFunction", class('Surface'))

# Start of delete_Surface

`delete_Surface` = function(self)
{
  ;.Call('R_swig_delete_Surface', self, PACKAGE='QuantLib');
  
}

attr(`delete_Surface`, 'returnType') = 'void'
attr(`delete_Surface`, "inputTypes") = c('_p_boost__shared_ptrT_Surface_t')
class(`delete_Surface`) = c("SWIGFunction", class('delete_Surface'))

# Start of Surface___call__

`Surface___call__` = function(self, x, y, .copy = FALSE)
{
  ;.Call('R_swig_Surface___call__', self, x, y, as.logical(.copy), PACKAGE='QuantLib');
  
}

attr(`Surface___call__`, 'returnType') = 'numeric'
attr(`Surface___call__`, "inputTypes") = c('_p_boost__shared_ptrT_Surface_t', 'numeric', 'numeric')
class(`Surface___call__`) = c("SWIGFunction", class('Surface___call__'))

# Start of Surface_domain

`Surface_domain` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_Surface_domain', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_boost__shared_ptrT_Domain_t";
  
  ans
  
}

attr(`Surface_domain`, 'returnType') = '_p_boost__shared_ptrT_Domain_t'
attr(`Surface_domain`, "inputTypes") = c('_p_boost__shared_ptrT_Surface_t')
class(`Surface_domain`) = c("SWIGFunction", class('Surface_domain'))

# Start of accessor method for boost::shared_ptr<(Surface)>
setMethod('$', '_p_boost__shared_ptrT_Surface_t', function(x, name)

{
  accessorFuns = list('__deref__' = Surface___deref__, 'isNull' = Surface_isNull, '__call__' = Surface___call__, 'domain' = Surface_domain);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for boost::shared_ptr<(Surface)>
setMethod('delete', '_p_boost__shared_ptrT_Surface_t', function(obj) {delete_boost__shared_ptrT_Surface_t(obj)})
# Start of new_TestSurface

`TestSurface` = function()
{
  ;ans = .Call('R_swig_new_TestSurface', PACKAGE='QuantLib');
  class(ans) <- "_p_TestSurfacePtr";
  
  reg.finalizer(ans, delete_TestSurface)
  ans
  
}

attr(`TestSurface`, 'returnType') = '_p_TestSurfacePtr'
class(`TestSurface`) = c("SWIGFunction", class('TestSurface'))

# Start of delete_TestSurface

`delete_TestSurface` = function(self)
{
  ;.Call('R_swig_delete_TestSurface', self, PACKAGE='QuantLib');
  
}

attr(`delete_TestSurface`, 'returnType') = 'void'
attr(`delete_TestSurface`, "inputTypes") = c('_p_TestSurfacePtr')
class(`delete_TestSurface`) = c("SWIGFunction", class('delete_TestSurface'))

setMethod('delete', '_p_TestSurfacePtr', function(obj) {delete_TestSurfacePtr(obj)})
# Start of enableTracing

`enableTracing` = function()
{
  ;.Call('R_swig_enableTracing', PACKAGE='QuantLib');
  
}

attr(`enableTracing`, 'returnType') = 'void'
class(`enableTracing`) = c("SWIGFunction", class('enableTracing'))

# Start of disableTracing

`disableTracing` = function()
{
  ;.Call('R_swig_disableTracing', PACKAGE='QuantLib');
  
}

attr(`disableTracing`, 'returnType') = 'void'
class(`disableTracing`) = c("SWIGFunction", class('disableTracing'))

# Start of new_ConstantEstimator

`ConstantEstimator` = function(size)
{
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_new_ConstantEstimator', size, PACKAGE='QuantLib');
  class(ans) <- "_p_ConstantEstimator";
  
  reg.finalizer(ans, delete_ConstantEstimator)
  ans
  
}

attr(`ConstantEstimator`, 'returnType') = '_p_ConstantEstimator'
attr(`ConstantEstimator`, "inputTypes") = c('integer')
class(`ConstantEstimator`) = c("SWIGFunction", class('ConstantEstimator'))

# Start of ConstantEstimator_calculate

`ConstantEstimator_calculate` = function(self, s_arg2, .copy = FALSE)
{
  ;ans = .Call('R_swig_ConstantEstimator_calculate', self, s_arg2, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_TimeSeriesT_double_std__mapT_Date_double_t_t";
  
  ans
  
}

attr(`ConstantEstimator_calculate`, 'returnType') = '_p_TimeSeriesT_double_std__mapT_Date_double_t_t'
attr(`ConstantEstimator_calculate`, "inputTypes") = c('_p_ConstantEstimator', '_p_TimeSeriesT_double_std__mapT_Date_double_t_t')
class(`ConstantEstimator_calculate`) = c("SWIGFunction", class('ConstantEstimator_calculate'))

# Start of delete_ConstantEstimator

`delete_ConstantEstimator` = function(self)
{
  ;.Call('R_swig_delete_ConstantEstimator', self, PACKAGE='QuantLib');
  
}

attr(`delete_ConstantEstimator`, 'returnType') = 'void'
attr(`delete_ConstantEstimator`, "inputTypes") = c('_p_ConstantEstimator')
class(`delete_ConstantEstimator`) = c("SWIGFunction", class('delete_ConstantEstimator'))

# Start of accessor method for ConstantEstimator
setMethod('$', '_p_ConstantEstimator', function(x, name)

{
  accessorFuns = list('calculate' = ConstantEstimator_calculate);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for ConstantEstimator
setMethod('delete', '_p_ConstantEstimator', function(obj) {delete_ConstantEstimator(obj)})
# Start of new_ParkinsonSigma

`ParkinsonSigma` = function(yearFraction)
{
  ;ans = .Call('R_swig_new_ParkinsonSigma', yearFraction, PACKAGE='QuantLib');
  class(ans) <- "_p_ParkinsonSigma";
  
  reg.finalizer(ans, delete_ParkinsonSigma)
  ans
  
}

attr(`ParkinsonSigma`, 'returnType') = '_p_ParkinsonSigma'
attr(`ParkinsonSigma`, "inputTypes") = c('numeric')
class(`ParkinsonSigma`) = c("SWIGFunction", class('ParkinsonSigma'))

# Start of ParkinsonSigma_calculate

`ParkinsonSigma_calculate` = function(self, s_arg2, .copy = FALSE)
{
  ;ans = .Call('R_swig_ParkinsonSigma_calculate', self, s_arg2, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_TimeSeriesT_double_std__mapT_Date_double_t_t";
  
  ans
  
}

attr(`ParkinsonSigma_calculate`, 'returnType') = '_p_TimeSeriesT_double_std__mapT_Date_double_t_t'
attr(`ParkinsonSigma_calculate`, "inputTypes") = c('_p_ParkinsonSigma', '_p_TimeSeriesT_IntervalPrice_std__mapT_Date_IntervalPrice_t_t')
class(`ParkinsonSigma_calculate`) = c("SWIGFunction", class('ParkinsonSigma_calculate'))

# Start of delete_ParkinsonSigma

`delete_ParkinsonSigma` = function(self)
{
  ;.Call('R_swig_delete_ParkinsonSigma', self, PACKAGE='QuantLib');
  
}

attr(`delete_ParkinsonSigma`, 'returnType') = 'void'
attr(`delete_ParkinsonSigma`, "inputTypes") = c('_p_ParkinsonSigma')
class(`delete_ParkinsonSigma`) = c("SWIGFunction", class('delete_ParkinsonSigma'))

# Start of accessor method for ParkinsonSigma
setMethod('$', '_p_ParkinsonSigma', function(x, name)

{
  accessorFuns = list('calculate' = ParkinsonSigma_calculate);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for ParkinsonSigma
setMethod('delete', '_p_ParkinsonSigma', function(obj) {delete_ParkinsonSigma(obj)})
# Start of new_GarmanKlassSigma1

`GarmanKlassSigma1` = function(yearFraction, marketOpenFraction)
{
  ;ans = .Call('R_swig_new_GarmanKlassSigma1', yearFraction, marketOpenFraction, PACKAGE='QuantLib');
  class(ans) <- "_p_GarmanKlassSigma1";
  
  reg.finalizer(ans, delete_GarmanKlassSigma1)
  ans
  
}

attr(`GarmanKlassSigma1`, 'returnType') = '_p_GarmanKlassSigma1'
attr(`GarmanKlassSigma1`, "inputTypes") = c('numeric', 'numeric')
class(`GarmanKlassSigma1`) = c("SWIGFunction", class('GarmanKlassSigma1'))

# Start of GarmanKlassSigma1_calculate

`GarmanKlassSigma1_calculate` = function(self, s_arg2, .copy = FALSE)
{
  ;ans = .Call('R_swig_GarmanKlassSigma1_calculate', self, s_arg2, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_TimeSeriesT_double_std__mapT_Date_double_t_t";
  
  ans
  
}

attr(`GarmanKlassSigma1_calculate`, 'returnType') = '_p_TimeSeriesT_double_std__mapT_Date_double_t_t'
attr(`GarmanKlassSigma1_calculate`, "inputTypes") = c('_p_GarmanKlassSigma1', '_p_TimeSeriesT_IntervalPrice_std__mapT_Date_IntervalPrice_t_t')
class(`GarmanKlassSigma1_calculate`) = c("SWIGFunction", class('GarmanKlassSigma1_calculate'))

# Start of delete_GarmanKlassSigma1

`delete_GarmanKlassSigma1` = function(self)
{
  ;.Call('R_swig_delete_GarmanKlassSigma1', self, PACKAGE='QuantLib');
  
}

attr(`delete_GarmanKlassSigma1`, 'returnType') = 'void'
attr(`delete_GarmanKlassSigma1`, "inputTypes") = c('_p_GarmanKlassSigma1')
class(`delete_GarmanKlassSigma1`) = c("SWIGFunction", class('delete_GarmanKlassSigma1'))

# Start of accessor method for GarmanKlassSigma1
setMethod('$', '_p_GarmanKlassSigma1', function(x, name)

{
  accessorFuns = list('calculate' = GarmanKlassSigma1_calculate);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for GarmanKlassSigma1
setMethod('delete', '_p_GarmanKlassSigma1', function(obj) {delete_GarmanKlassSigma1(obj)})
# Start of new_GarmanKlassSigma3

`GarmanKlassSigma3` = function(yearFraction, marketOpenFraction)
{
  ;ans = .Call('R_swig_new_GarmanKlassSigma3', yearFraction, marketOpenFraction, PACKAGE='QuantLib');
  class(ans) <- "_p_GarmanKlassSigma3";
  
  reg.finalizer(ans, delete_GarmanKlassSigma3)
  ans
  
}

attr(`GarmanKlassSigma3`, 'returnType') = '_p_GarmanKlassSigma3'
attr(`GarmanKlassSigma3`, "inputTypes") = c('numeric', 'numeric')
class(`GarmanKlassSigma3`) = c("SWIGFunction", class('GarmanKlassSigma3'))

# Start of GarmanKlassSigma3_calculate

`GarmanKlassSigma3_calculate` = function(self, s_arg2, .copy = FALSE)
{
  ;ans = .Call('R_swig_GarmanKlassSigma3_calculate', self, s_arg2, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_TimeSeriesT_double_std__mapT_Date_double_t_t";
  
  ans
  
}

attr(`GarmanKlassSigma3_calculate`, 'returnType') = '_p_TimeSeriesT_double_std__mapT_Date_double_t_t'
attr(`GarmanKlassSigma3_calculate`, "inputTypes") = c('_p_GarmanKlassSigma3', '_p_TimeSeriesT_IntervalPrice_std__mapT_Date_IntervalPrice_t_t')
class(`GarmanKlassSigma3_calculate`) = c("SWIGFunction", class('GarmanKlassSigma3_calculate'))

# Start of delete_GarmanKlassSigma3

`delete_GarmanKlassSigma3` = function(self)
{
  ;.Call('R_swig_delete_GarmanKlassSigma3', self, PACKAGE='QuantLib');
  
}

attr(`delete_GarmanKlassSigma3`, 'returnType') = 'void'
attr(`delete_GarmanKlassSigma3`, "inputTypes") = c('_p_GarmanKlassSigma3')
class(`delete_GarmanKlassSigma3`) = c("SWIGFunction", class('delete_GarmanKlassSigma3'))

# Start of accessor method for GarmanKlassSigma3
setMethod('$', '_p_GarmanKlassSigma3', function(x, name)

{
  accessorFuns = list('calculate' = GarmanKlassSigma3_calculate);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for GarmanKlassSigma3
setMethod('delete', '_p_GarmanKlassSigma3', function(obj) {delete_GarmanKlassSigma3(obj)})
# Start of new_GarmanKlassSigma4

`GarmanKlassSigma4` = function(yearFraction)
{
  ;ans = .Call('R_swig_new_GarmanKlassSigma4', yearFraction, PACKAGE='QuantLib');
  class(ans) <- "_p_GarmanKlassSigma4";
  
  reg.finalizer(ans, delete_GarmanKlassSigma4)
  ans
  
}

attr(`GarmanKlassSigma4`, 'returnType') = '_p_GarmanKlassSigma4'
attr(`GarmanKlassSigma4`, "inputTypes") = c('numeric')
class(`GarmanKlassSigma4`) = c("SWIGFunction", class('GarmanKlassSigma4'))

# Start of GarmanKlassSigma4_calculate

`GarmanKlassSigma4_calculate` = function(self, s_arg2, .copy = FALSE)
{
  ;ans = .Call('R_swig_GarmanKlassSigma4_calculate', self, s_arg2, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_TimeSeriesT_double_std__mapT_Date_double_t_t";
  
  ans
  
}

attr(`GarmanKlassSigma4_calculate`, 'returnType') = '_p_TimeSeriesT_double_std__mapT_Date_double_t_t'
attr(`GarmanKlassSigma4_calculate`, "inputTypes") = c('_p_GarmanKlassSigma4', '_p_TimeSeriesT_IntervalPrice_std__mapT_Date_IntervalPrice_t_t')
class(`GarmanKlassSigma4_calculate`) = c("SWIGFunction", class('GarmanKlassSigma4_calculate'))

# Start of delete_GarmanKlassSigma4

`delete_GarmanKlassSigma4` = function(self)
{
  ;.Call('R_swig_delete_GarmanKlassSigma4', self, PACKAGE='QuantLib');
  
}

attr(`delete_GarmanKlassSigma4`, 'returnType') = 'void'
attr(`delete_GarmanKlassSigma4`, "inputTypes") = c('_p_GarmanKlassSigma4')
class(`delete_GarmanKlassSigma4`) = c("SWIGFunction", class('delete_GarmanKlassSigma4'))

# Start of accessor method for GarmanKlassSigma4
setMethod('$', '_p_GarmanKlassSigma4', function(x, name)

{
  accessorFuns = list('calculate' = GarmanKlassSigma4_calculate);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for GarmanKlassSigma4
setMethod('delete', '_p_GarmanKlassSigma4', function(obj) {delete_GarmanKlassSigma4(obj)})
# Start of new_GarmanKlassSigma5

`GarmanKlassSigma5` = function(yearFraction)
{
  ;ans = .Call('R_swig_new_GarmanKlassSigma5', yearFraction, PACKAGE='QuantLib');
  class(ans) <- "_p_GarmanKlassSigma5";
  
  reg.finalizer(ans, delete_GarmanKlassSigma5)
  ans
  
}

attr(`GarmanKlassSigma5`, 'returnType') = '_p_GarmanKlassSigma5'
attr(`GarmanKlassSigma5`, "inputTypes") = c('numeric')
class(`GarmanKlassSigma5`) = c("SWIGFunction", class('GarmanKlassSigma5'))

# Start of GarmanKlassSigma5_calculate

`GarmanKlassSigma5_calculate` = function(self, s_arg2, .copy = FALSE)
{
  ;ans = .Call('R_swig_GarmanKlassSigma5_calculate', self, s_arg2, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_TimeSeriesT_double_std__mapT_Date_double_t_t";
  
  ans
  
}

attr(`GarmanKlassSigma5_calculate`, 'returnType') = '_p_TimeSeriesT_double_std__mapT_Date_double_t_t'
attr(`GarmanKlassSigma5_calculate`, "inputTypes") = c('_p_GarmanKlassSigma5', '_p_TimeSeriesT_IntervalPrice_std__mapT_Date_IntervalPrice_t_t')
class(`GarmanKlassSigma5_calculate`) = c("SWIGFunction", class('GarmanKlassSigma5_calculate'))

# Start of delete_GarmanKlassSigma5

`delete_GarmanKlassSigma5` = function(self)
{
  ;.Call('R_swig_delete_GarmanKlassSigma5', self, PACKAGE='QuantLib');
  
}

attr(`delete_GarmanKlassSigma5`, 'returnType') = 'void'
attr(`delete_GarmanKlassSigma5`, "inputTypes") = c('_p_GarmanKlassSigma5')
class(`delete_GarmanKlassSigma5`) = c("SWIGFunction", class('delete_GarmanKlassSigma5'))

# Start of accessor method for GarmanKlassSigma5
setMethod('$', '_p_GarmanKlassSigma5', function(x, name)

{
  accessorFuns = list('calculate' = GarmanKlassSigma5_calculate);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for GarmanKlassSigma5
setMethod('delete', '_p_GarmanKlassSigma5', function(obj) {delete_GarmanKlassSigma5(obj)})
# Start of new_GarmanKlassSigma6

`GarmanKlassSigma6` = function(yearFraction, marketOpenFraction)
{
  ;ans = .Call('R_swig_new_GarmanKlassSigma6', yearFraction, marketOpenFraction, PACKAGE='QuantLib');
  class(ans) <- "_p_GarmanKlassSigma6";
  
  reg.finalizer(ans, delete_GarmanKlassSigma6)
  ans
  
}

attr(`GarmanKlassSigma6`, 'returnType') = '_p_GarmanKlassSigma6'
attr(`GarmanKlassSigma6`, "inputTypes") = c('numeric', 'numeric')
class(`GarmanKlassSigma6`) = c("SWIGFunction", class('GarmanKlassSigma6'))

# Start of GarmanKlassSigma6_calculate

`GarmanKlassSigma6_calculate` = function(self, s_arg2, .copy = FALSE)
{
  ;ans = .Call('R_swig_GarmanKlassSigma6_calculate', self, s_arg2, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_TimeSeriesT_double_std__mapT_Date_double_t_t";
  
  ans
  
}

attr(`GarmanKlassSigma6_calculate`, 'returnType') = '_p_TimeSeriesT_double_std__mapT_Date_double_t_t'
attr(`GarmanKlassSigma6_calculate`, "inputTypes") = c('_p_GarmanKlassSigma6', '_p_TimeSeriesT_IntervalPrice_std__mapT_Date_IntervalPrice_t_t')
class(`GarmanKlassSigma6_calculate`) = c("SWIGFunction", class('GarmanKlassSigma6_calculate'))

# Start of delete_GarmanKlassSigma6

`delete_GarmanKlassSigma6` = function(self)
{
  ;.Call('R_swig_delete_GarmanKlassSigma6', self, PACKAGE='QuantLib');
  
}

attr(`delete_GarmanKlassSigma6`, 'returnType') = 'void'
attr(`delete_GarmanKlassSigma6`, "inputTypes") = c('_p_GarmanKlassSigma6')
class(`delete_GarmanKlassSigma6`) = c("SWIGFunction", class('delete_GarmanKlassSigma6'))

# Start of accessor method for GarmanKlassSigma6
setMethod('$', '_p_GarmanKlassSigma6', function(x, name)

{
  accessorFuns = list('calculate' = GarmanKlassSigma6_calculate);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for GarmanKlassSigma6
setMethod('delete', '_p_GarmanKlassSigma6', function(obj) {delete_GarmanKlassSigma6(obj)})
# Start of new_ZeroCurve

`ZeroCurve__SWIG_0` = function(dates, yields, dayCounter, calendar, i)
{
  ;ans = .Call('R_swig_new_ZeroCurve__SWIG_0', dates, yields, dayCounter, calendar, i, PACKAGE='QuantLib');
  class(ans) <- "_p_ZeroCurvePtr";
  
  reg.finalizer(ans, delete_ZeroCurve)
  ans
  
}

attr(`ZeroCurve__SWIG_0`, 'returnType') = '_p_ZeroCurvePtr'
attr(`ZeroCurve__SWIG_0`, "inputTypes") = c('_p_std__vectorT_Date_std__allocatorT_Date_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_DayCounter', '_p_Calendar', '_p_Linear')
class(`ZeroCurve__SWIG_0`) = c("SWIGFunction", class('ZeroCurve__SWIG_0'))

# Start of new_ZeroCurve

`ZeroCurve__SWIG_1` = function(dates, yields, dayCounter, calendar)
{
  ;ans = .Call('R_swig_new_ZeroCurve__SWIG_1', dates, yields, dayCounter, calendar, PACKAGE='QuantLib');
  class(ans) <- "_p_ZeroCurvePtr";
  
  reg.finalizer(ans, delete_ZeroCurve)
  ans
  
}

attr(`ZeroCurve__SWIG_1`, 'returnType') = '_p_ZeroCurvePtr'
attr(`ZeroCurve__SWIG_1`, "inputTypes") = c('_p_std__vectorT_Date_std__allocatorT_Date_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_DayCounter', '_p_Calendar')
class(`ZeroCurve__SWIG_1`) = c("SWIGFunction", class('ZeroCurve__SWIG_1'))

# Start of new_ZeroCurve

`ZeroCurve__SWIG_2` = function(dates, yields, dayCounter)
{
  ;ans = .Call('R_swig_new_ZeroCurve__SWIG_2', dates, yields, dayCounter, PACKAGE='QuantLib');
  class(ans) <- "_p_ZeroCurvePtr";
  
  reg.finalizer(ans, delete_ZeroCurve)
  ans
  
}

attr(`ZeroCurve__SWIG_2`, 'returnType') = '_p_ZeroCurvePtr'
attr(`ZeroCurve__SWIG_2`, "inputTypes") = c('_p_std__vectorT_Date_std__allocatorT_Date_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_DayCounter')
class(`ZeroCurve__SWIG_2`) = c("SWIGFunction", class('ZeroCurve__SWIG_2'))

`ZeroCurve` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 3) {
    if (extends(argtypes[1], '_p_std__vectorT_Date_std__allocatorT_Date_t_t') && extends(argtypes[2], '_p_std__vectorT_double_std__allocatorT_double_t_t') && extends(argtypes[3], '_p_DayCounter')) {
      f <- ZeroCurve__SWIG_2; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_std__vectorT_Date_std__allocatorT_Date_t_t') && extends(argtypes[2], '_p_std__vectorT_double_std__allocatorT_double_t_t') && extends(argtypes[3], '_p_DayCounter') && extends(argtypes[4], '_p_Calendar')) {
      f <- ZeroCurve__SWIG_1; 
    }
  } else if (argc == 5) {
    if (extends(argtypes[1], '_p_std__vectorT_Date_std__allocatorT_Date_t_t') && extends(argtypes[2], '_p_std__vectorT_double_std__allocatorT_double_t_t') && extends(argtypes[3], '_p_DayCounter') && extends(argtypes[4], '_p_Calendar') && extends(argtypes[5], '_p_Linear')) {
      f <- ZeroCurve__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for ZeroCurve with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of ZeroCurve_dates

`ZeroCurve_dates` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_ZeroCurve_dates', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_Date_std__allocatorT_Date_t_t";
  
  ans
  
}

attr(`ZeroCurve_dates`, 'returnType') = '_p_std__vectorT_Date_std__allocatorT_Date_t_t'
attr(`ZeroCurve_dates`, "inputTypes") = c('_p_ZeroCurvePtr')
class(`ZeroCurve_dates`) = c("SWIGFunction", class('ZeroCurve_dates'))

# Start of ZeroCurve_zeroRates

`ZeroCurve_zeroRates` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_ZeroCurve_zeroRates', self, as.logical(.copy), PACKAGE='QuantLib');
  class(ans) <- "_p_std__vectorT_double_std__allocatorT_double_t_t";
  
  ans
  
}

attr(`ZeroCurve_zeroRates`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`ZeroCurve_zeroRates`, "inputTypes") = c('_p_ZeroCurvePtr')
class(`ZeroCurve_zeroRates`) = c("SWIGFunction", class('ZeroCurve_zeroRates'))

# Start of delete_ZeroCurve

`delete_ZeroCurve` = function(self)
{
  ;.Call('R_swig_delete_ZeroCurve', self, PACKAGE='QuantLib');
  
}

attr(`delete_ZeroCurve`, 'returnType') = 'void'
attr(`delete_ZeroCurve`, "inputTypes") = c('_p_ZeroCurvePtr')
class(`delete_ZeroCurve`) = c("SWIGFunction", class('delete_ZeroCurve'))

# Start of accessor method for ZeroCurvePtr
setMethod('$', '_p_ZeroCurvePtr', function(x, name)

{
  accessorFuns = list('dates' = ZeroCurve_dates, 'zeroRates' = ZeroCurve_zeroRates);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for ZeroCurvePtr
setMethod('delete', '_p_ZeroCurvePtr', function(obj) {delete_ZeroCurvePtr(obj)})

